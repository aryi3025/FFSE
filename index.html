<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>FFSE - Fantasy Football Stock Exchange</title><!-- Updated: 2025-11-18-22:01:30 --><meta property="og:title" content="FFSE"><meta property="og:description" content="Advanced Fantasy Football Analytics"><meta property="og:type" content="website"><meta property="og:url" content="https://ffexchange.vercel.app/"><meta property="og:image" content="https://ffexchange.vercel.app/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="630"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="FFSE"><meta name="twitter:description" content="Advanced Fantasy Football Analytics"><meta name="twitter:image" content="https://ffexchange.vercel.app/og-image.png"><meta name="description" content="FFSE - Advanced Fantasy Football Analytics"><meta name="theme-color" content="#000000"><script src="https://cdn.jsdelivr.net/npm/chart.js"></script><script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script><script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script><script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script><style>

* {
margin: 0;
padding: 0;
box-sizing: border-box;
}
:root {

--bg-primary: #000;
--bg-secondary: #0a0a0a;
--bg-tertiary: #1c1c1e;
--bg-elevated: #2c2c2e;

--text-primary: #fff;
--text-secondary: #8e8e93;
--text-tertiary: #636366;

--positive: #30d158;
--positive-bg: rgba(48, 209, 88, 0.15);
--negative: #ff453a;
--negative-bg: rgba(255, 69, 58, 0.15);
--accent-blue: #0a84ff;

--border-color: #1c1c1e;
--border-color-light: #2c2c2e;

--spacing-xs: 4px;
--spacing-sm: 8px;
--spacing-md: 16px;
--spacing-lg: 24px;
--spacing-xl: 32px;
}

[data-theme="light"] {
--bg-primary: #f9f8f4;
--bg-secondary: #f4f3ef;
--bg-tertiary: #eceae5;
--bg-elevated: #ffffff;

--text-primary: #1a1a1a;
--text-secondary: #5a5a5a;
--text-tertiary: #7a7a7a;

--positive: #28a745;
--positive-bg: rgba(40, 167, 69, 0.1);
--negative: #dc3545;
--negative-bg: rgba(220, 53, 69, 0.1);
--accent-blue: #007aff;

--border-color: #d9d7d2;
--border-color-light: #eceae5;
}

.theme-toggle {
position: fixed;
bottom: 24px;
right: 24px;
width: 56px;
height: 56px;
border-radius: 50%;
background: var(--bg-elevated);
border: 1px solid var(--border-color);
cursor: pointer;
display: flex;
align-items: center;
justify-content: center;
z-index: 9999;
transition: all 0.3s ease;
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}
.theme-toggle:hover {
transform: scale(1.1);
box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
}
.theme-toggle svg {
width: 24px;
height: 24px;
transition: all 0.3s ease;
}
.theme-toggle .sun-icon {
display: none;
color: #ffa500;
}
.theme-toggle .moon-icon {
display: block;
color: #0a84ff;
}
[data-theme="light"] .theme-toggle .sun-icon {
display: block;
}
[data-theme="light"] .theme-toggle .moon-icon {
display: none;
}
@media (max-width: 768px) {
.theme-toggle {
display: none; 
}
}
body {
font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', system-ui, sans-serif;
background: var(--bg-primary);
color: var(--text-primary);
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;
overflow-x: hidden;
}

.app-container {
min-height: 100vh;
display: flex;
flex-direction: column;
max-width: 100vw;
overflow-x: hidden;
overflow-y: visible;
}
.main-content {
flex: 1;
padding: var(--spacing-lg);
max-width: 1400px;
margin: 0 auto;
width: 100%;
box-sizing: border-box;
overflow: visible;
}
.page {
display: none;
animation: fadeIn 0.3s ease-in;
overflow: visible;
}
.page.active {
display: block;
overflow: visible;
}
@media (max-width: 768px) {
.page {
overflow-x: hidden;
max-width: 100vw;
}
}

.all-leaderboards-wrapper {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
gap: 24px;
padding: 24px 24px 48px;
width: 100%;
max-width: 100%;
overflow: hidden;
}
@media (max-width: 768px) {
.all-leaderboards-wrapper {
grid-template-columns: 1fr !important;
padding: 12px !important;
gap: 16px;
max-width: 100vw;
overflow: hidden;
}

.all-leaderboards-wrapper > div {
max-width: 100%;
overflow: hidden;
padding: 12px !important;
box-sizing: border-box;
}

.all-leaderboards-wrapper .compact-player-card,
.all-leaderboards-wrapper .player-card {
max-width: 100%;
overflow: hidden;
box-sizing: border-box;
padding: 8px 10px !important;
width: 100% !important;
}

.compact-player-card .metric-bar-container {
max-width: 60px !important;
width: 60px !important;
min-width: 60px !important;
flex-shrink: 0;
}
.compact-player-card .compact-metric-value {
flex-shrink: 0;
min-width: 0;
}

#ppg-leaderboard-content {
grid-template-columns: 1fr !important;
}

#all-leaderboards-grid > div {
grid-template-columns: 1fr !important;
}
.ppg-position-btn {
flex: 1;
padding: 8px 8px !important;
font-size: 11px !important;
}

#all-leaderboards .page-header {
padding: 16px 12px !important;
}
#all-leaderboards .page-title {
font-size: 20px !important;
}
#all-leaderboards .page-subtitle {
font-size: 12px !important;
}

.compact-player-card > div {
min-width: 0 !important;
}
}
@keyframes fadeIn {
from { opacity: 0; transform: translateY(10px); }
to { opacity: 1; transform: translateY(0); }
}

.home-hero {
text-align: center;
padding: 48px 24px 32px;
border-bottom: 1px solid var(--border-color);
background: linear-gradient(180deg, var(--bg-secondary) 0%, var(--bg-primary) 100%);
}
.home-headline {
font-size: 48px;
font-weight: 700;
line-height: 1.1;
margin-bottom: 16px;
background: linear-gradient(135deg, var(--positive) 0%, var(--accent-blue) 100%);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
min-height: 58px;
transition: opacity 0.5s ease;
}
.home-subheadline {
font-size: 18px;
color: var(--text-secondary);
font-weight: 500;
margin-bottom: 32px;
min-height: 22px;
transition: opacity 0.5s ease;
}
.home-cta-group {
display: flex;
gap: 12px;
justify-content: center;
flex-wrap: wrap;
}
.home-cta-primary {
padding: 14px 32px;
background: var(--positive);
border: none;
border-radius: 10px;
color: white;
font-size: 15px;
font-weight: 600;
cursor: pointer;
transition: all 0.2s ease;
}
.home-cta-primary:hover {
transform: translateY(-2px);
box-shadow: 0 8px 20px rgba(48, 209, 88, 0.3);
}
.home-cta-secondary {
padding: 14px 32px;
background: transparent;
border: 2px solid var(--border-color);
border-radius: 10px;
color: var(--text-primary);
font-size: 15px;
font-weight: 600;
cursor: pointer;
transition: all 0.2s ease;
}
.home-cta-secondary:hover {
border-color: var(--accent-blue);
background: rgba(10, 132, 255, 0.1);
}
.home-insights-section {
padding: 48px 24px;
max-width: 1200px;
margin: 0 auto;
}
.home-section-header {
margin-bottom: 32px;
}
.home-section-title {
font-size: 32px;
font-weight: 700;
margin-bottom: 8px;
}
.home-section-subtitle {
font-size: 15px;
color: var(--text-secondary);
}
.home-insights-grid {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
gap: 20px;
margin-bottom: 48px;
grid-auto-flow: dense;
}
.home-insight-card {
background: var(--bg-secondary);
border: 1px solid var(--border-color);
clip-path: polygon(12px 0, 100% 0, 100% calc(100% - 12px), calc(100% - 12px) 100%, 0 100%, 0 12px);
padding: 24px;
cursor: pointer;
transition: all 0.3s ease;
display: flex;
flex-direction: column;
overflow: hidden;
}
.home-insight-card:hover {
transform: scale(1.02);
box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
border-color: var(--accent-blue);
}
.home-insight-card.large-feature {
grid-column: span 2;
grid-row: span 2;
}
.home-insight-card.horizontal-wide {
grid-column: span 2;
}
@media (min-width: 1400px) {
.home-insights-grid {
grid-template-columns: repeat(4, 1fr);
}
}
@media (min-width: 1024px) and (max-width: 1399px) {
.home-insights-grid {
grid-template-columns: repeat(3, 1fr);
}
.home-insight-card.large-feature {
grid-column: span 2;
grid-row: span 2;
}
.home-insight-card.horizontal-wide {
grid-column: span 2;
}
}
@media (max-width: 1023px) {
.home-insights-grid {
grid-template-columns: repeat(2, 1fr);
}
.home-insight-card.large-feature {
grid-column: span 2;
grid-row: span 1;
}
.home-insight-card.horizontal-wide {
grid-column: span 2;
}
}
@media (max-width: 768px) {
.home-insights-grid {
grid-template-columns: 1fr;
}
.home-insight-card.large-feature,
.home-insight-card.horizontal-wide {
grid-column: span 1;
grid-row: span 1;
}
.home-insight-card:nth-child(n+4) {
display: none;
}
}
.home-insight-card {
background: var(--bg-secondary);
border: 1px solid var(--border-color);
border-radius: 12px;
padding: 24px;
cursor: pointer;
transition: all 0.3s ease;
}
.home-insight-card:hover {
transform: scale(1.02);
box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
border-color: var(--accent-blue);
}
.insight-card-header {
display: flex;
justify-content: space-between;
align-items: flex-start;
margin-bottom: 16px;
}
.insight-card-label {
font-size: 11px;
font-weight: 600;
color: var(--text-tertiary);
text-transform: uppercase;
letter-spacing: 0.5px;
}
.insight-card-arrow {
font-size: 18px;
color: var(--text-tertiary);
transition: transform 0.3s ease;
}
.home-insight-card:hover .insight-card-arrow {
transform: translateX(4px);
color: var(--accent-blue);
}
.insight-card-value {
font-size: 36px;
font-weight: 700;
margin-bottom: 12px;
line-height: 1;
}
.insight-card-value.positive {
color: var(--positive);
}
.insight-card-value.negative {
color: var(--negative);
}
.insight-card-title {
font-size: 16px;
font-weight: 600;
margin-bottom: 8px;
color: var(--text-primary);
}
.insight-card-description {
font-size: 13px;
color: var(--text-secondary);
line-height: 1.5;
margin-bottom: 16px;
}
.insight-chart-container {
height: 140px;
background: var(--bg-tertiary);
clip-path: polygon(6px 0, 100% 0, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0 100%, 0 6px);
padding: 16px;
margin-top: 16px;
position: relative;
overflow: hidden;
}
.insight-chart-container canvas {
max-width: 100%;
max-height: 100%;
}
.insight-chart-container.small {
height: 80px;
padding: 12px;
}
.insight-chart-container.medium {
height: 140px;
}
.insight-chart-container.large {
height: 240px;
}
.insight-chart-container.tall {
height: 180px;
}
.insight-stat-badges {
display: flex;
gap: 8px;
margin-top: 12px;
flex-wrap: wrap;
}
.insight-stat-badge {
background: var(--bg-elevated);
border: 1px solid var(--border-color-light);
border-radius: 6px;
padding: 6px 10px;
font-size: 10px;
}
.insight-stat-badge-label {
color: var(--text-tertiary);
font-weight: 500;
margin-bottom: 2px;
}
.insight-stat-badge-value {
color: var(--text-primary);
font-weight: 700;
font-size: 13px;
}
.insight-split-charts {
display: grid;
grid-template-columns: 1fr 1fr;
gap: 12px;
margin-top: 16px;
}
.insight-mini-chart {
background: var(--bg-elevated);
border-radius: 6px;
padding: 12px;
height: 100px;
overflow: hidden;
}
.insight-mini-chart canvas {
max-width: 100%;
max-height: 100%;
}
.insight-mini-chart-label {
font-size: 10px;
color: var(--text-tertiary);
font-weight: 600;
margin-bottom: 8px;
text-transform: uppercase;
letter-spacing: 0.5px;
}
@media (max-width: 768px) {
.home-insight-card:nth-child(n+4) {
display: none;
}
}
.insight-card-chart-preview {
height: 120px;
background: var(--bg-tertiary);
border-radius: 8px;
margin-top: 16px;
position: relative;
overflow: hidden;
}
.chart-preview-mini {
width: 100%;
height: 100%;
max-width: 100%;
max-height: 100%;
}
.home-quick-links {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
gap: 16px;
margin-top: 32px;
}
.quick-link-card {
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
border-radius: 10px;
padding: 20px;
cursor: pointer;
transition: all 0.2s ease;
display: flex;
align-items: center;
gap: 16px;
}
.quick-link-card:hover {
background: var(--bg-elevated);
border-color: var(--accent-blue);
transform: translateX(4px);
}
.quick-link-icon {
font-size: 32px;
flex-shrink: 0;
display: none;
}
.quick-link-content {
flex: 1;
}
.quick-link-title {
font-size: 15px;
font-weight: 600;
margin-bottom: 4px;
}
.quick-link-description {
font-size: 12px;
color: var(--text-secondary);
}
@media (max-width: 768px) {
.home-hero {
padding: 32px 16px 24px;
}
.home-headline {
font-size: 32px;
}
.home-subheadline {
font-size: 15px;
}
.home-insights-grid {
grid-template-columns: 1fr;
gap: 16px;
}
.home-section-title {
font-size: 24px;
}
.insight-card-value {
font-size: 28px;
}
.home-quick-links {
grid-template-columns: 1fr;
}
}

.header {
background: var(--bg-secondary);
border-bottom: 1px solid var(--border-color);
position: sticky;
top: 0;
z-index: 100;
}
.ticker-section {
background: var(--bg-secondary);
border-bottom: 1px solid var(--border-color);
overflow: hidden;
position: sticky;
top: 73px; 
z-index: 99;
margin-bottom: 24px;
border-radius: 0; 
}
.ticker-header {
padding: 8px 24px;
font-size: 11px;
font-weight: 600;
color: var(--text-secondary);
text-transform: uppercase;
letter-spacing: 0.5px;
display: flex;
align-items: center;
gap: 8px;
}
.ticker-info-icon {
display: inline-flex;
align-items: center;
justify-content: center;
width: 16px;
height: 16px;
border-radius: 50%;
border: 1.5px solid var(--text-tertiary);
color: var(--text-tertiary);
font-size: 10px;
font-weight: 700;
font-style: normal;
cursor: pointer;
transition: all 0.2s ease;
position: relative;
z-index: 9999; 
flex-shrink: 0;
}
.ticker-info-icon:hover {
border-color: var(--text-secondary);
color: var(--text-secondary);
background: rgba(255, 255, 255, 0.05);
}
.ticker-info-icon:active {
transform: scale(0.95);
}
.ticker-tooltip {
position: absolute;
left: calc(100% + 8px);
top: 50%;
transform: translateY(-30%);
background: var(--bg-secondary);
border: 1px solid var(--border-color);
border-radius: 8px;
padding: 10px 14px;
font-size: 11px;
font-weight: 400;
color: var(--text-primary);
line-height: 1.4;
white-space: normal;
width: 300px;
max-width: calc(100vw - 80px);
text-transform: none;
letter-spacing: normal;
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
z-index: 10000; 
opacity: 0;
visibility: hidden;
transition: opacity 0.2s ease, visibility 0.2s ease;
}
.ticker-tooltip.active {
opacity: 1;
visibility: visible;
}
.ticker-tooltip::before {
content: '';
position: absolute;
right: 100%;
top: 20%;
border: 6px solid transparent;
border-right-color: var(--border-color);
}
.ticker-tooltip::after {
content: '';
position: absolute;
right: 100%;
top: 20%;
border: 5px solid transparent;
border-right-color: var(--bg-secondary);
margin-right: -1px;
}
@media (max-width: 768px) {
.ticker-tooltip {
width: 260px;
font-size: 10px;
padding: 8px 12px;
left: auto;
right: -8px;
transform: translateY(-30%) translateX(100%);
}
.ticker-tooltip::before {
right: auto;
left: 100%;
top: 20%;
border-right-color: transparent;
border-left-color: var(--border-color);
}
.ticker-tooltip::after {
right: auto;
left: 100%;
top: 20%;
margin-right: 0;
margin-left: -1px;
border-right-color: transparent;
border-left-color: var(--bg-secondary);
}
}

.leaderboard-info-icon {
display: inline-flex;
align-items: center;
justify-content: center;
width: 14px;
height: 14px;
border-radius: 50%;
border: 1.5px solid var(--text-tertiary);
color: var(--text-tertiary);
font-size: 9px;
font-weight: 700;
font-style: normal;
cursor: pointer;
transition: all 0.2s ease;
position: relative;
z-index: 9999; 
flex-shrink: 0;
margin-left: 6px;
}
.leaderboard-info-icon:hover {
border-color: var(--text-secondary);
color: var(--text-secondary);
background: rgba(255, 255, 255, 0.05);
}
.leaderboard-info-icon:active {
transform: scale(0.95);
}
.leaderboard-tooltip {
position: absolute;
left: calc(100% + 8px);
top: 50%;
transform: translateY(-30%);
background: var(--bg-secondary);
border: 1px solid var(--border-color);
border-radius: 8px;
padding: 10px 14px;
font-size: 11px;
font-weight: 400;
color: var(--text-primary);
line-height: 1.4;
white-space: normal;
width: 280px;
max-width: calc(100vw - 80px);
text-transform: none;
letter-spacing: normal;
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
z-index: 10000; 
opacity: 0;
visibility: hidden;
transition: opacity 0.2s ease, visibility 0.2s ease;
}
.leaderboard-tooltip.active {
opacity: 1;
visibility: visible;
}
.leaderboard-tooltip::before {
content: '';
position: absolute;
right: 100%;
top: 20%;
border: 6px solid transparent;
border-right-color: var(--border-color);
}
.leaderboard-tooltip::after {
content: '';
position: absolute;
right: 100%;
top: 20%;
border: 5px solid transparent;
border-right-color: var(--bg-secondary);
margin-right: -1px;
}
@media (max-width: 768px) {
.leaderboard-tooltip {
width: 240px;
font-size: 10px;
padding: 8px 12px;
}

.schedule-row {
display: flex !important;
flex-direction: column !important;
gap: 10px !important;
padding: 14px 16px !important;
grid-template-columns: unset !important;
}
.week-info {
flex-direction: row !important;
align-items: center;
justify-content: flex-start;
gap: 6px;
}
.week-label {
font-size: 10px !important;
text-transform: uppercase;
color: var(--text-secondary) !important;
}
.week-number {
font-size: 18px !important;
font-weight: 700;
}
.matchup-info {
justify-content: flex-end;
margin: 0;
}
.opponent-line {
margin-bottom: 0;
display: flex;
align-items: baseline;
gap: 6px;
justify-content: flex-end;
}
.vs-label {
font-size: 12px !important;
font-weight: 600 !important;
}
.opponent-team {
font-size: 18px !important;
font-weight: 700;
}

.mobile-defense-ranks {
display: flex !important;
flex-wrap: wrap;
gap: 8px;
margin-top: 0;
}
.mobile-rank {
font-size: 12px !important;
padding: 4px 10px;
border-radius: 6px;
white-space: nowrap;
font-weight: 600;
}

.mobile-rank.elite {
background: rgba(48, 209, 88, 0.2) !important;
color: #30d158 !important;
border: 1px solid rgba(48, 209, 88, 0.4);
}
.mobile-rank.good {
background: rgba(100, 210, 120, 0.15) !important;
color: #5ed573 !important;
border: 1px solid rgba(100, 210, 120, 0.3);
}
.mobile-rank.average {
background: rgba(255, 214, 10, 0.15) !important;
color: #ffd60a !important;
border: 1px solid rgba(255, 214, 10, 0.3);
}
.mobile-rank.tough {
background: rgba(255, 159, 10, 0.15) !important;
color: #ff9f0a !important;
border: 1px solid rgba(255, 159, 10, 0.3);
}
.mobile-rank.bad {
background: rgba(255, 69, 58, 0.15) !important;
color: #ff453a !important;
border: 1px solid rgba(255, 69, 58, 0.3);
}
.mobile-rank-separator {
display: none;
}
.desktop-only {
display: none !important;
}

#modal-candles-chart {
max-height: 300px !important;
}
#modal-chart-candles > div {
padding: 12px !important;
}
#modal-chart-candles h3 {
font-size: 16px !important;
}
#modal-chart-candles > div > div:first-child {
margin-bottom: 16px !important;
flex-direction: column !important;
align-items: flex-start !important;
gap: 8px !important;
}
#modal-chart-candles > div > div:first-child > div:last-child {
font-size: 11px !important;
}

#modal-chart-candles .modal-chart-wrapper,
#modal-chart-candles > div > div[style*="background: var(--bg-tertiary)"] {
padding: 12px !important;
border-radius: 8px !important;
}

#modal-chart-candles > div > div[style*="margin-top: 20px"] {
gap: 16px !important;
font-size: 11px !important;
margin-top: 12px !important;
}
#modal-chart-candles > div > div[style*="margin-top: 20px"] > div > div {
width: 12px !important;
height: 18px !important;
}
#candles-summary {
grid-template-columns: repeat(2, 1fr) !important;
gap: 8px !important;
margin-top: 16px !important;
}
#candles-summary > div {
padding: 12px !important;
}
#candles-summary > div > div:first-child {
font-size: 22px !important;
}
#candles-summary > div > div:last-child {
font-size: 10px !important;
}

#modal-chart-reliability > div {
padding: 16px 12px !important;
}
#modal-chart-reliability h3 {
font-size: 16px !important;
}

#modal-chart-reliability > div > div[style*="grid-template-columns: 180px"] {
grid-template-columns: 1fr !important;
gap: 16px !important;
}

#modal-chart-reliability canvas {
width: 100px !important;
height: 100px !important;
}

#modal-chart-reliability > div > div[style*="grid-template-columns: 180px"] > div:last-child {
grid-template-columns: 1fr 1fr !important;
gap: 8px !important;
}

#modal-chart-reliability > div > div[style*="grid-template-columns: 180px"] > div:last-child > div {
padding: 12px !important;
}
#modal-chart-reliability > div > div[style*="grid-template-columns: 180px"] > div:last-child span[style*="font-size: 13px"] {
font-size: 11px !important;
}
#modal-chart-reliability > div > div[style*="grid-template-columns: 180px"] > div:last-child div[style*="font-size: 16px"] {
font-size: 14px !important;
}

#prs-usage-value,
#prs-rz-value,
#prs-consistency-value,
#prs-games-value {
display: block !important;
visibility: visible !important;
opacity: 1 !important;
-webkit-font-smoothing: antialiased !important;
-moz-osx-font-smoothing: grayscale !important;
font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', system-ui, sans-serif !important;
min-height: 20px !important;
position: relative !important;
}

#prs-usage-value:empty::after,
#prs-rz-value:empty::after {
content: attr(data-value) !important;
display: block !important;
font-size: 16px !important;
font-weight: 600 !important;
}

#modal-chart-reliability > div > div[style*="grid-template-columns: 180px"] > div:last-child > div {
opacity: 1 !important;
visibility: visible !important;
}

#prs-tooltip {
left: auto !important;
right: 0 !important;
width: 280px !important;
top: 25px !important;
}

.modal-team-badge {
width: 48px !important;
height: 48px !important;
font-size: 14px !important;
border-radius: 6px !important;
}

#team-modal .modal-header {
position: relative !important;
}
#team-modal .modal-player-name {
font-size: 20px !important;
}
#team-modal .modal-player-meta {
font-size: 11px !important;
}

#key-players-grid {
grid-template-columns: 1fr !important;
gap: 8px !important;
}
.key-players-section h3 {
font-size: 14px !important;
margin-bottom: 10px !important;
}

#team-modal-controls-grid {
grid-template-columns: 1fr !important;
gap: 12px !important;
margin-bottom: 16px !important;
}
#team-modal-controls-grid label {
font-size: 12px !important;
margin-bottom: 6px !important;
}
#team-modal-controls-grid select {
padding: 8px 10px !important;
font-size: 13px !important;
}

.team-modal-charts-grid {
grid-template-columns: 1fr !important;
gap: 16px !important;
}
.chart-header {
font-size: 13px !important;
padding: 10px 12px !important;
}
.chart-wrapper {
height: 250px !important;
}

.modal-team-badge {
width: 48px !important;
height: 48px !important;
font-size: 14px !important;
border-radius: 6px !important;
}
.modal-player-name {
font-size: 22px !important;
line-height: 1.2 !important;
}
.modal-player-meta {
font-size: 12px !important;
}
.modal-player-info {
gap: 12px !important;
margin-bottom: 12px !important;
}
.modal-header {
padding: 16px !important;
position: relative !important;
}

.modal-header .sentiment-bar-3section {
width: 140px !important;
height: 6px !important;
}
.modal-header [style*="font-size: 11px"] {
font-size: 10px !important;
}
.vote-btn {
padding: 4px 10px !important;
font-size: 10px !important;
}

.modal-close {
width: 28px !important;
height: 28px !important;
font-size: 18px !important;
top: 12px !important;
right: 12px !important;
}
}
.ticker-content {
overflow: hidden;
}
.header-content {
max-width: 1400px;
margin: 0 auto;
padding: var(--spacing-md) var(--spacing-lg);
display: flex;
justify-content: space-between;
align-items: center;
}
.logo {
font-size: 24px;
font-weight: 900;
color: #fff;
display: flex;
align-items: center;
gap: 10px;
}
.logo-icon {
width: 32px;
height: 32px;
background: linear-gradient(135deg, #30d158, #0a84ff);
border-radius: 8px;
display: flex;
align-items: center;
justify-content: center;
position: relative;
font-size: 22px;
font-weight: 900;
color: white;
box-shadow: 0 0 20px rgba(48, 209, 88, 0.4),
0 0 40px rgba(10, 132, 255, 0.2);
transition: all 0.3s ease;
}
.logo-icon:hover {
animation: logoPulse 2s ease-in-out infinite;
}
@keyframes logoPulse {
0%, 100% {
box-shadow: 0 0 20px rgba(48, 209, 88, 0.4),
0 0 40px rgba(10, 132, 255, 0.2);
transform: scale(1);
}
50% {
box-shadow: 0 0 30px rgba(48, 209, 88, 0.6),
0 0 60px rgba(10, 132, 255, 0.4);
transform: scale(1.05);
}
}
.logo-icon::before {
content: '>';
transform: scaleX(1.3);
}
.nav-tabs {
display: flex;
gap: var(--spacing-sm);
align-items: center;
}
.nav-tab {
padding: var(--spacing-sm) var(--spacing-md);
background: transparent;
border: none;
color: var(--text-secondary);
font-size: 14px;
font-weight: 500;
cursor: pointer;
border-radius: 8px;
transition: all 0.2s ease;
}
.nav-tab:hover {
background: var(--bg-tertiary);
color: var(--text-primary);
}
.nav-tab.active {
background: var(--bg-tertiary);
color: var(--text-primary);
font-weight: 700;
}

/* Dropdown Navigation */
.nav-dropdown {
position: relative;
}
.nav-dropdown-trigger {
padding: var(--spacing-sm) var(--spacing-md);
background: transparent;
border: none;
color: var(--text-secondary);
font-size: 14px;
font-weight: 500;
cursor: pointer;
border-radius: 8px;
transition: all 0.2s ease;
display: flex;
align-items: center;
gap: 6px;
}
.nav-dropdown-trigger::after {
content: 'â–¼';
font-size: 10px;
transition: transform 0.2s ease;
}
.nav-dropdown.open .nav-dropdown-trigger::after {
transform: rotate(180deg);
}
.nav-dropdown-trigger:hover,
.nav-dropdown.open .nav-dropdown-trigger {
background: var(--bg-tertiary);
color: var(--text-primary);
}
.dropdown-menu {
position: absolute;
top: calc(100% + 8px);
left: 0;
background: var(--bg-elevated);
border: 1px solid var(--border-color-light);
border-radius: 12px;
min-width: 200px;
opacity: 0;
visibility: hidden;
transform: translateY(-10px);
transition: all 0.2s ease;
box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
z-index: 1001;
}
.nav-dropdown.open .dropdown-menu {
opacity: 1;
visibility: visible;
transform: translateY(0);
}
.dropdown-item {
display: block;
width: 100%;
padding: 12px 16px;
background: transparent;
border: none;
color: var(--text-secondary);
font-size: 14px;
font-weight: 600;
cursor: pointer;
text-align: left;
transition: all 0.2s ease;
border-radius: 0;
}
.dropdown-item:first-child {
border-top-left-radius: 12px;
border-top-right-radius: 12px;
}
.dropdown-item:last-child {
border-bottom-left-radius: 12px;
border-bottom-right-radius: 12px;
}
.dropdown-item:hover {
background: var(--bg-tertiary);
color: var(--text-primary);
}
.dropdown-item.active {
background: var(--bg-tertiary);
color: var(--accent-blue);
}
.upload-btn {
padding: var(--spacing-sm) var(--spacing-md);
background: linear-gradient(135deg, #30d158, #0a84ff);
color: white;
border: none;
border-radius: 8px;
font-weight: 600;
cursor: pointer;
font-size: 14px;
transition: all 0.2s ease;
box-shadow: 0 0 15px rgba(48, 209, 88, 0.3),
0 0 30px rgba(10, 132, 255, 0.15);
}
.upload-btn:hover {
box-shadow: 0 0 20px rgba(48, 209, 88, 0.5),
0 0 40px rgba(10, 132, 255, 0.25);
transform: translateY(-1px);
}


.header-scoring-dropdown {
position: relative;
display: inline-block;
}
.header-scoring-button {
padding: 6px 16px;
font-size: 11px;
font-weight: 600;
color: var(--text-primary);
background: var(--bg-tertiary);
border: none;
border-radius: 16px;
cursor: pointer;
transition: all 0.2s ease;
text-transform: uppercase;
letter-spacing: 0.5px;
display: flex;
align-items: center;
gap: 6px;
position: relative;
}
.header-scoring-button::after {
content: '';
position: absolute;
bottom: -1px;
left: 50%;
transform: translateX(-50%);
width: 16px;
height: 2px;
background: var(--positive);
border-radius: 2px;
}
.header-scoring-button:hover {
background: var(--bg-elevated);
}
.header-scoring-button .arrow {
font-size: 10px;
transition: transform 0.2s ease;
}
.header-scoring-dropdown.open .header-scoring-button .arrow {
transform: rotate(180deg);
}
.header-scoring-menu {
position: absolute;
top: calc(100% + 8px);
right: 0;
background: var(--bg-elevated);
border-radius: 12px;
padding: 6px;
min-width: 140px;
box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
opacity: 0;
visibility: hidden;
transform: translateY(-10px);
transition: all 0.2s ease;
z-index: 1000;
}
.header-scoring-dropdown.open .header-scoring-menu {
opacity: 1;
visibility: visible;
transform: translateY(0);
}
.header-scoring-menu button {
width: 100%;
padding: 10px 16px;
font-size: 12px;
font-weight: 600;
color: var(--text-secondary);
background: transparent;
border: none;
border-radius: 8px;
cursor: pointer;
transition: all 0.2s ease;
text-align: left;
text-transform: uppercase;
letter-spacing: 0.5px;
}
.header-scoring-menu button:hover {
background: rgba(255, 255, 255, 0.05);
color: var(--text-primary);
}
.header-scoring-menu button.active {
background: var(--positive);
color: white;
}
.ticker-container {
background: var(--bg-secondary);
border-bottom: 1px solid var(--border-color);
overflow: hidden;
height: 40px;
display: flex;
align-items: center;
}

/* Ticker Stat Styles (for leaderboard-style ticker) */
.ticker-stat {
    display: inline-flex;
    align-items: center;
    padding: 0 24px;
    border-right: 1px solid rgba(255, 255, 255, 0.08);
    gap: 16px;
    white-space: nowrap;
}

.ticker-stat:first-child {
    padding-left: 0;
}

.ticker-stat-label {
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary);
    white-space: nowrap;
}

.ticker-stat-value-group {
    display: inline-flex;
    align-items: center;
    gap: 12px;
}

.ticker-stat-team {
    font-size: 11px;
    color: var(--text-tertiary);
    font-weight: 500;
    white-space: nowrap;
}

.ticker-stat-change {
    font-size: 13px;
    font-weight: 600;
    white-space: nowrap;
}
.ticker-stat-change.positive {
    color: var(--positive);
}
.ticker-stat-change.negative {
    color: var(--negative);
}

.ticker-stat-value {
    font-size: 11px;
    font-weight: 600;
    color: var(--text-secondary);
    font-variant-numeric: tabular-nums;
    white-space: nowrap;
}



.ticker-stat:hover {
    background: linear-gradient(90deg, rgba(255, 255, 255, 0.03) 0%, rgba(255, 255, 255, 0.05) 100%);
}

.ticker-stat:first-child {
    border-left: 1px solid rgba(255, 255, 255, 0.06);
}

.ticker-stat-value-group {
    display: flex;
    align-items: center;
    gap: 16px;
    flex-wrap: nowrap;
}

.ticker-track {
display: flex;
animation: scroll 60s linear infinite;
white-space: nowrap;
}
@keyframes scroll {
0% { transform: translateX(0); }
100% { transform: translateX(-50%); }
}
@keyframes scrollReverse {
0% { transform: translateX(-50%); }
100% { transform: translateX(0%); }
}
.ticker-track {
animation-duration: 540s !important;
}
.ticker-item {
padding: 0 var(--spacing-lg);
font-size: 13px;
display: inline-block;
white-space: nowrap;
}
.ticker-item > span {
display: inline;
vertical-align: middle;
line-height: 1;
}
.ticker-item .player-name {
font-weight: 700;
color: var(--text-primary);
}
#teams-ticker-track .ticker-item .player-name {
font-size: 13px;
font-weight: 700;
}
.ticker-item .avg-pts {
color: var(--text-secondary);
}

#analytics-insights-track .ticker-item .avg-pts {
color: var(--positive);
font-weight: 600;
background: rgba(48, 209, 88, 0.15);
padding: 2px 8px;
border-radius: 4px;
}
.ticker-item .change {
font-weight: 600;
}
.ticker-item .change.positive {
color: var(--positive);
}
.ticker-item .change.negative {
color: var(--negative);
}

.scoring-toggle-container {
display: none; 
}
.scoring-toggle {
display: inline-flex;
background: var(--bg-tertiary);
border-radius: 20px;
padding: 4px;
gap: 4px;
box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
}
.scoring-option {
padding: 8px 20px;
font-size: 12px;
font-weight: 600;
color: var(--text-secondary);
background: transparent;
border: none;
border-radius: 16px;
cursor: pointer;
transition: all 0.3s ease;
text-transform: uppercase;
letter-spacing: 0.5px;
position: relative;
}
.scoring-option:hover {
color: var(--text-primary);
background: rgba(255, 255, 255, 0.05);
}
.scoring-option.active {
background: var(--bg-elevated);
color: var(--text-primary);
box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}
.scoring-option.active::after {
content: '';
position: absolute;
bottom: -2px;
left: 50%;
transform: translateX(-50%);
width: 20px;
height: 2px;
background: var(--positive);
border-radius: 2px;
}

@keyframes fadeUpdate {
0% { opacity: 1; }
50% { opacity: 0.4; }
100% { opacity: 1; }
}
.updating-values {
animation: fadeUpdate 0.6s ease-in-out;
}

.player-table {
background: var(--bg-secondary);
border-radius: 12px;
overflow: hidden;
margin-top: var(--spacing-lg);
}
.table-header {
display: grid;
grid-template-columns: 50px 60px 1fr 80px 80px 80px 100px 120px;
gap: var(--spacing-md);
padding: var(--spacing-md) var(--spacing-lg);
background: var(--bg-tertiary);
font-size: 12px;
font-weight: 600;
color: var(--text-secondary);
text-transform: uppercase;
letter-spacing: 0.5px;
border-bottom: 1px solid var(--border-color);
}
.table-header > div {
cursor: pointer;
user-select: none;
display: flex;
align-items: center;
gap: 4px;
}
.table-header > div:hover {
color: var(--text-primary);
}
.player-row {
display: grid;
grid-template-columns: 50px 60px 1fr 80px 80px 80px 100px 120px;
gap: var(--spacing-md);
padding: var(--spacing-md) var(--spacing-lg);
align-items: center;
border-bottom: 1px solid var(--border-color);
cursor: pointer;
transition: all 0.2s ease;
}
.mini-chart {
width: 100%;
height: 30px;
position: relative;
}
.mini-chart canvas {
width: 100% !important;
height: 30px !important;
}
.player-row:hover {
background: var(--bg-tertiary);
}
.player-row:last-child {
border-bottom: none;
}
.player-rank {
font-weight: 700;
color: var(--text-secondary);
font-size: 14px;
}
.team-badge {
width: 40px;
height: 40px;
border-radius: 6px;
display: flex;
align-items: center;
justify-content: center;
font-size: 11px;
font-weight: 700;
color: white;
}
.player-info {
display: flex;
flex-direction: column;
}
.player-name-text {
font-weight: 600;
font-size: 15px;
color: var(--text-primary);
display: flex;
align-items: center;
gap: 8px;
}

.player-headshot {
width: 32px;
height: 32px;
border-radius: 50%;
background: var(--bg-elevated);
border: 2px solid var(--border-color);
object-fit: cover;
flex-shrink: 0;
}
.player-headshot.loading {
background: linear-gradient(90deg, var(--bg-elevated) 25%, var(--bg-tertiary) 50%, var(--bg-elevated) 75%);
background-size: 200% 100%;
animation: shimmer 1.5s infinite;
}
@keyframes shimmer {
0% { background-position: 200% 0; }
100% { background-position: -200% 0; }
}
.player-position {
font-size: 12px;
color: var(--text-secondary);
}
.player-stat {
font-weight: 600;
font-size: 14px;
}
.stat-change {
display: flex;
align-items: center;
gap: 4px;
font-weight: 600;
font-size: 14px;
}
.stat-change.positive {
color: var(--positive);
}
.stat-change.negative {
color: var(--negative);
}

.cards-grid {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
gap: var(--spacing-md);
margin-top: var(--spacing-lg);
justify-content: center;
}
.cards-grid.two-or-less {
grid-template-columns: repeat(2, 1fr);
}
.grid-spacer {

visibility: hidden;
}
.team-card {
width: 100%;
background: var(--bg-secondary);
border: 1px solid var(--border-color);
border-radius: 12px;
padding: var(--spacing-md);
cursor: pointer;
transition: all 0.2s ease;
display: flex;
flex-direction: column;
}
.team-card:hover {
transform: translateY(-2px);
border-color: var(--border-color-light);
box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
}
.team-card-header {
display: flex;
align-items: center;
gap: var(--spacing-sm);
margin-bottom: var(--spacing-sm);
}
.team-card-badge {
width: 40px;
height: 40px;
border-radius: 8px;
display: flex;
align-items: center;
justify-content: center;
font-size: 12px;
font-weight: 700;
color: white;
}
.team-card-name {
font-size: 16px;
font-weight: 700;
}
.team-card-stats {
display: flex;
flex-direction: column;
gap: var(--spacing-xs);
margin-bottom: var(--spacing-sm);
}
.team-stat {
display: flex;
justify-content: space-between;
font-size: 12px;
position: relative;
}
.team-stat:hover .stat-tooltip {
opacity: 1;
}
.team-stat-label {
color: var(--text-secondary);
font-size: 8px;
}
.team-stat-value {
font-weight: 600;
font-size: 12px;
}
.team-card-chart {
height: 140px;
margin-top: auto;
position: relative;
}
.team-card-chart canvas {
max-height: 140px;
}

.player-card {
width: 100%;
max-width: 100%; 
min-height: 160px;
background: var(--bg-secondary);
border: 1px solid var(--border-color);
border-radius: 12px;
padding: var(--spacing-lg);
cursor: pointer;
transition: all 0.2s ease;
display: flex;
flex-direction: column;
}

.player-cards-grid {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); 
gap: 16px;
overflow: visible;
width: 100%;
}

.player-cards-grid .player-card {
width: 100%;
}
.player-card:hover {
transform: translateY(-2px);
border-color: var(--border-color-light);
box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
z-index: 10; 
position: relative; 
}
.player-card-header {
display: flex;
align-items: center;
gap: var(--spacing-md);
margin-bottom: var(--spacing-md);
}
.player-card-badge {
width: 50px;
height: 50px;
border-radius: 8px;
display: flex;
align-items: center;
justify-content: center;
font-size: 11px;
font-weight: 700;
color: white;
text-align: center;
}
.player-card-name {
font-size: 16px;
font-weight: 700;
margin-bottom: 4px;
}
.player-card-team {
font-size: 13px;
color: var(--text-secondary);
}
.player-tags {
display: flex;
gap: 6px;
flex-wrap: wrap;
margin-top: 6px;
}
.player-tag {
font-size: 10px;
font-weight: 600;
padding: 3px 8px;
border-radius: 4px;
text-transform: uppercase;
letter-spacing: 0.3px;
position: relative;
cursor: help;
}
.player-tag:hover::after {
content: attr(data-tooltip);
position: absolute;
bottom: 100%;
left: 50%;
transform: translateX(-50%);
margin-bottom: 8px;
padding: 8px 12px;
background: rgba(0, 0, 0, 0.95);
color: #fff;
font-size: 11px;
font-weight: 500;
border-radius: 6px;
white-space: nowrap;
z-index: 1000;
border: 1px solid rgba(255, 255, 255, 0.1);
letter-spacing: 0;
text-transform: none;
}
.player-tag:hover::before {
content: '';
position: absolute;
bottom: 100%;
left: 50%;
transform: translateX(-50%);
margin-bottom: 2px;
border: 4px solid transparent;
border-top-color: rgba(0, 0, 0, 0.95);
z-index: 1000;
}
.player-tag.buy-low {
background: rgba(48, 209, 88, 0.15);
color: #30d158;
border: 1px solid rgba(48, 209, 88, 0.3);
}
.player-tag.sell-high {
background: rgba(255, 69, 58, 0.15);
color: #ff453a;
border: 1px solid rgba(255, 69, 58, 0.3);
}
.player-tag.rz-up {
background: rgba(255, 214, 10, 0.15);
color: #FFD60A;
border: 1px solid rgba(255, 214, 10, 0.3);
}

.injury-badge {
font-size: 9px;
font-weight: 700;
padding: 2px 6px;
border-radius: 3px;
text-transform: uppercase;
letter-spacing: 0.5px;
display: inline-block;
margin-left: 6px;
position: relative;
cursor: help;
}
.injury-badge.questionable {
background: rgba(255, 214, 10, 0.2);
color: #FFD60A;
border: 1px solid rgba(255, 214, 10, 0.4);
}
.injury-badge.doubtful {
background: rgba(255, 149, 0, 0.2);
color: #FF9500;
border: 1px solid rgba(255, 149, 0, 0.4);
}
.injury-badge.out,
.injury-badge.ir,
.injury-badge.pup {
background: rgba(255, 69, 58, 0.2);
color: #FF453A;
border: 1px solid rgba(255, 69, 58, 0.4);
}
.injury-badge.suspended,
.injury-badge.cov {
background: rgba(142, 142, 147, 0.2);
color: #8E8E93;
border: 1px solid rgba(142, 142, 147, 0.4);
}
.injury-badge:hover::after {
content: attr(data-injury-details);
position: absolute;
bottom: 100%;
left: 50%;
transform: translateX(-50%);
margin-bottom: 8px;
padding: 8px 12px;
background: rgba(0, 0, 0, 0.95);
color: #fff;
font-size: 11px;
font-weight: 500;
border-radius: 6px;
white-space: nowrap;
z-index: 10000;
border: 1px solid rgba(255, 255, 255, 0.1);
letter-spacing: 0;
text-transform: none;
}
.injury-badge:hover::before {
content: '';
position: absolute;
bottom: 100%;
left: 50%;
transform: translateX(-50%);
margin-bottom: 2px;
border: 4px solid transparent;
border-top-color: rgba(0, 0, 0, 0.95);
z-index: 10000;
}
.player-card-stats {
display: flex;
flex-direction: column;
gap: var(--spacing-sm);
margin-bottom: var(--spacing-md);
}
.player-stat {
display: flex;
justify-content: space-between;
font-size: 13px;
position: relative;
}

.player-stat-label:hover + .stat-tooltip,
.player-stat-label:hover ~ .stat-tooltip {
opacity: 1;
}

.player-stat:hover .stat-tooltip {
opacity: 1;
}
.player-stat:hover .player-stat-with-comparison:hover ~ .stat-tooltip,
.player-stat-with-comparison:hover ~ .stat-tooltip {
opacity: 0 !important; 
}
.stat-tooltip {
position: absolute;
bottom: 100%;
left: 50%;
transform: translateX(-50%);
margin-bottom: 8px;
background: var(--bg-elevated);
border: 1px solid var(--border-color-light);
border-radius: 8px;
padding: 8px 12px;
font-size: 11px;
white-space: nowrap;
opacity: 0;
pointer-events: none;
transition: opacity 0.2s ease;
z-index: 1000;
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}
.player-stat-label {
color: var(--text-secondary);
}
.player-stat-value {
font-weight: 600;
}
.player-comparison {
display: flex;
align-items: center;
gap: 4px;
font-size: 11px;
font-weight: 600;
}
.comparison-icon {
font-size: 10px;
}
.comparison-up {
color: var(--positive);
}
.comparison-down {
color: var(--negative);
}
.player-stat-with-comparison {
display: flex;
align-items: center;
justify-content: space-between;
gap: 8px;
position: relative;
}
.comparison-tooltip {
position: absolute;
bottom: 100%;
right: 0; 
transform: translateY(0);
margin-bottom: 8px;
background: var(--bg-elevated);
border: 1px solid var(--border-color-light);
border-radius: 8px;
padding: 8px 12px;
font-size: 11px;
white-space: nowrap;
opacity: 0;
pointer-events: none;
transition: opacity 0.2s ease;
z-index: 1001; 
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}

.player-comparison:hover + .comparison-tooltip,
.player-comparison:hover ~ .comparison-tooltip {
opacity: 1;
}
.tooltip-label {
color: var(--text-secondary);
margin-bottom: 4px;
}
.tooltip-data {
font-weight: 600;
color: var(--text-primary);
}
.player-card-chart {
height: 120px;
margin-top: auto;
position: relative;
}
.player-card-chart canvas {
max-height: 120px;
}
.tier-section {
margin-bottom: var(--spacing-xl);
}
.tier-header {
display: flex;
align-items: center;
gap: var(--spacing-md);
margin-bottom: var(--spacing-lg);
padding-bottom: var(--spacing-md);
border-bottom: 2px solid var(--border-color);
cursor: pointer;
user-select: none;
transition: opacity 0.2s ease;
}
.tier-header:hover {
opacity: 0.8;
}
.tier-collapse-icon {
font-size: 14px;
color: var(--text-secondary);
transition: transform 0.3s ease;
margin-left: 8px;
}
.tier-collapse-icon.collapsed {
transform: rotate(-90deg);
}
.tier-cards-container {
overflow: hidden;
max-height: 100000px; 
transition: max-height 0.3s ease, opacity 0.3s ease;
opacity: 1;
}
.tier-cards-container.collapsed {
max-height: 0 !important;
opacity: 0;
}
.tier-badge {
padding: 6px 12px;
border-radius: 6px;
font-size: 12px;
font-weight: 700;
text-transform: uppercase;
letter-spacing: 0.5px;
}
.tier-badge.elite {
background: rgba(48, 209, 88, 0.2);
color: #30d158;
}
.tier-badge.wr2 {
background: rgba(10, 132, 255, 0.2);
color: #0a84ff;
}
.tier-badge.flex {
background: rgba(255, 214, 10, 0.2);
color: #FFD60A;
}
.tier-badge.depth {
background: rgba(142, 142, 147, 0.2);
color: #8e8e93;
}
.tier-title {
font-size: 20px;
font-weight: 700;
}
.tier-count {
font-size: 14px;
color: var(--text-secondary);
text-align: right;
margin-left: auto;
}


.momentum-badge {
display: inline-block;
padding: 2px 6px;
border-radius: 4px;
font-size: 11px;
font-weight: 700;
margin-left: 4px;
cursor: help;
position: relative;
transition: all 0.2s ease;
}
.momentum-badge.up {
background: rgba(52, 199, 89, 0.2);
color: #34c759;
border: 1px solid rgba(52, 199, 89, 0.4);
}
.momentum-badge.down {
background: rgba(255, 69, 58, 0.2);
color: #ff453a;
border: 1px solid rgba(255, 69, 58, 0.4);
}
.momentum-badge.neutral {
display: none; 
}
.momentum-badge:hover {
transform: scale(1.1);
}

.momentum-badge::after {
content: attr(data-tooltip);
position: absolute;
bottom: 100%;
left: 50%;
transform: translateX(-50%);
margin-bottom: 8px;
padding: 8px 12px;
background: rgba(0, 0, 0, 0.95);
color: #fff;
font-size: 11px;
font-weight: 500;
border-radius: 6px;
white-space: nowrap;
z-index: 1000;
border: 1px solid rgba(255, 255, 255, 0.1);
opacity: 0;
pointer-events: none;
transition: opacity 0.2s ease;
}
.momentum-badge:hover::after {
opacity: 1;
}
.momentum-badge::before {
content: '';
position: absolute;
bottom: 100%;
left: 50%;
transform: translateX(-50%);
margin-bottom: 2px;
border: 4px solid transparent;
border-top-color: rgba(0, 0, 0, 0.95);
z-index: 1000;
opacity: 0;
pointer-events: none;
transition: opacity 0.2s ease;
}
.momentum-badge:hover::before {
opacity: 1;
}

.top-movers-container {
display: flex;
flex-direction: column;
gap: 20px;
margin-top: 20px;
}
.top-movers-container {
display: grid;
grid-template-columns: 1fr 1fr;
gap: 16px;
margin-bottom: 24px;
}
.top-movers-widget {
background: var(--bg-secondary);
border-radius: 12px;
padding: 16px;
border: 1px solid var(--border-color);
animation: fadeInUp 0.4s ease-out;
}
@keyframes fadeInUp {
from {
opacity: 0;
transform: translateY(10px);
}
to {
opacity: 1;
transform: translateY(0);
}
}
.top-movers-header {
display: flex;
align-items: center;
justify-content: space-between;
gap: 8px;
margin-bottom: 12px;
padding-bottom: 10px;
border-bottom: 1px solid var(--border-color);
user-select: none;
}
.top-movers-header:hover {
opacity: 1; 
}
.top-movers-header-left {
display: flex;
align-items: center;
gap: 8px;
}
.top-movers-title {
font-size: 13px;
font-weight: 700;
text-transform: uppercase;
letter-spacing: 0.5px;
}
.top-movers-widget.risers .top-movers-title {
color: #30d158;
}
.top-movers-widget.fallers .top-movers-title {
color: #ff453a;
}
.top-movers-icon {
font-size: 16px;
}
.top-movers-list {
display: grid;
grid-template-columns: repeat(2, 1fr); 
gap: 8px;
}
.top-mover-item {
position: relative;
display: flex;
flex-direction: column;
align-items: flex-start;
gap: 4px;
padding: 10px;
background: var(--bg-tertiary);
border-radius: 8px;
cursor: pointer;
transition: all 0.2s ease;
}
.top-mover-item:hover {
background: var(--bg-elevated);
transform: translateY(-2px);
}
.top-mover-rank {
font-size: 11px;
font-weight: 700;
color: var(--text-secondary);
margin-bottom: 4px;
}
.top-mover-arrow {
position: absolute;
top: 8px;
right: 8px;
font-size: 14px;
flex-shrink: 0;
}
.top-movers-widget.risers .top-mover-arrow {
color: #30d158;
}
.top-movers-widget.fallers .top-mover-arrow {
color: #ff453a;
}
.top-mover-info {
flex: 1;
min-width: 0;
width: 100%;
}
.top-mover-name {
font-size: 13px;
font-weight: 600;
color: var(--text-primary);
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
margin-bottom: 2px;
}
.top-mover-team {
font-size: 11px;
color: var(--text-secondary);
margin-bottom: 4px;
}
.top-mover-score {
font-size: 13px;
font-weight: 700;
flex-shrink: 0;
}
.top-movers-widget.risers .top-mover-score {
color: #30d158;
}
.top-movers-widget.fallers .top-mover-score {
color: #ff453a;
}

.top-mover-hidden {
display: none;
}
.top-movers-expand-btn {
width: 100%;
padding: 10px;
margin-top: 12px;
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
border-radius: 8px;
color: var(--text-primary);
font-size: 13px;
font-weight: 600;
cursor: pointer;
transition: all 0.2s ease;
}
.top-movers-expand-btn:hover {
background: var(--bg-elevated);
border-color: var(--positive);
}

.top-movers-content {
max-height: 1000px;
overflow: visible; 
transition: max-height 0.3s ease, opacity 0.3s ease;
opacity: 1;
}
.top-movers-content.collapsed {
max-height: 0;
opacity: 0;
}

@media (min-width: 1024px) {
.top-movers-list {
grid-template-columns: repeat(4, 1fr); 
}
}
@media (max-width: 900px) {
.top-movers-container {
grid-template-columns: 1fr;
}
}

.player-card {
position: relative;
}

.charts-container {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
gap: var(--spacing-lg);
margin-top: var(--spacing-lg);
}
.chart-card {
background: var(--bg-secondary);
clip-path: polygon(12px 0, 100% 0, 100% calc(100% - 12px), calc(100% - 12px) 100%, 0 100%, 0 12px);
padding: var(--spacing-lg);
overflow: hidden; 
}
.chart-card canvas {
background: rgba(255, 255, 255, 0.02);
clip-path: polygon(6px 0, 100% 0, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0 100%, 0 6px);
max-width: 100%; 
}
.chart-header {
margin-bottom: var(--spacing-md);
}
.chart-title {
font-size: 18px;
font-weight: 700;
margin-bottom: var(--spacing-xs);
}
.chart-subtitle {
font-size: 13px;
color: var(--text-secondary);
}
.chart-wrapper {
position: relative;
height: 400px;
width: 100%; 
max-width: 100%;
overflow: hidden; 
}

#team-pie-chart, #team-secondary-chart {
filter: drop-shadow(0 0 15px rgba(10, 132, 255, 0.4));
}

#team-balance-scatter, #advanced-scatter-chart, #wr-trend-chart, #rb-trend-chart {
filter: drop-shadow(0 0 15px rgba(10, 132, 255, 0.4));
}
.chart-insight {
background: var(--bg-tertiary);
border-left: 3px solid var(--positive);
padding: 12px 16px;
margin-bottom: 16px;
border-radius: 8px;
font-size: 14px;
line-height: 1.5;
color: var(--text-secondary);
}
.chart-insight strong {
color: var(--text-primary);
font-weight: 600;
}

.trend-toggle-container {
display: flex;
justify-content: flex-end;
margin-bottom: 12px;
}
.trend-toggle-btn {
padding: 6px 12px;
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
border-radius: 6px;
color: var(--text-secondary);
font-size: 12px;
font-weight: 600;
cursor: pointer;
transition: all 0.2s ease;
display: flex;
align-items: center;
gap: 6px;
}
.trend-toggle-btn:hover {
background: var(--bg-elevated);
color: var(--text-primary);
}
.trend-toggle-btn.active {
background: var(--positive-bg);
border-color: var(--positive);
color: var(--positive);
}
.trend-toggle-icon {
font-size: 14px;
}

.week-indicator {
position: absolute;
top: 10px;
left: 50%;
transform: translateX(-50%);
background: rgba(0, 0, 0, 0.85);
color: var(--text-primary);
padding: 8px 16px;
border-radius: 20px;
font-size: 13px;
font-weight: 700;
z-index: 20;
border: 1px solid var(--border-color);
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
}

.week-scrubber-container {
margin-top: 16px;
padding: 12px 16px;
background: var(--bg-tertiary);
border-radius: 8px;
border: 1px solid var(--border-color);
}
.scrubber-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 12px;
}
.scrubber-label {
font-size: 13px;
font-weight: 600;
color: var(--text-primary);
}
.playback-controls {
display: flex;
gap: 8px;
align-items: center;
}
.playback-btn {
width: 32px;
height: 32px;
border-radius: 50%;
background: var(--bg-elevated);
border: 1px solid var(--border-color);
color: var(--text-primary);
cursor: pointer;
display: flex;
align-items: center;
justify-content: center;
transition: all 0.2s ease;
}
.playback-btn:hover {
background: var(--positive-bg);
border-color: var(--positive);
color: var(--positive);
}
.playback-btn.playing {
background: var(--positive-bg);
border-color: var(--positive);
color: var(--positive);
}
.play-icon {
font-size: 12px;
}
.week-scrubber {
width: 100%;
height: 6px;
-webkit-appearance: none;
appearance: none;
background: linear-gradient(to right, var(--positive) 0%, var(--positive) 100%, var(--bg-elevated) 100%);
border-radius: 3px;
outline: none;
cursor: pointer;
}
.week-scrubber::-webkit-slider-thumb {
-webkit-appearance: none;
appearance: none;
width: 18px;
height: 18px;
border-radius: 50%;
background: var(--positive);
cursor: pointer;
box-shadow: 0 2px 6px rgba(48, 209, 88, 0.4);
transition: all 0.15s ease;
}
.week-scrubber::-webkit-slider-thumb:hover {
transform: scale(1.2);
box-shadow: 0 3px 10px rgba(48, 209, 88, 0.6);
}
.week-scrubber::-moz-range-thumb {
width: 18px;
height: 18px;
border-radius: 50%;
background: var(--positive);
cursor: pointer;
border: none;
box-shadow: 0 2px 6px rgba(48, 209, 88, 0.4);
transition: all 0.15s ease;
}
.week-scrubber::-moz-range-thumb:hover {
transform: scale(1.2);
box-shadow: 0 3px 10px rgba(48, 209, 88, 0.6);
}

.quadrant-overlay {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
pointer-events: none;
z-index: 10;
}
.quadrant-highlight {
position: absolute;
border: 2px solid var(--positive);
border-radius: 8px;
background: rgba(48, 209, 88, 0.05);
animation: pulseHighlight 2s infinite;
pointer-events: none;
}
@keyframes pulseHighlight {
0%, 100% { opacity: 0.6; transform: scale(1); }
50% { opacity: 0.9; transform: scale(1.02); }
}
.highlighted-player {
filter: drop-shadow(0 0 12px var(--positive));
animation: glowPlayer 2s infinite;
}
@keyframes glowPlayer {
0%, 100% { filter: drop-shadow(0 0 10px var(--positive)); }
50% { filter: drop-shadow(0 0 18px var(--positive)); }
}
.chart-wrapper {
position: relative;
}


.sentiment-bar-container {
display: flex;
align-items: center;
gap: 8px;
margin-top: 4px;
}
.sentiment-bar {
flex: 1;
height: 4px;
background: var(--bg-tertiary);
border-radius: 2px;
overflow: hidden;
display: flex;
position: relative;
}
.sentiment-bar-fill {
height: 100%;
transition: width 0.3s ease;
position: absolute;
top: 0;
left: 0;
}
.sentiment-bar-buy {
background: var(--positive);
z-index: 2;
}
.sentiment-bar-sell {
background: var(--negative);
z-index: 1;
width: 100% !important;
}

.sentiment-segment-buy {
background: linear-gradient(135deg, #10b981 0%, #059669 100%);
}
.sentiment-segment-hold {
background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
}
.sentiment-segment-sell {
background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
}
.sentiment-label {
font-size: 11px;
color: var(--text-secondary);
min-width: 45px;
text-align: right;
}
.vote-buttons {
display: flex;
gap: 8px;
margin-top: 12px;
}
.vote-btn {
flex: 1;
padding: 8px 12px;
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
border-radius: 6px;
color: var(--text-secondary);
font-size: 13px;
font-weight: 600;
cursor: pointer;
transition: all 0.2s ease;
display: flex;
align-items: center;
justify-content: center;
gap: 6px;
}
.vote-btn:hover {
background: var(--bg-elevated);
color: var(--text-primary);
}
.vote-btn.active {
border-color: currentColor;
}
.vote-btn.buy-btn {
color: var(--positive);
}
.vote-btn.buy-btn.active {
background: var(--positive-bg);
}
.vote-btn.sell-btn {
color: var(--negative);
}
.vote-btn.sell-btn.active {
background: var(--negative-bg);
}
.vote-btn.hold-btn.active {
background: rgba(142, 142, 147, 0.15);
}
.vote-count {
font-size: 11px;
opacity: 0.7;
}
.signal-tag {
display: inline-flex;
align-items: center;
gap: 4px;
padding: 4px 8px;
border-radius: 4px;
font-size: 11px;
font-weight: 600;
text-transform: uppercase;
letter-spacing: 0.3px;
}
.signal-tag.positive {
background: var(--positive-bg);
color: var(--positive);
}
.signal-tag.neutral {
background: rgba(142, 142, 147, 0.15);
color: var(--text-secondary);
}
.signal-tag.opportunity {
background: rgba(10, 132, 255, 0.15);
color: #0a84ff;
}
.comment-section {
margin-top: 20px;
padding-top: 20px;
border-top: 1px solid var(--border-color);
}
.comment-header {
font-size: 14px;
font-weight: 600;
margin-bottom: 12px;
color: var(--text-primary);
}
.comment-input-container {
display: flex;
gap: 8px;
margin-bottom: 16px;
}
.comment-input {
flex: 1;
padding: 8px 12px;
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
border-radius: 6px;
color: var(--text-primary);
font-size: 13px;
font-family: inherit;
}
.comment-input:focus {
outline: none;
border-color: var(--positive);
}
.comment-submit {
padding: 8px 16px;
background: var(--positive);
color: white;
border: none;
border-radius: 6px;
font-size: 13px;
font-weight: 600;
cursor: pointer;
}
.comment-submit:hover {
background: #28c149;
}
.comment-list {
display: flex;
flex-direction: column;
gap: 8px;
}
.comment-item {
padding: 10px;
background: var(--bg-tertiary);
border-radius: 6px;
font-size: 13px;
line-height: 1.4;
}
.comment-meta {
font-size: 11px;
color: var(--text-secondary);
margin-top: 4px;
}

.modal-overlay {
position: fixed;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: rgba(0, 0, 0, 0.85);
backdrop-filter: blur(10px);
display: none;
align-items: center;
justify-content: center;
z-index: 10000; 
animation: fadeIn 0.2s ease;
}
.modal-overlay.active {
display: flex;
}
.modal {
background: var(--bg-secondary);
border-radius: 16px;
width: 90%;
max-width: 900px;
max-height: 90vh;
overflow-y: auto;
-webkit-overflow-scrolling: touch;
touch-action: pan-y;
animation: slideUp 0.3s ease;
}
@keyframes slideUp {
from { opacity: 0; transform: translateY(20px); }
to { opacity: 1; transform: translateY(0); }
}
.modal-header {
padding: var(--spacing-lg);
border-bottom: 1px solid var(--border-color);
position: sticky;
top: 0;
background: var(--bg-secondary);
z-index: 10;
}
.modal-player-info {
display: flex;
align-items: center;
gap: var(--spacing-md);
margin-bottom: var(--spacing-md);
}
.modal-team-badge {
width: 60px;
height: 60px;
border-radius: 8px;
display: flex;
align-items: center;
justify-content: center;
font-size: 16px;
font-weight: 700;
color: white;
}
.modal-player-details {
flex: 1;
}
.modal-player-name {
font-size: 32px;
font-weight: 700;
margin-bottom: 4px;
}
.modal-player-meta {
font-size: 14px;
color: var(--text-secondary);
}
.modal-close {
background: var(--bg-tertiary);
border: none;
width: 32px;
height: 32px;
border-radius: 50%;
color: var(--text-secondary);
font-size: 20px;
cursor: pointer;
transition: all 0.2s ease;
}
.modal-close:hover {
background: var(--bg-elevated);
color: var(--text-primary);
}
.modal-stats-grid {
display: grid;
grid-template-columns: repeat(4, 1fr);
gap: 0;
}
.modal-section-header {
font-size: 11px;
color: rgba(235, 235, 245, 0.5);
text-transform: uppercase;
letter-spacing: 0.8px;
font-weight: 600;
padding: 16px 0 12px 0;
margin-top: 8px;
}
.modal-section-header:first-child {
margin-top: 0;
}
.modal-stats-table {
display: grid;
grid-template-columns: repeat(4, 1fr);
gap: 0;
border-top: 1px solid rgba(142, 142, 147, 0.2);
}
.modal-stat-cell {
padding: 14px 12px;
border-right: 1px solid rgba(142, 142, 147, 0.15);
border-bottom: 1px solid rgba(142, 142, 147, 0.2);
display: flex;
flex-direction: column;
gap: 4px;
position: relative;
cursor: help;
}
.modal-stat-cell:nth-child(4n) {
border-right: none;
}
.modal-stat-cell:hover .stat-tooltip {
opacity: 1;
}
.modal-stat-cell .stat-tooltip {
position: absolute;
bottom: 100%;
left: 50%;
transform: translateX(-50%);
margin-bottom: 8px;
background: var(--bg-elevated);
border: 1px solid var(--border-color-light);
border-radius: 8px;
padding: 8px 12px;
font-size: 11px;
white-space: nowrap;
opacity: 0;
pointer-events: none;
transition: opacity 0.2s ease;
z-index: 1000;
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
color: var(--text-primary);
min-width: 200px;
white-space: normal;
text-align: left;
line-height: 1.4;
}

@media (max-width: 768px) {
.modal-stat-cell .stat-tooltip {
left: auto;
right: 0;
transform: none;
min-width: 180px;
max-width: 250px;
}
.modal-stat-cell:first-child .stat-tooltip,
.modal-stat-cell:nth-child(2) .stat-tooltip {
left: 0;
right: auto;
}
}
.modal-stat-empty {
border: none;
background: transparent;
}

.modal-stat-box {
padding: 16px 12px;
position: relative;
cursor: help;
border-right: 1px solid rgba(142, 142, 147, 0.2);
display: flex;
flex-direction: column;
align-items: flex-start;
justify-content: flex-start;
min-height: 90px;
}
.modal-stat-box:nth-child(4n) {
border-right: none;
}
.modal-stat-box:hover .stat-tooltip {
opacity: 1;
}
.modal-stat-box .stat-tooltip {
position: absolute;
bottom: 100%;
left: 50%;
transform: translateX(-50%);
margin-bottom: 8px;
background: var(--bg-elevated);
border: 1px solid var(--border-color-light);
border-radius: 8px;
padding: 8px 12px;
font-size: 11px;
white-space: nowrap;
opacity: 0;
pointer-events: none;
transition: opacity 0.2s ease;
z-index: 1000;
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
color: var(--text-primary);
min-width: 200px;
white-space: normal;
text-align: left;
line-height: 1.4;
}
.modal-stat-label {
font-size: 13px;
color: rgba(235, 235, 245, 0.6);
font-weight: 400;
}
.modal-stat-value {
font-size: 17px;
font-weight: 600;
color: #ffffff;
line-height: 1.2;
}
.modal-stat-comparison {
font-size: 13px;
font-weight: 500;
line-height: 1.2;
display: flex;
align-items: center;
gap: 4px;
}
.modal-body {
padding: 8px var(--spacing-lg) var(--spacing-lg) var(--spacing-lg);
}
.chart-tabs {
display: flex;
gap: var(--spacing-sm);
margin-bottom: var(--spacing-lg);
border-bottom: 1px solid var(--border-color);
}
.chart-tab {
padding: var(--spacing-md);
background: transparent;
border: none;
color: var(--text-secondary);
font-size: 14px;
font-weight: 600;
cursor: pointer;
border-bottom: 2px solid transparent;
transition: all 0.2s ease;
}
.chart-tab:hover {
color: var(--text-primary);
}
.chart-tab.active {
color: var(--text-primary);
border-bottom-color: var(--positive);
}
.chart-content {
display: none;
}
.chart-content.active {
display: block;
}
.modal-chart-wrapper {
position: relative;
height: 350px;
}

.radial-with-tooltip:hover .radial-tooltip {
opacity: 1 !important;
}

@media (max-width: 768px) {
.radial-with-tooltip.active .radial-tooltip {
opacity: 1 !important;
}
}

.upload-section {
background: var(--bg-secondary);
border-radius: 12px;
padding: var(--spacing-xl);
text-align: center;
margin-top: var(--spacing-lg);
}
.upload-title {
font-size: 24px;
font-weight: 700;
margin-bottom: var(--spacing-sm);
}
.upload-subtitle {
color: var(--text-secondary);
margin-bottom: var(--spacing-lg);
}
.upload-buttons {
display: flex;
gap: var(--spacing-md);
justify-content: center;
flex-wrap: wrap;
}
.upload-file-btn {
padding: var(--spacing-md) var(--spacing-lg);
background: var(--bg-tertiary);
color: var(--text-primary);
border: 2px dashed var(--border-color-light);
border-radius: 8px;
font-weight: 600;
cursor: pointer;
transition: all 0.2s ease;
font-size: 14px;
}
.upload-file-btn:hover {
border-color: var(--positive);
background: var(--bg-elevated);
}
input[type="file"] {
display: none;
}
.data-status {
margin-top: var(--spacing-lg);
padding: var(--spacing-md);
background: var(--positive-bg);
border-radius: 8px;
color: var(--positive);
font-weight: 600;
}


@media (max-width: 1200px) {
.cards-grid {
grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
}
}

@media (max-width: 900px) {
.cards-grid {
grid-template-columns: repeat(2, 1fr);
gap: 12px;
}
}

@media (max-width: 768px) {
.nav-tabs {
overflow-x: auto;
-webkit-overflow-scrolling: touch;
}
.table-header,
.player-row {
grid-template-columns: 40px 50px 1fr 70px;
font-size: 12px;
}
.table-header > div:nth-child(5),
.table-header > div:nth-child(6),
.table-header > div:nth-child(7),
.table-header > div:nth-child(8),
.player-row > div:nth-child(5),
.player-row > div:nth-child(6),
.player-row > div:nth-child(7),
.player-row > div:nth-child(8) {
display: none;
}
.modal-stats-grid {
grid-template-columns: repeat(2, 1fr);
}
.modal-stats-table {
grid-template-columns: repeat(2, 1fr);
}
.modal-stat-cell:nth-child(2n) {
border-right: none;
}
.modal-stat-cell:nth-child(4n) {
border-right: 1px solid rgba(142, 142, 147, 0.15);
}
.modal-stat-box:nth-child(2n) {
border-right: none;
}
.modal-stat-box:nth-child(4n) {
border-right: 1px solid rgba(142, 142, 147, 0.2);
}
.modal-stat-value {
font-size: 16px;
}
.modal-stat-comparison {
font-size: 12px;
}
.modal-stat-label {
font-size: 12px;
}
.charts-container {
grid-template-columns: 1fr;
}
.movers-container {
grid-template-columns: 1fr;
}
.cards-grid {
grid-template-columns: repeat(2, 1fr);
gap: 12px;
}

.player-headshot {
width: 28px;
height: 28px;
font-size: 10px;
}
.chart-wrapper {
height: 300px !important; 
}
.trend-toggle-btn {
font-size: 11px;
padding: 4px 8px;
}
.signal-tag {
font-size: 9px;
padding: 3px 6px;
}

.modal-overlay {
padding: 10px;
}
.modal-header {
padding: 16px;
}

.modal-header > div:first-child {
flex-direction: column !important;
gap: 16px !important;
}

.modal-header > div:first-child > div:nth-child(2) {
width: 100% !important;
margin-right: 0 !important;
align-items: flex-start !important;
}

.modal-header .sentiment-bar-3section {
width: 150px !important;
}

.modal-header .vote-buttons {
width: 100% !important;
}
.modal-header .vote-btn {
flex: 1 !important;
}
.modal-title {
font-size: 18px;
}
.modal-subtitle {
font-size: 12px;
}
.modal-body {
padding: 16px;
max-height: calc(90vh - 120px);
overflow-y: auto;
}
.modal-stat-box {
padding: 10px;
}
.modal-stat-label {
font-size: 10px;
}
.modal-stat-value {
font-size: 18px;
}
.modal-stat-change {
font-size: 11px;
}

.sentiment-card {
padding: 12px;
}
.sentiment-percentage {
font-size: 28px;
}
.sentiment-label {
font-size: 11px;
}
.sentiment-breakdown {
font-size: 10px;
}

.modal-body > div[style*="display: flex"][style*="gap: 20px"] {
flex-direction: column !important;
gap: 12px !important;
padding: 12px 16px !important;
}

.modal-body > div[style*="display: flex"] > div[style*="flex-shrink: 0"]:first-child {
display: flex;
justify-content: space-between;
align-items: center;
width: 100%;
}

.modal-stats-container {
position: relative;
overflow: hidden;
margin-top: 32px;
padding-top: 16px;
border-top: 1px solid rgba(142, 142, 147, 0.2);
}
.modal-stats-wrapper {
display: flex;
transition: transform 0.3s ease;
touch-action: pan-y;
}
.modal-stats-page {
min-width: 100%;
flex-shrink: 0;
}
.modal-stats-grid {
grid-template-columns: repeat(2, 1fr) !important;
gap: 12px !important;
}

.stats-dots {
display: flex;
justify-content: center;
gap: 8px;
margin-top: 16px;
padding-bottom: 4px;
margin-bottom: 8px;
}
.stats-dot {
width: 8px;
height: 8px;
border-radius: 50%;
background: #6b7280;
opacity: 0.5;
transition: all 0.3s ease;
cursor: pointer;
}
.stats-dot.active {
opacity: 1;
background: #10b981;
transform: scale(1.2);
}

.chart-tabs {
gap: 6px;
overflow-x: auto;
-webkit-overflow-scrolling: touch;
}
.chart-tab {
padding: 6px 12px;
font-size: 11px;
white-space: nowrap;
}

[data-tooltip]::after,
.stat-tooltip,
.comparison-tooltip,
.ticker-tooltip,
.leaderboard-tooltip,
.player-tag:hover::after,
.injury-badge:hover::after,
.momentum-badge:hover::after {
position: absolute !important;
left: auto !important;
right: auto !important;
transform: translateX(-50%) !important;
max-width: min(200px, 90vw) !important;
white-space: normal !important;
text-align: center !important;
margin-left: 0 !important;
margin-right: 0 !important;
}

.tooltip,
[class*="tooltip"]:not(.stat-tooltip):not(.comparison-tooltip):not(.ticker-tooltip):not(.leaderboard-tooltip) {
max-width: min(250px, 90vw) !important;
}

.ticker-info-icon {
z-index: 100 !important; 
}
.ticker-tooltip {
z-index: 101 !important; 
}

.mobile-nav-toggle {
z-index: 10001 !important;
}
.nav-tabs {
z-index: 10000 !important;
}
}

.division-section {
background: var(--bg-secondary);
border: 1px solid var(--border-color);
border-radius: 12px;
margin-bottom: 16px;
overflow: hidden;
}
.division-header {
padding: 16px 20px;
display: flex;
justify-content: space-between;
align-items: center;
cursor: pointer;
transition: background 0.2s ease;
user-select: none;
}
.division-header:hover {
background: var(--bg-tertiary);
}
.division-title {
font-size: 15px;
font-weight: 700;
color: var(--text-primary);
}
.division-arrow {
font-size: 12px;
color: var(--text-secondary);
transition: transform 0.3s ease;
}
.division-arrow.expanded {
transform: rotate(180deg);
}
.division-content {
max-height: 0;
overflow: hidden;
transition: max-height 0.3s ease, padding 0.3s ease;
}
.division-content.expanded {
max-height: 1000px;
padding: 0 20px 20px 20px;
}
.division-teams-grid {
display: grid;
grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
gap: 12px;
}
.division-team-card {
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
border-radius: 8px;
padding: 12px;
cursor: pointer;
transition: all 0.2s ease;
display: flex;
align-items: center;
gap: 12px;
}
.division-team-card:hover {
background: var(--bg-elevated);
border-color: var(--positive);
}
.division-team-logo {
width: 40px;
height: 40px;
border-radius: 50%;
background: var(--bg-elevated);
display: flex;
align-items: center;
justify-content: center;
font-weight: 700;
font-size: 14px;
color: white;
}
.division-team-info {
flex: 1;
}
.division-team-name {
font-size: 13px;
font-weight: 600;
color: var(--text-primary);
margin-bottom: 2px;
}
.division-team-stats {
font-size: 11px;
color: var(--text-secondary);
}

/* ===== HEATMAP PAGE REDESIGN ===== */

/* Gradient Line - Now below ticker */
.heatmap-gradient-line {
height: 3px;
background: linear-gradient(90deg, var(--positive) 0%, var(--accent-blue) 100%);
margin: 0 -24px;
}

/* Market Ticker Bar with Rotating Insights */
.heatmap-ticker-bar {
display: flex;
align-items: center;
gap: 16px;
padding: 16px 24px;
background: var(--bg-secondary);
border-bottom: 1px solid var(--border-color);
margin: 0 -24px;
min-height: 80px;
}

.heatmap-ticker-status {
display: flex;
align-items: center;
gap: 8px;
flex-shrink: 0;
}

.heatmap-status-dot {
width: 8px;
height: 8px;
background: var(--positive);
border-radius: 50%;
animation: heatmapPulse 2s infinite;
}

@keyframes heatmapPulse {
0%, 100% { opacity: 1; }
50% { opacity: 0.5; }
}

.heatmap-status-text {
font-size: 11px;
font-weight: 700;
color: var(--positive);
text-transform: uppercase;
letter-spacing: 1.5px;
}

.heatmap-ticker-divider {
width: 1px;
height: 40px;
background: var(--border-color-light);
flex-shrink: 0;
}

.heatmap-ticker-week {
color: var(--text-tertiary);
font-size: 12px;
font-weight: 500;
flex-shrink: 0;
margin-left: auto;
}

/* Rotating Insight Container */
.heatmap-rotating-insight-container {
flex: 1;
display: flex;
align-items: center;
gap: 16px;
min-height: 60px;
}

.heatmap-insight-value {
font-size: 48px;
font-weight: 800;
line-height: 1;
color: var(--text-primary);
flex-shrink: 0;
transition: opacity 0.3s ease;
}

.heatmap-insight-content {
flex: 1;
display: flex;
flex-direction: column;
gap: 4px;
}

.heatmap-insight-label {
font-size: 13px;
font-weight: 700;
color: var(--text-primary);
text-transform: uppercase;
letter-spacing: 0.5px;
transition: opacity 0.3s ease;
}

.heatmap-insight-text {
font-size: 13px;
line-height: 1.5;
color: var(--text-secondary);
transition: opacity 0.3s ease;
}

/* Horizontal Filters Bar - Single Line with Dropdowns */
.heatmap-filters-bar {
background: var(--bg-secondary);
padding: 16px 24px;
display: flex;
gap: 12px;
align-items: center;
border-bottom: 1px solid var(--border-color);
margin: 0 -24px 24px;
flex-wrap: nowrap;
}

.heatmap-filter-group-inline {
display: flex;
align-items: center;
gap: 8px;
white-space: nowrap;
}

.heatmap-filter-label {
font-size: 11px;
font-weight: 700;
color: var(--text-tertiary);
text-transform: uppercase;
letter-spacing: 0.5px;
flex-shrink: 0;
}

.heatmap-filter-separator {
width: 1px;
height: 20px;
background: var(--border-color-light);
margin: 0 4px;
flex-shrink: 0;
}

/* Dropdown Select Styling */
.heatmap-filter-select {
padding: 8px 16px;
background: var(--bg-elevated);
border: 1px solid var(--border-color);
color: var(--text-primary);
font-size: 13px;
font-weight: 600;
cursor: pointer;
transition: all 0.2s;
border-radius: 6px;
white-space: nowrap;
min-width: 140px;
appearance: none;
background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%238e8e93' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E");
background-repeat: no-repeat;
background-position: right 12px center;
padding-right: 36px;
}

.heatmap-filter-select:hover {
background: var(--bg-tertiary);
border-color: var(--border-color-light);
}

.heatmap-filter-select:focus {
outline: none;
border-color: var(--positive);
background: var(--bg-tertiary);
}

/* Simple Insights List - No Containers */
/* Sleek Modern Apple-Style Insights - Glass Effect with Angled Cards */
.heatmap-simple-insights {
margin: 40px auto 0 auto;
padding: 0 24px;
max-width: 1400px;
box-sizing: border-box;
}

.insights-grid {
display: grid;
grid-template-columns: repeat(4, 1fr);
gap: 16px;
}

.heatmap-simple-insight {
background: rgba(255, 255, 255, 0.03);
backdrop-filter: blur(20px);
-webkit-backdrop-filter: blur(20px);
border-radius: 16px;
padding: 20px 22px;
font-size: 15px;
line-height: 1.6;
color: var(--text-secondary);
position: relative;
transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
overflow: hidden;
}

.heatmap-simple-insight::before {
content: '';
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: linear-gradient(135deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0) 100%);
pointer-events: none;
}

.heatmap-simple-insight:hover {
transform: translateY(-4px) scale(1.02);
background: rgba(255, 255, 255, 0.06);
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
}

/* Insight Type Styling - Subtle Colored Backgrounds */
.heatmap-simple-insight[data-type="breakout"] {
background: linear-gradient(135deg, rgba(0, 200, 83, 0.08) 0%, rgba(0, 200, 83, 0.02) 100%);
}

.heatmap-simple-insight[data-type="buy-low"] {
background: linear-gradient(135deg, rgba(10, 132, 255, 0.08) 0%, rgba(10, 132, 255, 0.02) 100%);
}

.heatmap-simple-insight[data-type="volume-spike"] {
background: linear-gradient(135deg, rgba(100, 221, 23, 0.08) 0%, rgba(100, 221, 23, 0.02) 100%);
}

.heatmap-simple-insight[data-type="rising"] {
background: linear-gradient(135deg, rgba(118, 255, 3, 0.08) 0%, rgba(118, 255, 3, 0.02) 100%);
}

.heatmap-simple-insight[data-type="steady"] {
background: linear-gradient(135deg, rgba(10, 132, 255, 0.08) 0%, rgba(10, 132, 255, 0.02) 100%);
}

.heatmap-simple-insight[data-type="high-floor"] {
background: linear-gradient(135deg, rgba(142, 142, 147, 0.08) 0%, rgba(142, 142, 147, 0.02) 100%);
}

.heatmap-simple-insight[data-type="watch"] {
background: linear-gradient(135deg, rgba(191, 90, 242, 0.08) 0%, rgba(191, 90, 242, 0.02) 100%);
}

.heatmap-simple-insight[data-type="cooling"] {
background: linear-gradient(135deg, rgba(255, 214, 0, 0.08) 0%, rgba(255, 214, 0, 0.02) 100%);
}

.heatmap-simple-insight[data-type="neg-momentum"] {
background: linear-gradient(135deg, rgba(255, 149, 0, 0.08) 0%, rgba(255, 149, 0, 0.02) 100%);
}

.heatmap-simple-insight[data-type="volume-drain"] {
background: linear-gradient(135deg, rgba(255, 111, 0, 0.08) 0%, rgba(255, 111, 0, 0.02) 100%);
}

.heatmap-simple-insight[data-type="underperform"] {
background: linear-gradient(135deg, rgba(255, 69, 58, 0.08) 0%, rgba(255, 69, 58, 0.02) 100%);
}

.heatmap-simple-insight[data-type="fade"] {
background: linear-gradient(135deg, rgba(211, 47, 47, 0.08) 0%, rgba(211, 47, 47, 0.02) 100%);
}

/* Content Container */
.insight-content {
width: 100%;
position: relative;
z-index: 1;
}

.insight-content strong {
color: var(--text-primary);
font-weight: 700;
display: flex;
align-items: center;
gap: 10px;
margin-bottom: 10px;
font-size: 18px;
letter-spacing: -0.3px;
text-transform: uppercase;
}

/* Tier Badge - Colored Pill Style */
.tier-badge {
display: inline-block;
padding: 4px 10px;
border-radius: 20px;
font-size: 9px;
font-weight: 700;
text-transform: uppercase;
letter-spacing: 0.5px;
white-space: nowrap;
}

/* Positive Tier Badges */
.heatmap-simple-insight[data-type="breakout"] .tier-badge {
background: rgba(0, 200, 83, 0.2);
color: #00c853;
}

.heatmap-simple-insight[data-type="buy-low"] .tier-badge {
background: rgba(10, 132, 255, 0.2);
color: #0a84ff;
}

/* Neutral Tier Badges */
.heatmap-simple-insight[data-type="steady"] .tier-badge {
background: rgba(10, 132, 255, 0.2);
color: #0a84ff;
}

/* Negative Tier Badges */
.heatmap-simple-insight[data-type="neg-momentum"] .tier-badge {
background: rgba(255, 149, 0, 0.2);
color: #ff9500;
}

/* Bold Metric Numbers */
.bold-metric {
font-weight: 800;
font-size: 15px;
letter-spacing: -0.3px;
}

/* Icon Badges - Larger with Gradients and Shadow */
.insight-badge {
display: inline-flex;
align-items: center;
justify-content: center;
width: 24px;
height: 24px;
border-radius: 8px;
font-size: 13px;
font-weight: 700;
flex-shrink: 0;
box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
}

/* Positive Badges (Green shades) */
.heatmap-simple-insight[data-type="breakout"] .insight-badge {
background: linear-gradient(135deg, #00c853 0%, #00e676 100%);
color: #000;
}

.heatmap-simple-insight[data-type="buy-low"] .insight-badge {
background: linear-gradient(135deg, #0a84ff 0%, #0af 100%);
color: #000;
}

.heatmap-simple-insight[data-type="volume-spike"] .insight-badge {
background: linear-gradient(135deg, #64dd17 0%, #76ff03 100%);
color: #000;
}

.heatmap-simple-insight[data-type="rising"] .insight-badge {
background: linear-gradient(135deg, #76ff03 0%, #a4ff00 100%);
color: #000;
}

/* Neutral Badges (Blue/Gray/Purple shades) */
.heatmap-simple-insight[data-type="steady"] .insight-badge {
background: linear-gradient(135deg, #0a84ff 0%, #0af 100%);
color: #000;
}

.heatmap-simple-insight[data-type="high-floor"] .insight-badge {
background: linear-gradient(135deg, #8e8e93 0%, #aeaeb2 100%);
color: #000;
}

.heatmap-simple-insight[data-type="watch"] .insight-badge {
background: linear-gradient(135deg, #bf5af2 0%, #da70f5 100%);
color: #000;
}

/* Negative Badges (Yellow to Red spectrum) */
.heatmap-simple-insight[data-type="cooling"] .insight-badge {
background: linear-gradient(135deg, #ffd600 0%, #ffe234 100%);
color: #000;
}

.heatmap-simple-insight[data-type="neg-momentum"] .insight-badge {
background: linear-gradient(135deg, #ff9500 0%, #ffb340 100%);
color: #000;
}

.heatmap-simple-insight[data-type="volume-drain"] .insight-badge {
background: linear-gradient(135deg, #ff6f00 0%, #ff8c42 100%);
color: #000;
}

.heatmap-simple-insight[data-type="underperform"] .insight-badge {
background: linear-gradient(135deg, #ff453a 0%, #ff6259 100%);
color: #000;
}

.heatmap-simple-insight[data-type="fade"] .insight-badge {
background: linear-gradient(135deg, #d32f2f 0%, #e64a4a 100%);
color: #000;
}

/* Empty State */
.insights-empty {
text-align: center;
padding: 32px;
color: var(--text-tertiary);
font-size: 14px;
background: rgba(255, 255, 255, 0.03);
backdrop-filter: blur(20px);
border-radius: 16px;
grid-column: 1 / -1;
}

/* Mobile Responsiveness */
@media (max-width: 1200px) {
.insights-grid {
grid-template-columns: repeat(3, 1fr);
}
}

@media (max-width: 1024px) {
.insights-grid {
grid-template-columns: repeat(2, 1fr);
}
}

@media (max-width: 768px) {
.heatmap-simple-insights {
padding: 0 16px;
margin-top: 32px;
}
  
.insights-grid {
grid-template-columns: 1fr;
gap: 12px;
}
  
.heatmap-simple-insight {
padding: 16px 18px;
font-size: 13px;
}
  
.insight-content strong {
font-size: 16px;
gap: 8px;
margin-bottom: 8px;
}

.insight-badge {
width: 22px;
height: 22px;
font-size: 12px;
}

.tier-badge {
font-size: 8px;
padding: 3px 8px;
}

.bold-metric {
font-size: 14px;
}
}

.highlight-positive {
color: var(--positive);
font-weight: 600;
}

.highlight-negative {
color: var(--negative);
font-weight: 600;
}

.highlight-neutral {
color: var(--text-primary);
font-weight: 600;
}

/* Mobile Responsiveness */
@media (max-width: 768px) {
.heatmap-ticker-bar {
flex-direction: column;
align-items: flex-start;
gap: 12px;
padding: 12px 16px;
min-height: auto;
overflow: visible;
margin: 0;
}

.heatmap-status-text {
font-size: 11px;
white-space: nowrap;
}
    
.heatmap-ticker-divider {
width: 100%;
height: 1px;
}

.heatmap-ticker-week {
margin-left: 0;
font-size: 11px;
}

.heatmap-rotating-insight-container {
width: 100%;
flex-direction: column;
align-items: flex-start;
gap: 8px;
}

.heatmap-insight-value {
font-size: 28px;
line-height: 1.2;
word-break: break-word;
}

.heatmap-insight-label {
font-size: 11px;
}

.heatmap-insight-text {
font-size: 12px;
line-height: 1.4;
}

.heatmap-gradient-line {
margin: 0;
}
    
.heatmap-filters-bar {
flex-wrap: wrap;
padding: 12px 16px;
gap: 12px;
overflow: visible;
margin: 0 0 16px 0;
}
    
.heatmap-filter-group-inline {
flex: 1 1 100%;
min-width: unset;
width: 100%;
}
    
.heatmap-filter-separator {
display: none;
}

.heatmap-filter-label {
font-size: 10px;
margin-bottom: 4px;
display: block;
}
    
.heatmap-filter-select {
font-size: 13px;
padding: 10px 12px;
min-width: unset;
width: 100%;
}

/* Mobile Heatmap Grid - 3 columns */
.heatmap-player-grid {
grid-template-columns: repeat(3, 1fr) !important;
gap: 8px !important;
}

.heatmap-player-card {
padding: 10px 8px !important;
min-height: 110px !important;
}

.heatmap-player-name {
font-size: 11px !important;
margin-bottom: 3px !important;
}

.heatmap-player-team {
font-size: 9px !important;
margin-bottom: 6px !important;
}

.heatmap-value {
font-size: 18px !important;
}

.heatmap-arrow {
font-size: 20px !important;
}

.heatmap-delta-value {
font-size: 9px !important;
}

/* Mobile Legend */
.heatmap-legend {
padding: 12px !important;
}

.heatmap-legend-title {
font-size: 11px !important;
margin-bottom: 8px !important;
}

.heatmap-legend-items {
display: grid !important;
grid-template-columns: repeat(3, 1fr) !important;
gap: 8px !important;
}

.heatmap-legend-item {
padding: 6px 4px !important;
}

.heatmap-legend-color {
width: 100% !important;
height: 4px !important;
margin-bottom: 4px !important;
}

.heatmap-legend-label {
font-size: 8px !important;
line-height: 1.3 !important;
}

/* Mobile Widget */
.heatmap-widget {
padding: 16px !important;
margin: 0 16px 24px 16px !important;
max-width: calc(100% - 32px) !important;
}

.heatmap-stat-text {
font-size: 11px !important;
margin-bottom: 12px !important;
}

/* Mobile Insights */
.heatmap-simple-insights {
padding: 24px 16px !important;
}

.heatmap-simple-insight {
font-size: 13px !important;
line-height: 1.7 !important;
margin-bottom: 14px !important;
}
}

/* Extra small mobile - 2 columns */
@media (max-width: 480px) {
.heatmap-player-grid {
grid-template-columns: repeat(2, 1fr) !important;
gap: 8px !important;
}

.heatmap-player-card {
padding: 10px !important;
min-height: 120px !important;
}

.heatmap-player-name {
font-size: 12px !important;
}

.heatmap-value {
font-size: 20px !important;
}

.heatmap-legend-items {
grid-template-columns: repeat(2, 1fr) !important;
}
}

.analytics-dashboard-container {
padding: 0;
max-width: 100%;
margin: 0 auto;
}

.heatmap-widget {
background: var(--bg-primary);
border: 1px solid var(--border-color);
clip-path: polygon(16px 0, 100% 0, 100% calc(100% - 16px), calc(100% - 16px) 100%, 0 100%, 0 16px);
padding: 24px;
margin: 0 auto 32px auto;
max-width: 1400px;
width: 100%;
box-sizing: border-box;
}

.position-selector {
display: flex;
align-items: center;
justify-content: space-between;
gap: 12px;
margin-bottom: 12px;
padding-bottom: 12px;
border-bottom: 1px solid var(--border-color);
}
.position-selector-left {
display: flex;
align-items: center;
gap: 12px;
}
.dropdown-label {
font-size: 11px;
font-weight: 600;
color: var(--text-secondary);
text-transform: uppercase;
letter-spacing: 0.5px;
}
.position-select {
padding: 10px 16px;
background: var(--bg-primary);
border: 1px solid var(--border-color);
clip-path: polygon(4px 0, 100% 0, 100% calc(100% - 4px), calc(100% - 4px) 100%, 0 100%, 0 4px);
color: var(--text-primary);
font-size: 14px;
font-weight: 600;
cursor: pointer;
min-width: 220px;
}
.position-select:focus {
outline: none;
border-color: var(--positive);
}

.heatmap-stat-text {
text-align: right;
font-size: 11px;
color: var(--text-secondary);
margin-bottom: 8px;
font-weight: 500;
letter-spacing: 0.3px;
}
.heatmap-controls {
display: grid;
grid-template-columns: repeat(4, 1fr);
gap: 16px;
padding: 10px 16px;
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
clip-path: polygon(6px 0, 100% 0, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0 100%, 0 6px);
margin-bottom: 16px;
}
@media (max-width: 768px) {
.heatmap-controls {
grid-template-columns: repeat(2, 1fr);
gap: 12px;
padding: 12px 16px;
}
}
.heatmap-control-group {
display: flex;
flex-direction: column;
gap: 6px;
}
.heatmap-control-label {
font-size: 9px;
font-weight: 600;
color: var(--text-secondary);
text-transform: uppercase;
letter-spacing: 0.5px;
white-space: nowrap;
}

.info-icon {
display: inline-block;
margin-left: 6px;
font-size: 13px;
color: rgba(10, 132, 255, 0.7);
cursor: pointer;
transition: all 0.2s ease;
position: relative;
}
.info-icon:hover {
color: rgba(10, 132, 255, 1);
transform: scale(1.15);
}

.info-icon-tooltip {
position: absolute;
bottom: calc(100% + 8px);
left: 50%;
transform: translateX(-50%);
background: var(--bg-elevated);
border: 1px solid var(--border-color-light);
border-radius: 8px;
padding: 8px 12px;
font-size: 9px;
line-height: 1.4;
color: var(--text-primary);
max-width: 260px;
white-space: normal;
opacity: 0;
pointer-events: none;
transition: opacity 0.2s ease;
z-index: 2001;
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}

.info-icon:hover .info-icon-tooltip {
opacity: 1;
}

.buy .info-icon-tooltip,
.buy-low .info-icon-tooltip {
bottom: auto;
top: calc(100% + 8px);
}

@media (max-width: 768px) {
.info-icon-tooltip {
left: auto;
right: 0;
transform: translateX(0);
max-width: 220px;
font-size: 8px;
}
}

.metric-tooltip {
position: absolute;
top: 100%;
left: 0;
right: 0;
margin-top: 8px;
background: rgba(28, 28, 30, 0.98);
border: 1px solid rgba(142, 142, 147, 0.3);
border-radius: 8px;
padding: 16px;
z-index: 1000;
box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
animation: tooltipFadeIn 0.2s ease;
}
@keyframes tooltipFadeIn {
from {
opacity: 0;
transform: translateY(-4px);
}
to {
opacity: 1;
transform: translateY(0);
}
}
.metric-tooltip-content {
font-size: 12px;
line-height: 1.6;
color: var(--text-primary);
}
.metric-tooltip-content strong {
color: rgba(10, 132, 255, 1);
display: block;
margin-bottom: 6px;
font-size: 13px;
}
.metric-tooltip-content .tooltip-section {
margin-bottom: 10px;
}
.metric-tooltip-content .tooltip-section:last-child {
margin-bottom: 0;
}
.metric-tooltip-content .tooltip-label {
color: rgba(235, 235, 245, 0.6);
font-size: 10px;
text-transform: uppercase;
letter-spacing: 0.5px;
margin-bottom: 4px;
}
.heatmap-control-group {
position: relative;
}
.heatmap-toggle-group {
display: flex;
gap: 6px;
}
.heatmap-toggle-btn {
padding: 6px 12px;
background: var(--bg-primary);
border: 1px solid var(--border-color);
clip-path: polygon(4px 0, 100% 0, 100% calc(100% - 4px), calc(100% - 4px) 100%, 0 100%, 0 4px);
color: var(--text-secondary);
font-size: 12px;
font-weight: 500;
cursor: pointer;
transition: all 0.2s ease;
}
.heatmap-toggle-btn:hover {
background: rgba(255, 255, 255, 0.05);
color: var(--text-primary);
}
.heatmap-toggle-btn.active {
background: var(--positive);
border-color: var(--positive);
color: #ffffff;
font-weight: 600;
}
.metric-select {
padding: 8px 12px;
background: var(--bg-primary);
border: 1px solid var(--border-color);
clip-path: polygon(4px 0, 100% 0, 100% calc(100% - 4px), calc(100% - 4px) 100%, 0 100%, 0 4px);
color: var(--text-primary);
font-size: 12px;
font-weight: 500;
cursor: pointer;
width: 100%;
}
.metric-select:focus {
outline: none;
border-color: var(--positive);
}
font-weight: 500;
cursor: pointer;
min-width: 240px;
}
.metric-select:focus {
outline: none;
border-color: var(--positive);
}

.position-info {
display: flex;
align-items: center;
gap: 12px;
}
.position-badge {
padding: 6px 12px;
border-radius: 6px;
font-size: 13px;
font-weight: 700;
letter-spacing: 0.5px;
}
.position-badge.wr-badge {
background: rgba(0, 212, 255, 0.2);
color: #00d4ff;
border: 1px solid rgba(0, 212, 255, 0.4);
}
.position-badge.rb-badge {
background: rgba(48, 209, 88, 0.2);
color: var(--positive);
border: 1px solid rgba(48, 209, 88, 0.4);
}
.position-badge.te-badge {
background: rgba(255, 214, 10, 0.2);
color: #FFD60A;
border: 1px solid rgba(255, 214, 10, 0.4);
}
.position-title {
font-size: 18px;
font-weight: 700;
color: var(--text-primary);
}
.position-stats {
display: flex;
gap: 24px;
align-items: center;
}
.position-stat {
display: flex;
flex-direction: row;
align-items: center;
gap: 6px;
cursor: help;
position: relative;
padding: 4px 10px;
background: var(--bg-primary);
border: 1px solid var(--border-color);
clip-path: polygon(4px 0, 100% 0, 100% calc(100% - 4px), calc(100% - 4px) 100%, 0 100%, 0 4px);
white-space: nowrap;
}
.position-stat-label {
font-size: 8px;
color: var(--text-secondary);
text-transform: uppercase;
letter-spacing: 0.4px;
font-weight: 600;
}
.position-stat-value {
font-size: 13px;
font-weight: 700;
color: var(--text-primary);
}
.position-delta {
font-size: 16px;
font-weight: 700;
}
.positive-delta {
color: var(--positive);
}
.negative-delta {
color: var(--negative);
}

.heatmap-player-grid {
display: grid;
grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
gap: 12px;
}
.heatmap-player-card {
background: var(--bg-primary);
border: 1px solid var(--border-color);
border-radius: 10px;
padding: 12px;
transition: all 0.2s ease;
cursor: pointer;
min-height: 120px;
display: flex;
flex-direction: column;
}
.heatmap-player-card:hover {
transform: scale(1.05);
box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
z-index: 10;
}
.heatmap-player-name {
font-size: 13px;
font-weight: 700;
color: var(--text-primary);
margin-bottom: 4px;
line-height: 1.2;
}
.heatmap-player-team {
font-size: 10px;
color: var(--text-secondary);
margin-bottom: 8px;
}
.heatmap-bottom-row {
display: flex;
align-items: flex-end;
justify-content: space-between;
margin-top: auto;
}
.heatmap-value {
font-size: 22px;
font-weight: 700;
color: var(--text-primary);
}
.heatmap-delta-group {
display: flex;
flex-direction: column;
align-items: flex-end;
}
.heatmap-arrow {
font-size: 24px;
line-height: 1;
}
.heatmap-delta-value {
font-size: 11px;
font-weight: 700;
}

.heatmap-player-card.extreme-positive {
background: rgba(48, 209, 88, 0.4) !important;
border-color: rgba(48, 209, 88, 0.6) !important;
}
.heatmap-player-card.strong-positive {
background: rgba(48, 209, 88, 0.3) !important;
border-color: rgba(48, 209, 88, 0.5) !important;
}
.heatmap-player-card.moderate-positive {
background: rgba(48, 209, 88, 0.2) !important;
border-color: rgba(48, 209, 88, 0.4) !important;
}
.heatmap-player-card.slight-positive {
background: rgba(48, 209, 88, 0.1) !important;
border-color: rgba(48, 209, 88, 0.3) !important;
}
.heatmap-player-card.neutral {
background: rgba(255, 255, 255, 0.05) !important;
border-color: var(--border-color) !important;
}
.heatmap-player-card.slight-negative {
background: rgba(255, 69, 58, 0.1) !important;
border-color: rgba(255, 69, 58, 0.3) !important;
}
.heatmap-player-card.moderate-negative {
background: rgba(255, 69, 58, 0.2) !important;
border-color: rgba(255, 69, 58, 0.4) !important;
}
.heatmap-player-card.strong-negative {
background: rgba(255, 69, 58, 0.3) !important;
border-color: rgba(255, 69, 58, 0.5) !important;
}
.heatmap-player-card.extreme-negative {
background: rgba(255, 69, 58, 0.4) !important;
border-color: rgba(255, 69, 58, 0.6) !important;
}

.heatmap-legend {
margin-top: 16px;
padding: 12px 16px;
background: var(--bg-elevated);
border: 1px solid var(--border-color);
clip-path: polygon(8px 0, 100% 0, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0 100%, 0 8px);
}
.heatmap-legend-title {
font-size: 10px;
font-weight: 600;
color: var(--text-secondary);
margin-bottom: 10px;
text-transform: uppercase;
letter-spacing: 0.5px;
text-align: center;
}
.heatmap-legend-items {
display: flex;
justify-content: space-between;
align-items: center;
gap: 6px;
}
@media (max-width: 768px) {
.heatmap-legend {
padding: 8px 12px;
}
.heatmap-legend-items {
gap: 4px;
overflow-x: auto;
-webkit-overflow-scrolling: touch;
padding-bottom: 4px;
}
.heatmap-legend-label {
font-size: 8px;
}
}
.heatmap-legend-item {
display: flex;
flex-direction: column;
align-items: center;
gap: 5px;
flex: 1;
}
.heatmap-legend-color {
width: 100%;
height: 20px;
clip-path: polygon(3px 0, 100% 0, 100% calc(100% - 3px), calc(100% - 3px) 100%, 0 100%, 0 3px);
border: 1px solid rgba(255, 255, 255, 0.1);
}
.heatmap-legend-label {
font-size: 9px;
color: var(--text-secondary);
text-align: center;
line-height: 1.2;
}

.heatmap-legend-color.extreme-negative {
background: rgba(255, 69, 58, 0.3);
border-color: rgba(255, 69, 58, 0.5);
}
.heatmap-legend-color.strong-negative {
background: rgba(255, 69, 58, 0.25);
border-color: rgba(255, 69, 58, 0.4);
}
.heatmap-legend-color.moderate-negative {
background: rgba(255, 69, 58, 0.2);
border-color: rgba(255, 69, 58, 0.3);
}
.heatmap-legend-color.slight-negative {
background: rgba(255, 69, 58, 0.15);
border-color: rgba(255, 69, 58, 0.25);
}
.heatmap-legend-color.neutral {
background: rgba(142, 142, 147, 0.2);
border-color: rgba(142, 142, 147, 0.3);
}
.heatmap-legend-color.slight-positive {
background: rgba(48, 209, 88, 0.15);
border-color: rgba(48, 209, 88, 0.25);
}
.heatmap-legend-color.moderate-positive {
background: rgba(48, 209, 88, 0.2);
border-color: rgba(48, 209, 88, 0.3);
}
.heatmap-legend-color.strong-positive {
background: rgba(48, 209, 88, 0.25);
border-color: rgba(48, 209, 88, 0.4);
}
.heatmap-legend-color.extreme-positive {
background: rgba(48, 209, 88, 0.3);
border-color: rgba(48, 209, 88, 0.5);
}

.market-opportunities-widget {
background: var(--bg-secondary);
border: 1px solid var(--border-color);
border-radius: 12px;
padding: 24px;
margin-bottom: 32px;
}
.market-header {
display: flex;
align-items: center;
gap: 12px;
margin-bottom: 20px;
padding-bottom: 16px;
border-bottom: 2px solid var(--border-color);
}
.market-title {
font-size: 20px;
font-weight: 700;
color: var(--text-primary);
}
.market-grid {
display: grid;
grid-template-columns: 1fr 1fr;
gap: 24px;
}
.market-column {
display: flex;
flex-direction: column;
gap: 12px;
}
.market-column-header {
display: flex;
align-items: center;
gap: 8px;
margin-bottom: 8px;
}
.market-column-title {
font-size: 14px;
font-weight: 700;
text-transform: uppercase;
letter-spacing: 0.5px;
}
.market-column-title.buy-low {
color: var(--positive);
}
.market-column-title.sell-high {
color: var(--negative);
}
.market-column-count {
font-size: 12px;
color: var(--text-secondary);
}
.opportunity-card {
background: var(--bg-primary);
border: 1px solid var(--border-color);
border-radius: 10px;
padding: 16px;
display: flex;
align-items: center;
gap: 12px;
transition: all 0.2s ease;
cursor: pointer;
}
.opportunity-card:hover {
transform: translateY(-2px);
border-color: rgba(142, 142, 147, 0.5);
background: rgba(255, 255, 255, 0.02);
}
.opportunity-badge {
padding: 4px 10px;
border-radius: 6px;
font-size: 11px;
font-weight: 700;
letter-spacing: 0.3px;
flex-shrink: 0;
}
.opportunity-badge.buy {
background: rgba(48, 209, 88, 0.2);
color: var(--positive);
border: 1px solid rgba(48, 209, 88, 0.4);
}
.opportunity-badge.sell {
background: rgba(255, 69, 58, 0.2);
color: var(--negative);
border: 1px solid rgba(255, 69, 58, 0.4);
}
.opportunity-info {
flex: 1;
}
.opportunity-name {
font-size: 15px;
font-weight: 700;
color: var(--text-primary);
margin-bottom: 4px;
}
.opportunity-reason {
font-size: 12px;
color: var(--text-secondary);
line-height: 1.4;
}
.opportunity-percentage {
font-size: 20px;
font-weight: 700;
flex-shrink: 0;
}
.opportunity-percentage.positive {
color: var(--positive);
}
.opportunity-percentage.negative {
color: var(--negative);
}

@media (max-width: 768px) {
.market-grid {
grid-template-columns: 1fr;
}
}
.heatmap-controls {
flex-direction: column;
align-items: stretch;
}
.heatmap-toggle-group {
flex-wrap: wrap;
}
.heatmap-player-grid {
grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
}
.position-stats {
flex-wrap: wrap;
gap: 12px;
}
}

.hidden {
display: none !important;
}
.loading {
text-align: center;
padding: var(--spacing-xl);
color: var(--text-secondary);
}
.empty-state {
text-align: center;
padding: var(--spacing-xl);
}
.empty-state-icon {
font-size: 48px;
margin-bottom: var(--spacing-md);
}
.empty-state-title {
font-size: 20px;
font-weight: 700;
margin-bottom: var(--spacing-sm);
}
.empty-state-subtitle {
color: var(--text-secondary);
}

.matrix-tab {
transition: all 0.2s ease;
}
.matrix-tab:hover {
background: var(--bg-elevated) !important;
}
.matrix-tab.active {
background: var(--positive) !important;
color: white !important;
}
.matrix-chart-tab {
transition: all 0.2s ease;
}
.matrix-chart-tab:hover {
color: var(--text-primary) !important;
}
.matrix-chart-tab.active {
color: var(--text-primary) !important;
border-bottom-color: var(--positive) !important;
}
.matrix-section {
animation: fadeIn 0.3s ease;
}
.matrix-chart-content {
animation: fadeIn 0.3s ease;
}


.dashboard-header-widgets {
display: grid;
grid-template-columns: 1fr 1fr;
gap: 16px;
margin-bottom: 16px;
}
.dashboard-widget {
background: var(--bg-secondary);
border: 1px solid var(--border-color);
border-radius: 12px;
overflow: hidden;
}
.widget-header {
padding: 12px 16px;
border-bottom: 1px solid var(--border-color);
display: flex;
align-items: center;
justify-content: space-between;
gap: 10px;
background: var(--bg-tertiary);
}
.mover-filter-btns {
display: flex;
gap: 4px;
}
.filter-btn {
padding: 6px 12px;
font-size: 11px;
font-weight: 600;
background: var(--bg-secondary);
border: 1px solid var(--border-color);
border-radius: 6px;
color: var(--text-secondary);
cursor: pointer;
transition: all 0.2s ease;
}
.filter-btn:hover {
background: var(--bg-elevated);
color: var(--text-primary);
}
.filter-btn.active {
background: var(--positive);
color: white;
border-color: var(--positive);
}
.widget-title {
font-size: 13px;
font-weight: 700;
color: var(--text-primary);
}

.expand-btn {
background: var(--bg-secondary);
border: 1px solid var(--border-color);
color: var(--text-secondary);
border-radius: 6px;
padding: 4px 8px;
font-size: 14px;
cursor: pointer;
transition: all 0.2s ease;
line-height: 1;
}
.expand-btn:hover {
background: var(--bg-elevated);
color: var(--text-primary);
border-color: var(--positive);
}

.dashboard-widget.expanded {
grid-column: span 2 !important;
}
.dashboard-widget.collapsed {
display: none;
}
.dashboard-widget.expanded .expand-btn {
background: var(--positive);
color: white;
border-color: var(--positive);
}
.widget-body {
padding: 16px;
}

.dashboard-scatter-info {
display: none; 
align-items: center;
justify-content: center;
width: 18px;
height: 18px;
border-radius: 50%;
border: 1.5px solid var(--text-tertiary);
color: var(--text-tertiary);
font-size: 11px;
font-weight: 700;
font-style: normal;
cursor: pointer;
transition: all 0.2s ease;
position: relative;
flex-shrink: 0;
margin-left: 6px;
}
.dashboard-scatter-info:hover {
border-color: var(--text-secondary);
color: var(--text-secondary);
background: rgba(255, 255, 255, 0.05);
}
.dashboard-scatter-tooltip {
position: absolute;
left: calc(100% + 8px);
top: 50%;
transform: translateY(-50%);
background: var(--bg-secondary);
border: 1px solid var(--border-color);
border-radius: 8px;
padding: 10px 14px;
font-size: 11px;
color: var(--text-primary);
white-space: nowrap;
pointer-events: none;
opacity: 0;
visibility: hidden;
transition: all 0.2s ease;
z-index: 1000;
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}
.dashboard-scatter-info:hover .dashboard-scatter-tooltip,
.dashboard-scatter-info.active .dashboard-scatter-tooltip {
opacity: 1;
visibility: visible;
}

.stat-widget-full {
margin-bottom: 24px;
}
.stat-widget-full .widget-body {
padding: 16px 24px;
}
.stat-highlight-horizontal {
display: flex;
align-items: center;
gap: 24px;
}
.stat-highlight-horizontal .stat-highlight-value {
font-size: 48px;
font-weight: 900;
background: linear-gradient(135deg, #30d158, #0a84ff);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
flex-shrink: 0;
}
.stat-highlight-content {
flex: 1;
}
.stat-highlight-horizontal .stat-highlight-label {
font-size: 14px;
font-weight: 600;
color: var(--text-primary);
text-transform: uppercase;
letter-spacing: 0.5px;
margin-bottom: 4px;
}
.stat-highlight-horizontal .stat-highlight-text {
font-size: 13px;
line-height: 1.5;
color: var(--text-secondary);
}
.stat-highlight-horizontal .stat-highlight-text strong {
color: var(--positive);
font-weight: 700;
}

.insight-nav-btn {
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
color: var(--text-primary);
width: 28px;
height: 28px;
border-radius: 6px;
font-size: 18px;
font-weight: 600;
cursor: pointer;
display: flex;
align-items: center;
justify-content: center;
transition: all 0.2s ease;
padding: 0;
line-height: 1;
}
.insight-nav-btn:hover {
background: var(--bg-elevated);
border-color: var(--text-tertiary);
transform: translateY(-1px);
}
.insight-nav-btn:active {
transform: translateY(0);
}

.stat-highlight {
text-align: center;
}
.stat-highlight-value {
font-size: 32px;
font-weight: 900;
background: linear-gradient(135deg, #30d158, #0a84ff);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
margin-bottom: 4px;
}
.stat-highlight-label {
font-size: 11px;
font-weight: 600;
color: var(--text-secondary);
text-transform: uppercase;
letter-spacing: 0.5px;
margin-bottom: 8px;
}
.stat-highlight-text {
font-size: 11px;
line-height: 1.5;
color: var(--text-secondary);
}
.stat-highlight-text strong {
color: var(--positive);
font-weight: 700;
}

.trend-widget {
display: flex;
flex-direction: column;
}
.trend-widget .widget-body {
padding: 12px;
flex: 1;
display: flex;
flex-direction: column;
}
.dashboard-chart-wrapper {
flex: 1;
min-height: 220px;
position: relative;
}
.dashboard-chart-wrapper canvas {
width: 100% !important;
height: 100% !important;
}
.dashboard-scrubber {
margin-top: 8px;
display: flex;
align-items: center;
gap: 8px;
}
.scrubber-label {
font-size: 11px;
font-weight: 600;
color: var(--text-secondary);
min-width: 80px;
}
.dashboard-scrubber .week-scrubber {
flex: 1;
}
.playback-btn-small {
width: 28px;
height: 28px;
background: var(--positive);
border: none;
border-radius: 4px;
color: #000;
font-size: 12px;
cursor: pointer;
display: flex;
align-items: center;
justify-content: center;
transition: all 0.2s ease;
}
.playback-btn-small:hover {
background: #28c149;
}
.playback-btn-small.playing {
background: var(--negative);
}

.categories-section {
margin: 16px 0;
display: grid;
grid-template-columns: repeat(4, 1fr);
gap: 16px;
max-height: none; 
overflow: visible; 
padding-right: 8px;
}

.categories-section:has(.categories-carousel-container) {
display: block;
padding-right: 0;
}

.categories-section::-webkit-scrollbar {
width: 8px;
}
.categories-section::-webkit-scrollbar-track {
background: var(--bg-secondary);
border-radius: 4px;
}
.categories-section::-webkit-scrollbar-thumb {
background: var(--bg-elevated);
border-radius: 4px;
}
.categories-section::-webkit-scrollbar-thumb:hover {
background: var(--border-color-light);
}
.category-row {
margin-bottom: 0;
background: var(--bg-secondary);
border: 1px solid var(--border-color);
border-radius: 8px;
padding: 12px;
}

.categories-carousel-container {
position: relative;
margin-bottom: 0;
margin-top: -24px; 
min-height: 340px; 
overflow: hidden; 
width: 100%; 
max-width: 100%; 
}
.categories-carousel-scroll {
display: flex;
gap: 20px;
overflow: visible; 
scrollbar-width: none;
-ms-overflow-style: none;
padding: 20px 0; 
margin: 0; 
animation: scrollReverse 240s linear infinite;
white-space: nowrap;
width: fit-content; 
}
.categories-carousel-scroll:hover {
animation-play-state: paused; 
}
.categories-carousel-scroll::-webkit-scrollbar {
display: none;
}
.category-carousel-item {
flex: 0 0 calc(50% - 10px);
scroll-snap-align: start;
background: var(--bg-secondary);
border: 1px solid var(--border-color);
border-radius: 12px;
padding: 10px;
min-width: 360px;
max-width: 400px;
min-height: 160px; 
overflow: visible; 
}
.carousel-nav {
position: absolute;
top: 50%;
transform: translateY(-50%);
z-index: 10;
background: var(--bg-elevated);
border: 1px solid var(--border-color);
width: 48px;
height: 48px;
border-radius: 50%;
font-size: 28px;
font-weight: 600;
color: var(--text-primary);
cursor: pointer;
transition: all 0.2s ease;
display: flex;
align-items: center;
justify-content: center;
box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}
.carousel-nav:hover {
background: var(--text-primary);
color: var(--bg-primary);
transform: translateY(-50%) scale(1.1);
}
.carousel-nav-left {
left: 10px;
}
.carousel-nav-right {
right: 10px;
}

.category-footnote {
margin-top: 16px;
text-align: center;
}
.footnote-toggle {
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
border-radius: 6px;
padding: 8px 16px;
color: var(--text-secondary);
font-size: 12px;
cursor: pointer;
transition: all 0.2s ease;
}
.footnote-toggle:hover {
background: var(--bg-elevated);
color: var(--text-primary);
}
.footnote-content {
margin-top: 12px;
padding: 12px 16px;
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
border-radius: 8px;
font-size: 11px;
line-height: 1.6;
color: var(--text-secondary);
text-align: left;
max-width: 800px;
margin-left: auto;
margin-right: auto;
}

.team-stat-card {
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
border-radius: 8px;
padding: 12px;
text-align: center;
transition: all 0.2s ease;
}
.team-stat-card:hover {
transform: translateY(-2px);
border-color: var(--border-color-light);
}
.team-stat-value {
font-size: 24px;
font-weight: 700;
color: var(--text-primary);
margin-bottom: 4px;
}
.team-stat-label {
font-size: 11px;
color: var(--text-secondary);
text-transform: uppercase;
letter-spacing: 0.5px;
}
.team-stats-summary {
display: grid;
grid-template-columns: repeat(4, 1fr);
gap: 16px;
margin-bottom: 24px;
}
.key-player-card {
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
border-radius: 8px;
padding: 12px;
display: flex;
align-items: center;
gap: 12px;
transition: all 0.2s ease;
cursor: pointer;
}
.key-player-card:hover {
transform: translateY(-2px);
border-color: var(--positive);
background: var(--bg-elevated);
}
.key-player-position {
width: 36px;
height: 36px;
border-radius: 6px;
display: flex;
align-items: center;
justify-content: center;
font-size: 12px;
font-weight: 700;
color: white;
flex-shrink: 0;
}
.key-player-info {
flex: 1;
}
.key-player-name {
font-size: 12px;
font-weight: 600;
color: #ffffff !important;
margin-bottom: 2px;
}
.key-player-stat {
font-size: 11px;
color: var(--text-secondary);
}
.category-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 6px;
padding-bottom: 6px;
border-bottom: 2px solid var(--border-color);
}
.category-title {
font-size: 16px;
font-weight: 700;
color: var(--text-primary);
display: flex;
align-items: center;
gap: 6px;
letter-spacing: 0.3px;
}
.category-icon {
font-size: 18px;
filter: brightness(1.2);
}
.category-expand-btn {
padding: 6px 12px;
background: var(--bg-elevated);
border: 1px solid var(--border-color);
border-radius: 6px;
color: var(--text-secondary);
font-size: 12px;
font-weight: 600;
cursor: pointer;
transition: all 0.2s ease;
}
.category-expand-btn:hover {
background: var(--bg-tertiary);
color: var(--text-primary);
border-color: var(--border-color-light);
}
.category-cards-container {
display: grid;
grid-template-columns: 1fr;
gap: 4px;
margin-top: 6px;
max-height: none; 
overflow: visible; 
}

.category-rank-simple {
font-size: 14px;
font-weight: 700;
color: var(--text-secondary);
flex-shrink: 0;
}

.category-cards-container .player-card {
padding: 4px;
position: relative;
margin-bottom: 0;
min-height: 38px !important; 
height: auto;
}
.category-cards-container .player-card-header {
margin-bottom: 0;
gap: 8px;
}
.category-cards-container .player-card-badge {
width: 28px;
height: 28px;
font-size: 9px;
}
.category-cards-container .player-card-name {
font-size: 12px;
line-height: 1.2;
}
.category-cards-container .player-card-team {
font-size: 10px;
margin-top: 0;
}
.category-cards-container .player-card-stats {
gap: 4px;
margin-bottom: 0;
display: grid;
grid-template-columns: 1fr 1fr;
}
.category-cards-container .player-stat {
font-size: 10px;
justify-content: flex-start;
gap: 2px;
position: relative;
}

.category-info-icon:hover .stat-tooltip {
opacity: 1;
}

.category-cards-container .player-stat-value:hover .stat-tooltip {
opacity: 1;
}

.category-cards-container .player-comparison:hover .change-tooltip {
opacity: 1;
}

.category-cards-container .player-comparison span:hover .change-tooltip {
opacity: 1;
}
.category-cards-container .player-stat-label {
font-size: 8px;
text-transform: uppercase;
letter-spacing: 0.3px;
}
.category-cards-container .player-stat-value {
font-size: 12px;
font-weight: 700;
}
.category-cards-container .player-comparison {
font-size: 12px;
}
.category-cards-container .player-card-chart {
display: none;
}

.category-cards-container .stat-tooltip {
font-size: 10px;
white-space: normal;
max-width: 200px;
z-index: 2000;
line-height: 1.4;
}
.category-cards-container .comparison-tooltip {
display: none; 
}

.change-tooltip {
position: absolute;
bottom: 100%;
right: 0;
transform: translateY(0);
margin-bottom: 8px;
background: var(--bg-elevated);
border: 1px solid var(--border-color-light);
border-radius: 8px;
padding: 8px 12px;
font-size: 10px;
white-space: normal;
max-width: 180px;
opacity: 0;
pointer-events: none;
transition: opacity 0.2s ease;
z-index: 2001;
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
line-height: 1.4;
}

@media (max-width: 768px) {
.change-tooltip {
right: auto;
left: 0; /* Open to the right on mobile */
}
}

.player-comparison:hover .change-tooltip {
opacity: 1;
}

.info-icon {
display: inline-block;
margin-left: 6px;
font-size: 13px;
color: var(--text-secondary);
cursor: help;
opacity: 0.7;
transition: opacity 0.2s;
}

.info-icon:hover {
opacity: 1;
}

.compact-player-card:hover {
background: var(--bg-elevated);
border-color: var(--border-color-light);
transform: translateY(-1px);
}
.compact-player-card .player-comparison:hover .change-tooltip {
opacity: 1;
}
.compact-metric-value:hover .stat-tooltip {
opacity: 1;
}

#portal-tooltip {
position: fixed;
background: var(--bg-elevated);
border: 1px solid var(--border-color-light);
border-radius: 8px;
padding: 10px 14px;
font-size: 11px;
line-height: 1.5;
color: var(--text-primary);
max-width: 280px;
opacity: 0;
pointer-events: none;
transition: opacity 0.15s ease;
z-index: 99999;
box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
}
#portal-tooltip.visible {
opacity: 1;
}
#portal-tooltip .tooltip-secondary {
color: var(--text-tertiary);
margin-top: 6px;
display: block;
font-size: 10px;
}

.metric-bar-container {
position: relative;
width: 100%;
height: 10px;
margin-top: 4px;
border-radius: 5px;
background: rgba(255, 255, 255, 0.05);
overflow: hidden;
}
.metric-bar {
height: 100%;
border-radius: 5px;
transition: width 0.6s ease;
}



.category-cards-expanded {
grid-template-columns: 1fr;
}
.category-card-hidden {
display: none;
}

.advanced-analytics-container {
max-width: 1400px;
margin: 0 auto;
}
.advanced-header {
margin-bottom: 32px;
}
.advanced-title {
font-size: 18px;
font-weight: 700;
margin-bottom: 8px;
}
.advanced-subtitle {
font-size: 13px;
color: var(--text-secondary);
}
.position-toggle {
display: flex;
gap: 8px;
margin-bottom: 24px;
padding: 4px;
background: var(--bg-tertiary);
border-radius: 12px;
width: fit-content;
}
.position-toggle-btn {
padding: 10px 24px;
background: transparent;
border: none;
color: var(--text-secondary);
font-size: 14px;
font-weight: 600;
cursor: pointer;
border-radius: 8px;
transition: all 0.2s ease;
}
.position-toggle-btn.active {
background: var(--bg-secondary);
color: var(--text-primary);
box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.player-count-btn {
padding: 6px 14px;
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
color: var(--text-secondary);
font-size: 13px;
font-weight: 600;
cursor: pointer;
border-radius: 6px;
transition: all 0.2s ease;
min-width: 40px;
}
.player-count-btn:hover {
background: var(--bg-secondary);
border-color: var(--border-color-light);
color: var(--text-primary);
}
.player-count-btn.active {
background: var(--accent-blue);
border-color: var(--accent-blue);
color: white;
}

.zoom-btn {
padding: 6px 12px;
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
color: var(--text-secondary);
font-size: 13px;
font-weight: 600;
cursor: pointer;
border-radius: 6px;
transition: all 0.2s ease;
display: flex;
align-items: center;
gap: 6px;
}
.zoom-btn:hover {
background: var(--bg-secondary);
border-color: var(--border-color-light);
color: var(--text-primary);
}
.zoom-btn svg {
flex-shrink: 0;
}
.preset-section {
margin-bottom: 24px;
background: var(--bg-tertiary);
padding: 20px;
border-radius: 12px;
border: 1px solid var(--border-color);
}
.preset-label {
font-size: 12px;
font-weight: 600;
color: var(--text-secondary);
text-transform: uppercase;
letter-spacing: 0.5px;
margin-bottom: 12px;
}
.preset-buttons {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
gap: 8px;
}
.preset-btn {
padding: 10px 16px;
background: var(--bg-secondary);
border: 1px solid var(--border-color-light);
color: var(--text-primary);
font-size: 13px;
font-weight: 500;
cursor: pointer;
border-radius: 8px;
transition: all 0.2s ease;
white-space: nowrap;
text-align: center;
}
.preset-btn:hover {
background: var(--bg-elevated);
border-color: var(--positive);
transform: translateY(-1px);
}
.preset-btn:active {
transform: translateY(0);
}
.preset-btn.active {
background: var(--positive);
border-color: var(--positive);
color: white;
font-weight: 600;
}
.axis-controls {
display: grid;
grid-template-columns: 1fr 1fr;
gap: 24px;
margin-bottom: 32px;
}
.axis-control {
background: var(--bg-tertiary);
padding: 20px;
border-radius: 12px;
border: 1px solid var(--border-color);
}

@keyframes subtle-pulse {
0%, 100% {
box-shadow: 0 0 0 0 rgba(10, 132, 255, 0);
}
50% {
box-shadow: 0 0 8px 2px rgba(10, 132, 255, 0.3);
}
}
.axis-label {
font-size: 12px;
font-weight: 600;
color: var(--text-secondary);
text-transform: uppercase;
letter-spacing: 0.5px;
margin-bottom: 12px;
display: flex;
align-items: center;
justify-content: space-between;
cursor: pointer;
user-select: none;
padding: 8px 12px;
margin: -8px -12px 4px -12px;
border-radius: 8px;
transition: all 0.3s ease;
animation: subtle-pulse 3s ease-in-out infinite;
}
.axis-label:hover {
background: var(--bg-secondary);
color: var(--accent);
animation: none;
}

.axis-label-static {
font-size: 12px;
font-weight: 600;
color: var(--text-secondary);
text-transform: uppercase;
letter-spacing: 0.5px;
margin-bottom: 12px;
display: flex;
align-items: center;
justify-content: space-between;
user-select: none;
}
.axis-label-text {
flex: 1;
}
.axis-collapse-icon {
font-size: 14px;
transition: transform 0.2s ease;
color: var(--text-tertiary);
}
.axis-collapse-icon.collapsed {
transform: rotate(-90deg);
}
.axis-control-content {
max-height: 200px;
overflow: hidden;
transition: max-height 0.3s ease, opacity 0.3s ease;
opacity: 1;
}
.axis-control-content.collapsed {
max-height: 0;
opacity: 0;
}
.axis-select {
width: 100%;
padding: 12px 16px;
background: var(--bg-secondary);
border: 1px solid var(--border-color-light);
border-radius: 8px;
color: var(--text-primary);
font-size: 15px;
font-weight: 500;
cursor: pointer;
transition: all 0.2s ease;
}
.axis-select:hover {
border-color: var(--positive);
}
.axis-select:focus {
outline: none;
border-color: var(--positive);
box-shadow: 0 0 0 3px rgba(48, 209, 88, 0.1);
}
.scatter-chart-card {
background: var(--bg-tertiary);
border-radius: 16px;
padding: 24px;
border: 1px solid var(--border-color);
}
.scatter-chart-header {
margin-bottom: 20px;
}
.scatter-chart-title {
font-size: 20px;
font-weight: 700;
margin-bottom: 4px;
}
#team-chart-title {
font-size: 16px;
font-weight: 600;
}
.scatter-chart-description {
font-size: 14px;
color: var(--text-secondary);
line-height: 1.5;
}
.scatter-chart-description strong {
color: var(--text-primary);
font-weight: 600;
}
.scatter-chart-wrapper {
position: relative;
height: 600px;
}

.footer {
background: var(--bg-secondary);
border-top: 1px solid var(--border-color);
padding: 48px 24px 24px;
margin-top: 80px;
}
.footer-content {
max-width: 1400px;
margin: 0 auto;
display: grid;
grid-template-columns: 2fr 1fr 1fr;
gap: 48px;
}
.footer-section h3 {
font-size: 14px;
font-weight: 700;
color: var(--text-primary);
margin-bottom: 16px;
letter-spacing: 0.5px;
}
.footer-section p {
font-size: 13px;
color: var(--text-secondary);
line-height: 1.6;
margin-bottom: 16px;
}
.waitlist-form {
display: flex;
gap: 8px;
margin-top: 16px;
}
.waitlist-input {
flex: 1;
padding: 10px 14px;
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
border-radius: 8px;
color: var(--text-primary);
font-size: 13px;
transition: all 0.2s ease;
}
.waitlist-input:focus {
outline: none;
border-color: #0a84ff;
background: var(--bg-elevated);
}
.waitlist-input::placeholder {
color: var(--text-tertiary);
}
.waitlist-btn {
padding: 10px 20px;
background: linear-gradient(135deg, #30d158, #0a84ff);
border: none;
border-radius: 8px;
color: #fff;
font-size: 13px;
font-weight: 600;
cursor: pointer;
transition: all 0.2s ease;
white-space: nowrap;
box-shadow: 0 0 15px rgba(48, 209, 88, 0.3),
0 0 30px rgba(10, 132, 255, 0.15);
}
.waitlist-btn:hover {
box-shadow: 0 0 20px rgba(48, 209, 88, 0.5),
0 0 40px rgba(10, 132, 255, 0.25);
transform: translateY(-1px);
}
.waitlist-btn:active {
transform: translateY(0);
}
.footer-links {
display: flex;
flex-direction: column;
gap: 10px;
}
.footer-link {
color: var(--text-secondary);
text-decoration: none;
font-size: 13px;
transition: color 0.2s ease;
}
.footer-link:hover {
color: var(--text-primary);
}
.footer-bottom {
max-width: 1400px;
margin: 32px auto 0;
padding-top: 24px;
border-top: 1px solid var(--border-color);
display: flex;
align-items: center;
justify-content: space-between;
font-size: 12px;
color: var(--text-tertiary);
}
.footer-logo {
display: flex;
align-items: center;
gap: 8px;
font-size: 16px;
font-weight: 700;
color: var(--text-primary);
}
.footer-logo-icon {
width: 24px;
height: 24px;
background: linear-gradient(135deg, #30d158, #0a84ff);
border-radius: 6px;
display: flex;
align-items: center;
justify-content: center;
font-size: 16px;
font-weight: 900;
color: white;
box-shadow: 0 0 15px rgba(48, 209, 88, 0.3),
0 0 30px rgba(10, 132, 255, 0.15);
}
.footer-logo-icon::before {
content: '>';
transform: scaleX(1.3);
}
.footer-copyright {
flex: 1;
text-align: center;
}
.success-message {
padding: 10px 14px;
background: var(--positive-bg);
border: 1px solid var(--positive);
border-radius: 8px;
color: var(--positive);
font-size: 13px;
margin-top: 8px;
display: none;
}
.success-message.show {
display: block;
animation: fadeIn 0.3s ease;
}

.waitlist-modal {
display: none;
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(0, 0, 0, 0.85);
z-index: 10000;
justify-content: center;
align-items: center;
backdrop-filter: blur(4px);
}
.waitlist-modal.show {
display: flex;
animation: fadeIn 0.3s ease;
}
.waitlist-modal-content {
background: var(--bg-elevated);
border-radius: 16px;
padding: 32px;
max-width: 400px;
width: 90%;
text-align: center;
border: 1px solid var(--border-color-light);
animation: slideUp 0.3s ease;
}
@keyframes slideUp {
from {
opacity: 0;
transform: translateY(30px);
}
to {
opacity: 1;
transform: translateY(0);
}
}
.waitlist-modal-icon {
font-size: 48px;
margin-bottom: 16px;
}
.waitlist-modal-title {
font-size: 24px;
font-weight: 700;
color: var(--text-primary);
margin-bottom: 8px;
}
.waitlist-modal-message {
font-size: 14px;
color: var(--text-secondary);
margin-bottom: 24px;
line-height: 1.5;
}
.waitlist-modal-btn {
padding: 12px 32px;
background: var(--positive);
color: white;
border: none;
border-radius: 8px;
font-weight: 600;
cursor: pointer;
font-size: 14px;
transition: all 0.2s ease;
}
.waitlist-modal-btn:hover {
background: #28c149;
transform: translateY(-1px);
}
@media (max-width: 768px) {
.footer-content {
grid-template-columns: 1fr;
gap: 32px;
}

.category-carousel-item {
flex: 0 0 100%;
min-width: calc(100vw - 80px);
max-width: calc(100vw - 80px);
scroll-snap-align: center;
}
.categories-carousel-container {
overflow-x: scroll;
overflow-y: hidden;
scroll-snap-type: x mandatory;
-webkit-overflow-scrolling: touch;
scrollbar-width: none;
-ms-overflow-style: none;
scroll-behavior: smooth;
touch-action: pan-x;
}
.categories-carousel-container::-webkit-scrollbar {
display: none;
}
.categories-carousel-scroll {
animation: none !important; 
gap: 20px;
padding: 20px 40px;
display: flex;
width: auto;
}
}
@media (min-width: 769px) {
.category-carousel-item {
flex: 0 0 calc(50% - 10px);
min-width: 360px;
max-width: 400px;
}
}

.mobile-menu-button {
display: none; 
flex-direction: column;
justify-content: center;
align-items: center;
width: 40px;
height: 40px;
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
border-radius: 8px;
cursor: pointer;
transition: all 0.2s ease;
z-index: 10002; 
position: relative;
}
.mobile-menu-button:hover {
background: var(--bg-elevated);
}
.hamburger-line {
width: 20px;
height: 2px;
background: var(--text-primary);
margin: 3px 0;
transition: all 0.3s ease;
}
.mobile-menu-button.active .hamburger-line:nth-child(1) {
transform: rotate(45deg) translate(6px, 6px);
}
.mobile-menu-button.active .hamburger-line:nth-child(2) {
opacity: 0;
}
.mobile-menu-button.active .hamburger-line:nth-child(3) {
transform: rotate(-45deg) translate(6px, -6px);
}
.mobile-menu-overlay {
position: fixed;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: rgba(0, 0, 0, 0.8);
z-index: 10000; 
opacity: 0;
pointer-events: none;
transition: opacity 0.3s ease;
}
.mobile-menu-overlay.active {
opacity: 1;
pointer-events: all;
}
.mobile-menu {
position: fixed;
top: 0;
right: -100%;
width: 280px;
height: 100vh;
background: var(--bg-secondary);
border-left: 1px solid var(--border-color);
z-index: 10001; 
padding: 24px;
overflow-y: auto;
transition: right 0.3s ease;
}
.mobile-menu.active {
right: 0;
}
.mobile-menu-header {
display: flex;
justify-content: space-between;
align-items: center;
margin-bottom: 32px;
padding-bottom: 16px;
border-bottom: 1px solid var(--border-color);
}
.mobile-menu-title {
font-size: 18px;
font-weight: 700;
color: var(--text-primary);
}
.mobile-menu-close {
width: 32px;
height: 32px;
display: flex;
align-items: center;
justify-content: center;
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
border-radius: 6px;
color: var(--text-primary);
font-size: 20px;
cursor: pointer;
transition: all 0.2s ease;
}
.mobile-menu-close:hover {
background: var(--bg-elevated);
}
.mobile-menu-items {
display: flex;
flex-direction: column;
gap: 8px;
}
.mobile-menu-item {
padding: 14px 16px;
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
border-radius: 8px;
color: var(--text-primary);
font-size: 15px;
font-weight: 600;
cursor: pointer;
transition: all 0.2s ease;
text-align: left;
}
.mobile-menu-item:hover {
background: var(--bg-elevated);
border-color: var(--positive);
}
.mobile-menu-item.active {
background: var(--positive-bg);
border-color: var(--positive);
color: var(--positive);
}
.mobile-menu-divider {
height: 1px;
background: var(--border-color);
margin: 16px 0;
}
.mobile-menu-waitlist {
margin-top: 16px;
padding: 14px 16px;
background: var(--positive);
border: none;
border-radius: 8px;
color: white;
font-size: 15px;
font-weight: 600;
cursor: pointer;
transition: all 0.2s ease;
width: 100%;
}
.mobile-menu-waitlist:hover {
background: #28c149;
transform: translateY(-1px);
}
.mobile-menu-theme-toggle {
margin-top: 16px;
padding: 14px 16px;
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
border-radius: 8px;
color: var(--text-primary);
font-size: 15px;
font-weight: 600;
cursor: pointer;
transition: all 0.2s ease;
width: 100%;
display: flex;
align-items: center;
justify-content: center;
gap: 12px;
}
.mobile-menu-theme-toggle:hover {
background: var(--bg-elevated);
transform: translateY(-1px);
}
.mobile-menu-theme-toggle .sun-icon {
display: none;
color: #ffa500;
}
.mobile-menu-theme-toggle .moon-icon {
display: block;
color: #0a84ff;
}
[data-theme="light"] .mobile-menu-theme-toggle .sun-icon {
display: block;
}
[data-theme="light"] .mobile-menu-theme-toggle .moon-icon {
display: none;
}
.mobile-menu-theme-toggle .light-label {
display: none;
}
.mobile-menu-theme-toggle .dark-label {
display: inline;
}
[data-theme="light"] .mobile-menu-theme-toggle .light-label {
display: inline;
}
[data-theme="light"] .mobile-menu-theme-toggle .dark-label {
display: none;
}

.carousel-dots {
display: none; 
justify-content: center;
gap: 8px;
padding: 16px 0;
margin-top: -16px;
}
.carousel-dot {
width: 8px;
height: 8px;
border-radius: 50%;
background: var(--text-tertiary);
opacity: 0.3;
transition: all 0.3s ease;
cursor: pointer; 
}
.carousel-dot:hover {
opacity: 0.6; 
}
.carousel-dot.active {
width: 24px;
border-radius: 4px;
background: var(--positive);
opacity: 1;
}
@media (max-width: 768px) {
.carousel-dots {
display: flex;
}
}

@media (max-width: 1200px) {
.player-cards-grid {
grid-template-columns: repeat(2, 1fr); 
gap: 16px;
}
}
@media (max-width: 1024px) {
.main-content {
padding: var(--spacing-md);
}
.player-cards-grid {
grid-template-columns: repeat(2, 1fr);
gap: 16px;
}
}
@media (max-width: 768px) {
body {
overflow-x: hidden;
max-width: 100vw;
}
.header {
padding: 12px 16px;
}
.logo {
font-size: 18px;
}

.nav-tabs {
display: none;
}

.header-right-section {
display: flex !important;
}
.header-right-section .upload-btn {
display: none !important;
}
.header-right-section .header-scoring-dropdown {
display: block !important;
}

.mobile-menu-button {
display: flex !important;
}
.nav-tab {
padding: 8px 12px;
font-size: 12px;
flex-shrink: 0;
}
.upload-btn {
padding: 8px 14px;
font-size: 12px;
}
.main-content {
padding: 16px;
overflow-x: hidden;
max-width: 100vw;
}
.page-title {
font-size: 20px;
}
.page-subtitle {
font-size: 13px;
}
.player-cards-grid {
grid-template-columns: repeat(2, 1fr) !important;
gap: 12px;
max-width: 100%;
overflow: hidden;
}
.player-card {
padding: 12px;
max-width: 100%;
overflow: hidden;
box-sizing: border-box;
}

.player-card-badge {
width: 40px;
height: 40px;
font-size: 10px;
}
.player-card-name {
font-size: 14px;
overflow: hidden;
text-overflow: ellipsis;
white-space: nowrap;
}
.player-card-team {
font-size: 11px;
}
.player-card-header {
gap: 10px;
margin-bottom: 10px;
}
.stat-value {
font-size: 18px;
}
.stat-label {
font-size: 10px;
}
.player-tags {
gap: 4px;
}
.player-tag {
font-size: 9px;
padding: 2px 6px;
}
.teams-grid {
grid-template-columns: 1fr;
}

.team-analysis-controls {
grid-template-columns: repeat(2, 1fr) !important;
}

#team-charts-container {
grid-template-columns: 1fr !important;
min-height: auto !important;
}

#team-balance-scatter {
height: 350px !important;
}
.chart-wrapper {
height: 300px !important;
width: 100% !important;
max-width: 100% !important;
overflow: hidden;
}
.chart-card {
padding: 12px !important;
overflow: hidden;
}
.chart-card canvas {
max-width: 100% !important;
height: auto !important;
}

#team-pie-chart, #team-secondary-chart {
max-width: 100% !important;
}
.categories-grid {
grid-template-columns: 1fr;
}
.scatter-plots {
grid-template-columns: 1fr;
}

.dashboard-header-widgets {
grid-template-columns: 1fr !important;
}

.dashboard-scrubber {
display: none !important;
}

.dashboard-widget .mover-filter-btns {
display: none !important;
}
.dashboard-widget .expand-btn {
display: none !important;
}

.dashboard-scatter-info {
display: inline-flex !important;
}

.ticker-section {
position: relative !important; 
top: auto !important;
margin-bottom: 24px !important;
}
#wr-top-movers-sidebar,
#rb-top-movers-sidebar,
#te-top-movers-sidebar {
margin-top: 0 !important;
}

.stat-tooltip {
left: 0 !important;
transform: translateX(0) !important;
right: auto !important;
white-space: normal !important;
max-width: 250px !important;
}

.player-stat:last-child .stat-tooltip,
.compact-metric:last-child .stat-tooltip {
left: auto !important;
right: 0 !important;
transform: translateX(0) !important;
}
.modal {
width: 95%;
max-width: 95%;
margin: 20px;
max-height: 90vh;
padding: 20px;
}

.team-modal-charts-grid {
grid-template-columns: 1fr !important;
gap: 16px !important;
}
#team-modal-controls-grid {
gap: 12px !important;
}

#team-stats-summary {
grid-template-columns: repeat(2, 1fr) !important;
}

#key-players-grid {
gap: 12px !important;
}
.modal-charts-grid {
grid-template-columns: 1fr !important;
}
.axis-controls {
grid-template-columns: 1fr;
}
.preset-buttons {
grid-template-columns: 1fr;
}

.advanced-analytics-charts-wrapper {
display: flex;
flex-direction: column-reverse; 
}
.preset-buttons {
grid-template-columns: repeat(2, 1fr) !important;
}
.footer {
padding: 32px 16px 16px;
}
.footer-content {
grid-template-columns: 1fr;
gap: 24px;
}
.footer-bottom {
flex-direction: column;
gap: 16px;
text-align: center;
}
.footer-copyright {
text-align: center;
}
.waitlist-form {
flex-direction: column;
}
.waitlist-btn {
width: 100%;
}
}
@media (max-width: 480px) {
.logo span {
display: inline;
font-size: 16px;
}
.nav-tab {
padding: 6px 10px;
font-size: 11px;
}
.page-title {
font-size: 18px;
}

.cards-grid {
grid-template-columns: 1fr !important;
gap: 12px;
}

.player-card {
padding: 10px;
}
.player-stat-value {
font-size: 14px;
}

#wide-receivers > div[style*="grid-template-columns"],
#running-backs > div[style*="grid-template-columns"] {
grid-template-columns: 1fr !important;
}
#wr-top-movers-sidebar,
#rb-top-movers-sidebar {
position: static !important;
margin-top: 20px;
}
}

.loading-spinner {
width: 40px;
height: 40px;
margin: 0 auto;
border: 4px solid var(--bg-tertiary);
border-top: 4px solid var(--positive);
border-radius: 50%;
animation: spin 1s linear infinite;
}
@keyframes spin {
0% { transform: rotate(0deg); }
100% { transform: rotate(360deg); }
}

#initial-loading-screen {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: var(--bg-primary);
z-index: 99999;
display: flex;
align-items: center;
justify-content: center;
transition: opacity 0.5s ease-out;
}
#initial-loading-screen.fade-out {
opacity: 0;
pointer-events: none;
}
.loading-container {
text-align: center;
padding: 40px;
max-width: 500px;
width: 90%;
}
.loading-logo {
width: 64px;
height: 64px;
margin: 0 auto 24px;
background: linear-gradient(135deg, #30d158, #0a84ff);
border-radius: 12px;
display: flex;
align-items: center;
justify-content: center;
position: relative;
font-size: 44px;
font-weight: 900;
box-shadow: 0 0 20px rgba(48, 209, 88, 0.4),
0 0 40px rgba(10, 132, 255, 0.2);
}
.loading-logo::before {
content: '>';
transform: scaleX(1.3);
color: #fff;
text-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}
.loading-logo-icon {
display: none; 
}
@keyframes pulse-logo {
0%, 100% {
transform: scale(1);
box-shadow: 0 0 20px rgba(48, 209, 88, 0.4),
0 0 40px rgba(10, 132, 255, 0.2);
}
50% {
transform: scale(1.05);
box-shadow: 0 0 30px rgba(48, 209, 88, 0.6),
0 0 60px rgba(10, 132, 255, 0.4);
}
}
.loading-title {
font-size: 32px;
font-weight: 900;
color: var(--text-primary);
margin-bottom: 8px;
letter-spacing: 1px;
}
.loading-subtitle {
font-size: 14px;
color: var(--text-secondary);
margin-bottom: 32px;
}
.loading-ticker {
display: flex;
justify-content: center;
align-items: center;
gap: 16px;
margin-bottom: 40px;
}
.ticker-arrow {
font-size: 24px;
font-weight: 700;
opacity: 0.3;
animation: ticker-pulse 1.5s ease-in-out infinite;
}
.ticker-arrow:nth-child(1) {
color: var(--positive);
animation-delay: 0s;
}
.ticker-arrow:nth-child(2) {
color: var(--negative);
animation-delay: 0.5s;
}
.ticker-arrow:nth-child(3) {
color: var(--positive);
animation-delay: 1s;
}
@keyframes ticker-pulse {
0%, 100% {
opacity: 0.3;
transform: scale(1);
}
50% {
opacity: 1;
transform: scale(1.2);
}
}
.loading-progress-container {
margin-bottom: 16px;
width: 60%;
max-width: 300px;
margin-left: auto;
margin-right: auto;
}
.loading-progress-bar {
width: 100%;
height: 2px;
background: var(--bg-tertiary);
border-radius: 2px;
overflow: hidden;
position: relative;
}
.loading-progress-fill {
height: 100%;
background: linear-gradient(90deg, var(--positive) 0%, #00d9ff 100%);
border-radius: 2px;
transition: width 0.8s cubic-bezier(0.4, 0.0, 0.2, 1);
width: 0%;
box-shadow: 0 0 6px rgba(48, 209, 88, 0.3);
}
.loading-progress-text {
display: flex;
justify-content: space-between;
align-items: center;
margin-top: 12px;
}
.loading-percentage {
font-size: 16px;
font-weight: 600;
color: var(--text-primary);
}
.loading-status {
font-size: 13px;
color: var(--text-secondary);
}
@media (max-width: 768px) {
.loading-container {
padding: 24px;
}
.loading-logo {
width: 56px;
height: 56px;
font-size: 38px;
}
.loading-title {
font-size: 24px;
}
.loading-subtitle {
font-size: 13px;
margin-bottom: 24px;
}
.loading-ticker {
gap: 12px;
margin-bottom: 32px;
}
.ticker-arrow {
font-size: 20px;
}
.loading-progress-container {
width: 70%;
max-width: 250px;
}
.loading-progress-bar {
height: 1.5px;
}
.loading-progress-fill {
border-radius: 1.5px;
}

/* Advanced Analytics Mobile Optimization */
.advanced-analytics-charts-wrapper {
width: 100%;
max-width: 100vw;
overflow: hidden;
padding: 0 !important;
}

#advanced-analytics .heatmap-filters-bar {
flex-wrap: wrap !important;
padding: 12px !important;
gap: 8px !important;
}

#advanced-analytics .advanced-filters-container {
margin: 0 0 16px 0 !important;
}

#advanced-analytics .heatmap-filter-group-inline {
flex-wrap: wrap;
min-width: 0;
flex: 1 1 100%;
width: 100%;
}

#advanced-analytics .heatmap-filter-label {
font-size: 10px !important;
white-space: nowrap;
}

#advanced-analytics .heatmap-filter-select {
font-size: 11px !important;
padding: 6px 12px !important;
padding-right: 28px !important;
min-width: 100px !important;
flex: 1;
}

#advanced-analytics .heatmap-filter-separator {
display: none;
}

#player-search-input {
font-size: 11px !important;
padding: 6px 12px !important;
width: 100% !important;
}

#advanced-analytics .player-count-btn {
padding: 6px 10px !important;
font-size: 10px !important;
min-width: 38px;
}

#advanced-analytics .zoom-btn {
padding: 6px 10px !important;
font-size: 10px !important;
width: 100%;
justify-content: center;
}

#advanced-analytics .zoom-btn svg {
width: 12px !important;
height: 12px !important;
}

#preset-buttons-container {
width: 100%;
}

#preset-buttons-container button {
font-size: 10px !important;
padding: 6px 10px !important;
}

#x-axis-select,
#y-axis-select {
max-width: none !important;
}

#advanced-analytics .scatter-chart-wrapper {
height: 400px !important;
}

#advanced-analytics .scatter-chart-header {
padding: 12px !important;
}

#advanced-analytics .scatter-chart-title {
font-size: 16px !important;
}

#advanced-analytics .scatter-chart-description {
font-size: 11px !important;
}

#scatter-insight-cards {
grid-template-columns: 1fr !important;
padding: 0 12px;
}

.scatter-insight-card {
background: var(--bg-secondary);
border: 1px solid var(--border-color);
border-radius: 12px;
padding: 20px;
cursor: pointer;
transition: all 0.2s ease;
display: flex;
flex-direction: column;
height: 550px;
min-height: 550px;
max-height: 550px;
}

.scatter-card-header {
flex: 0 0 auto;
margin-bottom: 16px;
}

.scatter-card-details {
display: flex;
flex-direction: column;
flex: 1;
}

.scatter-section-narrative {
flex: 0 0 80px;
overflow: hidden;
margin-bottom: 16px;
}

.scatter-section-narrative > div {
display: -webkit-box;
-webkit-line-clamp: 4;
-webkit-box-orient: vertical;
overflow: hidden;
text-overflow: ellipsis;
line-height: 1.5;
max-height: 80px;
}

.scatter-section-plots {
flex: 0 0 auto;
min-height: 240px;
max-height: 240px;
overflow: hidden;
margin-bottom: 16px;
}

.scatter-section-plots > div {
max-height: 240px;
overflow: hidden;
}

.scatter-section-strengths {
flex: 0 0 auto;
min-height: 90px;
max-height: 90px;
overflow: hidden;
}

.scatter-section-strengths > div {
max-height: 90px;
overflow: hidden;
}

.scatter-insight-card:hover {
transform: translateY(-2px);
}

.scatter-insight-card.expanded {
padding: 24px;
cursor: default;
}

.scatter-card-header {
display: flex;
justify-content: space-between;
align-items: start;
gap: 16px;
}

.scatter-insight-card.expanded .scatter-card-header {
cursor: pointer;
}

.scatter-card-player-name {
font-size: 20px;
font-weight: 800;
color: var(--text-primary);
line-height: 1.2;
}

.scatter-card-team-badge {
padding: 3px 10px;
border-radius: 4px;
font-size: 10px;
font-weight: 700;
color: white;
letter-spacing: 0.5px;
}

.scatter-card-meta {
font-size: 11px;
color: var(--text-tertiary);
}

.scatter-card-badge {
padding: 6px 14px;
border-radius: 8px;
font-size: 11px;
font-weight: 700;
color: white;
letter-spacing: 0.8px;
white-space: nowrap;
text-transform: uppercase;
}

.scatter-card-expand-icon {
font-size: 14px;
color: var(--text-tertiary);
transition: transform 0.2s ease;
margin-left: auto;
padding-left: 8px;
}

.scatter-insight-card.expanded .scatter-card-expand-icon {
transform: rotate(180deg);
}

.scatter-card-details {
display: none;
}

.scatter-insight-card.expanded .scatter-card-details {
display: block;
}

@media (max-width: 768px) {
.scatter-insight-card {
padding: 16px;
}

.scatter-insight-card.expanded {
padding: 20px;
}

.scatter-card-player-name {
font-size: 16px;
}
}

#advanced-analytics .heatmap-ticker-bar {
flex-wrap: wrap;
min-height: auto;
padding: 12px !important;
gap: 12px !important;
}

#advanced-analytics .heatmap-rotating-insight-container {
width: 100%;
order: 1;
}

#advanced-analytics .heatmap-ticker-status {
order: 0;
}

#advanced-analytics .heatmap-ticker-divider {
display: none;
}

#advanced-analytics .heatmap-ticker-week {
order: 2;
margin-left: 0;
}

#advanced-analytics .heatmap-insight-value {
font-size: 32px !important;
}

#advanced-analytics .heatmap-insight-label,
#advanced-analytics .heatmap-insight-text {
font-size: 11px !important;
}
}

.radial-with-tooltip:hover .radial-tooltip {
opacity: 1 !important;
pointer-events: auto;
}

.schedule-content {
padding: 30px;
}
.schedule-header {
text-align: center;
margin-bottom: 24px;
}
.schedule-title {
font-size: 20px;
font-weight: 700;
margin-bottom: 8px;
}
.schedule-subtitle {
font-size: 13px;
color: #8e8e93;
}
.schedule-list {
display: flex;
flex-direction: column;
gap: 8px;
}
.schedule-row {
display: grid;
grid-template-columns: 100px 180px 160px 160px;
gap: 20px;
background: #2c2c2e;
padding: 12px 16px;
border-radius: 10px;
align-items: center;
border: 1px solid #3c3c3e;
transition: all 0.2s ease;
}
.schedule-row:hover {
background: #3c3c3e;
transform: translateX(2px);
border-color: #30d158;
}
.schedule-row.bye-week {
opacity: 0.5;
}

.week-info {
display: flex;
flex-direction: column;
gap: 2px;
}
.week-label {
font-size: 11px;
color: #8e8e93;
text-transform: uppercase;
letter-spacing: 0.5px;
}
.week-number {
font-size: 15px;
font-weight: 700;
color: #fff;
}

.matchup-info {
display: flex;
flex-direction: column;
gap: 4px;
}
.opponent-line {
display: flex;
align-items: center;
gap: 6px;
}
.vs-label {
font-size: 11px;
color: #8e8e93;
font-weight: 600;
}
.opponent-team {
font-size: 15px;
font-weight: 700;
color: #fff;
}

.mobile-defense-ranks {
display: none;
margin-top: 6px;
font-size: 11px;
color: #8e8e93;
gap: 8px;
flex-wrap: wrap;
align-items: center;
}
.mobile-rank {
font-weight: 600;
}
.mobile-rank.good {
color: #30d158;
}
.mobile-rank.neutral {
color: #ffd60a;
}
.mobile-rank.bad {
color: #ff453a;
}
.mobile-rank-separator {
color: #636366;
}
.desktop-only {
display: block;
}
.betting-info {
display: flex;
flex-direction: column;
gap: 6px;
}
.betting-odds-column {
display: flex;
flex-direction: column;
gap: 6px;
align-items: flex-end;
justify-content: center;
}
.spread-badge {
display: inline-block;
background: rgba(10, 132, 255, 0.15);
color: #0a84ff;
padding: 2px 6px;
border-radius: 4px;
font-size: 10px;
font-weight: 600;
}
.over-under-badge {
display: inline-block;
background: rgba(255, 214, 10, 0.15);
color: #ffd60a;
padding: 2px 6px;
border-radius: 4px;
font-size: 10px;
font-weight: 600;
}

.defense-rank {
text-align: center;
position: relative;
cursor: help;
}
.rank-label {
font-size: 9px;
color: #8e8e93;
text-transform: uppercase;
letter-spacing: 0.5px;
margin-bottom: 4px;
display: flex;
align-items: center;
justify-content: center;
gap: 3px;
}
.info-icon {
display: inline-block;
width: 12px;
height: 12px;
background: #3c3c3e;
border-radius: 50%;
text-align: center;
line-height: 12px;
font-size: 9px;
color: #8e8e93;
font-weight: 700;
}
.rank-value {
font-size: 16px;
font-weight: 700;
padding: 4px 10px;
border-radius: 6px;
}
.rank-value.elite {
background: rgba(48, 209, 88, 0.15);
color: #30d158;
border: 1px solid rgba(48, 209, 88, 0.3);
}
.rank-value.elite {
background: rgba(48, 209, 88, 0.2);
color: #30d158;
border: 1px solid rgba(48, 209, 88, 0.4);
font-weight: 700;
}
.rank-value.good {
background: rgba(48, 209, 88, 0.12);
color: #30d158;
border: 1px solid rgba(48, 209, 88, 0.25);
}
.rank-value.average {
background: rgba(255, 214, 10, 0.15);
color: #ffd60a;
border: 1px solid rgba(255, 214, 10, 0.3);
}
.rank-value.tough {
background: rgba(255, 159, 10, 0.15);
color: #ff9f0a;
border: 1px solid rgba(255, 159, 10, 0.3);
}
.rank-value.bad {
background: rgba(255, 69, 58, 0.15);
color: #ff453a;
border: 1px solid rgba(255, 69, 58, 0.3);
}

.rank-tooltip {
position: absolute;
bottom: 100%;
left: 50%;
transform: translateX(-50%);
margin-bottom: 8px;
padding: 10px 12px;
background: rgba(0, 0, 0, 0.95);
border: 1px solid #30d158;
border-radius: 8px;
font-size: 11px;
line-height: 1.5;
color: #fff;
white-space: nowrap;
opacity: 0;
pointer-events: none;
transition: opacity 0.2s ease;
z-index: 1000;
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
}
.rank-tooltip::after {
content: '';
position: absolute;
top: 100%;
left: 50%;
transform: translateX(-50%);
border: 5px solid transparent;
border-top-color: #30d158;
}
.defense-rank:hover .rank-tooltip {
opacity: 1;
}
.tooltip-title {
color: #30d158;
font-weight: 700;
margin-bottom: 4px;
}
.tooltip-text {
color: #ddd;
}

[data-theme="light"] {

--shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.12);
--shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);
--shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);
}

[data-theme="light"] .logo span,
[data-theme="light"] .modal-player-name,
[data-theme="light"] .player-name,
[data-theme="light"] .team-name,
[data-theme="light"] .player-stat-value,
[data-theme="light"] .stat-value,
[data-theme="light"] .metric-value,
[data-theme="light"] h1,
[data-theme="light"] h2,
[data-theme="light"] h3,
[data-theme="light"] .chart-title,
[data-theme="light"] .category-title,
[data-theme="light"] .tier-name,
[data-theme="light"] .modal-stat-value,
[data-theme="light"] .score-value,
[data-theme="light"] .player-rank,
[data-theme="light"] .team-stat-value,
[data-theme="light"] .compact-metric-value,
[data-theme="light"] .dashboard-value,
[data-theme="light"] .advanced-title,
[data-theme="light"] .preset-btn,
[data-theme="light"] .player-card-name,
[data-theme="light"] .team-card-name {
color: var(--text-primary) !important;
}

[data-theme="light"] .player-card .player-info .player-name,
[data-theme="light"] .player-card .player-team,
[data-theme="light"] .player-card .stat-label,
[data-theme="light"] .player-card .stat-value,
[data-theme="light"] .player-card .player-tier,
[data-theme="light"] .player-card .player-rank {
color: var(--text-primary) !important;
}

[data-theme="light"] .team-card .team-name,
[data-theme="light"] .team-card .team-record,
[data-theme="light"] .team-card .stat-label,
[data-theme="light"] .team-card .stat-value,
[data-theme="light"] .team-card h3,
[data-theme="light"] .team-card h4 {
color: var(--text-primary) !important;
}

[data-theme="light"] .modal .modal-player-name,
[data-theme="light"] .modal .modal-player-meta,
[data-theme="light"] .modal h3,
[data-theme="light"] .modal .chart-title,
[data-theme="light"] .modal .stat-label,
[data-theme="light"] .modal .stat-value {
color: var(--text-primary) !important;
}

[data-theme="light"] .player-stats,
[data-theme="light"] .team-stats,
[data-theme="light"] .modal-stats,
[data-theme="light"] .stats-grid {
color: var(--text-primary);
}

[data-theme="light"] .dashboard-header h2,
[data-theme="light"] .scatter-title,
[data-theme="light"] .heatmap-title {
color: var(--text-primary) !important;
}

[data-theme="light"] .tier-header .tier-name {
color: var(--text-primary) !important;
}

[data-theme="light"] .player-card,
[data-theme="light"] .team-card,
[data-theme="light"] .modal,
[data-theme="light"] .category-card {
box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
border: 1px solid var(--border-color);
}

[data-theme="light"] .player-card:hover,
[data-theme="light"] .team-card:hover {
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
}

[data-theme="light"] canvas {
background: transparent;
}

[data-theme="light"] .loading-logo {
box-shadow: 0 0 20px rgba(48, 209, 88, 0.3),
0 0 40px rgba(10, 132, 255, 0.15);
}
[data-theme="light"] .loading-title,
[data-theme="light"] .loading-subtitle,
[data-theme="light"] .loading-status {
color: var(--text-primary) !important;
}

[data-theme="light"] .tier-header {
background: var(--bg-tertiary);
border-bottom: 2px solid var(--border-color);
}

[data-theme="light"] .sentiment-bar {
border: 1px solid var(--border-color);
}

[data-theme="light"] .modal-overlay {
background: rgba(0, 0, 0, 0.4);
}

[data-theme="light"] .nav-tab,
[data-theme="light"] .chart-tab {
border: 1px solid transparent;
}
[data-theme="light"] .nav-tab.active,
[data-theme="light"] .chart-tab.active {
border-color: var(--border-color);
background: var(--bg-elevated);
color: var(--text-primary) !important;
}

[data-theme="light"] .vote-btn {
border: 1px solid var(--border-color);
color: var(--text-primary);
}
[data-theme="light"] .vote-btn:hover {
box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

[data-theme="light"] .top-mover-name,
[data-theme="light"] .top-mover-score {
color: var(--text-primary) !important;
}

[data-theme="light"] ::-webkit-scrollbar-track {
background: var(--bg-secondary);
}
[data-theme="light"] ::-webkit-scrollbar-thumb {
background: var(--border-color);
}
[data-theme="light"] ::-webkit-scrollbar-thumb:hover {
background: var(--text-tertiary);
}

[data-theme="light"] .footer,
[data-theme="light"] .footer-link,
[data-theme="light"] .footer-copyright {
color: var(--text-secondary);
}

[data-theme="light"] select,
[data-theme="light"] option,
[data-theme="light"] .axis-select {
color: var(--text-primary);
background: var(--bg-elevated);
}

[data-theme="light"] #prs-score-value,
[data-theme="light"] #prs-usage-value,
[data-theme="light"] #prs-rz-value,
[data-theme="light"] #prs-consistency-value,
[data-theme="light"] #prs-games-value {
color: var(--text-primary) !important;
}


[data-theme="light"] #floor-fragility-value,
[data-theme="light"] #floor-ghost-value {
color: var(--text-primary) !important;
}

[data-theme="light"] #floor-fragility-value span,
[data-theme="light"] #floor-ghost-value span {
color: var(--text-secondary) !important;
}

[data-theme="light"] #floor-fragility-bar,
[data-theme="light"] #floor-ghost-bar {
background: var(--bg-tertiary) !important;
}

[data-theme="light"] #modal-chart-floor .chart-content > div > div > div > div[style*="rgba(255, 255, 255, 0.1)"] {
background: var(--bg-tertiary) !important;
}

[data-theme="light"] #floor-fragility-td,
[data-theme="light"] #floor-fragility-var,
[data-theme="light"] #floor-fragility-vol,
[data-theme="light"] #floor-ghost-playable,
[data-theme="light"] #floor-ghost-boom,
[data-theme="light"] #floor-ghost-bust {
color: var(--text-secondary) !important;
}

[data-theme="light"] #floor-fragility-pill,
[data-theme="light"] #floor-ghost-pill {
background: rgba(0, 0, 0, 0.15) !important;
color: var(--text-primary) !important;
}

[data-theme="light"] #modal-chart-floor div[style*="rgba(255, 255, 255, 0.05)"] {
background: var(--bg-tertiary) !important;
}

[data-theme="light"] #modal-chart-floor div[style*="rgba(235, 235, 245"] {
background: var(--text-tertiary) !important;
}


[data-theme="light"] #modal-chart-reliability div[style*="#2c2c2e"] {
background: var(--bg-tertiary) !important;
}

[data-theme="light"] #modal-chart-reliability span[style*="color: var(--text-primary)"] {
color: var(--text-primary) !important;
}

[data-theme="light"] #prs-usage-bar,
[data-theme="light"] #prs-rz-bar,
[data-theme="light"] #prs-consistency-bar,
[data-theme="light"] #prs-games-bar {
background: var(--bg-tertiary);
}

[data-theme="light"] #modal-chart-reliability div[style*="#1c1c1e"] {
background: var(--bg-tertiary) !important;
}


[data-theme="light"] .schedule-row {
background: var(--bg-elevated) !important;
border: 1px solid var(--border-color) !important;
}
[data-theme="light"] .schedule-row:hover {
background: var(--bg-tertiary) !important;
}

[data-theme="light"] .week-number {
color: var(--text-primary) !important;
}
[data-theme="light"] .week-label {
color: var(--text-secondary) !important;
}

[data-theme="light"] .opponent-team {
color: var(--text-primary) !important;
}
[data-theme="light"] .vs-label {
color: var(--text-secondary) !important;
}

[data-theme="light"] .defense-rank,
[data-theme="light"] .defense-rank-value {
color: var(--text-primary) !important;
}
[data-theme="light"] .rank-label {
color: var(--text-secondary) !important;
}

[data-theme="light"] .mobile-rank {
color: var(--text-primary) !important;
}
[data-theme="light"] .mobile-rank-separator {
color: var(--text-tertiary) !important;
}


[data-theme="light"] #modal-chart-reliability div[style*="background: #2c2c2e"] {
background: var(--bg-elevated) !important;
border: 1px solid var(--border-color) !important;
}

[data-theme="light"] #modal-chart-reliability div[style*="background: #1c1c1e"] {
background: var(--bg-tertiary) !important;
}

[data-theme="light"] #prs-tooltip {
background: var(--bg-elevated) !important;
border: 1px solid var(--border-color) !important;
}

[data-theme="light"] *[style*="rgba(235, 235, 245, 0.7)"],
[data-theme="light"] *[style*="rgba(235, 235, 245, 0.5)"] {
color: var(--text-secondary) !important;
}

[data-theme="light"] *[style*="rgba(255, 255, 255, 0.1)"] {
background: var(--bg-tertiary) !important;
}

[data-theme="light"] *[style*="rgba(255, 255, 255, 0.05)"] {
background: var(--bg-tertiary) !important;
}

[data-theme="light"] span[style*="rgba(0, 0, 0, 0.3)"] {
background: rgba(0, 0, 0, 0.1) !important;
}

[data-theme="light"] #prs-usage-weight,
[data-theme="light"] #prs-rz-weight,
[data-theme="light"] #prs-consistency-weight,
[data-theme="light"] #prs-games-weight {
color: var(--text-secondary) !important;
}

[data-theme="light"] #floor-fragility-td,
[data-theme="light"] #floor-fragility-var,
[data-theme="light"] #floor-fragility-vol,
[data-theme="light"] #floor-ghost-playable,
[data-theme="light"] #floor-ghost-boom,
[data-theme="light"] #floor-ghost-bust {
color: var(--text-primary) !important;
}

[data-theme="light"] #modal-chart-floor div[style*="width: 6px"][style*="height: 6px"] {
background: var(--text-secondary) !important;
}

[data-theme="light"] .modal-stat-label {
color: var(--text-secondary) !important;
}


[data-theme="light"] #modal-chart-floor div[style*="color: rgba(235, 235, 245, 0.7)"] {
background: transparent !important;
}

[data-theme="light"] #modal-chart-floor div[style*="height: 32px"][style*="background: rgba(255, 255, 255, 0.1)"] {
background: var(--bg-tertiary) !important;
}


[data-theme="light"] .key-player-name {
color: var(--text-primary) !important;
}

[data-theme="light"] .key-player-stat {
color: var(--text-secondary) !important;
}

[data-theme="light"] #team-pie-chart + div,
[data-theme="light"] #team-secondary-chart + div {
color: var(--text-secondary) !important;
}

[data-theme="light"] .chartjs-legend li,
[data-theme="light"] .chartjs-legend span {
color: var(--text-secondary) !important;
}

/* Light mode fixes for homepage */
[data-theme="light"] .market-status-bar {
    background: var(--bg-elevated);
}

[data-theme="light"] .hero-story,
[data-theme="light"] .hero-story-main,
[data-theme="light"] .hero-story-small {
    background: var(--bg-elevated);
}

[data-theme="light"] .hero-story-small:hover {
    background: var(--bg-tertiary);
}

[data-theme="light"] .story-headline {
    background: none;
    -webkit-background-clip: unset;
    -webkit-text-fill-color: var(--text-primary);
    color: var(--text-primary);
}

[data-theme="light"] .story-headline-small {
    color: var(--text-primary);
}


/* ========================================
   HOMEPAGE STYLES
   ======================================== */

        /* Market Status Bar */
        .market-status-bar {
            background: linear-gradient(90deg, var(--bg-secondary) 0%, #1a1a1a 100%);
            border-bottom: 1px solid var(--border-color-light);
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .market-status-left {
            display: flex;
            align-items: center;
            gap: 16px;
            flex: 1;
        }
        
        .market-status {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }
        
        .status-indicator {
            width: 8px;
            height: 8px;
            background: var(--positive);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .status-text {
            font-size: 13px;
            font-weight: 600;
            color: var(--positive);
            letter-spacing: 0.5px;
        }
        
        .status-divider {
            width: 1px;
            height: 24px;
            background: var(--border-color-light);
            flex-shrink: 0;
        }
        
        .rotating-headline-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            min-height: 40px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .status-headline {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
            transition: opacity 0.5s ease;
        }
        
        .status-subheadline {
            font-size: 13px;
            color: var(--text-secondary);
            margin-top: 2px;
            transition: opacity 0.5s ease;
        }
        
        .market-time {
            font-size: 12px;
            color: var(--text-secondary);
            font-variant-numeric: tabular-nums;
            flex-shrink: 0;
        }
        
        /* Gradient Bar */
        .gradient-bar {
            height: 4px;
            background: linear-gradient(90deg, var(--positive) 0%, var(--accent-blue) 100%);
        }
        
        /* Market Ticker */
        .market-ticker {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 12px 0;
            overflow: hidden;
        }
        
        .ticker-track {
            display: flex;
            gap: 48px;
            animation: scroll 40s linear infinite;
        }
        
        @keyframes scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        
        .ticker-item {
            display: flex;
            align-items: center;
            gap: 12px;
            white-space: nowrap;
        }
        
        .ticker-player {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .ticker-position {
            font-size: 11px;
            color: var(--text-tertiary);
            font-weight: 600;
        }
        
        .ticker-value {
            font-size: 14px;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }
        
        .ticker-value.positive {
            color: var(--positive);
        }
        
        .ticker-value.negative {
            color: var(--negative);
        }
        
        /* Hero Split */
        .hero-split {
            display: grid;
            grid-template-columns: 1fr 1fr;
            border-bottom: 1px solid var(--border-color-light);
            align-items: stretch;
        }
        
        .hero-story-wrapper {
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color-light);
        }
        
        .hero-story {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-primary) 100%);
        }
        
        .hero-story-main {
            padding: 60px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            flex: 1;
            border-bottom: 1px solid var(--border-color-light);
            min-height: 400px;
        }
        
        .hero-story-small-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            flex: 0 0 auto;
        }
        
        .hero-story-small {
            padding: 32px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            border-right: 1px solid var(--border-color-light);
            min-height: 200px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .hero-story-small:hover {
            background: linear-gradient(135deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%);
        }
        
        .hero-story-small:last-child {
            border-right: none;
        }
        
        .story-headline-small {
            font-size: 24px;
            font-weight: 700;
            line-height: 1.2;
            margin-bottom: 12px;
            color: var(--text-primary);
        }
        
        .story-subhead-small {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.4;
            margin-bottom: 20px;
        }
        
        .data-value-small {
            font-size: 28px;
            font-weight: 700;
            color: var(--positive);
            font-variant-numeric: tabular-nums;
        }
        
        .story-label {
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 1.5px;
            color: var(--positive);
            margin-bottom: 16px;
            text-transform: uppercase;
        }
        
        .story-headline {
            font-size: 42px;
            font-weight: 700;
            line-height: 1.1;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #fff 0%, var(--text-secondary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .story-subhead {
            font-size: 18px;
            color: var(--text-secondary);
            line-height: 1.5;
            margin-bottom: 32px;
        }
        
        .story-data-points {
            display: flex;
            gap: 32px;
            margin-bottom: 32px;
        }
        
        .data-point {
            display: flex;
            flex-direction: column;
        }
        
        .data-value {
            font-size: 32px;
            font-weight: 700;
            color: var(--positive);
            font-variant-numeric: tabular-nums;
        }
        
        .data-value.negative {
            color: var(--negative);
        }
        
        .data-value-split {
            display: flex;
            align-items: baseline;
            gap: 4px;
            font-variant-numeric: tabular-nums;
        }
        
        .data-value-number {
            font-size: 32px;
            font-weight: 700;
            color: var(--text-primary);
        }
        
        .data-value-unit {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-tertiary);
        }
        
        .data-label {
            font-size: 12px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 4px;
        }
        
        .story-cta {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 14px 28px;
            background: transparent;
            border: 2px solid var(--positive);
            color: var(--positive);
            font-size: 14px;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            align-self: flex-start;
        }
        
        .story-cta:hover {
            background: var(--positive-bg);
            transform: translateX(4px);
        }
        
        /* Buy/Sell List */
        .hero-activity {
            background: var(--bg-primary);
            padding: 40px 32px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .activity-header {
            margin-bottom: 24px;
        }
        
        .activity-title {
            font-size: 24px;
            font-weight: 700;
            letter-spacing: -0.5px;
            margin-bottom: 8px;
        }
        
        .buy-sell-container {
            display: flex;
            flex-direction: column;
            gap: 32px;
        }
        
        .buy-section, .sell-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .section-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .section-label {
            font-size: 13px;
            font-weight: 700;
            letter-spacing: 0.5px;
        }
        
        .section-label.buy {
            color: var(--positive);
        }
        
        .section-label.sell {
            color: var(--negative);
        }
        
        .section-count {
            font-size: 12px;
            color: var(--text-tertiary);
        }
        
        .player-item {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .player-item:hover {
            border-color: var(--border-color-light);
            background: #0f0f0f;
            transform: translateX(4px);
        }
        
        .action-badge {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 0.5px;
            flex-shrink: 0;
        }
        
        .action-badge.buy {
            background: var(--positive-bg);
            color: var(--positive);
            border: 1px solid var(--positive);
        }
        
        .action-badge.sell {
            background: var(--negative-bg);
            color: var(--negative);
            border: 1px solid var(--negative);
        }
        
        .player-info {
            flex: 1;
            min-width: 0;
        }
        
        .player-name {
            font-size: 15px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        
        .player-reason {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.4;
        }
        
        .player-change {
            font-size: 16px;
            font-weight: 700;
            flex-shrink: 0;
            font-variant-numeric: tabular-nums;
        }
        
        .player-change.positive {
            color: var(--positive);
        }
        
        .player-change.negative {
            color: var(--negative);
        }
        
        /* Market Intelligence - Smaller */
        .market-intelligence {
            padding: 48px 24px;
            background: var(--bg-primary);
        }
        
        .section-header-main {
            max-width: 1400px;
            margin: 0 auto 32px;
        }
        
        .section-title-main {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 6px;
            letter-spacing: -0.5px;
        }
        
        .section-subtitle-main {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        /* Smaller Grid */
        .intelligence-grid {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 2fr;
            grid-template-rows: 1fr 1fr;
            gap: 16px;
            height: 480px;
        }
        
        .intelligence-tile {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, #1a1a1a 100%);
            border: 1px solid var(--border-color-light);
            border-radius: 10px;
            padding: 24px;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .intelligence-tile::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, var(--positive) 0%, var(--accent-blue) 100%);
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }
        
        .intelligence-tile:hover::before {
            transform: scaleX(1);
        }
        
        .intelligence-tile:hover {
            border-color: var(--bg-elevated);
            transform: translateY(-3px);
        }
        
        .tile-large {
            grid-row: 1 / 3;
            grid-column: 2;
        }
        
        .tile-header {
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        
        .tile-header-left {
            flex: 1;
        }
        
        .tile-label {
            font-size: 10px;
            color: var(--text-tertiary);
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-bottom: 6px;
        }
        
        .tile-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 6px;
        }
        
        .tile-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .rotation-nav {
            display: flex;
            gap: 6px;
            margin-top: 6px;
        }
        
        .nav-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color-light);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .nav-dot.active {
            background: var(--positive);
            border-color: var(--positive);
            width: 20px;
            border-radius: 3px;
        }
        
        .nav-dot:hover:not(.active) {
            background: var(--border-color-light);
        }
        
        .viz-container {
            flex: 1;
            position: relative;
            min-height: 300px;
        }
        
        .viz-slide {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.6s ease;
            display: flex;
            flex-direction: column;
        }
        
        .viz-slide.active {
            opacity: 1;
            transform: translateX(0);
        }
        
        .viz-slide.prev {
            transform: translateX(-100%);
        }
        
        .chart-wrapper {
            flex: 1;
            position: relative;
        }
        
        .tile-small .tile-title {
            font-size: 16px;
        }
        
        .tile-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .tile-stat-large {
            font-size: 48px;
            font-weight: 900;
            color: var(--positive);
            line-height: 1;
            margin-bottom: 6px;
            font-variant-numeric: tabular-nums;
        }
        
        .tile-stat-label {
            font-size: 13px;
            color: var(--text-tertiary);
            margin-bottom: 12px;
        }
        
        .tile-player-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .tile-player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: var(--bg-primary);
            border-radius: 5px;
            font-size: 12px;
        }
        
        .tile-player-name {
            color: var(--text-primary);
            font-weight: 600;
        }
        
        .tile-player-stat {
            color: var(--positive);
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }
        
        /* Footer */
        .footer {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 48px 24px 24px;
            margin-top: 60px;
        }
        
        .footer-content {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 2fr 1fr 1fr;
            gap: 48px;
        }
        
        .footer-section h3 {
            font-size: 14px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 16px;
            letter-spacing: 0.5px;
        }
        
        .footer-section p {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 16px;
        }
        
        .waitlist-form {
            display: flex;
            gap: 8px;
            margin-top: 16px;
        }
        
        .waitlist-input {
            flex: 1;
            padding: 10px 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 13px;
            transition: all 0.2s ease;
        }
        
        .waitlist-input:focus {
            outline: none;
            border-color: var(--accent-blue);
            background: var(--bg-elevated);
        }
        
        .waitlist-input::placeholder {
            color: var(--text-tertiary);
        }
        
        .waitlist-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--positive), var(--accent-blue));
            border: none;
            border-radius: 8px;
            color: #fff;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            box-shadow: 0 0 15px rgba(48, 209, 88, 0.3), 0 0 30px rgba(10, 132, 255, 0.15);
        }
        
        .waitlist-btn:hover {
            box-shadow: 0 0 20px rgba(48, 209, 88, 0.5), 0 0 40px rgba(10, 132, 255, 0.25);
            transform: translateY(-1px);
        }
        
        .footer-links {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .footer-link {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 13px;
            transition: color 0.2s ease;
        }
        
        .footer-link:hover {
            color: var(--text-primary);
        }
        
        .footer-bottom {
            max-width: 1400px;
            margin: 32px auto 0;
            padding-top: 24px;
            border-top: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 12px;
            color: var(--text-tertiary);
        }
        
        .footer-logo {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 16px;
            font-weight: 700;
            color: var(--text-primary);
        }
        
        .footer-logo-icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, var(--positive), var(--accent-blue));
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 900;
            color: white;
            box-shadow: 0 0 15px rgba(48, 209, 88, 0.3), 0 0 30px rgba(10, 132, 255, 0.15);
        }
        
        .footer-logo-icon::before {
            content: '>';
            transform: scaleX(1.3);
        }
        
        .footer-copyright {
            flex: 1;
            text-align: center;
        }
        
        @media (max-width: 1024px) {
            .hero-split {
                grid-template-columns: 1fr;
            }
            
            .hero-story,
            .hero-story-main,
            .hero-story-small {
                border-right: none;
                border-bottom: 1px solid var(--border-color-light);
            }
            
            .hero-story-wrapper {
                border-right: none;
            }
            
            .hero-story-small-grid {
                grid-template-columns: 1fr;
            }
            
            .hero-story-small:last-child {
                border-bottom: none;
            }
            
            .intelligence-grid {
                grid-template-columns: 1fr;
                grid-template-rows: auto;
                height: auto;
            }
            
            .tile-large {
                grid-row: auto;
                grid-column: auto;
            }
            
            .rotating-headline-container {
                display: none;
            }
            
            .status-divider {
                display: none;
            }
            
            .footer-content {
                grid-template-columns: 1fr;
                gap: 32px;
            }
        }
        
        @media (max-width: 768px) {
            /* Prevent horizontal overflow - CRITICAL */
            html, body {
                overflow-x: hidden !important;
                max-width: 100vw !important;
                position: relative;
            }
            
            .app-container {
                overflow-x: hidden !important;
                width: 100vw;
            }
            
            .page {
                overflow-x: hidden !important;
                padding: 0 !important;
            }
            
            #home.page {
                overflow-x: hidden !important;
                max-width: 100vw !important;
                padding: 0 !important;
                margin: 0 !important;
            }
            
            .main-content {
                padding: 0 !important;
                margin: 0 !important;
                max-width: 100vw !important;
            }
            
            /* Hero section mobile adjustments */
            .hero-split {
                width: 100vw !important;
                max-width: 100vw !important;
                margin: 0 !important;
                padding: 0 !important;
                grid-template-columns: 1fr !important;
            }
            
            .hero-story-wrapper {
                width: 100vw !important;
                max-width: 100vw !important;
                border-right: none !important;
            }
            
            .hero-story-main {
                padding: 32px 16px !important;
                width: 100vw !important;
                max-width: 100vw !important;
                box-sizing: border-box !important;
                min-height: 300px !important;
            }
            
            .hero-story-small-grid {
                grid-template-columns: 1fr !important;
            }
            
            .hero-story-small {
                padding: 20px 16px !important;
                min-height: 140px !important;
                width: 100vw !important;
                box-sizing: border-box !important;
                border-right: none !important;
            }
            
            .hero-story-small:last-child {
                border-bottom: none !important;
            }
            
            .story-headline {
                font-size: 24px !important;
                word-wrap: break-word;
                overflow-wrap: break-word;
                line-height: 1.2;
                max-width: 100%;
            }
            
            .story-headline-small {
                font-size: 18px !important;
                word-wrap: break-word;
                line-height: 1.3;
                max-width: 100%;
            }
            
            .story-subhead {
                font-size: 14px !important;
                word-wrap: break-word;
                max-width: 100%;
            }
            
            .story-subhead-small {
                font-size: 12px !important;
                word-wrap: break-word;
                max-width: 100%;
            }
            
            .story-data-points {
                flex-direction: column;
                gap: 16px !important;
                margin-bottom: 20px !important;
                width: 100%;
                max-width: 100%;
            }
            
            .data-point {
                width: 100%;
                max-width: 100%;
            }
            
            .data-value-number {
                font-size: 24px !important;
            }
            
            .data-value-small {
                font-size: 20px !important;
            }
            
            .story-cta {
                padding: 12px 20px !important;
                font-size: 13px !important;
            }
            
            /* Market status bar mobile */
            .market-status-bar {
                padding: 12px 16px !important;
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
                width: 100vw !important;
                max-width: 100vw !important;
                box-sizing: border-box !important;
                margin: 0 !important;
            }
            
            /* Hero activity section mobile */
            .hero-activity {
                padding: 20px 16px !important;
                width: 100vw !important;
                max-width: 100vw !important;
                box-sizing: border-box !important;
                margin: 0 !important;
            }
            
            .activity-title {
                font-size: 18px !important;
            }
            
            .buy-sell-container {
                gap: 20px !important;
                width: 100%;
                padding: 0 !important;
                flex-direction: column;
            }
            
            .buy-column, .sell-column {
                width: 100% !important;
                max-width: 100% !important;
                padding: 0 !important;
            }
            
            .player-item {
                padding: 12px !important;
                margin: 0 !important;
                max-width: 100%;
            }
            
            /* Ticker mobile adjustments */
            .ticker-section {
                margin-left: 0 !important;
                margin-right: 0 !important;
                border-radius: 0 !important;
                width: 100vw !important;
                max-width: 100vw !important;
            }
            
            .ticker-container {
                width: 100vw !important;
                max-width: 100vw !important;
                overflow: hidden !important;
            }
            
            .ticker-stat {
                padding: 0 12px !important;
                gap: 8px !important;
            }
        }

/* ========================================
   START/SIT COMPARISON TOOL STYLES
   ======================================== */

.comparison-tool-container {
    max-width: 1400px; /* Increased from 900px */
    width: 95%;
    margin: 0 auto;
    padding: 0 16px;
    margin-top: 32px; /* Added padding between header and tool */
    overflow: visible;
}

@media (max-width: 768px) {
    .comparison-tool-container {
        width: 100%;
        padding: 0 12px;
    }
}

.comparison-tool-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    clip-path: polygon(12px 0, 100% 0, 100% calc(100% - 12px), calc(100% - 12px) 100%, 0 100%, 0 12px);
    padding: 24px;
    margin-bottom: 24px;
    transition: all 0.3s ease;
    overflow: visible;
}

.comparison-tool-card:hover {
    border-color: var(--accent-blue);
}

.comparison-tool-header {
    margin-bottom: 24px;
}

.comparison-tool-title {
    font-size: 20px;
    font-weight: 700;
    margin-bottom: 8px;
    color: var(--text-primary);
}

.comparison-tool-description {
    font-size: 14px;
    color: var(--text-secondary);
}

.comparison-player-selection {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
    margin-bottom: 24px;
    overflow: visible;
}

.comparison-player-search {
    position: relative;
    z-index: 10;
}

.comparison-player-search label {
    display: block;
    font-size: 12px;
    font-weight: 600;
    color: var(--text-secondary);
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.search-input-wrapper {
    position: relative;
    z-index: 100;
}

.comparison-player-search input {
    width: 100%;
    padding: 12px 16px;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-color-light);
    border-radius: 8px;
    color: var(--text-primary);
    font-size: 16px;
    font-weight: 600;
    transition: all 0.2s ease;
}

.comparison-player-search input:focus {
    outline: none;
    border-color: var(--accent-blue);
}

.comparison-player-search input:hover {
    border-color: var(--accent-blue);
}

.comparison-player-search input::placeholder {
    color: var(--text-tertiary);
    font-weight: 400;
}

.search-dropdown {
    position: fixed;
    background: var(--bg-elevated);
    border: 1px solid var(--border-color-light);
    border-radius: 8px;
    margin-top: 4px;
    max-height: 300px;
    overflow-y: auto;
    z-index: 9999;
    display: none;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
    min-width: 300px;
}

.search-dropdown.show {
    display: block;
}

.search-dropdown-item {
    padding: 12px 16px;
    cursor: pointer;
    transition: all 0.2s ease;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    align-items: center;
    gap: 12px;
}

.search-dropdown-item:last-child {
    border-bottom: none;
}

.search-dropdown-item:hover {
    background: var(--bg-tertiary);
}

.search-dropdown-item-content {
    flex: 1;
}

.search-dropdown-item-name {
    font-size: 14px;
    font-weight: 600;
    color: var(--text-primary);
}

.search-dropdown-item-info {
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 2px;
}

.comparison-team-logo {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 11px;
    color: white;
    flex-shrink: 0;
}

.comparison-player-name-container {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
}

.comparison-player-name-text {
    text-align: center;
}

.comparison-player-logo {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 14px;
    color: white;
    flex-shrink: 0;
}

/* Scrollbar styling for dropdown */
.search-dropdown::-webkit-scrollbar {
    width: 8px;
}

.search-dropdown::-webkit-scrollbar-track {
    background: var(--bg-secondary);
    border-radius: 8px;
}

.search-dropdown::-webkit-scrollbar-thumb {
    background: var(--bg-tertiary);
    border-radius: 8px;
}

.search-dropdown::-webkit-scrollbar-thumb:hover {
    background: var(--border-color-light);
}

.comparison-grid {
    margin-bottom: 24px;
    display: flex;
    flex-direction: column;
}

.comparison-player-names {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
    margin-bottom: 16px;
    order: 1;
}

.comparison-mini-stats {
    order: 3;
}

#core-metrics {
    order: 4;
}

#expanded-metrics {
    order: 5;
}

.comparison-expand-btn {
    order: 6;
}

.comparison-recommendation-banner {
    order: 2; /* Top on mobile (after player names) */
}

/* Desktop: Move recommendation to bottom */
@media (min-width: 769px) {
    .comparison-recommendation-banner {
        order: 99; /* Bottom on desktop */
    }
}

.comparison-player-names {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
    margin-bottom: 16px;
}

.comparison-player-name {
    text-align: center;
    font-size: 20px;
    font-weight: 700;
    padding: 16px;
    background: var(--bg-tertiary);
    border-radius: 8px;
    border: 2px solid transparent;
    transition: all 0.2s ease;
}

.comparison-player-name.recommended {
    border-color: var(--positive);
    background: var(--positive-bg);
    color: var(--positive);
}

.comparison-metric-row {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    gap: 16px;
    align-items: center;
    padding: 16px;
    margin-bottom: 8px;
    background: var(--bg-tertiary);
    border-radius: 8px;
}

.comparison-metric-label {
    grid-column: 2;
    font-size: 13px;
    color: var(--text-secondary);
    text-align: center;
    font-weight: 600;
    min-width: 100px;
}

.comparison-metric-value {
    font-size: 18px;
    font-weight: 700;
    text-align: center;
    padding: 10px 16px;
    border-radius: 6px;
    transition: all 0.2s ease;
}

.comparison-metric-value.left {
    grid-column: 1;
}

.comparison-metric-value.right {
    grid-column: 3;
}

.comparison-metric-value.winner {
    background: var(--positive-bg);
    color: var(--positive);
}

.comparison-metric-value.loser {
    opacity: 0.6;
}

.comparison-expand-btn {
    width: 100%;
    padding: 12px 24px;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-color-light);
    border-radius: 8px;
    color: var(--text-secondary);
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    margin-top: 8px;
}

.comparison-expand-btn:hover {
    background: var(--bg-elevated);
    border-color: var(--accent-blue);
    color: var(--text-primary);
}

.comparison-recommendation-banner {
    background: var(--positive-bg);
    border: 2px solid var(--positive);
    border-radius: 8px;
    padding: 20px 24px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
    margin-bottom: 24px;
    margin-top: 16px;
}

.comparison-recommendation-content {
    flex: 1;
}

.comparison-recommendation-label {
    font-size: 12px;
    font-weight: 600;
    color: var(--positive);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 4px;
    opacity: 0.8;
}

.comparison-recommendation-text {
    font-size: 18px;
    font-weight: 700;
    color: var(--positive);
}

.comparison-recommendation-reason {
    font-size: 14px;
    color: var(--text-secondary);
    margin-top: 4px;
}

.comparison-recommendation-confidence {
    text-align: right;
}

.comparison-confidence-score {
    font-size: 32px;
    font-weight: 700;
    color: var(--positive);
    line-height: 1;
}

.comparison-confidence-label {
    font-size: 11px;
    color: var(--positive);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-top: 4px;
    opacity: 0.8;
}

.comparison-info-note {
    background: var(--bg-tertiary);
    border: 1px solid var(--border-color-light);
    border-radius: 8px;
    padding: 16px;
    font-size: 13px;
    color: var(--text-secondary);
    text-align: center;
}

/* Mini Stat Bars */
.comparison-mini-stats {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 16px;
    margin-bottom: 24px;
}

.comparison-mini-stat {
    background: var(--bg-tertiary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 16px;
}

.comparison-mini-stat-label {
    font-size: 11px;
    font-weight: 600;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 12px;
    text-align: center;
}

.comparison-mini-bars {
    display: flex;
    gap: 8px;
    align-items: flex-end;
    justify-content: center;
}

.comparison-mini-bar-container {
    flex: 1;
    text-align: center;
}

.comparison-mini-bar-value {
    font-size: 12px;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 4px;
}

.comparison-mini-bar {
    background: var(--bg-elevated);
    border-radius: 4px;
    overflow: hidden;
    height: 90px;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
}

.comparison-mini-bar-fill {
    width: 100%;
    transition: height 0.5s ease;
    min-height: 4px;
}

.comparison-mini-bar-fill.winner {
    opacity: 1;
}

.comparison-mini-player-label {
    font-size: 10px;
    color: var(--text-tertiary);
    margin-top: 4px;
}

@media (max-width: 1024px) {
    .comparison-mini-stats {
        grid-template-columns: repeat(2, 1fr);
    }
}

@media (max-width: 768px) {
    .comparison-mini-stats {
        grid-template-columns: 1fr;
        gap: 12px;
    }
    
    .comparison-mini-bar {
        height: 70px;
    }
}

/* Mobile Responsive */
@media (max-width: 768px) {
    .comparison-player-selection {
        grid-template-columns: 1fr;
    }
    
    .comparison-metric-row {
        grid-template-columns: 1fr;
        gap: 8px;
        padding: 12px;
    }
    
    .comparison-metric-value.left,
    .comparison-metric-value.right {
        grid-column: 1;
    }
    
    .comparison-metric-label {
        grid-column: 1;
        margin: 4px 0;
        font-size: 11px;
    }
    
    .comparison-recommendation-banner {
        flex-direction: column;
        text-align: center;
    }
    
    .comparison-recommendation-confidence {
        text-align: center;
    }
}

</style><script src="/_vercel/insights/script.js"></script><script src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script><script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script></head><body><button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle theme"><svg class="sun-icon" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" clip-rule="evenodd"></path></svg><svg class="moon-icon" fill="currentColor" viewBox="0 0 20 20"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path></svg></button><div id="initial-loading-screen"><div class="loading-container"><div class="loading-logo"></div><div class="loading-title">FFSE</div><div class="loading-subtitle">Fantasy Football Stock Exchange</div><div class="loading-progress-container"><div class="loading-progress-bar"><div class="loading-progress-fill" id="loading-progress-fill"></div></div><div class="loading-progress-text"><span class="loading-status" id="loading-status">Initializing...</span><span class="loading-percentage" id="loading-percentage">0%</span></div></div></div></div><div class="app-container"><header class="header"><div class="header-content"><div class="logo" onclick="navigateToPage('home')" style="cursor: pointer;"><div class="logo-icon"></div><span>FFSE</span></div><nav class="nav-tabs"><button class="nav-tab active" data-page="home">Home</button><div class="nav-dropdown" id="decisionsDropdown"><button class="nav-dropdown-trigger">Decisions</button><div class="dropdown-menu"><button class="dropdown-item" data-page="start-sit">Start/Sit</button><button class="dropdown-item" data-page="waivers">Waivers</button><button class="dropdown-item" data-page="trades">Trades</button></div></div><div class="nav-dropdown" id="positionsDropdown"><button class="nav-dropdown-trigger">Positions</button><div class="dropdown-menu"><button class="dropdown-item" data-page="wide-receivers">WR</button><button class="dropdown-item" data-page="running-backs">RB</button><button class="dropdown-item" data-page="tight-ends">TE</button></div></div><div class="nav-dropdown" id="analyticsDropdown"><button class="nav-dropdown-trigger">Advanced Analytics</button><div class="dropdown-menu"><button class="dropdown-item" data-page="advanced-analytics">Scatter Plots</button><button class="dropdown-item" data-page="analytics-dashboard">Heatmap</button><button class="dropdown-item" data-page="teams">Team Outlook</button><button class="dropdown-item" data-page="top-movers">Leaderboards</button></div></div><button class="nav-tab" id="admin-tab" data-page="admin-panel" style="display: none;">Admin</button></nav><div class="header-right-section" style="display: flex; align-items: center; gap: 16px;"><div class="header-scoring-dropdown" id="header-scoring-dropdown"><button class="header-scoring-button" onclick="toggleHeaderScoringDropdown()"><span id="header-scoring-label">PPR</span><span class="arrow">â–¼</span></button><div class="header-scoring-menu"><button class="active" onclick="setHeaderScoringFormat('ppr')">PPR</button><button onclick="setHeaderScoringFormat('half')">Half-PPR</button><button onclick="setHeaderScoringFormat('std')">Standard</button></div></div><button class="upload-btn" onclick="scrollToWaitlist()">Join Waitlist</button><button class="mobile-menu-button" onclick="toggleMobileMenu()"><div class="hamburger-line"></div><div class="hamburger-line"></div><div class="hamburger-line"></div></button></div></div></header><div class="mobile-menu-overlay" id="mobile-menu-overlay" onclick="closeMobileMenu()"></div><div class="mobile-menu" id="mobile-menu"><div class="mobile-menu-header"><div class="mobile-menu-title">Menu</div><button class="mobile-menu-close" onclick="closeMobileMenu()">Ã—</button></div><div class="mobile-menu-items"><button class="mobile-menu-item active" data-page="home" onclick="navigateFromMobileMenu('home')">
Home
</button><div style="padding: 12px 20px; font-size: 11px; font-weight: 700; color: var(--text-tertiary); text-transform: uppercase; letter-spacing: 0.5px;">Decisions</div><button class="mobile-menu-item" data-page="start-sit" onclick="navigateFromMobileMenu('start-sit')">
Start/Sit
</button><button class="mobile-menu-item" data-page="waivers" onclick="navigateFromMobileMenu('waivers')">
Waivers
</button><button class="mobile-menu-item" data-page="trades" onclick="navigateFromMobileMenu('trades')">
Trades
</button><div style="padding: 12px 20px; font-size: 11px; font-weight: 700; color: var(--text-tertiary); text-transform: uppercase; letter-spacing: 0.5px;">Positions</div><button class="mobile-menu-item" data-page="wide-receivers" onclick="navigateFromMobileMenu('wide-receivers')">
Wide Receivers
</button><button class="mobile-menu-item" data-page="running-backs" onclick="navigateFromMobileMenu('running-backs')">
Running Backs
</button><button class="mobile-menu-item" data-page="tight-ends" onclick="navigateFromMobileMenu('tight-ends')">
Tight Ends
</button><div style="padding: 12px 20px; font-size: 11px; font-weight: 700; color: var(--text-tertiary); text-transform: uppercase; letter-spacing: 0.5px;">Advanced Analytics</div><button class="mobile-menu-item" data-page="advanced-analytics" onclick="navigateFromMobileMenu('advanced-analytics')">
Scatter Plots
</button><button class="mobile-menu-item" data-page="analytics-dashboard" onclick="navigateFromMobileMenu('analytics-dashboard')">
Heatmap
</button><button class="mobile-menu-item" data-page="teams" onclick="navigateFromMobileMenu('teams')">
Team Outlook
</button><button class="mobile-menu-item" data-page="top-movers" onclick="navigateFromMobileMenu('top-movers')">
Leaderboards
</button><button class="mobile-menu-item" id="mobile-admin-tab" data-page="admin-panel" onclick="navigateFromMobileMenu('admin-panel')" style="display: none;">
Admin Panel
</button></div><div class="mobile-menu-divider"></div><button class="mobile-menu-theme-toggle" onclick="toggleTheme(); event.stopPropagation();"><svg class="sun-icon" width="20" height="20" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" clip-rule="evenodd"></path></svg><svg class="moon-icon" width="20" height="20" fill="currentColor" viewBox="0 0 20 20"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path></svg><span class="theme-label"><span class="light-label">Light Mode</span><span class="dark-label">Dark Mode</span></span></button><button class="mobile-menu-waitlist" onclick="closeMobileMenu(); scrollToWaitlist();">
Join Waitlist
</button></div><div class="scoring-toggle-container"><div class="scoring-toggle"><button class="scoring-option active" data-format="ppr" onclick="setScoringFormat('ppr')">PPR</button><button class="scoring-option" data-format="half" onclick="setScoringFormat('half')">Half-PPR</button><button class="scoring-option" data-format="std" onclick="setScoringFormat('std')">Standard</button></div></div><main class="main-content"><div id="home" class="page active">
<!-- Market Status Bar -->
    <div class="market-status-bar">
        <div class="market-status-left">
            <div class="market-status">
                <div class="status-indicator"></div>
                <span class="status-text">MARKETS OPEN</span>
            </div>
            <div class="status-divider"></div>
            <div class="rotating-headline-container">
                <div class="status-headline" id="statusHeadline">Find value before your league does.</div>
                <div class="status-subheadline" id="statusSubheadline">See the trends before your league mates do.</div>
            </div>
        </div>
        <div class="market-time">WEEK 10</div>
    </div>
    
    <!-- Gradient Bar -->
    <div class="gradient-bar"></div>
    
    <!-- Market Ticker -->
    <div class="ticker-section" id="home-ticker-section" style="position: relative; top: 0; margin-top: 0; margin-bottom: 0; border-radius: 0;">
        <div class="ticker-content" id="home-ticker-content" style="position: relative;">
            
            <div class="ticker-container">
                <div class="ticker-track" id="home-ticker-track" style="animation-duration: 360s !important;"></div>
            </div>
        </div>
    </div>
    
    <!-- Hero Split -->
    <div class="hero-split">
        <div class="hero-story-wrapper">
            <!-- Main Story Container (Large) -->
            <div class="hero-story hero-story-main">
                <div class="story-label">TRENDING NOW</div>
                <h1 class="story-headline">Elite Usage Breakouts Emerging Across Positions</h1>
                <p class="story-subhead">Multiple players showing significant jumps in opportunity share and efficiency metrics that market hasn't fully priced in.</p>
                
                <div class="story-data-points">
                    <div class="data-point">
                        <div class="data-value">+237%</div>
                        <div class="data-label">Top Surge</div>
                    </div>
                    <div class="data-point">
                        <div class="data-value">89%</div>
                        <div class="data-label">Peak Snap</div>
                    </div>
                    <div class="data-point">
                        <div class="data-value">6</div>
                        <div class="data-label">Elite Movers</div>
                    </div>
                </div>
                
                <button class="story-cta">Deep Dive Analysis â†’</button>
            </div>
            
            <!-- Two Smaller Containers Below -->
            <div class="hero-story-small-grid">
                <div class="hero-story hero-story-small">
                    <div class="story-label">WEEK 10 INSIGHTS</div>
                    <h3 class="story-headline-small">Key Matchups</h3>
                    <p class="story-subhead-small">High-volume opportunities this week</p>
                    <div class="data-point">
                        <div class="data-value-small">12</div>
                        <div class="data-label">Target Hogs</div>
                    </div>
                </div>
                
                <div class="hero-story hero-story-small">
                    <div class="story-label">RED ZONE EDGE</div>
                    <h3 class="story-headline-small">Goal Line Value</h3>
                    <p class="story-subhead-small">Underpriced TD upside plays</p>
                    <div class="data-point">
                        <div class="data-value-small">8</div>
                        <div class="data-label">High RZ Usage</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="hero-activity">
            <div class="activity-header">
                <h2 class="activity-title">Market Opportunities</h2>
            </div>
            
            <div class="buy-sell-container" id="home-market-opportunities">
                <div class="buy-section">
                    <div class="section-header">
                        <span class="section-label buy">BUY LOW</span>
                        <span class="section-count">(5 players)</span>
                    </div>
                    
                    <div class="player-item">
                        <div class="action-badge buy">BUY</div>
                        <div class="player-info">
                            <div class="player-name">Mike Evans</div>
                            <div class="player-reason">Solid usage (0% share) but underperforming expected</div>
                        </div>
                        <div class="player-change positive">+55%</div>
                    </div>
                    
                    <div class="player-item">
                        <div class="action-badge buy">BUY</div>
                        <div class="player-info">
                            <div class="player-name">Nico Collins</div>
                            <div class="player-reason">Consistent 10+ point weeks - emerging reliable option</div>
                        </div>
                        <div class="player-change positive">+29%</div>
                    </div>
                    
                    <div class="player-item">
                        <div class="action-badge buy">BUY</div>
                        <div class="player-info">
                            <div class="player-name">Derrick Henry</div>
                            <div class="player-reason">Solid usage (0% share) but underperforming expected</div>
                        </div>
                        <div class="player-change positive">+27%</div>
                    </div>
                </div>
                
                <div class="sell-section">
                    <div class="section-header">
                        <span class="section-label sell">SELL HIGH</span>
                        <span class="section-count">(5 players)</span>
                    </div>
                    
                    <div class="player-item">
                        <div class="action-badge sell">SELL</div>
                        <div class="player-info">
                            <div class="player-name">Malik Nabers</div>
                            <div class="player-reason">Limited role + inconsistent - sell while value is up</div>
                        </div>
                        <div class="player-change negative">-24%</div>
                    </div>
                    
                    <div class="player-item">
                        <div class="action-badge sell">SELL</div>
                        <div class="player-info">
                            <div class="player-name">Rico Dowdle</div>
                            <div class="player-reason">Extreme variance recently - cash in while hot</div>
                        </div>
                        <div class="player-change negative">-15%</div>
                    </div>
                    
                    <div class="player-item">
                        <div class="action-badge sell">SELL</div>
                        <div class="player-info">
                            <div class="player-name">Cam Skattebo</div>
                            <div class="player-reason">Low-volume boom/bust profile - volatile week-to-week</div>
                        </div>
                        <div class="player-change negative">-13%</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    
    <!-- Footer -->
</div>

<!-- Start/Sit Page -->
<div id="start-sit" class="page">
<div class="page-header">
<h1 class="page-title">Start/Sit Decisions</h1>
<p class="page-subtitle">Confidence-based lineup decisions using consistency metrics, matchup analysis, and floor/ceiling projections</p>
</div>
<!-- Player Comparison Tool -->
<div class="comparison-tool-container">
  <div class="comparison-tool-card">
    <div class="comparison-tool-header">
      <h2 class="comparison-tool-title">Player Comparison Tool</h2>
      <p class="comparison-tool-description">Select two players to see how they stack up across key metrics</p>
    </div>
    
    <!-- Player Selection Search Bars -->
    <div class="comparison-player-selection">
      <div class="comparison-player-search">
        <label>Player 1</label>
        <div class="search-input-wrapper">
          <input type="text" id="player1-search" placeholder="Search for a player..." autocomplete="off" oninput="filterPlayers(1)" onfocus="showDropdown(1)" />
          <div class="search-dropdown" id="player1-dropdown"></div>
        </div>
      </div>
      <div class="comparison-player-search">
        <label>Player 2</label>
        <div class="search-input-wrapper">
          <input type="text" id="player2-search" placeholder="Search for a player..." autocomplete="off" oninput="filterPlayers(2)" onfocus="showDropdown(2)" />
          <div class="search-dropdown" id="player2-dropdown"></div>
        </div>
      </div>
    </div>
    
    <!-- Comparison Grid (Initially Hidden) -->
    <div id="comparison-results" style="display: none;">
      <div class="comparison-grid">
        <div class="comparison-player-names">
          <div class="comparison-player-name" id="player1-name"></div>
          <div class="comparison-player-name" id="player2-name"></div>
        </div>
        
        <!-- Mini Stat Bars -->
        <div class="comparison-mini-stats" id="mini-stats">
          <!-- Will be populated dynamically -->
        </div>
        
        <!-- Core Metrics (Always Visible) -->
        <div id="core-metrics">
          <!-- Metrics will be inserted here dynamically -->
        </div>
        
        <!-- Expandable Metrics (Hidden by default) -->
        <div id="expanded-metrics" style="display: none;">
          <!-- Additional metrics will be inserted here dynamically -->
        </div>
        
        <!-- Show More/Less Button -->
        <button class="comparison-expand-btn" id="expand-btn" onclick="toggleExpandedMetrics()">
          Show More Stats â–¼
        </button>
        
        <!-- Recommendation Banner (Bottom on desktop, top on mobile via CSS order) -->
        <div class="comparison-recommendation-banner" id="recommendation-banner">
          <div class="comparison-recommendation-content">
            <div class="comparison-recommendation-label">Recommendation</div>
            <div class="comparison-recommendation-text" id="recommendation-text">Start Player 1</div>
            <div class="comparison-recommendation-reason" id="recommendation-reason">Loading analysis...</div>
          </div>
          <div class="comparison-recommendation-confidence">
            <div class="comparison-confidence-score" id="confidence-score">--</div>
            <div class="comparison-confidence-label">Confidence</div>
          </div>
        </div>
      </div>
      
      <div class="comparison-info-note">
        Metrics reflect current season performance in <span id="scoring-format-display">PPR</span> scoring
      </div>
    </div>
  </div>
</div>
</div>

<!-- Waivers Page -->
<div id="waivers" class="page">
<div class="page-header">
<h1 class="page-title">Waiver Wire</h1>
<p class="page-subtitle">Identify breakout candidates before your league using snap share surges, target trends, and opportunity analysis</p>
</div>
<div style="background: var(--bg-elevated); border: 1px solid var(--border-color); border-radius: 12px; padding: 48px; text-align: center; margin: 24px 0;">
<h2 style="font-size: 24px; font-weight: 700; margin-bottom: 12px;">Waiver Wire Tools Coming Soon</h2>
<p style="font-size: 16px; color: var(--text-secondary); line-height: 1.6; max-width: 600px; margin: 0 auto;">
This page will aggregate all tools and visualizations to help you dominate the waiver wire, including:
</p>
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-top: 32px; text-align: left;">
<div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px;">
<h3 style="font-size: 16px; font-weight: 700; margin-bottom: 8px;">Breakout Alerts</h3>
<p style="font-size: 14px; color: var(--text-secondary);">Automated detection of snap % and target share surges</p>
</div>
<div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px;">
<h3 style="font-size: 16px; font-weight: 700; margin-bottom: 8px;">Waiver Priority Ranking</h3>
<p style="font-size: 14px; color: var(--text-secondary);">Upside-weighted rankings by opportunity and schedule</p>
</div>
<div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px;">
<h3 style="font-size: 16px; font-weight: 700; margin-bottom: 8px;">Roster Comparison</h3>
<p style="font-size: 14px; color: var(--text-secondary);">Compare waiver targets vs your bench players</p>
</div>
<div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px;">
<h3 style="font-size: 16px; font-weight: 700; margin-bottom: 8px;">Opportunity Share Trends</h3>
<p style="font-size: 14px; color: var(--text-secondary);">Track evolving roles through snap % and targets</p>
</div>
</div>
</div>
</div>

<!-- Trades Page -->
<div id="trades" class="page">
<div class="page-header">
<h1 class="page-title">Trade Analyzer</h1>
<p class="page-subtitle">Buy low on positive trends, sell high on negative regression signals using momentum scores and value divergence</p>
</div>
<div style="background: var(--bg-elevated); border: 1px solid var(--border-color); border-radius: 12px; padding: 48px; text-align: center; margin: 24px 0;">
<h2 style="font-size: 24px; font-weight: 700; margin-bottom: 12px;">Trade Tools Coming Soon</h2>
<p style="font-size: 16px; color: var(--text-secondary); line-height: 1.6; max-width: 600px; margin: 0 auto;">
This page will aggregate all tools and visualizations to help you make winning trades, including:
</p>
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-top: 32px; text-align: left;">
<div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px;">
<h3 style="font-size: 16px; font-weight: 700; margin-bottom: 8px;">Buy Low / Sell High Signals</h3>
<p style="font-size: 14px; color: var(--text-secondary);">Momentum-based trading signals and trends</p>
</div>
<div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px;">
<h3 style="font-size: 16px; font-weight: 700; margin-bottom: 8px;">Trade Value Charts</h3>
<p style="font-size: 14px; color: var(--text-secondary);">Dynamic values based on recent performance</p>
</div>
<div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px;">
<h3 style="font-size: 16px; font-weight: 700; margin-bottom: 8px;">Performance Divergence</h3>
<p style="font-size: 14px; color: var(--text-secondary);">Identify TD luck and regression candidates</p>
</div>
<div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px;">
<h3 style="font-size: 16px; font-weight: 700; margin-bottom: 8px;">ROS Projections</h3>
<p style="font-size: 14px; color: var(--text-secondary);">Rest-of-season outlook with playoff schedule</p>
</div>
</div>
</div>
</div>

<div id="analytics-dashboard" class="page">
<!-- Market Ticker with Rotating Insights -->
<div class="heatmap-ticker-bar">
    <div class="heatmap-ticker-status">
        <div class="heatmap-status-dot"></div>
        <span class="heatmap-status-text">HEATMAP</span>
    </div>
    <div class="heatmap-ticker-divider"></div>
    <div class="heatmap-rotating-insight-container">
        <div class="heatmap-insight-value" id="heatmap-rotating-value">Loading...</div>
        <div class="heatmap-insight-content">
            <div class="heatmap-insight-label" id="heatmap-rotating-label">Analyzing data...</div>
            <div class="heatmap-insight-text" id="heatmap-rotating-text">Processing player statistics to find actionable insights.</div>
        </div>
    </div>
    <div class="heatmap-ticker-week">WEEK 10</div>
</div>

<!-- Gradient Line -->
<div class="heatmap-gradient-line"></div>

<!-- Horizontal Filters Bar - All Dropdowns on One Line -->
<div class="heatmap-filters-bar">
    <div class="heatmap-filter-group-inline">
        <span class="heatmap-filter-label">POSITION:</span>
        <select class="heatmap-filter-select" id="heatmap-position-select-new" onchange="setHeatmapPosition(this.value)">
            <option value="WR">WR</option>
            <option value="RB">RB</option>
            <option value="TE">TE</option>
        </select>
    </div>
    
    <div class="heatmap-filter-separator"></div>
    
    <div class="heatmap-filter-group-inline">
        <span class="heatmap-filter-label">METRIC:</span>
        <select class="heatmap-filter-select" id="heatmap-metric-select-new" onchange="setHeatmapMetric(this.value)">
            <option value="actual-vs-expected">Actual vs Expected</option>
            <option value="target-share">Target Share</option>
            <option value="rz-opp-share">RZ Opportunities</option>
        </select>
    </div>
    
    <div class="heatmap-filter-separator"></div>
    
    <div class="heatmap-filter-group-inline">
        <span class="heatmap-filter-label">RANGE:</span>
        <select class="heatmap-filter-select" id="heatmap-period-select-new" onchange="setHeatmapPeriodNew(this.value)">
            <option value="last3">3 Weeks</option>
            <option value="last5">5 Weeks</option>
        </select>
    </div>
    
    <div class="heatmap-filter-separator"></div>
    
    <div class="heatmap-filter-group-inline">
        <span class="heatmap-filter-label">DISPLAY:</span>
        <select class="heatmap-filter-select" id="heatmap-display-select-new" onchange="setHeatmapDisplayNew(this.value)">
            <option value="24">Top 24</option>
            <option value="36" selected>Top 36</option>
            <option value="50">Top 50</option>
        </select>
    </div>
</div>

<!-- Main Heatmap Container -->
<div class="analytics-dashboard-container">
    <div class="heatmap-widget">
        <div class="heatmap-stat-text" id="heatmap-position-stats"></div>
        <div class="heatmap-player-grid" id="heatmap-player-grid"></div>
        <div class="heatmap-legend">
            <div class="heatmap-legend-title" id="heatmap-legend-title">Performance vs Expected</div>
            <div class="heatmap-legend-items" id="heatmap-legend-items">
                <div class="heatmap-legend-item">
                    <div class="heatmap-legend-color extreme-negative"></div>
                    <div class="heatmap-legend-label" id="legend-label-0">-20%+<br>Extreme Under</div>
                </div>
                <div class="heatmap-legend-item">
                    <div class="heatmap-legend-color strong-negative"></div>
                    <div class="heatmap-legend-label" id="legend-label-1">-15 to -20%<br>Strong Under</div>
                </div>
                <div class="heatmap-legend-item">
                    <div class="heatmap-legend-color moderate-negative"></div>
                    <div class="heatmap-legend-label" id="legend-label-2">-10 to -15%<br>Moderate Under</div>
                </div>
                <div class="heatmap-legend-item">
                    <div class="heatmap-legend-color slight-negative"></div>
                    <div class="heatmap-legend-label" id="legend-label-3">-5 to -10%<br>Slight Under</div>
                </div>
                <div class="heatmap-legend-item">
                    <div class="heatmap-legend-color neutral"></div>
                    <div class="heatmap-legend-label" id="legend-label-4">Â±5%<br>On Target</div>
                </div>
                <div class="heatmap-legend-item">
                    <div class="heatmap-legend-color slight-positive"></div>
                    <div class="heatmap-legend-label" id="legend-label-5">+5 to +10%<br>Slight Over</div>
                </div>
                <div class="heatmap-legend-item">
                    <div class="heatmap-legend-color moderate-positive"></div>
                    <div class="heatmap-legend-label" id="legend-label-6">+10 to +15%<br>Moderate Over</div>
                </div>
                <div class="heatmap-legend-item">
                    <div class="heatmap-legend-color strong-positive"></div>
                    <div class="heatmap-legend-label" id="legend-label-7">+15 to +20%<br>Strong Over</div>
                </div>
                <div class="heatmap-legend-item">
                    <div class="heatmap-legend-color extreme-positive"></div>
                    <div class="heatmap-legend-label" id="legend-label-8">+20%+<br>Extreme Over</div>
                </div>
            </div>
        </div>
        
        <!-- Smart Insights - Horizontal Cards -->
        <div class="heatmap-simple-insights" id="heatmap-simple-insights">
            <!-- Insights will be dynamically inserted here as horizontal cards -->
        </div>
    </div>
</div>
</div><div id="wide-receivers" class="page"><div class="ticker-section" id="wr-ticker-section"><div class="ticker-header"><span>Wide Receivers - Top 50 by Avg Points</span><div class="ticker-info-icon" onclick="toggleTickerTooltip(event)">
i
<div class="ticker-tooltip">
Shows average fantasy points per game and % change in target share (week-over-week).
</div></div></div><div class="ticker-content" id="wr-ticker-content"><div class="ticker-container"><div class="ticker-track" id="wr-ticker-track" style="animation-duration: 720s !important;"></div></div></div></div><div id="wr-top-movers-sidebar" style="margin-bottom: 24px;"></div><div><div id="wr-rankings-content" class="sub-content active"><div id="wr-players-grid"></div></div></div></div><div id="running-backs" class="page"><div class="ticker-section" id="rb-ticker-section"><div class="ticker-header"><span>Running Backs - Top 50 by Avg Points</span><div class="ticker-info-icon" onclick="toggleTickerTooltip(event)">
i
<div class="ticker-tooltip">
Shows average fantasy points per game and % change in opportunity share (rush attempts + targets, week-over-week).
</div></div></div><div class="ticker-content" id="rb-ticker-content"><div class="ticker-container"><div class="ticker-track" id="rb-ticker-track" style="animation-duration: 720s !important;"></div></div></div></div><div id="rb-top-movers-sidebar" style="margin-bottom: 24px;"></div><div><div id="rb-rankings-content" class="sub-content active"><div id="rb-players-grid"></div></div></div></div><div id="tight-ends" class="page"><div class="ticker-section" id="te-ticker-section"><div class="ticker-header"><span>Tight Ends - Top 50 by Avg Points</span><div class="ticker-info-icon" onclick="toggleTickerTooltip(event)">
i
<div class="ticker-tooltip">
Shows average fantasy points per game and % change in target share (week-over-week).
</div></div></div><div class="ticker-content" id="te-ticker-content"><div class="ticker-container"><div class="ticker-track" id="te-ticker-track" style="animation-duration: 720s !important;"></div></div></div></div><div id="te-top-movers-sidebar" style="margin-bottom: 24px;"></div><div><div id="te-rankings-content" class="sub-content active"><div id="te-players-grid"></div></div></div></div><div id="teams" class="page">
<!-- Heatmap-Style Ticker Bar for Teams -->
<div class="heatmap-ticker-bar">
    <div class="heatmap-ticker-status">
        <div class="heatmap-status-dot"></div>
        <span class="heatmap-status-text">TEAM OUTLOOK</span>
    </div>
    <div class="heatmap-ticker-divider"></div>
    <div class="heatmap-rotating-insight-container">
        <div class="heatmap-insight-value" id="teams-rotating-value">Loading...</div>
        <div class="heatmap-insight-content">
            <div class="heatmap-insight-label" id="teams-rotating-label">Analyzing teams...</div>
            <div class="heatmap-insight-text" id="teams-rotating-text">Processing team statistics to find key insights.</div>
        </div>
    </div>
    <div class="heatmap-ticker-week">WEEK 10</div>
</div>

<!-- Gradient Line -->
<div class="heatmap-gradient-line"></div>

<!-- Scrolling Team Rankings Ticker -->
<div style="margin-bottom: 0;">
    <div class="ticker-content" id="teams-ticker-content">
        <div class="ticker-container">
            <div class="ticker-track" id="teams-ticker-track" style="animation-duration: 480s !important;"></div>
        </div>
    </div>
</div>

<!-- Heatmap-Style Filters Bar with Toggle Buttons -->
<div class="heatmap-filters-bar">
    <div class="heatmap-filter-group-inline">
        <span class="heatmap-filter-label">TEAM:</span>
        <select class="heatmap-filter-select" id="team-select" onchange="updateTeamAnalysis()">
        </select>
    </div>
    
    <div class="heatmap-filter-separator"></div>
    
    <div class="heatmap-filter-group-inline">
        <span class="heatmap-filter-label">POSITION:</span>
        <select class="heatmap-filter-select" id="position-group-select" onchange="updateTeamAnalysis()">
            <option value="WR">Pass-Catchers</option>
            <option value="RB">Running Backs</option>
        </select>
    </div>
    
    <div class="heatmap-filter-separator"></div>
    
    <div class="heatmap-filter-group-inline">
        <span class="heatmap-filter-label">RANGE:</span>
        <select class="heatmap-filter-select" id="time-frame-select" onchange="updateTeamAnalysis()">
            <option value="single">Single Week</option>
            <option value="last3">Last 3 Weeks</option>
            <option value="last5">Last 5 Weeks</option>
            <option value="season">Season Long</option>
        </select>
    </div>
    
    <div class="heatmap-filter-separator"></div>
    
    <div class="heatmap-filter-group-inline" id="week-select-container">
        <span class="heatmap-filter-label">WEEK:</span>
        <select class="heatmap-filter-select" id="week-select" onchange="updateTeamAnalysis()">
        </select>
    </div>
    
    <div class="heatmap-filter-separator"></div>
    
    <!-- League Comparison Toggle -->
    <button
        id="league-comparison-toggle"
        onclick="toggleLeagueComparison()"
        style="padding: 8px 14px; background: var(--positive); border: 1px solid var(--positive); border-radius: 6px; color: white; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 6px; white-space: nowrap; flex-shrink: 0;"
    ><span id="league-comparison-icon">â—</span><span>League Avg</span></button>
    
    <!-- Usage Toggle Container (shown for Season Long only) -->
    <div id="main-rz-toggle-container" style="display: none; gap: 4px; align-items: center; flex-shrink: 0;">
        <div class="heatmap-filter-separator"></div>
        
        <!-- Total Usage / RZ Usage Toggle Buttons -->
        <div style="display: flex; gap: 4px;">
            <button id="main-usage-btn" class="rz-toggle-btn active" onclick="toggleMainTeamChartMetric('usage')" style="padding: 8px 12px; background: var(--positive); border: 1px solid var(--positive); border-radius: 6px; color: white; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s; white-space: nowrap;">Total Usage</button>
            <button id="main-rz-btn" class="rz-toggle-btn" onclick="toggleMainTeamChartMetric('rz')" style="padding: 8px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-secondary); font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s; white-space: nowrap;">RZ Usage</button>
        </div>
        
        <!-- RZ Metric Toggle (shown when RZ Usage is active) -->
        <div id="main-rz-metric-toggle" style="display: none; gap: 4px;">
            <button id="main-pct-btn" class="rz-metric-btn active" onclick="toggleMainRZMetric('pct')" style="padding: 8px 12px; background: var(--positive); border: 1px solid var(--positive); border-radius: 6px; color: white; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s; white-space: nowrap;">% Share</button>
            <button id="main-num-btn" class="rz-metric-btn" onclick="toggleMainRZMetric('num')" style="padding: 8px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-secondary); font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s; white-space: nowrap;"># of Opps</button>
        </div>
    </div>
</div>

<!-- Content Below Filters Bar -->
<div class="advanced-analytics-container" style="margin-bottom: 32px;">
<div class="scatter-chart-card"><div class="scatter-chart-header"><div class="scatter-chart-title" id="team-chart-title">Team Target Distribution</div><div class="scatter-chart-description" id="team-chart-description">
Select a team and time frame to view distribution
</div></div><div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; min-height: 420px;" id="team-charts-container"><div id="team-chart-placeholder" style="grid-column: 1; display: flex; align-items: center; justify-content: center;"><div style="text-align: center; color: #8e8e93; font-size: 18px; font-weight: 600;">
Select a Team
</div></div><div class="chart-wrapper" style="display: none;"><canvas id="team-pie-chart"></canvas></div><div class="chart-wrapper" id="team-secondary-chart-wrapper" style="display: none;"><canvas id="team-secondary-chart"></canvas></div></div></div></div><div class="chart-card" style="margin-bottom: 32px;"><div class="chart-header"><div class="chart-title">Offensive Identity Map</div><div class="chart-subtitle">Pass-Heavy vs Run-Heavy Offenses</div></div><div class="chart-insight"><strong>What to look for:</strong> Top Right = Pass Heavy + Run Heavy, Bottom Right = Pass Heavy, Top Left = Run Heavy, Bottom Left = Avoid. Bigger Circles = More Total Fantasy Output.
</div><div class="chart-wrapper"><canvas id="team-balance-scatter"></canvas></div></div><div class="cards-grid" id="teams-grid" style="display: none;"></div></div><div id="top-movers" class="page"><div class="page-header" style="padding-bottom: 24px;"><h1 class="page-title">Leaderboard</h1></div><div style="background: var(--bg-secondary); border-radius: 12px; padding: 24px; border: 1px solid var(--border-color); margin-bottom: 24px;"><div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;"><div><h2 style="font-size: 18px; font-weight: 700; color: var(--text-primary); margin-bottom: 4px;">Player Reliability Score (PRS)</h2><p style="font-size: 12px; color: var(--text-tertiary);">Composite score combining PPG, volume, efficiency, and consistency (min. 3 games)</p></div><div style="display: flex; gap: 8px;"><button class="prs-position-btn active" data-position="WR" onclick="filterPRSLeaderboard('WR')" style="padding: 6px 12px; background: var(--positive); border: 1px solid var(--positive); border-radius: 6px; color: white; font-size: 12px; font-weight: 600; cursor: pointer;">WR</button><button class="prs-position-btn" data-position="RB" onclick="filterPRSLeaderboard('RB')" style="padding: 6px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-secondary); font-size: 12px; font-weight: 600; cursor: pointer;">RB</button><button class="prs-position-btn" data-position="TE" onclick="filterPRSLeaderboard('TE')" style="padding: 6px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-secondary); font-size: 12px; font-weight: 600; cursor: pointer;">TE</button></div></div><div id="prs-leaderboard-content" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 12px;"></div></div><div class="dashboard-widget" style="margin-bottom: 24px;"><div class="widget-header"><div><span class="widget-title" style="font-size: 18px; text-transform: uppercase; letter-spacing: 0.5px;">Leaderboards</span><div style="font-size: 11px; color: var(--text-tertiary); margin-top: 2px;">Last 3 Weeks Performance</div></div><button onclick="navigateToPage('all-leaderboards')" style="padding: 8px 16px; background: var(--positive); color: white; border: none; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">
See All
</button></div></div><div class="categories-section" id="dashboard-categories"></div><div class="category-footnote"><button class="footnote-toggle" onclick="toggleFootnote()"><span id="footnote-icon">â“˜</span> Methodology
</button><div class="footnote-content" id="footnote-content" style="display: none;"><strong>ðŸ“Š Category Leaderboard Methodology</strong><br><br><strong>Time Window:</strong> All rankings are based on performance over the <strong>last 3 weeks of the season</strong>. Players must have played (with fantasy points scored) in at least <strong>2 of the last 3 weeks</strong> to be eligible for any category.<br><br><strong>Minimum Threshold:</strong> Players must average <strong>7.0+ fantasy points per game</strong> over their qualifying games to appear on leaderboards.<br><br><strong>Category Definitions:</strong><br>
â€¢ <strong>Volume Monsters (RB):</strong> Running backs with the highest opportunities per game (rush attempts + targets) over the last 3 weeks. Identifies true workhorse backs.<br>
â€¢ <strong>Efficiency Elites:</strong> Players with the best points per touch/target ratio over the last 3 weeks. Shows who's doing the most with their opportunities.<br>
â€¢ <strong>Red Zone Kings:</strong> Players with the most red zone opportunities per game. For WRs: red zone targets. For RBs: red zone rush attempts + targets. High TD upside.<br>
â€¢ <strong>High-Volume Alphas (WR):</strong> Wide receivers with the most targets per game over the last 3 weeks. High-volume pass catchers dominating their team's offense.<br><br><strong>Why Last 3 Weeks?</strong> Recent performance is more predictive than season-long averages. Player roles evolve, injuries affect usage, and offensive schemes shift throughout the season. The last 3 weeks capture current reality and help identify emerging trends and hot streaks.
</div></div></div><div id="advanced-analytics" class="page">

<!-- Ticker Bar -->
<div class="heatmap-ticker-bar">
    <div class="heatmap-ticker-status">
        <div class="heatmap-status-dot"></div>
        <span class="heatmap-status-text">SCATTER PLOTS</span>
    </div>
    <div class="heatmap-ticker-divider"></div>
    <div class="rotating-headline-container" style="flex: 1; min-height: 40px;">
        <div class="status-headline" id="scatter-rotating-headline" style="font-size: 18px; font-weight: 700; color: var(--text-primary); transition: opacity 0.5s ease;">Volume vs Efficiency</div>
        <div class="status-subheadline" id="scatter-rotating-subheadline" style="font-size: 13px; color: var(--text-secondary); margin-top: 2px; transition: opacity 0.5s ease;">High-volume receivers with strong catch rates</div>
    </div>
    <div class="heatmap-ticker-week">WEEK 10</div>
</div>

<!-- Gradient Line -->
<div class="heatmap-gradient-line"></div>

<!-- Consolidated Filters Bar - Three Rows -->
<div class="advanced-filters-container" style="background: var(--bg-secondary); border-bottom: 1px solid var(--border-color); margin: 0 -24px 24px;">
    <!-- Row 1: Player Search + Main Dropdowns -->
    <div class="heatmap-filters-bar" style="border-bottom: none; margin: 0; padding-bottom: 12px;">
        <div class="heatmap-filter-group-inline" style="flex: 1; min-width: 0;">
            <span class="heatmap-filter-label">HIGHLIGHT:</span>
            <div style="position: relative; flex: 1;">
                <input
                    type="text"
                    id="player-search-input"
                    class="heatmap-filter-select"
                    placeholder="Search to highlight players (Max 4)"
                    oninput="filterPlayerSearch()"
                    onfocus="showPlayerSearchDropdown()"
                    style="padding-right: 30px; width: 100%;"
                />
                <button
                    id="clear-player-btn"
                    onclick="clearPlayerHighlight()"
                    style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: transparent; border: none; color: var(--text-secondary); cursor: pointer; font-size: 18px; display: none; padding: 0; width: 20px; height: 20px; line-height: 1;"
                    title="Clear highlighted players"
                >Ã—</button>
                <div id="selected-players-container" style="display: none; margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap;"></div>
            </div>
        </div>
        
        <div class="heatmap-filter-separator"></div>
        
        <div class="heatmap-filter-group-inline">
            <span class="heatmap-filter-label">POSITION:</span>
            <select class="heatmap-filter-select" id="advanced-position-select" onchange="switchAdvancedPositionFromFilter(this.value)">
                <option value="WR">Wide Receivers</option>
                <option value="RB" selected>Running Backs</option>
                <option value="TE">Tight Ends</option>
            </select>
        </div>
        
        <div class="heatmap-filter-separator"></div>
        
        <div class="heatmap-filter-group-inline">
            <span class="heatmap-filter-label">X-AXIS:</span>
            <select class="heatmap-filter-select" id="x-axis-select" onchange="currentQuadrantExplanation = ''; updateAdvancedScatter()"></select>
        </div>
        
        <div class="heatmap-filter-separator"></div>
        
        <div class="heatmap-filter-group-inline">
            <span class="heatmap-filter-label">Y-AXIS:</span>
            <select class="heatmap-filter-select" id="y-axis-select" onchange="currentQuadrantExplanation = ''; updateAdvancedScatter()"></select>
        </div>
    </div>
    
    <!-- Row 2: Show Top Buttons + Reset + Range -->
    <div class="heatmap-filters-bar" style="border-bottom: none; margin: 0; padding-top: 0; padding-bottom: 12px;">
        <div class="heatmap-filter-group-inline">
            <span class="heatmap-filter-label">SHOW TOP:</span>
            <div style="display: flex; gap: 4px; align-items: center;">
                <button class="player-count-btn" onclick="setPlayerCount(12)" id="count-12">12</button>
                <button class="player-count-btn" onclick="setPlayerCount(24)" id="count-24">24</button>
                <button class="player-count-btn" onclick="setPlayerCount(36)" id="count-36">36</button>
                <button class="player-count-btn active" onclick="setPlayerCount(50)" id="count-50">50</button>
                <button class="player-count-btn" onclick="setPlayerCount(null)" id="count-all">All</button>
            </div>
        </div>
        
        <div class="heatmap-filter-separator"></div>
        
        <button class="zoom-btn" onclick="resetAdvancedZoom()" title="Reset Zoom" style="padding: 8px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-secondary); font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s; white-space: nowrap; display: flex; align-items: center; gap: 6px;">
            <svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><path d="M8 5v6M5 8h6"/></svg>
            Zoom Reset
        </button>
        
        <div class="heatmap-filter-separator"></div>
        
        <div class="heatmap-filter-group-inline">
            <span class="heatmap-filter-label">RANGE:</span>
            <select class="heatmap-filter-select" id="week-range-select" onchange="updateAdvancedScatter()">
                <option value="all">All Weeks</option>
                <option value="last3">Last 3 Weeks</option>
                <option value="last5">Last 5 Weeks</option>
                <option value="1-4">Weeks 1-4</option>
                <option value="5-8">Weeks 5-8</option>
            </select>
        </div>
    </div>
    
    <!-- Row 3: Quick Presets -->
    <div class="heatmap-filters-bar" style="border-bottom: none; margin: 0; padding-top: 0;">
        <div class="heatmap-filter-group-inline" style="flex: 1;">
            <span class="heatmap-filter-label">QUICK PRESETS:</span>
            <div id="preset-buttons-container" style="display: flex; gap: 6px; flex-wrap: wrap; flex: 1;"></div>
        </div>
    </div>
</div>

<!-- Hidden dropdown for player search (outside filters bar) -->
<div id="player-search-dropdown" style="display: none; position: absolute; background: var(--bg-elevated); border: 1px solid var(--border-color); border-radius: 8px; margin-top: 4px; max-height: 200px; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);"></div>

<!-- Content Below Filters -->
<div class="advanced-analytics-container"><div class="advanced-analytics-charts-wrapper"><div class="scatter-chart-card"><div class="scatter-chart-header"><div class="scatter-chart-title" id="scatter-title">Fantasy Points vs Targets</div><div class="scatter-chart-description" id="scatter-description">
Click on any point to view player details
</div></div><div class="scatter-chart-wrapper"><canvas id="advanced-scatter-chart"></canvas></div></div></div>

<!-- Insight Cards Below Chart -->
<div id="scatter-insight-cards" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 16px; margin-top: 48px;">
    <!-- Cards will be dynamically populated -->
</div>

</div></div></div></div><div id="all-leaderboards" class="page"><div class="page-header" style="padding-bottom: 24px;"><h1 class="page-title">Leaderboard</h1></div><div style="background: var(--bg-secondary); border-radius: 12px; padding: 24px; border: 1px solid var(--border-color); margin-bottom: 24px;"><div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;"><div><h2 style="font-size: 18px; font-weight: 700; color: var(--text-primary); margin-bottom: 4px;">Points Per Game Leaders</h2><p style="font-size: 12px; color: var(--text-tertiary);">Top performers by average fantasy points per game (min. 3 games played)</p></div><div style="display: flex; gap: 8px;"><button class="ppg-position-btn active" data-position="WR" onclick="filterPPGLeaderboard('WR')" style="padding: 6px 12px; background: var(--positive); border: 1px solid var(--positive); border-radius: 6px; color: white; font-size: 12px; font-weight: 600; cursor: pointer;">WR</button><button class="ppg-position-btn" data-position="RB" onclick="filterPPGLeaderboard('RB')" style="padding: 6px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-secondary); font-size: 12px; font-weight: 600; cursor: pointer;">RB</button><button class="ppg-position-btn" data-position="TE" onclick="filterPPGLeaderboard('TE')" style="padding: 6px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-secondary); font-size: 12px; font-weight: 600; cursor: pointer;">TE</button></div></div><div id="ppg-leaderboard-content" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 12px;"></div></div><div class="all-leaderboards-wrapper"><div id="all-leaderboards-grid"></div></div><div class="category-footnote" style="margin-top: 24px;"><button class="footnote-toggle" onclick="togglePRSFootnote()"><span id="prs-footnote-icon">â“˜</span> PRS Methodology
</button><div class="footnote-content" id="prs-footnote-content" style="display: none;"><strong>ðŸ“Š Player Reliability Score (PRS) Methodology</strong><br><br><strong>What is PRS?</strong> PRS is a comprehensive player evaluation metric that combines multiple performance factors into a single score to identify true fantasy standouts.<br><br><strong>Calculation:</strong> PRS = (Avg PPG Ã— 0.4) + (Volume Score Ã— 0.3) + (Efficiency Score Ã— 0.2) + (Consistency Score Ã— 0.1)<br><br><strong>Component Breakdown:</strong><br>
â€¢ <strong>Avg PPG (40%):</strong> Average fantasy points per game - the most important factor<br>
â€¢ <strong>Volume Score (30%):</strong> Normalized opportunity share (targets for WR/TE, opportunities for RB)<br>
â€¢ <strong>Efficiency Score (20%):</strong> Points per touch/target compared to position average<br>
â€¢ <strong>Consistency Score (10%):</strong> Standard deviation of weekly scores (lower is better)<br><br><strong>Why PRS?</strong> Unlike raw PPG, PRS accounts for opportunity volume and efficiency, helping identify players who are both productive AND sustainable. High PRS = High production + High volume + High efficiency + Consistent output.
</div></div></div><div id="admin-panel" class="page"><div class="page-header"><h1 class="page-title">Admin Panel</h1><p class="page-subtitle">Upload new data and manage the site</p></div><div style="max-width: 800px; margin: 0 auto;"><div style="background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 24px; margin-bottom: 24px;"><div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;"><div><div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">Logged in as Admin</div><div style="font-size: 12px; color: var(--text-tertiary);" id="admin-email-display"><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="50312229396360626510373d31393c7e333f3d">[email&#160;protected]</a></div></div><button onclick="logoutAdmin()" style="padding: 8px 16px; background: var(--negative); border: none; border-radius: 8px; color: white; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">
Sign Out
</button></div><div style="padding-top: 16px; border-top: 1px solid var(--border-color); font-size: 12px; color: var(--text-secondary);">
Last updated: <span id="admin-last-updated">No data uploaded</span></div></div><div style="background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 24px;"><h2 style="font-size: 18px; font-weight: 700; color: var(--text-primary); margin-bottom: 16px;">Upload New Data</h2><div style="display: flex; flex-direction: column; gap: 20px;"><div><label style="display: block; font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">Wide Receiver Data (CSV)</label><input type="file" id="admin-wr-upload" accept=".csv" onchange="handleAdminWRUpload(event)" style="display: block; width: 100%; padding: 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 13px; cursor: pointer;"><div id="admin-wr-status" style="margin-top: 6px; font-size: 12px; color: var(--text-tertiary);"></div></div><div><label style="display: block; font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">Running Back Data (CSV)</label><input type="file" id="admin-rb-upload" accept=".csv" onchange="handleAdminRBUpload(event)" style="display: block; width: 100%; padding: 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 13px; cursor: pointer;"><div id="admin-rb-status" style="margin-top: 6px; font-size: 12px; color: var(--text-tertiary);"></div></div><div><label style="display: block; font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">Tight End Data (CSV)</label><input type="file" id="admin-te-upload" accept=".csv" onchange="handleAdminTEUpload(event)" style="display: block; width: 100%; padding: 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 13px; cursor: pointer;"><div id="admin-te-status" style="margin-top: 6px; font-size: 12px; color: var(--text-tertiary);"></div></div><div style="margin-top: 8px; padding: 16px; background: var(--bg-tertiary); border-radius: 8px; font-size: 13px; color: var(--text-secondary); line-height: 1.6;"><strong style="color: var(--text-primary);">Instructions:</strong><br>
1. Upload WR, RB, and TE CSV files<br>
2. Data will be processed automatically<br>
3. All pages will update with new data<br>
4. "Last updated" date will be set to today<br>
5. Data persists until you upload again
</div></div></div></div></div></main><footer class="footer"><div class="footer-content"><div class="footer-section"><h3>JOIN THE WAITLIST</h3><p>Get early access to premium features, real-time updates, and exclusive fantasy football insights.</p><form class="waitlist-form" onsubmit="submitWaitlist(event)"><input
type="email"
class="waitlist-input"
id="waitlist-email"
placeholder="Enter your email"
required
/><button type="submit" class="waitlist-btn">Join Waitlist</button></form><div class="success-message" id="waitlist-success">
âœ“ Thanks! You've been added to the waitlist.
</div></div><div class="footer-section"><h3>QUICK LINKS</h3><div class="footer-links"><a href="#" class="footer-link" id="admin-login-link" onclick="showLoginModal(); return false;">Admin Login</a><a href="#" class="footer-link" onclick="navigateToPage('analytics-dashboard'); return false;">Heatmap</a><a href="#" class="footer-link" onclick="navigateToPage('top-movers'); return false;">Leaderboards</a><a href="#" class="footer-link" onclick="navigateToPage('advanced-analytics'); return false;">Analytics</a></div></div><div class="footer-section"><h3>ABOUT FFSE</h3><div class="footer-links"><a href="#" class="footer-link" onclick="showPrivacyModal(); return false;">Privacy Policy</a><a href="#" class="footer-link">Contact</a></div><div style="margin-top: 16px; font-size: 11px; color: var(--text-tertiary);">
Last updated: <span id="last-updated-date">No data uploaded</span></div></div></div><div class="footer-bottom"><div class="footer-logo"><div class="footer-logo-icon"></div><span>FFSE</span></div><div class="footer-copyright">
Â© 2025 Fantasy Football Stock Exchange. All rights reserved. | Data updated weekly during NFL season.
</div></div></footer><div class="waitlist-modal" id="waitlist-modal"><div class="waitlist-modal-content"><div class="waitlist-modal-icon">ðŸŽ‰</div><div class="waitlist-modal-title">Welcome to the Waitlist!</div><div class="waitlist-modal-message">
Thanks for signing up! We'll keep you updated on new features, premium analytics, and exclusive fantasy football insights.
</div><button class="waitlist-modal-btn" onclick="closeWaitlistModal()">Got it!</button></div></div></div><div class="modal-overlay" id="player-modal"><div class="modal"><div class="modal-header"><div style="display: flex; justify-content: space-between; align-items: flex-start; width: 100%;"><div class="modal-player-info"><div class="modal-team-badge" id="modal-team-badge"></div><div class="modal-player-details"><div class="modal-player-name" id="modal-player-name"></div><div class="modal-player-meta" id="modal-player-meta"></div></div></div><div style="display: flex; flex-direction: column; align-items: flex-end; gap: 8px; margin-right: 40px;"><div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; font-weight: 500;">
COMMUNITY SENTIMENT
</div><div style="display: flex; align-items: center; gap: 12px;"><div class="sentiment-bar-3section" style="height: 8px; width: 200px; border-radius: 4px; display: flex; overflow: hidden; background: var(--bg-secondary);"><div class="sentiment-segment sentiment-segment-buy" id="modal-sentiment-segment-buy" style="transition: width 0.3s ease;"></div><div class="sentiment-segment sentiment-segment-hold" id="modal-sentiment-segment-hold" style="transition: width 0.3s ease;"></div><div class="sentiment-segment sentiment-segment-sell" id="modal-sentiment-segment-sell" style="transition: width 0.3s ease;"></div></div><div id="modal-sentiment-vote-count" style="font-size: 11px; color: var(--text-secondary); font-weight: 500; white-space: nowrap;"></div></div><div class="vote-buttons" style="gap: 6px; display: flex;"><button class="vote-btn buy-btn" onclick="castVote('buy')" style="padding: 6px 12px; font-size: 11px; font-weight: 600;">
Buy
</button><button class="vote-btn hold-btn" onclick="castVote('hold')" style="padding: 6px 12px; font-size: 11px; font-weight: 600;">
Hold
</button><button class="vote-btn sell-btn" onclick="castVote('sell')" style="padding: 6px 12px; font-size: 11px; font-weight: 600;">
Sell
</button></div></div><button class="modal-close" onclick="closeModal()" style="position: absolute; top: 16px; right: 16px;">Ã—</button></div><div id="modal-category-context" style="display: none; margin-top: 16px; padding: 12px 16px; background: var(--bg-elevated); border-radius: 8px; border-left: 3px solid var(--positive);"><div style="font-size: 11px; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 4px;">
Category Ranking
</div><div style="font-size: 14px; font-weight: 700; color: var(--text-primary); margin-bottom: 8px;"><span id="modal-category-title"></span> - <span id="modal-category-rank"></span></div><div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;"><span id="modal-category-explanation"></span></div><div style="display: flex; gap: 16px; margin-top: 8px; font-size: 12px;"><div><span style="color: var(--text-secondary);"><span id="modal-category-metric-label"></span>:</span><span style="color: var(--text-primary); font-weight: 600; margin-left: 4px;" id="modal-category-metric-value"></span></div></div></div><button onclick="toggleStatsCollapse()" id="stats-collapse-btn" style="width: 100%; padding: 8px; background: transparent; border: none; border-top: 1px solid var(--border-color); color: var(--text-secondary); font-size: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px; transition: all 0.2s;"><span id="stats-collapse-icon">â–¼</span><span id="stats-collapse-text">Hide Stats</span></button><div class="modal-stats-container" id="modal-stats-container"><div class="modal-stats-wrapper" id="modal-stats-wrapper"><div class="modal-stats-page"><div class="modal-section-header">Performance</div><div class="modal-stats-table"><div class="modal-stat-cell"><div class="modal-stat-label">FPTS/G</div><div class="modal-stat-value" id="modal-avg-pts">--</div><div class="modal-stat-comparison" id="modal-avg-pts-comparison"></div><div class="stat-tooltip">Average fantasy points per game across all weeks played</div></div><div class="modal-stat-cell"><div class="modal-stat-label" id="modal-actual-pts-label">Actual Pts (W9)</div><div class="modal-stat-value" id="modal-actual-pts">--</div><div class="modal-stat-comparison" id="modal-actual-comparison"></div><div class="stat-tooltip">Actual fantasy points scored in the most recent week</div></div><div class="modal-stat-cell"><div class="modal-stat-label">Momentum</div><div class="modal-stat-value" id="modal-momentum">--</div><div class="modal-stat-comparison" id="modal-momentum-comparison"></div><div class="stat-tooltip">Trend direction based on last 3 weeks vs previous 3 weeks performance</div></div><div class="modal-stat-cell"><div class="modal-stat-label">PPG vs Expected</div><div class="modal-stat-value" id="modal-ppg-expected">--</div><div class="modal-stat-comparison" id="modal-ppg-expected-comparison"></div><div class="stat-tooltip">Season-long average actual points compared to expected points based on opportunities</div></div></div></div><div class="modal-stats-page"><div class="modal-section-header">Volume & Opportunity</div><div class="modal-stats-table"><div class="modal-stat-cell"><div class="modal-stat-label" id="modal-opp-share-label">Tgt Share (W9)</div><div class="modal-stat-value" id="modal-opp-share">--</div><div class="modal-stat-comparison" id="modal-opp-share-comparison"></div><div class="stat-tooltip" id="modal-opp-share-tooltip">Player's share of team targets in the most recent week</div></div><div class="modal-stat-cell"><div class="modal-stat-label" id="modal-avg-volume-label">Avg Tgt vs Top 24</div><div class="modal-stat-value" id="modal-avg-volume">--</div><div class="modal-stat-comparison" id="modal-avg-volume-comparison"></div><div class="stat-tooltip" id="modal-avg-volume-tooltip">Average targets per game compared to Top 24 WR average</div></div><div class="modal-stat-cell"><div class="modal-stat-label">RZ Opp Share</div><div class="modal-stat-value" id="modal-rz-share">--</div><div class="modal-stat-comparison" id="modal-rz-share-comparison"></div><div class="stat-tooltip">Player's RZ opportunities / Team's total RZ opportunities (% share). Shows player's share of ALL team red zone opportunities across all weeks (rush attempts + targets)</div></div><div class="modal-stat-cell"><div class="modal-stat-label" id="modal-rz-avg-label">RZ Avg vs Top 24</div><div class="modal-stat-value" id="modal-rz-avg">--</div><div class="modal-stat-comparison" id="modal-rz-avg-comparison"></div><div class="stat-tooltip" id="modal-rz-avg-tooltip">Average red zone opportunities per game compared to Top 24 average</div></div></div></div></div><div class="stats-dots"><div class="stats-dot active" data-page="0"></div><div class="stats-dot" data-page="1"></div></div></div></div><div class="modal-body"><div class="chart-tabs"><button class="chart-tab" onclick="switchModalChart('reliability')">Reliability</button><button class="chart-tab active" onclick="switchModalChart('outcomes')">Performance Consistency</button><button class="chart-tab" onclick="switchModalChart('spider')">Player Profile</button><button class="chart-tab" onclick="switchModalChart('floor')">Floor Metrics</button><button class="chart-tab" onclick="switchModalChart('candles')">Performance Candles</button><button class="chart-tab" onclick="switchModalChart('schedule')">Schedule</button></div><div id="modal-chart-variance" class="chart-content"><div class="modal-chart-wrapper"><canvas id="modal-variance-chart"></canvas></div></div><div id="modal-chart-outcomes" class="chart-content active"><div class="modal-chart-wrapper"><canvas id="modal-outcomes-chart"></canvas></div></div><div id="modal-chart-spider" class="chart-content"><div class="modal-chart-wrapper"><canvas id="modal-spider-chart"></canvas></div><div style="margin-top: 16px; border-top: 1px solid var(--border-color); padding-top: 12px;"><button onclick="toggleSpiderExplanation()"
style="display: flex; align-items: center; gap: 6px; background: transparent; border: none; color: var(--text-secondary); cursor: pointer; font-size: 12px; padding: 0; font-weight: 500; transition: color 0.2s;"
onmouseover="this.style.color='var(--text-primary)'"
onmouseout="this.style.color='var(--text-secondary)'"><span id="spider-explanation-icon" style="font-size: 14px;">â„¹ï¸</span><span>How rankings are calculated</span></button><div id="spider-explanation" style="display: none; margin-top: 12px; background: var(--bg-elevated); border-radius: 8px; padding: 16px; font-size: 13px; line-height: 1.6;"><div style="color: var(--text-primary); font-weight: 600; margin-bottom: 8px;">Player Profile Rankings</div><div style="color: var(--text-secondary); margin-bottom: 12px;">
Each metric is ranked against <strong style="color: var(--text-primary);">all eligible players</strong> (minimum 3 games played) using per-game averages. Your rank determines your score: <strong style="color: var(--positive);">#1 = 100 points</strong>, <strong style="color: var(--text-primary);">#100 = 50 points</strong>, <strong style="color: var(--text-tertiary);">#200 = 0.5 points</strong>.
</div><div id="spider-wr-metrics" style="display: none;"><div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px; font-size: 12px;">WR Metrics:</div><div style="display: grid; gap: 8px; color: var(--text-secondary); font-size: 12px;"><div><strong style="color: var(--text-primary);">Volume:</strong> Targets per game (total targets Ã· games played)</div><div><strong style="color: var(--text-primary);">Efficiency:</strong> Fantasy points per target (avg points Ã· targets per game)</div><div><strong style="color: var(--text-primary);">Red Zone:</strong> Red zone opportunities per game (total RZ opps Ã· games played)</div><div><strong style="color: var(--text-primary);">Team Share:</strong> Target share % in most recent week</div><div><strong style="color: var(--text-primary);">Catch Rate:</strong> Receptions per target (total receptions Ã· total targets Ã— 100%)</div></div></div><div id="spider-rb-metrics" style="display: none;"><div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px; font-size: 12px;">RB Metrics:</div><div style="display: grid; gap: 8px; color: var(--text-secondary); font-size: 12px;"><div><strong style="color: var(--text-primary);">Volume:</strong> Opportunities per game (total opportunities Ã· games played)</div><div><strong style="color: var(--text-primary);">Efficiency:</strong> Fantasy points per opportunity (avg points Ã· opps per game)</div><div><strong style="color: var(--text-primary);">Red Zone:</strong> Red zone opportunities per game (total RZ opps Ã· games played)</div><div><strong style="color: var(--text-primary);">Team Share:</strong> Opportunity share % in most recent week</div><div><strong style="color: var(--text-primary);">Yards After Contact:</strong> Yards after contact per attempt (total YACON Ã· total attempts)</div></div></div><div id="spider-te-metrics" style="display: none;"><div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px; font-size: 12px;">TE Metrics:</div><div style="display: grid; gap: 8px; color: var(--text-secondary); font-size: 12px;"><div><strong style="color: var(--text-primary);">Volume:</strong> Targets per game (total targets Ã· games played)</div><div><strong style="color: var(--text-primary);">Efficiency:</strong> Fantasy points per target (avg points Ã· targets per game)</div><div><strong style="color: var(--text-primary);">Red Zone:</strong> Red zone opportunities per game (total RZ opps Ã· games played)</div><div><strong style="color: var(--text-primary);">Team Share:</strong> Target share % in most recent week</div><div><strong style="color: var(--text-primary);">Catch Rate:</strong> Receptions per target (total receptions Ã· total targets Ã— 100%)</div></div></div><div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color); font-size: 11px; color: var(--text-tertiary);"><strong style="color: var(--text-secondary);">Note:</strong> Rankings only shown for Top 200 players. All metrics are calculated as per-game averages to ensure fair comparison regardless of games played.
</div></div></div></div><div id="modal-chart-reliability" class="chart-content"><div style="padding: 20px;"><div style="display: flex; align-items: center; gap: 8px; margin-bottom: 24px;"><h3 style="font-size: 18px; font-weight: 700; color: var(--text-primary); margin: 0;">Player Reliability Score (PRS)</h3><div style="position: relative; display: inline-block;"><span style="cursor: help; color: var(--text-secondary); font-size: 16px;" onmouseover="document.getElementById('prs-tooltip').style.display='block'" onmouseout="document.getElementById('prs-tooltip').style.display='none'">â“˜</span><div id="prs-tooltip" style="display: none; position: absolute; left: 25px; top: -10px; background: rgba(28, 28, 30, 0.98); border: 1px solid var(--border-color); border-radius: 8px; padding: 12px; width: 320px; z-index: 10000; font-size: 12px; color: var(--text-secondary); box-shadow: 0 4px 12px rgba(0,0,0,0.3); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);"><div style="color: var(--text-primary); font-weight: 600; margin-bottom: 6px;">How PRS is Calculated</div><div style="line-height: 1.5;">
PRS measures role stability and reliability on a 0-100 scale:
<div style="margin-top: 8px; display: grid; gap: 4px;"><div>â€¢ <strong style="color: var(--text-primary);">Opportunity Value</strong> - Production-weighted usage</div><div>â€¢ <strong style="color: var(--text-primary);">Scoring Role</strong> - Production-weighted RZ involvement</div><div>â€¢ <strong style="color: var(--text-primary);">Floor Reliability</strong> - Hitting expected points</div><div>â€¢ <strong style="color: var(--text-primary);">Games</strong> - Availability/games played</div></div><div style="margin-top: 8px; font-size: 11px; color: var(--text-tertiary);"><strong>Note:</strong> WRs weight floor reliability higher (30%) vs RB/TE (20%). Exact weights shown on cards.
</div><div style="margin-top: 4px; font-size: 11px; color: var(--text-tertiary);">Higher score = more reliable fantasy asset</div></div></div></div></div><div style="display: grid; grid-template-columns: 180px 1fr; gap: 24px; align-items: start;"><div style="display: flex; flex-direction: column; align-items: center;"><canvas id="prs-gauge-chart" width="120" height="120"></canvas></div><div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;"><div style="background: #2c2c2e; border-radius: 8px; padding: 16px;"><div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;"><span style="font-size: 13px; color: var(--text-primary); font-weight: 600;">Opportunity Value</span><span id="prs-usage-weight" style="font-size: 11px; color: #8e8e93;">40%</span></div><div style="height: 6px; background: #1c1c1e; border-radius: 3px; overflow: hidden; margin-bottom: 10px;"><div id="prs-usage-bar" style="height: 100%; width: 0%; transition: width 0.3s ease, background 0.3s ease;"></div></div><div id="prs-usage-value" style="font-size: 16px; font-weight: 600;">--</div></div><div style="background: #2c2c2e; border-radius: 8px; padding: 16px;"><div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;"><span style="font-size: 13px; color: var(--text-primary); font-weight: 600;">Scoring Role</span><span id="prs-rz-weight" style="font-size: 11px; color: #8e8e93;">30%</span></div><div style="height: 6px; background: #1c1c1e; border-radius: 3px; overflow: hidden; margin-bottom: 10px;"><div id="prs-rz-bar" style="height: 100%; width: 0%; transition: width 0.3s ease, background 0.3s ease;"></div></div><div id="prs-rz-value" style="font-size: 16px; font-weight: 600;">--</div></div><div style="background: #2c2c2e; border-radius: 8px; padding: 16px;"><div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;"><span style="font-size: 13px; color: var(--text-primary); font-weight: 600;">Floor Reliability</span><span id="prs-consistency-weight" style="font-size: 11px; color: #8e8e93;">20%</span></div><div style="height: 6px; background: #1c1c1e; border-radius: 3px; overflow: hidden; margin-bottom: 10px;"><div id="prs-consistency-bar" style="height: 100%; width: 0%; transition: width 0.3s ease, background 0.3s ease;"></div></div><div id="prs-consistency-value" style="font-size: 16px; font-weight: 600;">--</div></div><div style="background: #2c2c2e; border-radius: 8px; padding: 16px;"><div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;"><span style="font-size: 13px; color: var(--text-primary); font-weight: 600;">Games Played</span><span id="prs-games-weight" style="font-size: 11px; color: #8e8e93;">10%</span></div><div style="height: 6px; background: #1c1c1e; border-radius: 3px; overflow: hidden; margin-bottom: 10px;"><div id="prs-games-bar" style="height: 100%; width: 0%; transition: width 0.3s ease, background 0.3s ease;"></div></div><div id="prs-games-value" style="font-size: 16px; font-weight: 600;">--</div></div></div></div><div style="margin-top: 24px; border-top: 1px solid var(--border-color); padding-top: 16px;"><div onclick="document.getElementById('prs-methodology').style.display = document.getElementById('prs-methodology').style.display === 'none' ? 'block' : 'none'; document.getElementById('prs-methodology-icon').textContent = document.getElementById('prs-methodology').style.display === 'none' ? 'â–¶' : 'â–¼';" style="cursor: pointer; display: flex; align-items: center; gap: 8px; padding: 8px; border-radius: 6px; transition: background 0.2s;" onmouseover="this.style.background='var(--bg-tertiary)'" onmouseout="this.style.background='transparent'"><span id="prs-methodology-icon" style="font-size: 12px; color: var(--text-secondary);">â–¶</span><span style="font-size: 13px; font-weight: 600; color: var(--text-primary);">Methodology</span></div><div id="prs-methodology" style="display: none; margin-top: 12px; padding: 12px; background: var(--bg-tertiary); border-radius: 8px; font-size: 12px; color: var(--text-secondary); line-height: 1.6;"><div style="color: var(--text-primary); font-weight: 600; margin-bottom: 8px;">How PRS Components Are Calculated</div><div style="margin-bottom: 12px;"><strong style="color: var(--text-primary);">Opportunity Value:</strong> Production-weighted opportunity score = Usage Share Ã— Average Fantasy Points. Rewards players whose touches translate to actual fantasy production. Example: A WR with 25% usage averaging 18 PPG scores higher than a WR with 30% usage averaging 10 PPG.
</div><div style="margin-bottom: 12px;"><strong style="color: var(--text-primary);">Scoring Role:</strong> Production-weighted red zone opportunity = RZ Share Ã— Average Fantasy Points. Elite scorers with significant RZ usage score higher than low-volume RZ specialists. Measures touchdown upside potential.
</div><div style="margin-bottom: 12px;"><strong style="color: var(--text-primary);">Floor Reliability:</strong> Measures how often a player meets or exceeds expected points. Formula: 60% hit rate + 40% average differential + bonus for elite scorers. Hit threshold: within 15% of expected for 14+ PPG players, 10% for others. Rewards players who consistently deliver on projections.
</div><div style="margin-bottom: 12px;"><strong style="color: var(--text-primary);">Games Played:</strong> Percentage of maximum games played in dataset. Availability is critical for reliability - you can't rely on a player who isn't on the field.
</div><div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color); font-size: 11px;"><strong style="color: var(--text-primary);">Position-Specific Weights:</strong><br>
â€¢ <strong>WR:</strong> Opportunity Value 40%, Scoring Role 20%, Floor Reliability 30%, Games 10%<br>
â€¢ <strong>RB/TE:</strong> Opportunity Value 40%, Scoring Role 30%, Floor Reliability 20%, Games 10%
</div><div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color); font-size: 11px;"><strong style="color: var(--text-primary);">Color Legend:</strong><span style="color: #30d158;">â– </span> Green (80-100) = Elite
<span style="color: #0a84ff;">â– </span> Blue (60-79) = Above Average
<span style="color: #ffd60a;">â– </span> Yellow (40-59) = Average
<span style="color: #ff453a;">â– </span> Red (0-39) = Below Average
</div></div></div></div></div><div id="modal-chart-floor" class="chart-content"><div style="padding: 32px 20px;"><div style="text-align: center; margin-bottom: 32px;"><h3 style="font-size: 20px; font-weight: 700; color: var(--text-primary); margin: 0 0 8px 0;">Floor Metrics</h3><p style="font-size: 13px; color: var(--text-secondary); margin: 0;">Risk indicators for fantasy reliability (lower is better)</p></div><div style="display: grid; grid-template-columns: 1fr 1fr; gap: 48px; max-width: 800px; margin: 0 auto;"><div style="display: flex; flex-direction: column; align-items: center;"><div style="position: relative; width: 200px; height: 120px; margin-bottom: 16px;"><canvas id="floor-fragility-gauge" width="200" height="120"></canvas><div style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); text-align: center;"><div id="floor-fragility-value" style="font-size: 32px; font-weight: 700; line-height: 1;">--</div><div style="font-size: 11px; color: var(--text-secondary); margin-top: 2px;" id="floor-fragility-pill">--</div></div></div><div style="font-size: 16px; font-weight: 600; color: var(--text-primary); text-align: center; margin-bottom: 8px;">Fragility Score</div><div style="display: flex; flex-direction: column; gap: 6px; font-size: 11px; color: var(--text-secondary); text-align: center;"><div id="floor-fragility-td">TD Dependency: --</div><div id="floor-fragility-var">Variance: --</div><div id="floor-fragility-vol">Volume Penalty: --</div></div></div><div style="display: flex; flex-direction: column; align-items: center;"><div style="position: relative; width: 200px; height: 120px; margin-bottom: 16px;"><canvas id="floor-ghost-gauge" width="200" height="120"></canvas><div style="position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); text-align: center;"><div id="floor-ghost-value" style="font-size: 32px; font-weight: 700; line-height: 1;">--</div><div style="font-size: 11px; color: var(--text-secondary); margin-top: 2px;" id="floor-ghost-pill">--</div></div></div><div style="font-size: 16px; font-weight: 600; color: var(--text-primary); text-align: center; margin-bottom: 8px;">Ghost Rate</div><div style="display: flex; flex-direction: column; gap: 6px; font-size: 11px; color: var(--text-secondary); text-align: center;"><div id="floor-ghost-playable">Playable: -- games</div><div id="floor-ghost-boom">Boom: -- games</div><div id="floor-ghost-bust">Bust: -- games</div></div></div></div><div style="margin-top: 32px; padding: 16px; background: rgba(255, 255, 255, 0.05); border-radius: 12px; max-width: 700px; margin-left: auto; margin-right: auto;"><div style="display: grid; gap: 12px; font-size: 12px; color: var(--text-secondary); line-height: 1.5;"><div><strong style="color: var(--text-primary);">Fragility Score (0-100):</strong> Measures scoring volatility and touchdown dependency. Lower scores indicate more reliable, consistent fantasy production.
</div><div><strong style="color: var(--text-primary);">Ghost Rate:</strong> Percentage of games scoring under 8 fantasy points. Lower rates indicate a more dependable fantasy floor.
</div></div></div></div></div><div id="modal-chart-candles" class="chart-content"><div style="padding: 20px;"><div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 24px;"><div style="display: flex; align-items: center; gap: 8px;"><h3 style="font-size: 20px; font-weight: 700; color: var(--text-primary); margin: 0;">Performance Candles</h3><div style="position: relative; display: inline-block;"><span style="cursor: help; color: var(--text-secondary); font-size: 16px;"
onmouseover="document.getElementById('candles-tooltip').style.display='block'"
onmouseout="document.getElementById('candles-tooltip').style.display='none'">â“˜</span><div id="candles-tooltip" style="display: none; position: absolute; left: 100%; top: 50%; transform: translateY(-50%); margin-left: 8px; background: var(--bg-elevated); padding: 12px; border-radius: 8px; width: 280px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 1000; font-size: 12px; color: var(--text-secondary); line-height: 1.5;">
Shows weekly points scored above or below expected value. Green candles = exceeded projection, Red candles = missed projection. Adjusted for your scoring format.
</div></div></div><div style="font-size: 12px; color: var(--text-secondary);"><span id="candles-scoring-format">PPR</span> Scoring
</div></div><div style="background: var(--bg-tertiary); border-radius: 12px; padding: 24px; max-width: 900px; margin: 0 auto;"><canvas id="modal-candles-chart" style="max-height: 400px;"></canvas></div><div style="margin-top: 20px; display: flex; justify-content: center; gap: 32px; flex-wrap: wrap; font-size: 13px;"><div style="display: flex; align-items: center; gap: 8px;"><div style="width: 16px; height: 24px; background: var(--positive); border-radius: 2px;"></div><span style="color: var(--text-secondary);">Above Expected</span></div><div style="display: flex; align-items: center; gap: 8px;"><div style="width: 16px; height: 24px; background: var(--negative); border-radius: 2px;"></div><span style="color: var(--text-secondary);">Below Expected</span></div></div><div id="candles-summary" style="margin-top: 32px; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; max-width: 700px; margin-left: auto; margin-right: auto;"></div></div></div><div id="modal-chart-schedule" class="chart-content"><div style="padding: 32px 20px;"><div id="modal-schedule-chart-content" style="max-width: 800px; margin: 0 auto;"><div style="text-align: center; color: var(--text-secondary); padding: 40px 20px;">
Loading schedule data...
</div></div></div></div><div class="comment-section"><div class="comment-header">Quick Takes</div><div class="comment-input-container"><input type="text" class="comment-input" id="comment-input" placeholder="Share your take (280 chars max)" maxlength="280"><button class="comment-submit" onclick="submitComment()">Post</button></div><div class="comment-list" id="comment-list"></div></div></div></div></div><div class="modal-overlay" id="team-modal"><div class="modal"><div class="modal-header"><div style="display: flex; justify-content: space-between; align-items: flex-start;"><div class="modal-player-info"><div class="modal-team-badge" id="team-modal-badge"></div><div class="modal-player-details"><div class="modal-player-name" id="team-modal-name"></div><div class="modal-player-meta" id="team-modal-meta"></div></div></div><button class="modal-close" onclick="closeTeamModal()">Ã—</button></div></div><div class="modal-body"><div class="team-stats-summary" id="team-stats-summary" style="display: none;"></div><button onclick="toggleTeamPlayers()" id="team-players-collapse-btn" style="width: 100%; padding: 8px; background: transparent; border: none; border-top: 1px solid var(--border-color); color: var(--text-secondary); font-size: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px; transition: all 0.2s;"><span id="team-players-collapse-icon">â–¼</span><span id="team-players-collapse-text">Hide Players</span></button><div class="key-players-section" id="key-players-section" style="margin-bottom: 24px;"><h3 style="font-size: 16px; font-weight: 700; margin-bottom: 12px; color: var(--text-primary);">Key Players</h3><div id="key-players-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;"></div></div><div id="team-modal-controls-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;"><div><label style="display: block; font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px;">Metric</label><select id="team-modal-metric" onchange="updateTeamModalCharts()" style="width: 100%; padding: 10px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 14px; cursor: pointer;"><option value="points">Points</option><option value="targets">Targets</option><option value="redzone">Red Zone Opps</option></select></div><div><label style="display: block; font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px;">Time Frame</label><select id="team-modal-timeframe" onchange="updateTeamModalCharts()" style="width: 100%; padding: 10px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 14px; cursor: pointer;"><option value="season">Season Long</option><option value="season-avg">Season Avg</option><option value="last5">Last 5 Weeks</option><option value="last3">Last 3 Weeks</option><option value="single">Single Week</option></select></div><div id="team-modal-week-selector" style="display: none; grid-column: span 2;"><label style="display: block; font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px;">Select Week</label><select id="team-modal-week" onchange="updateTeamModalCharts()" style="width: 100%; padding: 10px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 14px; cursor: pointer;"></select></div></div><div class="team-modal-charts-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;"><div class="chart-card"><div class="chart-header" id="team-modal-players-chart-header">Top 6 Players by Points</div><div class="chart-wrapper" style="height: 300px;"><canvas id="team-modal-players-chart"></canvas></div></div><div class="chart-card"><div class="chart-header" id="team-modal-position-chart-header">Points by Position</div><div class="chart-wrapper" style="height: 300px;"><canvas id="team-modal-position-chart"></canvas></div></div></div></div></div></div><div class="modal-overlay" id="login-modal" style="display: none;"><div class="modal" style="max-width: 400px;"><div class="modal-header"><h2 style="font-size: 20px; font-weight: 700; color: var(--text-primary);">Admin Login</h2><button class="modal-close" onclick="closeLoginModal()">Ã—</button></div><div class="modal-body"><form onsubmit="handleLogin(event)" style="display: flex; flex-direction: column; gap: 16px;"><div><label style="display: block; font-size: 13px; color: var(--text-secondary); margin-bottom: 6px;">Email</label><input
type="email"
id="login-email"
class="waitlist-input"
placeholder="admin@ffse.com"
required
style="width: 100%;"
/></div><div><label style="display: block; font-size: 13px; color: var(--text-secondary); margin-bottom: 6px;">Password</label><input
type="password"
id="login-password"
class="waitlist-input"
placeholder="Enter password"
required
style="width: 100%;"
/></div><button type="submit" class="waitlist-btn" onclick="handleLogin(event); return false;" style="width: 100%; padding: 12px;">
Login
</button></form><div class="success-message" id="login-error" style="background: var(--negative-bg); border-color: var(--negative); color: var(--negative);">
Invalid credentials
</div></div></div></div><div class="modal-overlay" id="privacy-modal" style="display: none;"><div class="modal" style="max-width: 700px; max-height: 80vh; overflow-y: auto;"><div class="modal-header"><h2 style="font-size: 20px; font-weight: 700; color: var(--text-primary);">Privacy Policy</h2><button class="modal-close" onclick="closePrivacyModal()">Ã—</button></div><div class="modal-body" style="color: var(--text-secondary); line-height: 1.6;"><p style="margin-bottom: 16px; color: var(--text-tertiary); font-size: 13px;"><strong>Effective Date:</strong> November 2025
</p><h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">1. Information We Collect</h3><p style="margin-bottom: 12px; font-size: 14px;">
We collect information you provide directly to us, including:
</p><ul style="margin-left: 24px; margin-bottom: 16px; font-size: 14px;"><li style="margin-bottom: 8px;">Email addresses submitted through our waitlist</li><li style="margin-bottom: 8px;">Usage data and analytics about how you interact with our platform</li><li style="margin-bottom: 8px;">Device and browser information</li></ul><h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">2. How We Use Your Information</h3><p style="margin-bottom: 12px; font-size: 14px;">
We use the information we collect to:
</p><ul style="margin-left: 24px; margin-bottom: 16px; font-size: 14px;"><li style="margin-bottom: 8px;">Provide, maintain, and improve our services</li><li style="margin-bottom: 8px;">Send you updates about FFSE features and releases</li><li style="margin-bottom: 8px;">Respond to your comments and questions</li><li style="margin-bottom: 8px;">Analyze usage patterns to enhance user experience</li></ul><h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">3. Information Sharing</h3><p style="margin-bottom: 16px; font-size: 14px;">
We do not sell, trade, or rent your personal information to third parties. We may share your information only in the following circumstances:
</p><ul style="margin-left: 24px; margin-bottom: 16px; font-size: 14px;"><li style="margin-bottom: 8px;">With your consent</li><li style="margin-bottom: 8px;">To comply with legal obligations</li><li style="margin-bottom: 8px;">With service providers who assist in our operations</li></ul><h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">4. Data Security</h3><p style="margin-bottom: 16px; font-size: 14px;">
We implement appropriate technical and organizational measures to protect your personal information against unauthorized access, alteration, disclosure, or destruction.
</p><h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">5. Cookies and Tracking</h3><p style="margin-bottom: 16px; font-size: 14px;">
We use cookies and similar tracking technologies to collect information about your browsing activities and to remember your preferences. You can control cookies through your browser settings.
</p><h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">6. Your Rights</h3><p style="margin-bottom: 12px; font-size: 14px;">
You have the right to:
</p><ul style="margin-left: 24px; margin-bottom: 16px; font-size: 14px;"><li style="margin-bottom: 8px;">Access the personal information we hold about you</li><li style="margin-bottom: 8px;">Request correction of inaccurate information</li><li style="margin-bottom: 8px;">Request deletion of your information</li><li style="margin-bottom: 8px;">Opt-out of marketing communications</li></ul><h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">7. Children's Privacy</h3><p style="margin-bottom: 16px; font-size: 14px;">
Our service is not directed to individuals under the age of 13. We do not knowingly collect personal information from children under 13.
</p><h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">8. Changes to This Policy</h3><p style="margin-bottom: 16px; font-size: 14px;">
We may update this Privacy Policy from time to time. We will notify you of any changes by posting the new Privacy Policy on this page and updating the "Effective Date."
</p><h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">9. Contact Us</h3><p style="margin-bottom: 16px; font-size: 14px;">
If you have any questions about this Privacy Policy, please contact us through the FFSE platform.
</p><div style="margin-top: 32px; padding-top: 24px; border-top: 1px solid var(--border-color);"><p style="font-size: 12px; color: var(--text-tertiary);">
By using FFSE, you acknowledge that you have read and understood this Privacy Policy.
</p></div></div></div></div><input type="file" id="wr-file-input" accept=".csv" onchange="handleWRUpload(event)"><input type="file" id="rb-file-input" accept=".csv" onchange="handleRBUpload(event)"><script>
// Disable datalabels plugin by default for all charts
Chart.defaults.set('plugins.datalabels', {
display: false
});

function loadTheme() {
const savedTheme = localStorage.getItem('ffse-theme') || 'dark';
document.documentElement.setAttribute('data-theme', savedTheme);
}
function getThemeColors() {
const isDark = !document.documentElement.getAttribute('data-theme') || document.documentElement.getAttribute('data-theme') === 'dark';
return {
text: isDark ? '#ffffff' : '#1a1a1a',
textSecondary: isDark ? '#8e8e93' : '#5a5a5a',
grid: isDark ? '#1c1c1e' : '#eceae5',
gridLight: isDark ? '#2c2c2e' : '#d9d7d2'
};
}
function toggleTheme() {
const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
document.documentElement.setAttribute('data-theme', newTheme);
localStorage.setItem('ffse-theme', newTheme);
console.log(`ðŸŽ¨ Theme switched to ${newTheme} mode`);
if (currentModalPlayer) {
renderModalRadarChart(currentModalPlayer);
}
if (currentTeamAnalysisTeam) {
updateTeamModalCharts();
}
// Redraw team outlook charts when theme changes
const teamsPage = document.getElementById('teams');
if (teamsPage && teamsPage.classList.contains('active')) {
renderTeamBalanceScatter();
renderDashboardCombinedTrend();
}
}
loadTheme();
const NFL_SCHEDULE_2025 = {
'ARI': { // Arizona Cardinals (BYE: Week 8)
11: { week: 11, opponent: 'SF', home: false },
12: { week: 12, opponent: 'JAC', home: true },
13: { week: 13, opponent: 'TB', home: false },
14: { week: 14, opponent: 'LAR', home: true },
15: { week: 15, opponent: 'HOU', home: false },
16: { week: 16, opponent: 'ATL', home: true },
17: { week: 17, opponent: 'CIN', home: false },
18: { week: 18, opponent: 'LAR', home: false }
},
'ATL': { // Atlanta Falcons (BYE: Week 5)
11: { week: 11, opponent: 'CAR', home: true },
12: { week: 12, opponent: 'NO', home: false },
13: { week: 13, opponent: 'NYJ', home: false },
14: { week: 14, opponent: 'SEA', home: true },
15: { week: 15, opponent: 'TB', home: false },
16: { week: 16, opponent: 'ARI', home: false },
17: { week: 17, opponent: 'LAR', home: true },
18: { week: 18, opponent: 'NO', home: true }
},
'BAL': { // Baltimore Ravens (BYE: Week 7)
11: { week: 11, opponent: 'CLE', home: false },
12: { week: 12, opponent: 'NYJ', home: true },
13: { week: 13, opponent: 'CIN', home: true },
14: { week: 14, opponent: 'PIT', home: true },
15: { week: 15, opponent: 'CIN', home: false },
16: { week: 16, opponent: 'NE', home: true },
17: { week: 17, opponent: 'GB', home: false },
18: { week: 18, opponent: 'PIT', home: false }
},
'BUF': { // Buffalo Bills (BYE: Week 7)
11: { week: 11, opponent: 'TB', home: true },
12: { week: 12, opponent: 'HOU', home: false },
13: { week: 13, opponent: 'PIT', home: false },
14: { week: 14, opponent: 'CIN', home: true },
15: { week: 15, opponent: 'NE', home: false },
16: { week: 16, opponent: 'CLE', home: false },
17: { week: 17, opponent: 'PHI', home: true },
18: { week: 18, opponent: 'NYJ', home: true }
},
'CAR': { // Carolina Panthers (BYE: Week 14)
11: { week: 11, opponent: 'ATL', home: false },
12: { week: 12, opponent: 'SF', home: false },
13: { week: 13, opponent: 'LAR', home: true },
14: { week: 14, opponent: 'BYE', home: null },
15: { week: 15, opponent: 'NO', home: false },
16: { week: 16, opponent: 'TB', home: true },
17: { week: 17, opponent: 'SEA', home: true },
18: { week: 18, opponent: 'TB', home: false }
},
'CHI': { // Chicago Bears (BYE: Week 5)
11: { week: 11, opponent: 'MIN', home: false },
12: { week: 12, opponent: 'PIT', home: true },
13: { week: 13, opponent: 'PHI', home: false },
14: { week: 14, opponent: 'GB', home: false },
15: { week: 15, opponent: 'CLE', home: true },
16: { week: 16, opponent: 'GB', home: true },
17: { week: 17, opponent: 'SF', home: false },
18: { week: 18, opponent: 'DET', home: true }
},
'CIN': { // Cincinnati Bengals (BYE: Week 10)
11: { week: 11, opponent: 'PIT', home: false },
12: { week: 12, opponent: 'NE', home: true },
13: { week: 13, opponent: 'BAL', home: false },
14: { week: 14, opponent: 'BUF', home: false },
15: { week: 15, opponent: 'BAL', home: true },
16: { week: 16, opponent: 'MIA', home: false },
17: { week: 17, opponent: 'ARI', home: true },
18: { week: 18, opponent: 'CLE', home: true }
},
'CLE': { // Cleveland Browns (BYE: Week 9)
11: { week: 11, opponent: 'BAL', home: true },
12: { week: 12, opponent: 'LV', home: false },
13: { week: 13, opponent: 'SF', home: true },
14: { week: 14, opponent: 'TEN', home: true },
15: { week: 15, opponent: 'CHI', home: false },
16: { week: 16, opponent: 'BUF', home: true },
17: { week: 17, opponent: 'PIT', home: true },
18: { week: 18, opponent: 'CIN', home: false }
},
'DAL': { // Dallas Cowboys (BYE: Week 10)
11: { week: 11, opponent: 'LV', home: false },
12: { week: 12, opponent: 'PHI', home: true },
13: { week: 13, opponent: 'KC', home: true },
14: { week: 14, opponent: 'DET', home: false },
15: { week: 15, opponent: 'MIN', home: true },
16: { week: 16, opponent: 'LAC', home: true },
17: { week: 17, opponent: 'WAS', home: false },
18: { week: 18, opponent: 'NYG', home: false }
},
'DEN': { // Denver Broncos (BYE: Week 12)
11: { week: 11, opponent: 'KC', home: true },
12: { week: 12, opponent: 'BYE', home: null },
13: { week: 13, opponent: 'WAS', home: false },
14: { week: 14, opponent: 'LV', home: false },
15: { week: 15, opponent: 'GB', home: true },
16: { week: 16, opponent: 'JAC', home: true },
17: { week: 17, opponent: 'KC', home: false },
18: { week: 18, opponent: 'LAC', home: true }
},
'DET': { // Detroit Lions (BYE: Week 8)
11: { week: 11, opponent: 'PHI', home: false },
12: { week: 12, opponent: 'NYG', home: true },
13: { week: 13, opponent: 'GB', home: true },
14: { week: 14, opponent: 'DAL', home: true },
15: { week: 15, opponent: 'LAR', home: false },
16: { week: 16, opponent: 'PIT', home: true },
17: { week: 17, opponent: 'MIN', home: false },
18: { week: 18, opponent: 'CHI', home: false }
},
'GB': { // Green Bay Packers (BYE: Week 5)
11: { week: 11, opponent: 'NYG', home: false },
12: { week: 12, opponent: 'MIN', home: true },
13: { week: 13, opponent: 'DET', home: false },
14: { week: 14, opponent: 'CHI', home: true },
15: { week: 15, opponent: 'DEN', home: false },
16: { week: 16, opponent: 'CHI', home: false },
17: { week: 17, opponent: 'BAL', home: true },
18: { week: 18, opponent: 'MIN', home: false }
},
'HOU': { // Houston Texans (BYE: Week 6)
11: { week: 11, opponent: 'TEN', home: false },
12: { week: 12, opponent: 'BUF', home: true },
13: { week: 13, opponent: 'IND', home: false },
14: { week: 14, opponent: 'KC', home: false },
15: { week: 15, opponent: 'ARI', home: true },
16: { week: 16, opponent: 'LV', home: true },
17: { week: 17, opponent: 'LAC', home: false },
18: { week: 18, opponent: 'IND', home: true }
},
'IND': { // Indianapolis Colts (BYE: Week 11)
11: { week: 11, opponent: 'BYE', home: null },
12: { week: 12, opponent: 'KC', home: false },
13: { week: 13, opponent: 'HOU', home: true },
14: { week: 14, opponent: 'JAC', home: false },
15: { week: 15, opponent: 'SEA', home: false },
16: { week: 16, opponent: 'SF', home: true },
17: { week: 17, opponent: 'JAC', home: true },
18: { week: 18, opponent: 'HOU', home: false }
},
'JAC': { // Jacksonville Jaguars (BYE: Week 8)
11: { week: 11, opponent: 'LV', home: true },
12: { week: 12, opponent: 'ARI', home: false },
13: { week: 13, opponent: 'SF', home: true },
14: { week: 14, opponent: 'IND', home: true },
15: { week: 15, opponent: 'NYJ', home: true },
16: { week: 16, opponent: 'DEN', home: false },
17: { week: 17, opponent: 'IND', home: false },
18: { week: 18, opponent: 'TEN', home: true }
},
'KC': { // Kansas City Chiefs (BYE: Week 10)
11: { week: 11, opponent: 'DEN', home: false },
12: { week: 12, opponent: 'IND', home: true },
13: { week: 13, opponent: 'DAL', home: false },
14: { week: 14, opponent: 'HOU', home: true },
15: { week: 15, opponent: 'LAC', home: true },
16: { week: 16, opponent: 'TEN', home: false },
17: { week: 17, opponent: 'DEN', home: true },
18: { week: 18, opponent: 'LV', home: false }
},
'LV': { // Las Vegas Raiders (BYE: Week 8)
11: { week: 11, opponent: 'JAC', home: false },
12: { week: 12, opponent: 'CLE', home: true },
13: { week: 13, opponent: 'LAC', home: false },
14: { week: 14, opponent: 'DEN', home: true },
15: { week: 15, opponent: 'PHI', home: false },
16: { week: 16, opponent: 'HOU', home: false },
17: { week: 17, opponent: 'NYG', home: true },
18: { week: 18, opponent: 'KC', home: true }
},
'LAC': { // Los Angeles Chargers (BYE: Week 12)
11: { week: 11, opponent: 'JAC', home: false },
12: { week: 12, opponent: 'BYE', home: null },
13: { week: 13, opponent: 'LV', home: true },
14: { week: 14, opponent: 'PHI', home: true },
15: { week: 15, opponent: 'KC', home: false },
16: { week: 16, opponent: 'DAL', home: false },
17: { week: 17, opponent: 'HOU', home: true },
18: { week: 18, opponent: 'DEN', home: false }
},
'LAR': { // Los Angeles Rams (BYE: Week 8)
11: { week: 11, opponent: 'SF', home: false },
12: { week: 12, opponent: 'TB', home: true },
13: { week: 13, opponent: 'CAR', home: false },
14: { week: 14, opponent: 'ARI', home: false },
15: { week: 15, opponent: 'DET', home: true },
16: { week: 16, opponent: 'SEA', home: false },
17: { week: 17, opponent: 'ATL', home: false },
18: { week: 18, opponent: 'ARI', home: true }
},
'MIA': { // Miami Dolphins (BYE: Week 12)
11: { week: 11, opponent: 'WAS', home: true },
12: { week: 12, opponent: 'BYE', home: null },
13: { week: 13, opponent: 'NO', home: true },
14: { week: 14, opponent: 'NYJ', home: false },
15: { week: 15, opponent: 'PIT', home: false },
16: { week: 16, opponent: 'CIN', home: true },
17: { week: 17, opponent: 'TB', home: true },
18: { week: 18, opponent: 'NE', home: false }
},
'MIN': { // Minnesota Vikings (BYE: Week 6)
11: { week: 11, opponent: 'CHI', home: true },
12: { week: 12, opponent: 'GB', home: false },
13: { week: 13, opponent: 'SEA', home: false },
14: { week: 14, opponent: 'WAS', home: true },
15: { week: 15, opponent: 'DAL', home: false },
16: { week: 16, opponent: 'NYG', home: false },
17: { week: 17, opponent: 'DET', home: true },
18: { week: 18, opponent: 'GB', home: true }
},
'NE': { // New England Patriots (BYE: Week 14)
11: { week: 11, opponent: 'NYJ', home: true },
12: { week: 12, opponent: 'CIN', home: false },
13: { week: 13, opponent: 'NYG', home: false },
14: { week: 14, opponent: 'BYE', home: null },
15: { week: 15, opponent: 'BUF', home: true },
16: { week: 16, opponent: 'BAL', home: false },
17: { week: 17, opponent: 'NYJ', home: false },
18: { week: 18, opponent: 'MIA', home: true }
},
'NO': { // New Orleans Saints (BYE: Week 11)
11: { week: 11, opponent: 'BYE', home: null },
12: { week: 12, opponent: 'ATL', home: true },
13: { week: 13, opponent: 'MIA', home: false },
14: { week: 14, opponent: 'TB', home: false },
15: { week: 15, opponent: 'CAR', home: true },
16: { week: 16, opponent: 'NYJ', home: true },
17: { week: 17, opponent: 'TEN', home: false },
18: { week: 18, opponent: 'ATL', home: false }
},
'NYG': { // New York Giants (BYE: Week 14)
11: { week: 11, opponent: 'GB', home: true },
12: { week: 12, opponent: 'DET', home: false },
13: { week: 13, opponent: 'NE', home: true },
14: { week: 14, opponent: 'BYE', home: null },
15: { week: 15, opponent: 'WAS', home: true },
16: { week: 16, opponent: 'MIN', home: true },
17: { week: 17, opponent: 'LV', home: false },
18: { week: 18, opponent: 'DAL', home: true }
},
'NYJ': { // New York Jets (BYE: Week 9)
11: { week: 11, opponent: 'NE', home: false },
12: { week: 12, opponent: 'BAL', home: false },
13: { week: 13, opponent: 'ATL', home: true },
14: { week: 14, opponent: 'MIA', home: true },
15: { week: 15, opponent: 'JAC', home: false },
16: { week: 16, opponent: 'NO', home: false },
17: { week: 17, opponent: 'NE', home: true },
18: { week: 18, opponent: 'BUF', home: false }
},
'PHI': { // Philadelphia Eagles (BYE: Week 9)
11: { week: 11, opponent: 'DET', home: true },
12: { week: 12, opponent: 'DAL', home: false },
13: { week: 13, opponent: 'CHI', home: true },
14: { week: 14, opponent: 'LAC', home: false },
15: { week: 15, opponent: 'LV', home: true },
16: { week: 16, opponent: 'WAS', home: false },
17: { week: 17, opponent: 'BUF', home: false },
18: { week: 18, opponent: 'WAS', home: true }
},
'PIT': { // Pittsburgh Steelers (BYE: Week 5)
11: { week: 11, opponent: 'CIN', home: true },
12: { week: 12, opponent: 'CHI', home: false },
13: { week: 13, opponent: 'BUF', home: true },
14: { week: 14, opponent: 'BAL', home: false },
15: { week: 15, opponent: 'MIA', home: true },
16: { week: 16, opponent: 'DET', home: false },
17: { week: 17, opponent: 'CLE', home: false },
18: { week: 18, opponent: 'BAL', home: true }
},
'SF': { // San Francisco 49ers (BYE: Week 14)
11: { week: 11, opponent: 'LAR', home: true },
12: { week: 12, opponent: 'CAR', home: true },
13: { week: 13, opponent: 'JAC', home: false },
14: { week: 14, opponent: 'BYE', home: null },
15: { week: 15, opponent: 'TEN', home: true },
16: { week: 16, opponent: 'IND', home: false },
17: { week: 17, opponent: 'CHI', home: true },
18: { week: 18, opponent: 'SEA', home: true }
},
'SEA': { // Seattle Seahawks (BYE: Week 8)
11: { week: 11, opponent: 'LAR', home: true },
12: { week: 12, opponent: 'TEN', home: true },
13: { week: 13, opponent: 'MIN', home: true },
14: { week: 14, opponent: 'ATL', home: false },
15: { week: 15, opponent: 'IND', home: true },
16: { week: 16, opponent: 'LAR', home: true },
17: { week: 17, opponent: 'CAR', home: false },
18: { week: 18, opponent: 'SF', home: false }
},
'TB': { // Tampa Bay Buccaneers (BYE: Week 9)
11: { week: 11, opponent: 'BUF', home: false },
12: { week: 12, opponent: 'LAR', home: false },
13: { week: 13, opponent: 'ARI', home: true },
14: { week: 14, opponent: 'NO', home: true },
15: { week: 15, opponent: 'ATL', home: true },
16: { week: 16, opponent: 'CAR', home: false },
17: { week: 17, opponent: 'MIA', home: false },
18: { week: 18, opponent: 'CAR', home: true }
},
'TEN': { // Tennessee Titans (BYE: Week 10)
11: { week: 11, opponent: 'HOU', home: true },
12: { week: 12, opponent: 'SEA', home: false },
13: { week: 13, opponent: 'JAC', home: false },
14: { week: 14, opponent: 'CLE', home: false },
15: { week: 15, opponent: 'SF', home: false },
16: { week: 16, opponent: 'KC', home: true },
17: { week: 17, opponent: 'NO', home: true },
18: { week: 18, opponent: 'JAC', home: false }
},
'WAS': { // Washington Commanders (BYE: Week 12)
11: { week: 11, opponent: 'MIA', home: false },
12: { week: 12, opponent: 'BYE', home: null },
13: { week: 13, opponent: 'DEN', home: true },
14: { week: 14, opponent: 'MIN', home: false },
15: { week: 15, opponent: 'NYG', home: false },
16: { week: 16, opponent: 'PHI', home: true },
17: { week: 17, opponent: 'DAL', home: true },
18: { week: 18, opponent: 'PHI', home: false }
}
};
function getOpponent(team, week) {
if (!NFL_SCHEDULE_2025[team] || !NFL_SCHEDULE_2025[team][week]) {
return null;
}
return NFL_SCHEDULE_2025[team][week];
}
if (typeof module !== 'undefined' && module.exports) {
module.exports = { NFL_SCHEDULE_2025, getOpponent };
}
const POINTS_ALLOWED_VS_POSITION = {
'ARI': { vsQB: 11, vsRB: 22, vsWR: 19, vsTE: 16 },
'ATL': { vsQB: 2, vsRB: 31, vsWR: 10, vsTE: 2 },
'BAL': { vsQB: 5, vsRB: 28, vsWR: 29, vsTE: 10 },
'BUF': { vsQB: 4, vsRB: 29, vsWR: 15, vsTE: 1 },
'CAR': { vsQB: 17, vsRB: 16, vsWR: 5, vsTE: 26 },
'CHI': { vsQB: 13, vsRB: 20, vsWR: 30, vsTE: 22 },
'CIN': { vsQB: 1, vsRB: 32, vsWR: 11, vsTE: 32 },
'CLE': { vsQB: 27, vsRB: 6, vsWR: 16, vsTE: 12 },
'DAL': { vsQB: 10, vsRB: 23, vsWR: 28, vsTE: 14 },
'DEN': { vsQB: 26, vsRB: 7, vsWR: 2, vsTE: 9 },
'DET': { vsQB: 29, vsRB: 4, vsWR: 25, vsTE: 15 },
'GB': { vsQB: 31, vsRB: 2, vsWR: 8, vsTE: 17 },
'HOU': { vsQB: 21, vsRB: 12, vsWR: 6, vsTE: 4 },
'IND': { vsQB: 22, vsRB: 11, vsWR: 23, vsTE: 27 },
'JAC': { vsQB: 23, vsRB: 10, vsWR: 24, vsTE: 31 },
'KC': { vsQB: 28, vsRB: 5, vsWR: 1, vsTE: 6 },
'LV': { vsQB: 15, vsRB: 18, vsWR: 27, vsTE: 5 },
'LAC': { vsQB: 19, vsRB: 14, vsWR: 3, vsTE: 7 },
'LAR': { vsQB: 32, vsRB: 1, vsWR: 18, vsTE: 21 },
'MIA': { vsQB: 7, vsRB: 26, vsWR: 4, vsTE: 30 },
'MIN': { vsQB: 20, vsRB: 13, vsWR: 9, vsTE: 23 },
'NE': { vsQB: 30, vsRB: 3, vsWR: 21, vsTE: 24 },
'NO': { vsQB: 14, vsRB: 19, vsWR: 14, vsTE: 18 },
'NYG': { vsQB: 3, vsRB: 30, vsWR: 26, vsTE: 13 },
'NYJ': { vsQB: 12, vsRB: 21, vsWR: 13, vsTE: 20 },
'PHI': { vsQB: 18, vsRB: 15, vsWR: 7, vsTE: 3 },
'PIT': { vsQB: 24, vsRB: 9, vsWR: 32, vsTE: 29 },
'SF': { vsQB: 16, vsRB: 17, vsWR: 22, vsTE: 19 },
'SEA': { vsQB: 25, vsRB: 8, vsWR: 12, vsTE: 28 },
'TB': { vsQB: 8, vsRB: 25, vsWR: 20, vsTE: 11 },
'TEN': { vsQB: 9, vsRB: 24, vsWR: 17, vsTE: 8 },
'WAS': { vsQB: 6, vsRB: 27, vsWR: 31, vsTE: 25 }
};
const PASS_DEFENSE_RANKS = {
'ATL': { rank: 1, yardsAllowed: 158.1, tdsAllowed: 13 },
'BUF': { rank: 2, yardsAllowed: 169.9, tdsAllowed: 7 },
'LAC': { rank: 3, yardsAllowed: 177.1, tdsAllowed: 8 },
'HOU': { rank: 4, yardsAllowed: 177.5, tdsAllowed: 8 },
'DEN': { rank: 5, yardsAllowed: 179.5, tdsAllowed: 8 },
'CLE': { rank: 6, yardsAllowed: 182.6, tdsAllowed: 15 },
'KC': { rank: 7, yardsAllowed: 187.2, tdsAllowed: 9 },
'MIN': { rank: 8, yardsAllowed: 194.5, tdsAllowed: 13 },
'GB': { rank: 9, yardsAllowed: 197, tdsAllowed: 12 },
'MIA': { rank: 10, yardsAllowed: 198.1, tdsAllowed: 15 },
'NYJ': { rank: 11, yardsAllowed: 199.6, tdsAllowed: 15 },
'DET': { rank: 12, yardsAllowed: 200.3, tdsAllowed: 16 },
'LAR': { rank: 13, yardsAllowed: 203.1, tdsAllowed: 9 },
'NO': { rank: 14, yardsAllowed: 203.9, tdsAllowed: 18 },
'CAR': { rank: 15, yardsAllowed: 205.8, tdsAllowed: 11 },
'LV': { rank: 16, yardsAllowed: 214.2, tdsAllowed: 12 },
'TEN': { rank: 17, yardsAllowed: 215.3, tdsAllowed: 14 },
'PHI': { rank: 18, yardsAllowed: 215.9, tdsAllowed: 8 },
'SEA': { rank: 19, yardsAllowed: 218, tdsAllowed: 11 },
'NE': { rank: 20, yardsAllowed: 223.6, tdsAllowed: 15 },
'SF': { rank: 21, yardsAllowed: 223.7, tdsAllowed: 15 },
'TB': { rank: 22, yardsAllowed: 228.8, tdsAllowed: 11 },
'ARI': { rank: 23, yardsAllowed: 231.8, tdsAllowed: 9 },
'NYG': { rank: 24, yardsAllowed: 232.1, tdsAllowed: 15 },
'CHI': { rank: 25, yardsAllowed: 237.6, tdsAllowed: 20 },
'IND': { rank: 26, yardsAllowed: 244.8, tdsAllowed: 15 },
'JAC': { rank: 27, yardsAllowed: 249.3, tdsAllowed: 19 },
'BAL': { rank: 28, yardsAllowed: 250, tdsAllowed: 14 },
'WAS': { rank: 29, yardsAllowed: 253.6, tdsAllowed: 19 },
'DAL': { rank: 30, yardsAllowed: 254.4, tdsAllowed: 22 },
'CIN': { rank: 31, yardsAllowed: 260.1, tdsAllowed: 23 },
'PIT': { rank: 32, yardsAllowed: 278.3, tdsAllowed: 14 }
};
const RUSH_DEFENSE_RANKS = {
'NE': { rank: 1, yardsAllowed: 75.4, tdsAllowed: 3 },
'SEA': { rank: 2, yardsAllowed: 85.9, tdsAllowed: 4 },
'JAC': { rank: 3, yardsAllowed: 86.9, tdsAllowed: 4 },
'IND': { rank: 4, yardsAllowed: 87, tdsAllowed: 6 },
'GB': { rank: 5, yardsAllowed: 89.4, tdsAllowed: 5 },
'HOU': { rank: 6, yardsAllowed: 89.9, tdsAllowed: 7 },
'DEN': { rank: 7, yardsAllowed: 91.2, tdsAllowed: 7 },
'TB': { rank: 8, yardsAllowed: 92.6, tdsAllowed: 7 },
'CLE': { rank: 9, yardsAllowed: 94.3, tdsAllowed: 3 },
'DET': { rank: 10, yardsAllowed: 94.5, tdsAllowed: 6 },
'LAR': { rank: 11, yardsAllowed: 99.8, tdsAllowed: 2 },
'ARI': { rank: 12, yardsAllowed: 103.6, tdsAllowed: 7 },
'KC': { rank: 13, yardsAllowed: 104.6, tdsAllowed: 9 },
'PIT': { rank: 14, yardsAllowed: 105.5, tdsAllowed: 6 },
'LV': { rank: 15, yardsAllowed: 106.6, tdsAllowed: 12 },
'SF': { rank: 16, yardsAllowed: 108.9, tdsAllowed: 5 },
'LAC': { rank: 17, yardsAllowed: 109.7, tdsAllowed: 10 },
'CAR': { rank: 18, yardsAllowed: 110.8, tdsAllowed: 10 },
'PHI': { rank: 19, yardsAllowed: 120.4, tdsAllowed: 10 },
'MIN': { rank: 20, yardsAllowed: 122.3, tdsAllowed: 6 },
'BAL': { rank: 21, yardsAllowed: 123.6, tdsAllowed: 10 },
'WAS': { rank: 22, yardsAllowed: 124.2, tdsAllowed: 7 },
'ATL': { rank: 23, yardsAllowed: 124.4, tdsAllowed: 5 },
'NO': { rank: 24, yardsAllowed: 129.4, tdsAllowed: 8 },
'CHI': { rank: 25, yardsAllowed: 131.1, tdsAllowed: 6 },
'NYJ': { rank: 26, yardsAllowed: 135.8, tdsAllowed: 8 },
'TEN': { rank: 27, yardsAllowed: 141.3, tdsAllowed: 15 },
'BUF': { rank: 28, yardsAllowed: 141.4, tdsAllowed: 12 },
'DAL': { rank: 29, yardsAllowed: 143, tdsAllowed: 11 },
'MIA': { rank: 30, yardsAllowed: 145.6, tdsAllowed: 10 },
'NYG': { rank: 31, yardsAllowed: 150, tdsAllowed: 12 },
'CIN': { rank: 32, yardsAllowed: 166.4, tdsAllowed: 12 }
};
function getVsPositionRank(team, position) {
if (!POINTS_ALLOWED_VS_POSITION[team]) return null;
const posMap = {
'QB': 'vsQB',
'RB': 'vsRB',
'WR': 'vsWR',
'TE': 'vsTE'
};
return POINTS_ALLOWED_VS_POSITION[team][posMap[position]] || null;
}
function getPassDefenseRank(team) {
return PASS_DEFENSE_RANKS[team]?.rank || null;
}
function getRushDefenseRank(team) {
return RUSH_DEFENSE_RANKS[team]?.rank || null;
}
function getDefenseRankClass(rank, type = 'position') {
if (!rank) return 'average';
if (type === 'position') {
if (rank <= 8) return 'bad'; // Hardest (1-8)
if (rank <= 16) return 'tough'; // Tough (9-16)
if (rank <= 24) return 'average'; // Average (17-24)
if (rank <= 28) return 'good'; // Good (25-28)
return 'elite'; // Easiest (29-32)
}
if (type === 'rush') {
if (rank <= 8) return 'bad'; // Hardest (1-8)
if (rank <= 16) return 'tough'; // Tough (9-16)
if (rank <= 24) return 'average'; // Average (17-24)
if (rank <= 28) return 'good'; // Good (25-28)
return 'elite'; // Easiest (29-32)
}
if (type === 'pass') {
if (rank <= 8) return 'bad'; // Hardest (1-8)
if (rank <= 16) return 'tough'; // Tough (9-16)
if (rank <= 24) return 'average'; // Average (17-24)
if (rank <= 28) return 'good'; // Good (25-28)
return 'elite'; // Easiest (29-32)
}
return 'average';
}
function getRankTooltip(rank, type, position = null) {
if (!rank) return '';
if (type === 'position') {
const posName = { 'QB': 'QBs', 'RB': 'RBs', 'WR': 'WRs', 'TE': 'TEs' }[position] || 'this position';
if (rank <= 8) return `${rank}${getOrdinal(rank)} = Hardest matchup`;
if (rank <= 16) return `${rank}${getOrdinal(rank)} = Tough matchup`;
if (rank <= 24) return `${rank}${getOrdinal(rank)} = Average matchup`;
if (rank <= 28) return `${rank}${getOrdinal(rank)} = Good matchup for ${posName}`;
return `${rank}${getOrdinal(rank)} = Elite matchup for ${posName}!`;
}
if (type === 'pass') {
if (rank <= 8) return `${rank}${getOrdinal(rank)} = Toughest pass defense`;
if (rank <= 16) return `${rank}${getOrdinal(rank)} = Tough pass defense`;
if (rank <= 24) return `${rank}${getOrdinal(rank)} = Average pass defense`;
if (rank <= 28) return `${rank}${getOrdinal(rank)} = Favorable pass defense`;
return `${rank}${getOrdinal(rank)} = Best passing matchup!`;
}
if (type === 'rush') {
if (rank <= 8) return `${rank}${getOrdinal(rank)} = Hardest rushing matchup`;
if (rank <= 16) return `${rank}${getOrdinal(rank)} = Tough run defense`;
if (rank <= 24) return `${rank}${getOrdinal(rank)} = Average run defense`;
if (rank <= 28) return `${rank}${getOrdinal(rank)} = Good rushing matchup`;
return `${rank}${getOrdinal(rank)} = Elite rushing matchup!`;
}
return '';
}
function getOrdinal(n) {
const s = ["th", "st", "nd", "rd"];
const v = n % 100;
return s[(v - 20) % 10] || s[v] || s[0];
}
if (typeof module !== 'undefined' && module.exports) {
module.exports = {
POINTS_ALLOWED_VS_POSITION,
PASS_DEFENSE_RANKS,
RUSH_DEFENSE_RANKS,
getVsPositionRank,
getPassDefenseRank,
getRushDefenseRank,
getDefenseRankClass,
getRankTooltip
};
}
const LoadingScreen = {
progressFill: null,
progressText: null,
statusText: null,
startTime: null,
estimatedDuration: 3000, // 3 seconds estimated load time
animationFrame: null,
isComplete: false,
init() {
this.progressFill = document.getElementById('loading-progress-fill');
this.progressText = document.getElementById('loading-percentage');
this.statusText = document.getElementById('loading-status');
this.startTime = Date.now();
this.animateProgress();
},
animateProgress() {
if (this.isComplete) return;

const elapsed = Date.now() - this.startTime;
// Smooth easing function that slows down as it approaches 95%
const progress = Math.min(95, (elapsed / this.estimatedDuration) * 100);
const easedProgress = progress - (Math.sin(progress * 0.02 * Math.PI) * 5);
const smoothProgress = Math.max(0, Math.min(95, easedProgress));

if (this.progressFill) {
this.progressFill.style.width = smoothProgress + '%';
}
if (this.progressText) {
this.progressText.textContent = Math.round(smoothProgress) + '%';
}

this.animationFrame = requestAnimationFrame(() => this.animateProgress());
},
updateProgress(percentage, status) {
// Just update status text, ignore percentage
if (this.statusText && status) {
this.statusText.textContent = status;
}
},
complete() {
this.isComplete = true;
// Quickly finish to 100%
if (this.progressFill) {
this.progressFill.style.width = '100%';
}
if (this.progressText) {
this.progressText.textContent = '100%';
}
if (this.statusText) {
this.statusText.textContent = 'Complete!';
}
setTimeout(() => {
if (this.animationFrame) {
cancelAnimationFrame(this.animationFrame);
}
const loadingScreen = document.getElementById('initial-loading-screen');
if (loadingScreen) {
loadingScreen.classList.add('fade-out');
setTimeout(() => {
loadingScreen.remove();
}, 500);
}
}, 300);
}
};
LoadingScreen.init();
LoadingScreen.updateProgress(5, 'Connecting to data source...');
const positionColors = {
'WR': '#0a84ff', // Blue
'RB': '#30d158', // Green
'TE': '#ff9f0a' // Orange/Amber
};
const teamColors = {
'BUF': '#00338D', 'MIA': '#008E97', 'NE': '#002244', 'NYJ': '#125740',
'BAL': '#241773', 'CIN': '#FB4F14', 'CLE': '#FF3C00', 'PIT': '#FFB612',
'HOU': '#03203F', 'IND': '#002C5F', 'JAC': '#006778', 'JAX': '#006778', 'TEN': '#0C2340',
'DEN': '#002244', 'KC': '#E31837', 'LV': '#A5ACAF', 'LAC': '#0080C6',
'DAL': '#041E42', 'NYG': '#0D2266', 'PHI': '#004C54', 'WAS': '#5A1414',
'CHI': '#0B162A', 'DET': '#0076B6', 'GB': '#203731', 'MIN': '#4F2683',
'ATL': '#A71930', 'CAR': '#0085CA', 'NO': '#D3BC8D', 'TB': '#A71930',
'ARI': '#97233F', 'LAR': '#003594', 'SF': '#AA0000', 'SEA': '#002244'
};
const teamSecondaryColors = {
'BUF': '#C60C30', 'MIA': '#FC4C02', 'NE': '#C60C30', 'NYJ': '#FFFFFF',
'BAL': '#9E7C0C', 'CIN': '#FB4F14', 'CLE': '#FF3C00', 'PIT': '#FFB612',
'HOU': '#E60029', 'IND': '#002C5F', 'JAC': '#9F792C', 'JAX': '#9F792C', 'TEN': '#C8102E',
'DEN': '#FB4F14', 'KC': '#FFB81C', 'LV': '#000000', 'LAC': '#FFC20E',
'DAL': '#041E42', 'NYG': '#A71930', 'PHI': '#2B8C4E', 'WAS': '#FFB612',
'CHI': '#C83803', 'DET': '#0076B6', 'GB': '#FFB612', 'MIN': '#FFC62F',
'ATL': '#A71930', 'CAR': '#0085CA', 'NO': '#D3BC8D', 'TB': '#FF7900',
'ARI': '#FFB612', 'LAR': '#FFD100', 'SF': '#B3995D', 'SEA': '#69BE28'
};
const teamColorPalettes = {
'BAL': ['#241773', '#9E7C0C', '#C8102E', '#8E8AFF'],
'CIN': ['#FB4F14', '#FF8F33', '#FFD6A5', '#FFB300'],
'CLE': ['#5A381E', '#FF3C00', '#FF8F66', '#FFB547'],
'PIT': ['#FFB612', '#00539B', '#C8102E', '#FFD65E'],
'BUF': ['#00338D', '#C60C30', '#66A3FF', '#0096FF'],
'MIA': ['#008E97', '#FC4C02', '#4DD5D0', '#00CFFF'],
'NE': ['#223C67', '#C60C30', '#B0B7BC', '#748FFF'],
'NYJ': ['#125740', '#FFFFFF', '#5DBB63', '#29D98C'],
'HOU': ['#14344C', '#A6192E', '#D6E3F8', '#007BFF'],
'IND': ['#002C5F', '#A2AAAD', '#589BFF', '#00A3E0'],
'JAC': ['#006778', '#D7A22A', '#9F792C', '#00CFCF'],
'JAX': ['#006778', '#D7A22A', '#9F792C', '#00CFCF'],
'TEN': ['#0C2340', '#4B92DB', '#C8102E', '#85BFFF'],
'DEN': ['#FB4F14', '#223C67', '#FFD6A5', '#FFB300'],
'KC': ['#E31837', '#FFB81C', '#FF9A66', '#FFD65E'],
'LV': ['#A5ACAF', '#FFFFFF', '#E6E6E6', '#B8C2CC'],
'LAC': ['#0080C6', '#FFC20E', '#F4F4F4', '#00CFFF'],
'CHI': ['#2E3E66', '#C83803', '#FF8A3D', '#FFB547'],
'DET': ['#0076B6', '#B0B7BC', '#5CB3FF', '#00A3E0'],
'GB': ['#203731', '#FFB81C', '#9FCF5A', '#D9B200'],
'MIN': ['#4F2683', '#FFC62F', '#A285E0', '#8E8AFF'],
'DAL': ['#003594', '#869397', '#A8B0B7', '#8CB5FF'],
'NYG': ['#0B2265', '#A71930', '#7FA9FF', '#007BFF'],
'PHI': ['#004C54', '#A5ACAF', '#2BAEA6', '#00D6B4'],
'WAS': ['#7A2222', '#FFB612', '#FFD65E', '#D2691E'],
'ATL': ['#A71930', '#A5ACAF', '#E94958', '#FFB5C3'],
'CAR': ['#0085CA', '#BFC0BF', '#59C9FF', '#00CFFF'],
'NO': ['#D3BC8D', '#F5E6CC', '#FFF1D4', '#FFD65E'],
'TB': ['#D50A0A', '#FF7900', '#D3D3D3', '#FFD65E'],
'ARI': ['#97233F', '#FFB612', '#E94958', '#FF8C8C'],
'LAR': ['#003594', '#FFA300', '#FFD65E', '#00CFFF'],
'SF': ['#AA0000', '#B3995D', '#FFD65E', '#FF8A8A'],
'SEA': ['#223C67', '#69BE28', '#A5ACAF', '#9EFF78']
};
let wrData = null;
let rbData = null;
let teData = null;
window.wrData = null;
window.rbData = null;
window.teData = null;

// Sleeper API News Integration
let sleeperNewsItems = [];
let lastNewsFetch = 0;
const NEWS_FETCH_INTERVAL = 5 * 60 * 1000; // 5 minutes

// Dynamic Week Tracking
let currentNFLWeek = 10; // Default fallback
let injuryData = {}; // Sleeper API injury data
window.aggregatedWRs = {};
window.aggregatedRBs = {};
window.aggregatedTEs = {};
let currentScoringFormat = localStorage.getItem('ffse_scoring_format') || 'ppr'; // 'ppr', 'half', or 'std'
let allPlayers = {};
let teamStats = {}; // Store team statistics globally for Advanced Analytics
(function initInjuryDataFromCache() {
const cachedData = localStorage.getItem('injuryData');
if (cachedData) {
try {
const parsedCache = JSON.parse(cachedData);
const cacheAge = Date.now() - (parsedCache.timestamp || 0);
if (cacheAge < 3600000) {
injuryData = parsedCache.data;
console.log('Injury data loaded from cache on init:', Object.keys(injuryData).length, 'players');
} else {
console.log('Cached injury data expired, will fetch fresh data');
}
} catch (e) {
console.error('Failed to parse cached injury data on init:', e);
}
} else {
console.log('No cached injury data found, will fetch from API');
}
})();
let teamAnalysisCharts = {
pie: null,
secondary: null
};
let leagueComparisonEnabled = true; // Start with league comparison ON
let currentTeamAnalysisTeam = null;
const nflDivisions = {
'AFC East': ['BUF', 'MIA', 'NYJ', 'NE'],
'AFC North': ['BAL', 'CIN', 'CLE', 'PIT'],
'AFC South': ['HOU', 'IND', 'JAX', 'TEN'],
'AFC West': ['DEN', 'KC', 'LV', 'LAC'],
'NFC East': ['DAL', 'NYG', 'PHI', 'WAS'],
'NFC North': ['CHI', 'DET', 'GB', 'MIN'],
'NFC South': ['ATL', 'CAR', 'NO', 'TB'],
'NFC West': ['ARI', 'LAR', 'SF', 'SEA']
};
const POSITION_COLORS = {
'WR': '#0a84ff', // Blue
'RB': '#30d158', // Green
'TE': '#FF9F0A' // Orange
};
function getPositionColor(position) {
return POSITION_COLORS[position] || '#8e8e93'; // Default gray
}
const firebaseConfig = {
apiKey: "AIzaSyCzzwKuYrpnQqBmdPwVtQRzN90mRN4YFVM",
authDomain: "ffse-92251.firebaseapp.com",
databaseURL: "https://ffse-92251-default-rtdb.firebaseio.com",
projectId: "ffse-92251",
storageBucket: "ffse-92251.firebasestorage.app",
messagingSenderId: "139627274251",
appId: "1:139627274251:web:655b2445fae6ef2736e70e",
measurementId: "G-JJ2D5BEQRS"
};
let firebaseApp;
let database;
let firebaseInitialized = false;
try {
firebaseApp = firebase.initializeApp(firebaseConfig);
database = firebase.database();
firebaseInitialized = true;
console.log('âœ… Firebase initialized successfully');
} catch (error) {
console.error('âŒ Firebase initialization failed:', error);
firebaseInitialized = false;
}
function getUserId() {
let userId = localStorage.getItem('ffse_user_id');
if (!userId) {
userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
localStorage.setItem('ffse_user_id', userId);
}
return userId;
}
let playerVotes = {}; // { playerName: { buy: count, sell: count, hold: count, lastVote: timestamp } }
let playerComments = {}; // { playerName: [ { text, timestamp, user } ] }
let userVoteCache = {}; // Cache of current user's votes
let sentimentDataLoaded = false;
function loadSentimentData() {
if (!firebaseInitialized) {
console.warn('Firebase not initialized, loading from localStorage fallback');
loadSentimentDataFallback();
sentimentDataLoaded = true;
return;
}
const votesRef = database.ref('votes');
votesRef.on('value', (snapshot) => {
const data = snapshot.val();
if (data) {
playerVotes = data;
console.log('ðŸ“Š Loaded vote data from Firebase:', Object.keys(playerVotes).length, 'players with votes');
const firstPlayer = Object.keys(playerVotes)[0];
if (firstPlayer) {
console.log(' Sample data for', firstPlayer, ':', playerVotes[firstPlayer]);
}
} else {
playerVotes = {};
console.log('ðŸ“Š No vote data in Firebase yet');
}
sentimentDataLoaded = true;
if (currentModalPlayer) {
updateModalSentiment(currentModalPlayer.name);
}
refreshPlayerCards();
});
const userId = getUserId();
const userVotesRef = database.ref('userVotes/' + userId);
userVotesRef.on('value', (snapshot) => {
const data = snapshot.val();
userVoteCache = data || {};
console.log('ðŸ‘¤ Loaded user votes from Firebase:', Object.keys(userVoteCache).length, 'votes');
if (currentModalPlayer) {
document.querySelectorAll('.vote-btn').forEach(btn => btn.classList.remove('active'));
const userVote = userVoteCache[currentModalPlayer.name];
if (userVote) {
document.querySelector(`.vote-btn.${userVote}-btn`)?.classList.add('active');
}
}
});
}
function loadSentimentDataFallback() {
const stored = localStorage.getItem('ffse_player_votes');
if (stored) {
playerVotes = JSON.parse(stored);
const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
Object.keys(playerVotes).forEach(player => {
if (playerVotes[player].lastVote < thirtyDaysAgo) {
delete playerVotes[player];
}
});
}
}
function resetAllSentimentData() {
if (firebaseInitialized) {
const userId = getUserId();
database.ref('votes').remove();
database.ref('userVotes/' + userId).remove();
alert('âœ… All sentiment data cleared from Firebase! Refreshing page...');
} else {
localStorage.removeItem('ffse_player_votes');
Object.keys(localStorage).forEach(key => {
if (key.startsWith('ffse_user_vote_')) {
localStorage.removeItem(key);
}
});
alert('âœ… All sentiment data cleared from localStorage! Refreshing page...');
}
playerVotes = {};
userVoteCache = {};
location.reload();
}
function saveSentimentData() {
}
function getSentimentScore(playerName) {
if (!playerVotes[playerName]) {
return { score: 0, buy: 0, sell: 0, hold: 0, total: 0 };
}
const votes = playerVotes[playerName];
const now = Date.now();
const sevenDays = 7 * 24 * 60 * 60 * 1000;
const daysSinceVote = (now - votes.lastVote) / (24 * 60 * 60 * 1000);
const decayFactor = Math.max(0, 1 - (daysSinceVote / 7));
const weightedBuy = (votes.buy || 0) * decayFactor;
const weightedSell = (votes.sell || 0) * decayFactor;
const weightedHold = (votes.hold || 0) * decayFactor;
const total = weightedBuy + weightedSell + weightedHold;
const score = total > 0 ? (weightedBuy - weightedSell) / total : 0;
return {
score: score, // -1 to +1
buy: votes.buy || 0,
sell: votes.sell || 0,
hold: votes.hold || 0,
total: (votes.buy || 0) + (votes.sell || 0) + (votes.hold || 0),
decayFactor: decayFactor
};
}
function getSignalTag(playerData) {
if (!playerData.oppShare || !playerData.weeklyData) return null;
const weeks = playerData.weeklyData.sort((a, b) => b.week - a.week);
if (weeks.length < 4) return null;
const recent2 = weeks.slice(0, 2);
const previous2 = weeks.slice(2, 4);
const recentAvg = recent2.reduce((sum, w) => sum + (parseFloat(w.oppShare) || 0), 0) / 2;
const previousAvg = previous2.reduce((sum, w) => sum + (parseFloat(w.oppShare) || 0), 0) / 2;
const change = recentAvg - previousAvg;
if (change >= 5) return { type: 'trending', label: 'Trending Up', class: 'positive' };
const avgPoints = weeks.reduce((sum, w) => sum + (parseFloat(w.fpts) || 0), 0) / weeks.length;
const variance = weeks.reduce((sum, w) => sum + Math.pow((parseFloat(w.fpts) || 0) - avgPoints, 2), 0) / weeks.length;
const stdDev = Math.sqrt(variance);
if (stdDev <= 3 && weeks.length >= 4) return { type: 'consistent', label: 'Consistent', class: 'neutral' };
const undershoots = weeks.filter(w => {
const actual = parseFloat(w.fpts) || 0;
const expected = parseFloat(w.expected) || actual;
return actual < expected;
}).length;
if (undershoots >= 3 && weeks.length >= 4) return { type: 'oversold', label: 'Buy Low', class: 'opportunity' };
return null;
}
let wrScatterChart = null;
let rbScatterChart = null;
let modalVarianceChart = null;
let modalOutcomesChart = null;
let modalSpiderChart = null;
let modalShareChart = null;
let modalTrendsChart = null;
let teamModalShareChart = null;
let teamModalTrendsChart = null;
let wrEfficiencyMatrix = null;
let wrShareMatrix = null;
let wrFloorMatrix = null;
let wrRedzoneMatrix = null;
let wrVolumeMonsterMatrix = null;
let wrCatchRateMatrix = null;
let rbEfficiencyMatrix = null;
let rbTalentMatrix = null;
function isMobileDevice() {
return window.innerWidth <= 768 || ('ontouchstart' in window);
}
let lastTapTime = 0;
let lastTapPlayer = null;
let stickyTooltipTimeout = null;
let currentStickyTooltip = null;
function createStickyChartTooltip(player, chart, event, additionalData) {
hideStickyChartTooltip();
let playersToShow = [player];
if (additionalData && additionalData.findOverlapping) {
const threshold = additionalData.threshold || 0.3;
const hoveredPoint = additionalData.point;
const overlapping = [];
if (chart && chart.data && chart.data.datasets) {
chart.data.datasets.forEach(dataset => {
if (dataset.data) {
dataset.data.forEach(point => {
if (point.player && hoveredPoint) {
const distance = Math.sqrt(
Math.pow((point.x - hoveredPoint.x), 2) +
Math.pow((point.y - hoveredPoint.y), 2)
);
if (distance < threshold) {
if (!overlapping.find(p => p.id === point.player.id)) {
overlapping.push({
...point.player,
x: point.x,
y: point.y
});
}
}
}
});
}
});
}
if (overlapping.length > 0) {
playersToShow = overlapping;
}
}
const tooltip = document.createElement('div');
tooltip.className = 'sticky-chart-tooltip';
let playersHtml = playersToShow.map((p, index) => {
const color = teamColors[p.team] || '#666';
let statsHtml = '';
if (additionalData && additionalData.stats) {
const statsText = additionalData.stats(p);
statsHtml = statsText.replace(/\n/g, '<br>');
}
return `
${index > 0 ? '<div style="height: 1px; background: rgba(255,255,255,0.1); margin: 8px 0;"></div>' : ''}
<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;"><div style="width: 10px; height: 10px; background: ${color}; border-radius: 2px; flex-shrink: 0;"></div><div style="font-weight: 600;">${p.name}</div></div><div style="font-size: 11px; color: #8e8e93; margin-left: 18px; margin-bottom: 2px;">${p.team}${p.pos ? ' - ' + p.pos : ''}</div>
${statsHtml ? `<div style="font-size: 11px; color: #8e8e93; margin-left: 18px;">${statsHtml}</div>` : ''}
`;
}).join('');
tooltip.innerHTML = `
${playersHtml}
${playersToShow.length > 0 ? `
<button id="tooltip-open-btn" style="
width: 100%;
margin-top: 10px;
padding: 8px 12px;
background: rgba(10, 132, 255, 0.15);
border: 1px solid rgba(10, 132, 255, 0.3);
border-radius: 6px;
color: #0a84ff;
font-size: 12px;
font-weight: 600;
cursor: pointer;
transition: all 0.2s ease;
">
View Player Card â†’
</button>
` : ''}
`;
const rect = chart.canvas.getBoundingClientRect();
const x = event.clientX || (event.touches && event.touches[0].clientX) || rect.left + rect.width / 2;
const y = event.clientY || (event.touches && event.touches[0].clientY) || rect.top + rect.height / 2;
tooltip.style.position = 'fixed';
tooltip.style.left = x + 'px';
tooltip.style.top = (y - 80) + 'px';
tooltip.style.transform = 'translateX(-50%)';
tooltip.style.backgroundColor = 'rgba(28, 28, 30, 0.95)';
tooltip.style.color = 'white';
tooltip.style.padding = '10px 14px';
tooltip.style.borderRadius = '8px';
tooltip.style.fontSize = '13px';
tooltip.style.zIndex = '10000';
tooltip.style.pointerEvents = 'auto';
tooltip.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
tooltip.style.border = '1px solid rgba(255,255,255,0.1)';
tooltip.style.maxWidth = '280px';
tooltip.style.minWidth = '180px';
document.body.appendChild(tooltip);
currentStickyTooltip = tooltip;
const openBtn = document.getElementById('tooltip-open-btn');
if (openBtn && playersToShow.length > 0) {
openBtn.addEventListener('click', function(e) {
e.stopPropagation();
hideStickyChartTooltip();
openPlayerModal(playersToShow[0].id);
});
openBtn.addEventListener('mouseenter', function() {
this.style.background = 'rgba(10, 132, 255, 0.25)';
this.style.borderColor = 'rgba(10, 132, 255, 0.5)';
});
openBtn.addEventListener('mouseleave', function() {
this.style.background = 'rgba(10, 132, 255, 0.15)';
this.style.borderColor = 'rgba(10, 132, 255, 0.3)';
});
}
stickyTooltipTimeout = setTimeout(() => {
hideStickyChartTooltip();
}, 8000);
}
function hideStickyChartTooltip() {
if (currentStickyTooltip) {
currentStickyTooltip.remove();
currentStickyTooltip = null;
}
if (stickyTooltipTimeout) {
clearTimeout(stickyTooltipTimeout);
stickyTooltipTimeout = null;
}
}
function handleChartClick(event, player, openModalFn, additionalData) {
if (!isMobileDevice()) {
openModalFn(player.id);
return;
}
hideStickyChartTooltip();
const chart = event.chart || event.target?.chart;
if (chart) {
createStickyChartTooltip(player, chart, event.native || event, additionalData);
}
}
function getMobileChartTooltipConfig() {
if (!isMobileDevice()) {
return {}; // No changes for desktop
}
return {
enabled: false, // Disable default tooltip on mobile
external: function(context) {
}
};
}
document.addEventListener('touchstart', function(e) {
if (!currentStickyTooltip) return;
const isChart = e.target.tagName === 'CANVAS';
const isTooltip = currentStickyTooltip.contains(e.target);
if (!isChart && !isTooltip) {
hideStickyChartTooltip();
}
});
let rbOpportunityMatrix = null;
let rbShareMatrix = null;
let rbFloorMatrix = null;
let rbRedzoneMatrix = null;

let evaluationDataWR = {};
let evaluationDataRB = {};

let segmentDataWR = {};
let segmentDataRB = {};
let wrEvalVolumeEfficiencyChart = null;
let wrEvalShareRZChart = null;
let rbEvalTotalRZChart = null;
let rbEvalVolumeEfficiencyChart = null;
let evaluationTrendActive = {};
let evaluationTrendIntervals = {};
let evaluationTrendCurrentWeek = {};
function getColorPalette(baseColor, count) {
const r = parseInt(baseColor.slice(1, 3), 16);
const g = parseInt(baseColor.slice(3, 5), 16);
const b = parseInt(baseColor.slice(5, 7), 16);
const colors = [];
for (let i = 0; i < count; i++) {
const saturationBoost = 1.3;
const brightnessStart = 1.0; // Start at 100% brightness for first color
const brightnessStep = 0.15; // 15% step between colors
const brightnessFactor = Math.max(0.55, brightnessStart - (i * brightnessStep));
const newR = Math.min(255, Math.floor(r * saturationBoost * brightnessFactor));
const newG = Math.min(255, Math.floor(g * saturationBoost * brightnessFactor));
const newB = Math.min(255, Math.floor(b * saturationBoost * brightnessFactor));
colors.push(`rgb(${newR}, ${newG}, ${newB})`);
}
return colors;
}

function getPlayerHeadshotUrl(playerName, team) {
const headshotMap = {
'Christian McCaffrey': '/mnt/user-data/uploads/McCaffrey_Christian.JPG',
'Jonathan Taylor': '/mnt/user-data/uploads/Taylor_Jonathan.JPG',
'Justin Jefferson': '/mnt/user-data/uploads/Jefferson_Justin.jpg',
'Ladd McConkey': '/mnt/user-data/uploads/McConkey_Ladd.jpg',
'Ja\'Marr Chase': '/mnt/user-data/uploads/Chase_Ja_Marr.jpg',
'Bijan Robinson': '/mnt/user-data/uploads/Robinson_Bijan.JPG'
};
return headshotMap[playerName] || null;
}
function createHeadshotElement(playerName, team) {
const url = getPlayerHeadshotUrl(playerName, team);
if (url) {
return `<img src="" data-src="${url}" alt="${playerName}" class="player-headshot loading" onerror="this.style.display='none'" loading="lazy">`;
} else {
const initials = playerName
.split(' ')
.map(n => n[0])
.join('')
.toUpperCase()
.slice(0, 2);
const bgColor = teamColors[team] || '#666';
return `<div class="player-headshot" style="background: ${bgColor}; display: flex; align-items: center; justify-content: center; font-size: 11px; font-weight: 700; color: white;">${initials}</div>`;
}
}
function initLazyLoadHeadshots() {
if ('IntersectionObserver' in window) {
const imageObserver = new IntersectionObserver((entries, observer) => {
entries.forEach(entry => {
if (entry.isIntersecting) {
const img = entry.target;
img.src = img.dataset.src;
img.classList.remove('loading');
observer.unobserve(img);
}
});
});
document.querySelectorAll('img.player-headshot[data-src]').forEach(img => {
imageObserver.observe(img);
});
} else {
document.querySelectorAll('img.player-headshot[data-src]').forEach(img => {
img.src = img.dataset.src;
img.classList.remove('loading');
});
}
}

const Easing = {
linear: t => t,
easeInOutSine: t => -(Math.cos(Math.PI * t) - 1) / 2,
easeOutCubic: t => 1 - Math.pow(1 - t, 3),
easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2
};
function updateChartData(chart, newData) {
if (!chart) return;
chart.data.datasets[0].data = newData;
chart.update('none'); // Update without animation for performance
}
function lerp(start, end, t) {
return start + (end - start) * t;
}

let trendAnimationActive = {};
let trendAnimationFrames = {};
function toggleTrendAnimation(chartId) {
trendAnimationActive[chartId] = !trendAnimationActive[chartId];
trendAnimationFrames[chartId] = 0;
const btn = document.querySelector(`[data-chart="${chartId}"]`);
if (btn) {
btn.classList.toggle('active');
}
}

function calculateLinearRegression(data) {
const n = data.length;
let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
data.forEach(point => {
sumX += point.x;
sumY += point.y;
sumXY += point.x * point.y;
sumX2 += point.x * point.x;
});
const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
const intercept = (sumY - slope * sumX) / n;
return { slope, intercept };
}


function calculateWREvaluationMetrics(weeklyData) {
const wrsByWeek = {};
const wrTeamTotals = {}; // Track team totals by week
weeklyData.forEach(row => {
const week = parseInt(row.Week);
const player = row.Player?.trim();
const team = row.Team?.trim();
if (!player || !week || week === 0) return;
if (!wrsByWeek[player]) {
wrsByWeek[player] = { team: team, weeks: {} };
}
const targets = parseFloat(row.TGT) || 0;
const fpts = parseFloat(row.FPTS) || 0;
const rzTargets = parseFloat(row['RZ TGT']) || parseFloat(row['RZ_TGT']) || 0;
wrsByWeek[player].weeks[week] = {
targets: targets,
fpts: fpts,
rzTargets: rzTargets,
team: team
};
const teamKey = `${team}-${week}`;
if (!wrTeamTotals[teamKey]) {
wrTeamTotals[teamKey] = { targets: 0, rzTargets: 0 };
}
wrTeamTotals[teamKey].targets += targets;
wrTeamTotals[teamKey].rzTargets += rzTargets;
});
Object.keys(wrsByWeek).forEach(player => {
const playerData = wrsByWeek[player];
const weeks = Object.keys(playerData.weeks).map(Number).sort((a, b) => a - b);
weeks.forEach(week => {
const weekData = playerData.weeks[week];
const teamKey = `${weekData.team}-${week}`;
const teamTotals = wrTeamTotals[teamKey] || { targets: 1, rzTargets: 1 };
weekData.targetsPerGame = weekData.targets; // Already per-game in weekly data
weekData.fptsPerTarget = weekData.targets > 0 ? weekData.fpts / weekData.targets : 0;
weekData.targetShare = (weekData.targets / teamTotals.targets) * 100;
weekData.rzTargetShare = teamTotals.rzTargets > 0 ? (weekData.rzTargets / teamTotals.rzTargets) * 100 : 0;
});
const allWeekData = weeks.map(w => playerData.weeks[w]);
playerData.aggregate = {
gamesPlayed: weeks.length,
totalTargets: allWeekData.reduce((sum, w) => sum + w.targets, 0),
totalFpts: allWeekData.reduce((sum, w) => sum + w.fpts, 0),
totalRZTargets: allWeekData.reduce((sum, w) => sum + w.rzTargets, 0),
avgTargetsPerGame: allWeekData.reduce((sum, w) => sum + w.targets, 0) / weeks.length,
avgFptsPerTarget: allWeekData.reduce((sum, w) => sum + w.fpts, 0) / allWeekData.reduce((sum, w) => sum + w.targets, 0.0001),
avgTargetShare: allWeekData.reduce((sum, w) => sum + w.targetShare, 0) / weeks.length,
avgRZTargetShare: allWeekData.reduce((sum, w) => sum + w.rzTargetShare, 0) / weeks.length,
latestWeek: Math.max(...weeks)
};
});
return wrsByWeek;
}

function calculateRBEvaluationMetrics(weeklyData) {
const rbsByWeek = {};
const rbTeamTotals = {}; // Track team totals by week
weeklyData.forEach(row => {
const week = parseInt(row.Week);
const player = row.Player?.trim();
const team = row.Team?.trim();
if (!player || !week || week === 0) return;
if (!rbsByWeek[player]) {
rbsByWeek[player] = { team: team, weeks: {} };
}
const rushAtt = parseFloat(row.ATT) || 0;
const targets = parseFloat(row.TGT) || 0;
const fpts = parseFloat(row.FPTS) || 0;
const rzRushAtt = parseFloat(row.RZ_RUSH_ATT) || 0;
const rzTargets = parseFloat(row['RZ TGT']) || parseFloat(row['RZ_TGT']) || 0;
const opportunities = rushAtt + targets;
const rzOpportunities = rzRushAtt + rzTargets;
rbsByWeek[player].weeks[week] = {
opportunities: opportunities,
fpts: fpts,
rzOpportunities: rzOpportunities,
team: team
};
const teamKey = `${team}-${week}`;
if (!rbTeamTotals[teamKey]) {
rbTeamTotals[teamKey] = { opportunities: 0, rzOpportunities: 0, targets: 0 };
}
rbTeamTotals[teamKey].opportunities += opportunities;
rbTeamTotals[teamKey].rzOpportunities += rzOpportunities;
rbTeamTotals[teamKey].targets += targets;
});
Object.keys(rbsByWeek).forEach(player => {
const playerData = rbsByWeek[player];
const weeks = Object.keys(playerData.weeks).map(Number).sort((a, b) => a - b);
weeks.forEach(week => {
const weekData = playerData.weeks[week];
weekData.opportunitiesPerGame = weekData.opportunities;
weekData.rzOpportunitiesPerGame = weekData.rzOpportunities;
weekData.efficiency = weekData.opportunities > 0 ? weekData.fpts / weekData.opportunities : 0;
const teamKey = `${weekData.team}-${week}`;
if (rbTeamTotals[teamKey]) {
weekData.teamOpportunities = rbTeamTotals[teamKey].opportunities;
weekData.teamRZOpportunities = rbTeamTotals[teamKey].rzOpportunities;
}
});
const allWeekData = weeks.map(w => playerData.weeks[w]);
playerData.aggregate = {
gamesPlayed: weeks.length,
totalOpportunities: allWeekData.reduce((sum, w) => sum + w.opportunities, 0),
totalFpts: allWeekData.reduce((sum, w) => sum + w.fpts, 0),
totalRZOpportunities: allWeekData.reduce((sum, w) => sum + w.rzOpportunities, 0),
avgOpportunitiesPerGame: allWeekData.reduce((sum, w) => sum + w.opportunities, 0) / weeks.length,
avgRZOpportunitiesPerGame: allWeekData.reduce((sum, w) => sum + w.rzOpportunities, 0) / weeks.length,
avgEfficiency: allWeekData.reduce((sum, w) => sum + w.fpts, 0) / allWeekData.reduce((sum, w) => sum + w.opportunities, 0.0001),
latestWeek: Math.max(...weeks)
};
});
return rbsByWeek;
}

function getEvaluationWeekData(evaluationData, week = null) {
const result = [];
Object.keys(evaluationData).forEach(player => {
const playerData = evaluationData[player];
const targetWeek = week || playerData.aggregate.latestWeek;
const weekData = playerData.weeks[targetWeek];
if (weekData) {
result.push({
player: player,
team: playerData.team,
...weekData,
aggregate: playerData.aggregate
});
}
});
return result;
}

function getAvailableWeeks(evaluationData) {
const weeks = new Set();
Object.values(evaluationData).forEach(playerData => {
Object.keys(playerData.weeks).forEach(week => weeks.add(parseInt(week)));
});
return Array.from(weeks).sort((a, b) => a - b);
}


function calculateSegmentAverages(evaluationData, segmentSize = 4) {
const allWeeks = new Set();
Object.values(evaluationData).forEach(playerData => {
Object.keys(playerData.weeks).forEach(week => {
allWeeks.add(parseInt(week));
});
});
const weeks = Array.from(allWeeks).sort((a, b) => a - b);
if (weeks.length < segmentSize) { return {};
}
const minWeek = weeks[0];
const maxWeek = weeks[weeks.length - 1];
const numSegments = Math.ceil(maxWeek / segmentSize);
const segmentData = {};
for (let segmentIndex = 0; segmentIndex < numSegments; segmentIndex++) {
const segmentStartWeek = (segmentIndex * segmentSize) + 1;
const segmentEndWeek = Math.min(segmentStartWeek + segmentSize - 1, maxWeek);
const segmentWeeks = [];
for (let w = segmentStartWeek; w <= segmentEndWeek; w++) {
if (weeks.includes(w)) {
segmentWeeks.push(w);
}
}
if (segmentWeeks.length === 0) continue;
const segmentPlayers = [];
Object.keys(evaluationData).forEach(playerName => {
const playerData = evaluationData[playerName];
const playerWeeksInSegment = [];
segmentWeeks.forEach(week => {
if (playerData.weeks[week]) {
playerWeeksInSegment.push({
week: week,
...playerData.weeks[week]
});
}
});
if (playerWeeksInSegment.length === 0) return;
const avgPlayer = {
player: playerName,
team: playerData.team,
segmentWeeks: segmentWeeks,
weeksInSegment: playerWeeksInSegment.length
};
const fieldsToAverage = [
'targets', 'targetsPerGame', 'fpts', 'fptsPerTarget',
'targetShare', 'rzTargets', 'rzTargetShare',
'opportunities', 'rzOpportunities', 'efficiency'
];
fieldsToAverage.forEach(field => {
const values = playerWeeksInSegment
.map(w => w[field])
.filter(v => v !== undefined && v !== null && !isNaN(v));
if (values.length > 0) {
avgPlayer[field] = values.reduce((sum, v) => sum + v, 0) / values.length;
}
});
avgPlayer.aggregate = playerData.aggregate;
segmentPlayers.push(avgPlayer);
});
segmentData[segmentIndex] = segmentPlayers;
}
return segmentData;
}

function getAvailableSegments(segmentData) {
return Object.keys(segmentData)
.map(Number)
.filter(s => !isNaN(s))
.sort((a, b) => a - b);
}

function getEvaluationSegmentData(segmentData, segmentIndex = null) {
const segments = getAvailableSegments(segmentData);
if (segments.length === 0) {
return [];
}
if (segmentIndex === null) {
return segmentData[segments[segments.length - 1]] || [];
}
if (Number.isInteger(segmentIndex) && segmentData[segmentIndex]) {
return segmentData[segmentIndex] || [];
}
const floorIndex = Math.floor(segmentIndex);
return segmentData[floorIndex] || [];
}

function getSegmentWeekRange(segmentData, segmentIndex) {
const segmentPlayers = segmentData[segmentIndex];
if (!segmentPlayers || segmentPlayers.length === 0) {
return [];
}
return segmentPlayers[0].segmentWeeks || [];
}

function formatSegmentLabel(segmentFloat, segmentData) {
const segmentIndex = Math.floor(segmentFloat);
const weeks = getSegmentWeekRange(segmentData, segmentIndex);
if (weeks.length === 0) {
return `Segment ${segmentIndex}`;
}
const firstWeek = weeks[0];
const lastWeek = weeks[weeks.length - 1];
if (firstWeek === lastWeek) {
return `Week ${firstWeek}`;
}
return `Segments ${firstWeek}-${lastWeek}`;
}

function generatePlayerAnalysis(player) {
const insights = [];
const oppShare = player.latestWeekOppShare;
if (oppShare > 30) {
insights.push(`<strong>High target</strong> with ${oppShare.toFixed(0)}% opportunity share - commanding a significant portion of team's offense.`);
} else if (oppShare > 20) {
insights.push(`<strong>Solid role</strong> with ${oppShare.toFixed(0)}% opportunity share - reliable contributor in the offense.`);
} else if (oppShare > 10) {
insights.push(`<strong>Limited role</strong> at ${oppShare.toFixed(0)}% opportunity share - may need more involvement for consistent production.`);
} else {
insights.push(`<strong>Minimal role</strong> with only ${oppShare.toFixed(0)}% opportunity share - volatility risk is high.`);
}
const overPerformances = player.weeks.filter(w => w.variance > 0).length;
const totalWeeks = player.weeks.length;
const overPerformRate = (overPerformances / totalWeeks) * 100;
if (overPerformRate > 65) {
insights.push(`<strong>Exceeding expectations</strong> - outperformed projections in ${overPerformances} of ${totalWeeks} games (${overPerformRate.toFixed(0)}%). High efficiency player.`);
} else if (overPerformRate > 35) {
insights.push(`<strong>Meeting expectations</strong> - balanced performance around projections (${overPerformRate.toFixed(0)}% over-performance rate).`);
} else {
insights.push(`<strong>Underperforming</strong> - only exceeded expectations in ${overPerformances} of ${totalWeeks} games. May be dealing with efficiency issues or tough matchups.`);
}
const avgVariance = player.weeks.reduce((sum, w) => sum + w.variance, 0) / totalWeeks;
const totalOpps = player.position === 'WR' ? player.totalTargets : player.totalOpportunities;
if (totalOpps > 70 && avgVariance < -1) {
insights.push(`<strong>High-volume, low-efficiency</strong> - receiving significant opportunities (${totalOpps}) but averaging ${Math.abs(avgVariance).toFixed(1)} points below expected per game.`);
} else if (totalOpps > 70 && avgVariance > 1) {
insights.push(`<strong>High-volume, high-efficiency</strong> - elite combination of opportunity (${totalOpps}) and production (+${avgVariance.toFixed(1)} vs expected per game).`);
} else if (totalOpps < 40 && avgVariance > 1) {
insights.push(`<strong>Limited volume, high efficiency</strong> - making the most of opportunities with +${avgVariance.toFixed(1)} vs expected, but volume (${totalOpps}) caps upside.`);
}
const variances = player.weeks.map(w => w.variance);
const stdDev = Math.sqrt(variances.reduce((sum, v) => sum + Math.pow(v, 2), 0) / totalWeeks);
if (stdDev < 3) {
insights.push(`<strong>High floor, stable producer</strong> - low variance (${stdDev.toFixed(1)}) suggests consistent weekly outcomes.`);
} else if (stdDev > 6) {
insights.push(`<strong>Boom-or-bust profile</strong> - high variance (${stdDev.toFixed(1)}) indicates wide range of weekly outcomes.`);
}
if (player.oppChange > 5) {
insights.push(`<strong>ðŸ“ˆ Trending up</strong> - opportunity share increased by ${player.oppChange.toFixed(1)}% recently, suggesting growing role.`);
} else if (player.oppChange < -5) {
insights.push(`<strong>ðŸ“‰ Trending down</strong> - opportunity share decreased by ${Math.abs(player.oppChange).toFixed(1)}%, role may be shrinking.`);
}
return insights.join(' ');
}
function loadStoredData() {
const storedWR = localStorage.getItem('wrData');
const storedRB = localStorage.getItem('rbData');
const storedTE = localStorage.getItem('teData');
if (storedWR) {
wrData = JSON.parse(storedWR);
window.wrData = wrData;
}
if (storedRB) {
rbData = JSON.parse(storedRB);
window.rbData = rbData;
}
if (storedTE) {
teData = JSON.parse(storedTE);
window.teData = teData;
}
if (wrData || rbData || teData) {
processAllData();
}
}
const GITHUB_DATA_URLS = {
wr: 'https://raw.githubusercontent.com/aryi3025/ffse-data/refs/heads/main/wr_data.csv',
rb: 'https://raw.githubusercontent.com/aryi3025/ffse-data/refs/heads/main/rb_data.csv',
te: 'https://raw.githubusercontent.com/aryi3025/ffse-data/refs/heads/main/te_data.csv'
};
async function fetchDataFromGitHub() {
try {
LoadingScreen.updateProgress(10, 'Connecting to data source...');
const [wrResponse, rbResponse, teResponse] = await Promise.all([
fetch(GITHUB_DATA_URLS.wr),
fetch(GITHUB_DATA_URLS.rb),
fetch(GITHUB_DATA_URLS.te)
]);
LoadingScreen.updateProgress(30, 'Downloading player data...');
if (!wrResponse.ok || !rbResponse.ok || !teResponse.ok) {
throw new Error('Failed to fetch data from GitHub');
}
const [wrText, rbText, teText] = await Promise.all([
wrResponse.text(),
rbResponse.text(),
teResponse.text()
]);
LoadingScreen.updateProgress(50, 'Parsing CSV data...');
Papa.parse(wrText, {
header: true,
skipEmptyLines: true,
complete: function(results) {
wrData = results.data.filter(row => row.Player && row.Week);
window.wrData = wrData;
localStorage.setItem('wrData', JSON.stringify(wrData));
LoadingScreen.updateProgress(60, 'Processing wide receivers...');
checkAndProcessData();
}
});
Papa.parse(rbText, {
header: true,
skipEmptyLines: true,
complete: function(results) {
rbData = results.data.filter(row => row.Player && row.Week);
window.rbData = rbData;
localStorage.setItem('rbData', JSON.stringify(rbData));
LoadingScreen.updateProgress(70, 'Processing running backs...');
checkAndProcessData();
}
});
Papa.parse(teText, {
header: true,
skipEmptyLines: true,
complete: function(results) {
teData = results.data.filter(row => row.Player && row.Week);
window.teData = teData;
localStorage.setItem('teData', JSON.stringify(teData));
LoadingScreen.updateProgress(75, 'Processing tight ends...');
checkAndProcessData();
}
});
} catch (error) { // Fall back to localStorage data if fetch fails
loadStoredData();
hideLoadingIndicator();
LoadingScreen.complete();
}
}
async function fetchInjuryData() {
try {
const response = await fetch('https://api.sleeper.app/v1/players/nfl');
if (!response.ok) {
throw new Error('Failed to fetch injury data from Sleeper');
}
const players = await response.json();
injuryData = {};
for (const playerId in players) {
const player = players[playerId];
if (player.injury_status && player.injury_status !== 'Healthy') {
const fullName = `${player.first_name} ${player.last_name}`;
injuryData[fullName] = {
status: player.injury_status, // 'Questionable', 'Doubtful', 'Out', 'IR', 'PUP', etc.
injuryBody: player.injury_body_part || 'Unknown',
team: player.team || 'FA',
position: player.position,
lastUpdate: Date.now()
};
}
}
localStorage.setItem('injuryData', JSON.stringify({
data: injuryData,
timestamp: Date.now()
}));
const irPlayers = Object.entries(injuryData)
.filter(([name, data]) => data.status === 'IR' || data.status === 'PUP')
.map(([name, data]) => `${name} (${data.status})`);
console.log('IR/PUP players in injury data:', irPlayers);
return injuryData;
} catch (error) {
const cached = localStorage.getItem('injuryData');
if (cached) {
const parsedCache = JSON.parse(cached);
const cacheAge = Date.now() - parsedCache.timestamp;
if (cacheAge < 3600000) {
injuryData = parsedCache.data;
return injuryData;
}
}
return {};
}
}
function getPlayerInjuryStatus(playerName) {
if (!injuryData || !injuryData[playerName]) {
return null;
}
return injuryData[playerName];
}
function formatInjuryStatus(status) {
const statusMap = {
'Questionable': { badge: 'Q', class: 'questionable', fullText: 'Questionable' },
'Doubtful': { badge: 'D', class: 'doubtful', fullText: 'Doubtful' },
'Out': { badge: 'O', class: 'out', fullText: 'Out' },
'IR': { badge: 'IR', class: 'ir', fullText: 'Injured Reserve' },
'PUP': { badge: 'PUP', class: 'pup', fullText: 'Physically Unable to Perform' },
'Suspended': { badge: 'SUS', class: 'suspended', fullText: 'Suspended' },
'COV': { badge: 'COV', class: 'cov', fullText: 'COVID-19 List' }
};
return statusMap[status] || { badge: status, class: 'questionable', fullText: status };
}
let dataLoadedCount = 0;
function checkAndProcessData() {
dataLoadedCount++;
if (dataLoadedCount >= 3) { // All three datasets loaded
LoadingScreen.updateProgress(80, 'Calculating player metrics...');
processAllData();
hideLoadingIndicator();
LoadingScreen.updateProgress(90, 'Rendering dashboard...');
setTimeout(() => {
const dashboardPage = document.getElementById('top-movers');
if (dashboardPage && dashboardPage.classList.contains('active')) {
renderDashboardCategories();
setTimeout(renderMiniScatterPlots, 100);
}
LoadingScreen.updateProgress(95, 'Finalizing...');
setTimeout(() => {
LoadingScreen.complete();
}, 300);
}, 200);
dataLoadedCount = 0; // Reset for next fetch
}
}
function showLoadingIndicator() {
const mainContent = document.querySelector('.main-content');
const loadingDiv = document.createElement('div');
loadingDiv.id = 'data-loading-indicator';
loadingDiv.style.cssText = `
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: var(--bg-elevated);
padding: 40px 60px;
border-radius: 16px;
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
text-align: center;
z-index: 10000;
`;
loadingDiv.innerHTML = `
<div style="font-size: 24px; font-weight: 700; color: var(--text-primary); margin-bottom: 12px;">
Loading Latest Data...
</div><div style="font-size: 14px; color: var(--text-secondary);">
Fetching player stats from database
</div><div style="margin-top: 20px;"><div class="loading-spinner"></div></div>
`;
document.body.appendChild(loadingDiv);
const backdrop = document.createElement('div');
backdrop.id = 'loading-backdrop';
backdrop.style.cssText = `
position: fixed;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: rgba(0, 0, 0, 0.5);
z-index: 9999;
`;
document.body.appendChild(backdrop);
}
function hideLoadingIndicator() {
const indicator = document.getElementById('data-loading-indicator');
const backdrop = document.getElementById('loading-backdrop');
if (indicator) indicator.remove();
if (backdrop) backdrop.remove();
}
function showUploadSection() {
const hasData = wrData && rbData && teData;
if (hasData) {
if (confirm('You already have data loaded. Do you want to upload new data?')) {
document.getElementById('wr-file-input').click();
}
} else {
document.getElementById('wr-file-input').click();
}
}
function handleWRUpload(event) {
const file = event.target.files[0];
if (file) {
Papa.parse(file, {
header: true,
skipEmptyLines: true,
complete: function(results) {
wrData = results.data.filter(row => row.Player && row.Week);
localStorage.setItem('wrData', JSON.stringify(wrData));
if (rbData) {
processAllData();
} else {
setTimeout(() => {
document.getElementById('rb-file-input').click();
}, 300);
}
}
});
}
}
function handleRBUpload(event) {
const file = event.target.files[0];
if (file) {
Papa.parse(file, {
header: true,
skipEmptyLines: true,
complete: function(results) {
rbData = results.data.filter(row => row.Player && row.Week);
localStorage.setItem('rbData', JSON.stringify(rbData));
processAllData();
}
});
}
}
function processAllData() {
if (wrData && wrData.length > 0) {
console.log('ðŸ” First WR row columns:', Object.keys(wrData[0]));
console.log('ðŸ” Expected points columns:', {
STD: wrData[0].Exp_Ft_Points_STD,
HALF: wrData[0].Exp_Ft_Points_HALF,
PPR: wrData[0].Exp_Ft_Points || wrData[0].Exp_Ft_Points_PPR
});
}

// Calculate current NFL week from data
try {
    calculateCurrentWeek();
} catch (error) {
    console.error('Error calculating current week:', error);
    currentNFLWeek = 10; // Fallback
}

try {
    if (wrData && Array.isArray(wrData)) {
        window.aggregatedWRs = aggregatePlayerData(wrData, 'WR');
        evaluationDataWR = calculateWREvaluationMetrics(wrData);
    }
} catch (error) {
    console.error('Error processing WR data:', error);
    window.aggregatedWRs = {};
}

try {
    if (rbData && Array.isArray(rbData)) {
        window.aggregatedRBs = aggregatePlayerData(rbData, 'RB');
        evaluationDataRB = calculateRBEvaluationMetrics(rbData);
    }
} catch (error) {
    console.error('Error processing RB data:', error);
    window.aggregatedRBs = {};
}

try {
    if (teData && Array.isArray(teData)) {
        window.aggregatedTEs = aggregatePlayerData(teData, 'TE');
    }
} catch (error) {
    console.error('Error processing TE data:', error);
    window.aggregatedTEs = {};
}

if (Object.keys(evaluationDataWR).length > 0) {
segmentDataWR = calculateSegmentAverages(evaluationDataWR, 4); }
if (Object.keys(evaluationDataRB).length > 0) {
segmentDataRB = calculateSegmentAverages(evaluationDataRB, 4); }

allPlayers = { ...window.aggregatedWRs, ...window.aggregatedRBs, ...window.aggregatedTEs };

try {
    calculateTeamTargetShares(allPlayers);
} catch (error) {
    console.error('Error calculating team target shares:', error);
}

try {
    calculateROSRanks();
} catch (error) {
    console.error('Error calculating ROS ranks:', error);
}

try {
    calculateAllMomentum();
} catch (error) {
    console.error('Error calculating momentum:', error);
}

try {
    renderAllPages();
} catch (error) {
    console.error('Error rendering pages:', error);
}

try {
    setLastUpdatedDate();
} catch (error) {
    console.error('Error setting last updated date:', error);
}

// Update week displays after data is processed
try {
    updateWeekDisplays();
} catch (error) {
    console.error('Error updating week displays:', error);
}
}

function calculateCurrentWeek() {
    let maxWeek = 10; // Default fallback
    
    // Find the highest week number across all datasets
    const datasets = [window.wrData, window.rbData, window.teData];
    datasets.forEach(data => {
        if (data && Array.isArray(data) && data.length > 0) {
            data.forEach(row => {
                if (row && row.Week) {
                    const week = parseInt(row.Week);
                    if (!isNaN(week) && week > maxWeek && week <= 18) { // Cap at week 18 for safety
                        maxWeek = week;
                    }
                }
            });
        }
    });
    
    currentNFLWeek = maxWeek;
    console.log(`ðŸ“… Current NFL Week: ${currentNFLWeek}`);
}

function updateWeekDisplays() {
    // Update all "WEEK X" displays throughout the app
    const weekElements = document.querySelectorAll('.market-time, .heatmap-ticker-week');
    weekElements.forEach(el => {
        if (el) {
            el.textContent = `WEEK ${currentNFLWeek}`;
        }
    });
    
    // Update "WEEK X INSIGHTS" label
    const insightLabels = document.querySelectorAll('.story-label');
    insightLabels.forEach(el => {
        if (el && el.textContent && el.textContent.includes('WEEK')) {
            el.textContent = `WEEK ${currentNFLWeek} INSIGHTS`;
        }
    });
    
    console.log(`âœ“ Updated week displays to WEEK ${currentNFLWeek}`);
}
function calculateTeamTargetShares(allPlayers) {
// First pass: Calculate team totals by week
const teamTotalsByWeek = {}; // Key: "TEAM-WEEK", Value: { targets: X }

Object.values(allPlayers).forEach(player => {
player.weeks.forEach(weekData => {
const teamKey = `${player.team}-${weekData.week}`;
if (!teamTotalsByWeek[teamKey]) {
teamTotalsByWeek[teamKey] = { targets: 0 };
}
// Add targets from all positions
if (weekData.targets !== undefined && weekData.targets > 0) {
teamTotalsByWeek[teamKey].targets += weekData.targets;
}
});
});

// Second pass: Calculate target share for each player's week
Object.values(allPlayers).forEach(player => {
player.weeks.forEach(weekData => {
const teamKey = `${player.team}-${weekData.week}`;
const teamTotals = teamTotalsByWeek[teamKey];

if (teamTotals && teamTotals.targets > 0 && weekData.targets !== undefined) {
// Calculate target share as percentage
weekData.teamShare = (weekData.targets / teamTotals.targets) * 100;
} else {
weekData.teamShare = 0;
}
});
});
}
function aggregatePlayerData(weeklyData, position) {
const players = {};
let debugLogCount = 0; // For debug logging
const getAdjustedFantasyPoints = (pprPoints, receptions) => {
if (currentScoringFormat === 'std') {
return pprPoints - receptions;
} else if (currentScoringFormat === 'half') {
return pprPoints - (0.5 * receptions);
} else {
return pprPoints;
}
};
weeklyData.forEach(row => {
if (!row.Player || !row.Week) return;
const id = `${row.Team}-${row.Player}`;
if (!players[id]) {
players[id] = {
id: id,
name: row.Player,
team: row.Team,
position: position,
weeks: [],
totalPoints: 0,
gamesPlayed: 0,
totalTargets: 0,
totalOpportunities: 0,
rzOpportunities: 0,
avgPoints: 0,
latestWeek: 0,
latestWeekPoints: 0,
latestWeekOppShare: 0,
oppChange: 0,
totalRec: 0,
totalAir: 0,
totalCatchable: 0,
totalYDS: 0,
totalYAC: 0,
catchRate: 0,
catchableCatchRate: 0,
racr: 0,
tgtPerGame: 0,
airYardsPerGame: 0,
yacPerRec: 0,
totalRecTDs: 0,
totalRushTDs: 0,
rzTDs: 0,
rzRushTDs: 0,
totalCarries: 0,
totalRushYards: 0,
totalRecYards: 0,
totalYBCON: 0,
totalYACON: 0
};
}
const weekNum = parseInt(row.Week);
const fptsPPR = parseFloat(row.FPTS || row.Fpts) || 0; // Base PPR points from CSV
const receptions = parseFloat(row.REC) || 0; // Get receptions for adjustment
const fpts = getAdjustedFantasyPoints(fptsPPR, receptions);
let expFpts, variance;
if (currentScoringFormat === 'std') {
expFpts = parseFloat(row.Exp_Ft_Points_STD) || 0;
variance = parseFloat(row.FPTS_Variance_STD) || 0;
} else if (currentScoringFormat === 'half') {
expFpts = parseFloat(row.Exp_Ft_Points_HALF) || 0;
variance = parseFloat(row.FPTS_Variance_HALF) || 0;
} else { // PPR (default)
expFpts = parseFloat(row.Exp_Ft_Points || row.Exp_Ft_Points_PPR) || 0;
variance = parseFloat(row.FPTS_Variance || row.FPTS_Variance_PPR) || 0;
}
if (position === 'WR' && weekNum === 1 && row.Player && debugLogCount < 1) {
console.log(`ðŸ“Œ ${position} ${row.Player} Week ${weekNum}:`, {
scoringFormat: currentScoringFormat,
expectedFpts: expFpts,
columns: {
STD: row.Exp_Ft_Points_STD,
HALF: row.Exp_Ft_Points_HALF,
PPR: row.Exp_Ft_Points || row.Exp_Ft_Points_PPR
}
});
debugLogCount++;
}
const weekData = {
week: weekNum,
fpts: fpts, // Adjusted fantasy points
fptsPPR: fptsPPR, // Store original PPR points for reference
receptions: receptions, // Store receptions for future adjustments
expectedFpts: expFpts,
expectedFptsPPR: parseFloat(row.Exp_Ft_Points || row.Exp_Ft_Points_PPR) || 0,
expectedFptsHALF: parseFloat(row.Exp_Ft_Points_HALF) || 0,
expectedFptsSTD: parseFloat(row.Exp_Ft_Points_STD) || 0,
variance: variance
};
// Check if this week already exists to prevent duplicates
const existingWeekIndex = players[id].weeks.findIndex(w => w.week === weekNum);
const isNewWeek = existingWeekIndex === -1;

if (position === 'WR' || position === 'TE') {
const tgt = parseFloat(row.TGT) || 0;
const rzTgt = parseFloat(row['RZ TGT']) || parseFloat(row.RZ_TGT) || 0;
const usageShare = (parseFloat(row.Usage_Share) || 0) * 100; // Convert decimal to percentage
const rzShare = (parseFloat(row.RZ_Share) || 0) * 100; // Convert decimal to percentage
const rec = parseFloat(row.REC) || 0;
const air = parseFloat(row.AIR) || 0;
const catchable = parseFloat(row.CATCHABLE) || 0;
const yds = parseFloat(row.REC_YDS) || parseFloat(row.YDS) || 0;
const yac = parseFloat(row.YAC) || 0;
const recTD = parseFloat(row.REC_TD) || 0;
const rushTD = parseFloat(row.RUSH_TD) || 0;
const rzRecTD = parseFloat(row.RZ_REC_TD) || 0;
const rzRushTD = parseFloat(row.RZ_RUSH_TD) || 0;
const rzTD = rzRecTD + rzRushTD;
const rushYds = parseFloat(row.RUSH_YDS) || 0;
const carries = parseFloat(row.CARRIES) || 0;
weekData.targets = tgt;
weekData.rzTargets = rzTgt;
weekData.usageShare = usageShare;
weekData.rzShare = rzShare;
weekData.receptions = rec; // Store for tooltips
weekData.recYards = yds; // Store for tooltips
weekData.rushAttempts = carries; // Store for tooltips
weekData.rushYards = rushYds; // Store for tooltips
weekData.rec_td = recTD; // Store TD data for sell-high analysis
weekData.rush_td = rushTD; // Store TD data for sell-high analysis

// Only accumulate stats if this is a NEW week, not a duplicate
if (isNewWeek) {
players[id].totalTargets += tgt;
players[id].rzOpportunities += rzTgt;
players[id].totalRec += rec;
players[id].totalAir += air;
players[id].totalCatchable += catchable;
players[id].totalYDS += yds;
players[id].totalYAC += yac;
players[id].totalRecTDs += recTD;
players[id].totalRushTDs += rushTD;
players[id].rzTDs += rzTD;
players[id].rzRushTDs += rzRushTD;
players[id].totalRushYards += rushYds;
players[id].totalCarries += carries;
}
} else {
const rbOpp = parseFloat(row['RB Opp']) || 0;
const rzRushAtt = parseFloat(row['RZ_RUSH_ATT']) || 0;
const rzTgt = parseFloat(row['RZ TGT']) || parseFloat(row['RZ_TGT']) || 0;
const rushAtt = parseFloat(row.ATT) || 0;
const tgt = parseFloat(row.TGT) || 0;
const usageShare = (parseFloat(row.Usage_Share) || 0) * 100; // Convert decimal to percentage
const rzShare = (parseFloat(row.RZ_Share) || 0) * 100; // Convert decimal to percentage
const rushYds = parseFloat(row.YDS) || 0;
const recYds = parseFloat(row.REC_YDS) || 0;
const ybcon = parseFloat(row.YBCON) || 0;
const yacon = parseFloat(row.YACON) || 0;
const rec = parseFloat(row.REC) || 0;
const recTD = parseFloat(row.REC_TD) || 0;
const rushTD = parseFloat(row.RUSH_TD) || 0;
const rzRecTD = parseFloat(row.RZ_REC_TD) || 0;
const rzRushTD = parseFloat(row.RZ_RUSH_TD) || 0;
const rzTD = rzRecTD + rzRushTD;
weekData.opportunities = rbOpp;
weekData.rzOpportunities = rzRushAtt + rzTgt; // Include both RZ rush attempts and RZ targets
weekData.rushAttempts = rushAtt;
weekData.rushYards = rushYds; // Store for tooltips
weekData.targets = tgt;
weekData.receptions = rec; // Store for tooltips
weekData.recYards = recYds; // Store for tooltips
weekData.usageShare = usageShare;
weekData.rzShare = rzShare;
weekData.rec_td = recTD; // Store TD data for sell-high analysis
weekData.rush_td = rushTD; // Store TD data for sell-high analysis

// Only accumulate stats if this is a NEW week, not a duplicate
if (isNewWeek) {
players[id].totalOpportunities += rbOpp;
players[id].rzOpportunities += (rzRushAtt + rzTgt); // Include both RZ rush attempts and RZ targets
players[id].totalCarries += rushAtt;
players[id].totalTargets += tgt;
players[id].totalRushYards += rushYds;
players[id].totalRecYards += recYds;
players[id].totalYBCON += ybcon;
players[id].totalYACON += yacon;
players[id].totalRec += rec;
players[id].totalRecTDs += recTD;
players[id].totalRushTDs += rushTD;
players[id].rzTDs += rzTD;
players[id].rzRushTDs += rzRushTD;
}
}

if (isNewWeek) {
// Week doesn't exist, add it
players[id].weeks.push(weekData);
players[id].totalPoints += fpts;
players[id].gamesPlayed++;
} else {
// Week already exists - update it instead of adding duplicate
// Subtract old values before adding new ones
const oldWeek = players[id].weeks[existingWeekIndex];
players[id].totalPoints -= oldWeek.fpts;

// Update the week data
players[id].weeks[existingWeekIndex] = weekData;
players[id].totalPoints += fpts;
// gamesPlayed stays the same since we're replacing, not adding
}

if (weekNum > players[id].latestWeek) {
players[id].latestWeek = weekNum;
players[id].latestWeekPoints = fpts;
if (position === 'WR') {
players[id].latestWeekOppShare = parseFloat(row['% TM']) || 0;
}
}
});
Object.values(players).forEach(player => {
player.avgPoints = player.gamesPlayed > 0 ? player.totalPoints / player.gamesPlayed : 0;
const totalExpected = player.weeks.reduce((sum, w) => sum + w.expectedFpts, 0);
player.pctOverExpected = totalExpected > 0 ? ((player.totalPoints - totalExpected) / totalExpected) * 100 : 0;

// Calculate TOTAL team RZ opportunities using ALL available data sources
let teamRzOpps = 0;

// Get all AGGREGATED players for this team from ALL positions
// This prevents double counting across multiple weeks
// Note: window.aggregatedWRs/RBs/TEs might not be fully populated yet when processing early positions
// So we combine current position's players with already-aggregated other positions
const currentPositionTeamPlayers = Object.values(players).filter(p => p.team === player.team);
const otherPositionsTeamPlayers = [];

// Add players from other positions if they exist
if (window.aggregatedWRs && position !== 'WR') {
otherPositionsTeamPlayers.push(...Object.values(window.aggregatedWRs).filter(p => p.team === player.team));
}
if (window.aggregatedRBs && position !== 'RB') {
otherPositionsTeamPlayers.push(...Object.values(window.aggregatedRBs).filter(p => p.team === player.team));
}
if (window.aggregatedTEs && position !== 'TE') {
otherPositionsTeamPlayers.push(...Object.values(window.aggregatedTEs).filter(p => p.team === player.team));
}

// Combine all team players and sum their RZ opportunities
const allTeamPlayers = [...currentPositionTeamPlayers, ...otherPositionsTeamPlayers];
allTeamPlayers.forEach(p => {
teamRzOpps += p.rzOpportunities || 0;
});

player.teamRzOpportunities = teamRzOpps;

// Debug logging for ARI players
if (player.team === 'ARI' && player.rzOpportunities > 0) {
console.log(`\n${'='.repeat(60)}`);
console.log(`RZ OPP SHARE CALCULATION FOR: ${player.name} (${player.position}, ARI)`);
console.log(`${'='.repeat(60)}`);
console.log(`\n1ï¸âƒ£ PLAYER'S RZ OPPORTUNITIES:`);
console.log(`   Total RZ Opportunities: ${player.rzOpportunities}`);
console.log(`   Games Played: ${player.gamesPlayed}`);
console.log(`   RZ Opp/Game: ${(player.rzOpportunities / player.gamesPlayed).toFixed(2)}`);

// Show week-by-week breakdown
console.log(`\n   Week-by-Week Breakdown:`);
player.weeks.forEach(w => {
if (w.rzTargets > 0) {
console.log(`   Week ${w.week}: ${w.rzTargets} RZ targets`);
}
});

console.log(`\n2ï¸âƒ£ TEAM'S TOTAL RZ OPPORTUNITIES:`);
console.log(`   Arizona Cardinals Total: ${teamRzOpps}`);

// Break down by position
const ariWRData = (window.wrData || []).filter(row => row.Team === 'ARI');
const ariRBData = (window.rbData || []).filter(row => row.Team === 'ARI');
const ariTEData = (window.teData || []).filter(row => row.Team === 'ARI');

let wrRzTotal = 0, rbRzTotal = 0, teRzTotal = 0;
ariWRData.forEach(row => {
const rzTgt = parseFloat(row['RZ TGT']) || parseFloat(row['RZ_TGT']) || 0;
wrRzTotal += rzTgt;
});
ariRBData.forEach(row => {
const rzRushAtt = parseFloat(row['RZ_RUSH_ATT']) || 0;
const rzTgt = parseFloat(row['RZ TGT']) || parseFloat(row['RZ_TGT']) || 0;
rbRzTotal += rzRushAtt + rzTgt;
});
ariTEData.forEach(row => {
const rzTgt = parseFloat(row['RZ TGT']) || parseFloat(row['RZ_TGT']) || 0;
teRzTotal += rzTgt;
});

console.log(`   From WRs: ${wrRzTotal} RZ targets`);
console.log(`   From RBs: ${rbRzTotal} RZ rush att + RZ targets`);
console.log(`   From TEs: ${teRzTotal} RZ targets`);
console.log(`   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`);
console.log(`   TOTAL: ${wrRzTotal + rbRzTotal + teRzTotal} RZ opportunities`);

console.log(`\n3ï¸âƒ£ CALCULATION:`);
console.log(`   RZ Opp Share = (${player.rzOpportunities} / ${teamRzOpps}) Ã— 100`);
console.log(`   RZ Opp Share = ${((player.rzOpportunities / teamRzOpps) * 100).toFixed(1)}%`);
console.log(`\n${'='.repeat(60)}\n`);
}

if ((position === 'WR' || position === 'TE') && player.gamesPlayed >= 3) {
player.catchRate = player.totalTargets > 0 ? (player.totalRec / player.totalTargets) * 100 : 0;
player.catchableCatchRate = player.totalCatchable > 0 ? (player.totalRec / player.totalCatchable) * 100 : 0;
player.racr = player.totalAir > 0 ? (player.totalYDS / player.totalAir) * 100 : 0;
player.tgtPerGame = player.gamesPlayed > 0 ? player.totalTargets / player.gamesPlayed : 0;
player.airYardsPerGame = player.gamesPlayed > 0 ? player.totalAir / player.gamesPlayed : 0;
player.yacPerRec = player.totalRec > 0 ? player.totalYAC / player.totalRec : 0;
}
player.weeks.sort((a, b) => a.week - b.week);
if (position === 'RB') {
player.latestWeekOppShare = calculateRBTeamShare(player, weeklyData);
}
player.oppChange = calculateOppChange(player);
});
return players;
}
function calculateRBTeamShare(player, weeklyData) {
if (player.weeks.length === 0) return 0;
const latestWeek = player.latestWeek;
const teamData = weeklyData.filter(row =>
row.Team === player.team &&
parseInt(row.Week) === latestWeek &&
row.Player &&
parseFloat(row['RB Opp']) > 0
);
const teamTotal = teamData.reduce((sum, row) => sum + (parseFloat(row['RB Opp']) || 0), 0);
const playerOpp = teamData.find(row => row.Player === player.name);
const playerTotal = playerOpp ? parseFloat(playerOpp['RB Opp']) || 0 : 0;
return teamTotal > 0 ? (playerTotal / teamTotal) * 100 : 0;
}
function calculateOppChange(player) {
if (player.weeks.length < 2) return 0;
const lastWeek = player.weeks[player.weeks.length - 1];
const prevWeek = player.weeks[player.weeks.length - 2];
let lastShare = 0;
let prevShare = 0;
if (player.position === 'WR') {
lastShare = lastWeek.teamShare || 0;
prevShare = prevWeek.teamShare || 0;
} else {
lastShare = player.latestWeekOppShare;
prevShare = lastShare;
}
return lastShare - prevShare;
}
function calculateROSRanks() {
const allPlayersList = Object.values(allPlayers);
allPlayersList.sort((a, b) => b.avgPoints - a.avgPoints);
allPlayersList.forEach((player, index) => {
player.rosRank = index + 1;
});
}
function calculateMomentum(player, position) {
if (!player.weeks || player.weeks.length < 4) {
return {
score: 0,
isValid: false,
direction: 'neutral'
};
}
const sortedWeeks = [...player.weeks].sort((a, b) => a.week - b.week);
const totalWeeks = sortedWeeks.length;
const currentWindow = sortedWeeks.slice(-3);
const previousWindow = sortedWeeks.slice(-6, -3);
if (currentWindow.length < 3 || previousWindow.length < 3) {
return {
score: 0,
isValid: false,
direction: 'neutral'
};
}
const avg = (arr, key) => {
const sum = arr.reduce((s, w) => s + (w[key] || 0), 0);
return sum / arr.length;
};
const pctChange = (current, previous) => {
if (previous === 0) return current > 0 ? 100 : 0;
return ((current - previous) / previous) * 100;
};
let momentum = 0;
if (position === 'WR') {
const currentTargets = avg(currentWindow, 'targets');
const previousTargets = avg(previousWindow, 'targets');
const targetsChange = pctChange(currentTargets, previousTargets);
const currentReceptions = avg(currentWindow, 'receptions');
const previousReceptions = avg(previousWindow, 'receptions');
const receptionsChange = pctChange(currentReceptions, previousReceptions);
const currentPoints = avg(currentWindow, 'fpts');
const previousPoints = avg(previousWindow, 'fpts');
const pointsChange = pctChange(currentPoints, previousPoints);
momentum = (0.5 * targetsChange) + (0.3 * receptionsChange) + (0.2 * pointsChange);
} else if (position === 'RB') {
const currentRushAttempts = avg(currentWindow, 'rushAttempts');
const previousRushAttempts = avg(previousWindow, 'rushAttempts');
const rushAttemptsChange = pctChange(currentRushAttempts, previousRushAttempts);
const currentRushYards = currentWindow.reduce((sum, w) => {
return sum + (w.rushYards || 0);
}, 0) / currentWindow.length;
const previousRushYards = previousWindow.reduce((sum, w) => {
return sum + (w.rushYards || 0);
}, 0) / previousWindow.length;
const rushYardsChange = pctChange(currentRushYards, previousRushYards);
const currentPoints = avg(currentWindow, 'fpts');
const previousPoints = avg(previousWindow, 'fpts');
const pointsChange = pctChange(currentPoints, previousPoints);
momentum = (0.5 * rushAttemptsChange) + (0.4 * rushYardsChange) + (0.1 * pointsChange);
}
let direction = 'neutral';
if (momentum > 5) {
direction = 'up';
} else if (momentum < -5) {
direction = 'down';
}
return {
score: momentum,
isValid: true,
direction: direction
};
}
function calculateAllMomentum() {
Object.values(window.aggregatedWRs).forEach(player => {
const momentum = calculateMomentum(player, 'WR');
player.momentum = momentum;
});
Object.values(window.aggregatedRBs).forEach(player => {
const momentum = calculateMomentum(player, 'RB');
player.momentum = momentum;
});
Object.values(window.aggregatedTEs).forEach(player => {
const momentum = calculateMomentum(player, 'WR');
player.momentum = momentum;
}); }
function getTopMovers(position, count = 5) {
const players = position === 'WR' ? Object.values(window.aggregatedWRs) :
position === 'RB' ? Object.values(window.aggregatedRBs) :
Object.values(window.aggregatedTEs);
const validPlayers = players.filter(p =>
p.momentum &&
p.momentum.isValid &&
p.gamesPlayed >= 6 // Need at least 6 weeks for momentum calculation
);
const sorted = [...validPlayers].sort((a, b) => b.momentum.score - a.momentum.score);
const risers = sorted.filter(p => p.momentum.score > 0).slice(0, count);
const fallers = sorted.filter(p => p.momentum.score < 0).reverse().slice(0, count);
return { risers, fallers };
}
function renderTopMoversWidgets(position, containerId) {
const container = document.getElementById(containerId);
if (!container) return;
const { risers, fallers } = getTopMovers(position, 8);
let html = '<div class="top-movers-container">';
if (risers.length > 0) {
const methodologyText = position === 'WR' || position === 'TE'
? 'Each player receives a <i><strong>Momentum Score</strong></i> by comparing their last 3 weeks to their previous 3 weeks. The formula weights: 50% change in targets per game + 30% change in receptions per game + 20% change in fantasy points per game. The percentage shown is the overall weighted <i><strong>Momentum Score</strong></i> - positive values indicate improvement, negative values indicate decline. Players must have at least 6 weeks of data to qualify.'
: 'Each player receives a <i><strong>Momentum Score</strong></i> by comparing their last 3 weeks to their previous 3 weeks. The formula weights: 50% change in rush attempts per game + 40% change in rush yards per game + 10% change in fantasy points per game. The percentage shown is the overall weighted <i><strong>Momentum Score</strong></i> - positive values indicate improvement, negative values indicate decline. Players must have at least 6 weeks of data to qualify.';
html += `
<div class="top-movers-widget risers"><div class="top-movers-header"><div class="top-movers-header-left"><span class="top-movers-title">Top Movers Up</span><div class="ticker-info-icon" onclick="event.stopPropagation(); toggleTickerTooltip(event)">
i
<div class="ticker-tooltip">
${methodologyText}
</div></div></div></div><div class="top-movers-content" id="risers-content-${position}"><div class="top-movers-list" id="risers-list-${position}">
`;
risers.forEach((player, index) => {
const escapedId = player.id.replace(/'/g, "\\'");
const hiddenClass = index >= 4 ? 'top-mover-hidden' : '';
html += `
<div class="top-mover-item ${hiddenClass}" onclick="openPlayerModal('${escapedId}')"><div class="top-mover-rank">${index + 1}</div><div class="top-mover-arrow">â†‘</div><div class="top-mover-info"><div class="top-mover-name">${player.name}</div><div class="top-mover-team">${player.team}</div></div><div class="top-mover-score">+${player.momentum.score.toFixed(1)}%</div></div>
`;
});
html += `
</div>
${risers.length > 4 ? `<button class="top-movers-expand-btn" onclick="event.stopPropagation(); toggleTopMovers('risers-list-${position}', this)">Show More (4 more)</button>` : ''}
</div></div>
`;
}
if (fallers.length > 0) {
const methodologyText = position === 'WR' || position === 'TE'
? 'Each player receives a <i><strong>Momentum Score</strong></i> by comparing their last 3 weeks to their previous 3 weeks. The formula weights: 50% change in targets per game + 30% change in receptions per game + 20% change in fantasy points per game. The percentage shown is the overall weighted <i><strong>Momentum Score</strong></i> - positive values indicate improvement, negative values indicate decline. Players must have at least 6 weeks of data to qualify.'
: 'Each player receives a <i><strong>Momentum Score</strong></i> by comparing their last 3 weeks to their previous 3 weeks. The formula weights: 50% change in rush attempts per game + 40% change in rush yards per game + 10% change in fantasy points per game. The percentage shown is the overall weighted <i><strong>Momentum Score</strong></i> - positive values indicate improvement, negative values indicate decline. Players must have at least 6 weeks of data to qualify.';
html += `
<div class="top-movers-widget fallers"><div class="top-movers-header"><div class="top-movers-header-left"><span class="top-movers-title">Top Movers Down</span><div class="ticker-info-icon" onclick="event.stopPropagation(); toggleTickerTooltip(event)">
i
<div class="ticker-tooltip">
${methodologyText}
</div></div></div></div><div class="top-movers-content" id="fallers-content-${position}"><div class="top-movers-list" id="fallers-list-${position}">
`;
fallers.forEach((player, index) => {
const escapedId = player.id.replace(/'/g, "\\'");
const hiddenClass = index >= 4 ? 'top-mover-hidden' : '';
html += `
<div class="top-mover-item ${hiddenClass}" onclick="openPlayerModal('${escapedId}')"><div class="top-mover-rank">${index + 1}</div><div class="top-mover-arrow">â†“</div><div class="top-mover-info"><div class="top-mover-name">${player.name}</div><div class="top-mover-team">${player.team}</div></div><div class="top-mover-score">${player.momentum.score.toFixed(1)}%</div></div>
`;
});
html += `
</div>
${fallers.length > 4 ? `<button class="top-movers-expand-btn" onclick="event.stopPropagation(); toggleTopMovers('fallers-list-${position}', this)">Show More (4 more)</button>` : ''}
</div></div>
`;
}
html += '</div>';
container.innerHTML = html;
}
function toggleTopMovers(listId, button) {
const list = document.getElementById(listId);
const hiddenItems = list.querySelectorAll('.top-mover-hidden');
const isExpanded = button.textContent.includes('Show Less');
if (isExpanded) {
hiddenItems.forEach(item => item.style.display = 'none');
button.textContent = 'Show More (4 more)';
} else {
hiddenItems.forEach(item => item.style.display = 'flex');
button.textContent = 'Show Less';
}
}
function toggleTierCollapse(headerElement) {
const icon = headerElement.querySelector('.tier-collapse-icon');
const container = headerElement.nextElementSibling;
if (icon && container) {
icon.classList.toggle('collapsed');
container.classList.toggle('collapsed');
if (!container.classList.contains('collapsed')) {
container.style.maxHeight = container.scrollHeight + 'px';
} else {
container.style.maxHeight = '0';
}
}
}
function expandAllTiers() {
const activePage = document.querySelector('.page.active');
if (!activePage) { return;
}
const icons = activePage.querySelectorAll('.tier-collapse-icon');
const containers = activePage.querySelectorAll('.tier-cards-container');
icons.forEach(icon => {
icon.classList.remove('collapsed');
});
containers.forEach(container => {
container.classList.remove('collapsed');
container.style.maxHeight = '100000px';
});
}
function renderMiniChart(canvasId, player) {
const ctx = document.getElementById(canvasId);
if (!ctx) return;
const actuals = player.weeks.map(w => w.fpts);
const expected = player.weeks.map(w => w.expectedFpts);
new Chart(ctx, {
type: 'line',
data: {
labels: player.weeks.map(w => w.week),
datasets: [
{
data: actuals,
borderColor: '#30d158',
borderWidth: 2.5, // Thicker trail for better visibility
fill: false,
pointRadius: 0,
tension: 0.3
},
{
data: expected,
borderColor: '#8e8e93',
borderWidth: 1,
borderDash: [2, 2],
fill: false,
pointRadius: 0,
tension: 0.3
}
]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: {
legend: { display: false },
tooltip: { enabled: false }
},
scales: {
x: { display: false },
y: { display: false }
},
interaction: { mode: null }
}
});
}
function renderAllPages() {
// renderHomeInsights(); // Old homepage - disabled
renderMarketTicker();
rotateHomeMessages();
updateHomepageInsights();  // Update dynamic homepage insights
renderTicker();
renderTeamsTicker();
renderInsightsTicker();
// renderAnalyticsTicker(); // Removed - ticker not needed on leaderboards page
renderDashboardCategories();
renderStatOfTheWeek();
renderPRSLeaderboard('WR');
renderWRPlayerCards();
renderRBPlayerCards();
renderTEPlayerCards();
renderTeamsPage();
renderScatterPlots();
renderTopMoversWidgets('WR', 'wr-top-movers-sidebar');
renderTopMoversWidgets('RB', 'rb-top-movers-sidebar');
renderTopMoversWidgets('TE', 'te-top-movers-sidebar');
setupDashboardTrendScrubbers();
initializeAdvancedAnalytics();
initializeAnalyticsDashboard();
}
function renderTicker() {
const wrTickerTrack = document.getElementById('wr-ticker-track');
const topWRs = Object.values(window.aggregatedWRs)
.sort((a, b) => b.avgPoints - a.avgPoints)
.slice(0, 50);
const wrTickerHTML = topWRs.map((player, index) => {
let shareChange = 0;
if (player.weeks.length >= 2) {
const weeksWithTargets = player.weeks.filter(w => w.teamShare && w.teamShare > 0);
if (weeksWithTargets.length >= 2) {
const latestWeek = weeksWithTargets[weeksWithTargets.length - 1];
const previousWeek = weeksWithTargets[weeksWithTargets.length - 2];
shareChange = latestWeek.teamShare - previousWeek.teamShare;
}
}
const changeClass = shareChange >= 0 ? 'positive' : 'negative';
const changeSymbol = shareChange >= 0 ? 'â–²' : 'â–¼';
const changePct = Math.abs(shareChange).toFixed(1);
const rank = index + 1;
return `
<div class="ticker-item"><span class="player-name">#${rank} ${player.name}</span><span class="avg-pts">${player.avgPoints.toFixed(1)}</span><span class="change ${changeClass}">${changeSymbol} ${changePct}% tgt share</span></div>
`;
}).join('');
wrTickerTrack.innerHTML = wrTickerHTML + wrTickerHTML;
const rbTickerTrack = document.getElementById('rb-ticker-track');
const topRBs = Object.values(window.aggregatedRBs)
.sort((a, b) => b.avgPoints - a.avgPoints)
.slice(0, 50);
const rbTickerHTML = topRBs.map((player, index) => {
let shareChange = 0;
if (player.weeks.length >= 2) {
const weeksWithOpps = player.weeks.filter(w => w.opportunities && w.opportunities > 0);
if (weeksWithOpps.length >= 2) {
const latestWeek = weeksWithOpps[weeksWithOpps.length - 1];
const previousWeek = weeksWithOpps[weeksWithOpps.length - 2];
const latestTeamRows = rbData.filter(row =>
row.Team === player.team &&
parseInt(row.Week) === latestWeek.week &&
parseFloat(row['RB Opp']) > 0
);
const prevTeamRows = rbData.filter(row =>
row.Team === player.team &&
parseInt(row.Week) === previousWeek.week &&
parseFloat(row['RB Opp']) > 0
);
const latestTeamTotal = latestTeamRows.reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);
const prevTeamTotal = prevTeamRows.reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);
const latestShare = latestTeamTotal > 0 ? (latestWeek.opportunities / latestTeamTotal) * 100 : 0;
const prevShare = prevTeamTotal > 0 ? (previousWeek.opportunities / prevTeamTotal) * 100 : 0;
shareChange = latestShare - prevShare;
}
}
const changeClass = shareChange >= 0 ? 'positive' : 'negative';
const changeSymbol = shareChange >= 0 ? 'â–²' : 'â–¼';
const changePct = Math.abs(shareChange).toFixed(1);
const rank = index + 1;
return `
<div class="ticker-item"><span class="player-name">#${rank} ${player.name}</span><span class="avg-pts">${player.avgPoints.toFixed(1)}</span><span class="change ${changeClass}">${changeSymbol} ${changePct}% opp share</span></div>
`;
}).join('');
rbTickerTrack.innerHTML = rbTickerHTML + rbTickerHTML;
const teTickerTrack = document.getElementById('te-ticker-track');
const topTEs = Object.values(window.aggregatedTEs)
.sort((a, b) => b.avgPoints - a.avgPoints)
.slice(0, 24);
const teTickerHTML = topTEs.map((player, index) => {
let shareChange = 0;
if (player.weeks.length >= 2) {
const weeksWithTargets = player.weeks.filter(w => w.teamShare && w.teamShare > 0);
if (weeksWithTargets.length >= 2) {
const latestWeek = weeksWithTargets[weeksWithTargets.length - 1];
const previousWeek = weeksWithTargets[weeksWithTargets.length - 2];
shareChange = latestWeek.teamShare - previousWeek.teamShare;
}
}
const changeClass = shareChange >= 0 ? 'positive' : 'negative';
const changeSymbol = shareChange >= 0 ? 'â–²' : 'â–¼';
const changePct = Math.abs(shareChange).toFixed(1);
const rank = index + 1;
return `
<div class="ticker-item"><span class="player-name">#${rank} ${player.name}</span><span class="avg-pts">${player.avgPoints.toFixed(1)}</span><span class="change ${changeClass}">${changeSymbol} ${changePct}% tgt share</span></div>
`;
}).join('');
teTickerTrack.innerHTML = teTickerHTML + teTickerHTML;
}
function renderTeamsTicker() {
const teamsTickerTrack = document.getElementById('teams-ticker-track');
console.log('renderTeamsTicker called, ticker track element found:', !!teamsTickerTrack);

if (!teamsTickerTrack) { return;
}
if (!wrData || !rbData) { 
    console.log('No WR/RB data available');
    return;
}
const allWeeks = [...new Set(wrData.map(row => parseInt(row.Week)))];
const latestWeek = Math.max(...allWeeks);
const previousWeek = latestWeek - 1;
const teamWeeklyData = {};
wrData.forEach(row => {
const team = row.Team;
const week = parseInt(row.Week);
const points = parseFloat(row.FPTS || row.Fpts) || 0; // Handle both FPTS and Fpts
if (team === 'FA' || !team) return;
if (!teamWeeklyData[team]) {
teamWeeklyData[team] = {
team: team,
weeks: {}
};
}
if (!teamWeeklyData[team].weeks[week]) {
teamWeeklyData[team].weeks[week] = { wrPoints: 0, rbPoints: 0, tePoints: 0, totalPoints: 0 };
}
teamWeeklyData[team].weeks[week].wrPoints += points;
teamWeeklyData[team].weeks[week].totalPoints += points;
});
rbData.forEach(row => {
const team = row.Team;
const week = parseInt(row.Week);
const points = parseFloat(row.FPTS || row.Fpts) || 0; // Handle both FPTS and Fpts
if (team === 'FA' || !team) return;
if (!teamWeeklyData[team]) {
teamWeeklyData[team] = {
team: team,
weeks: {}
};
}
if (!teamWeeklyData[team].weeks[week]) {
teamWeeklyData[team].weeks[week] = { wrPoints: 0, rbPoints: 0, tePoints: 0, totalPoints: 0 };
}
teamWeeklyData[team].weeks[week].rbPoints += points;
teamWeeklyData[team].weeks[week].totalPoints += points;
});
if (teData) {
teData.forEach(row => {
const team = row.Team;
const week = parseInt(row.Week);
const points = parseFloat(row.FPTS || row.Fpts) || 0; // Handle both FPTS and Fpts
if (team === 'FA' || !team) return;
if (!teamWeeklyData[team]) {
teamWeeklyData[team] = {
team: team,
weeks: {}
};
}
if (!teamWeeklyData[team].weeks[week]) {
teamWeeklyData[team].weeks[week] = { wrPoints: 0, rbPoints: 0, tePoints: 0, totalPoints: 0 };
}
teamWeeklyData[team].weeks[week].tePoints += points;
teamWeeklyData[team].weeks[week].totalPoints += points;
}); }
const teamsData = Object.values(teamWeeklyData).map(teamData => {
const latestWeekData = teamData.weeks[latestWeek] || { wrPoints: 0, rbPoints: 0, tePoints: 0, totalPoints: 0 };
const previousWeekData = teamData.weeks[previousWeek] || { wrPoints: 0, rbPoints: 0, tePoints: 0, totalPoints: 0 };
let percentChange = 0;
let showChange = true;

if (previousWeekData.totalPoints > 0) {
percentChange = ((latestWeekData.totalPoints - previousWeekData.totalPoints) / previousWeekData.totalPoints) * 100;
} else {
// No previous week data (likely bye week) - don't show change
showChange = false;
}

return {
team: teamData.team,
wrPoints: latestWeekData.wrPoints,
rbPoints: latestWeekData.rbPoints,
tePoints: latestWeekData.tePoints,
totalPoints: latestWeekData.totalPoints,
percentChange: percentChange,
previousTotal: previousWeekData.totalPoints,
showChange: showChange
};
});
const topTeams = teamsData
.sort((a, b) => b.totalPoints - a.totalPoints)
.slice(0, 32); // All teams
const teamsTickerHTML = topTeams.map((team, index) => {
const rank = index + 1;
const teamColor = teamColors[team.team] || '#0a84ff';
const changeClass = team.percentChange >= 0 ? 'positive' : 'negative';
const changeSymbol = team.percentChange >= 0 ? 'â–²' : 'â–¼';
const isDark = !document.documentElement.getAttribute('data-theme') || document.documentElement.getAttribute('data-theme') === 'dark';
const rankColor = isDark ? 'white' : '#1a1a1a';
const changeHTML = team.showChange 
? `<span class="change ${changeClass}" style="font-size: 13px; margin-left: 8px;">${changeSymbol} ${Math.abs(team.percentChange).toFixed(1)}%</span>` 
: '';
return `
<div class="ticker-item"><span class="player-name" style="font-size: 13px; font-weight: 700; color: ${rankColor}; vertical-align: baseline;">#${rank} ${team.team}</span> <span class="avg-pts" style="font-size: 13px; margin-left: 8px; vertical-align: baseline;">${team.totalPoints.toFixed(1)} pts</span> <span style="color: var(--text-secondary); font-size: 11px; margin-left: 8px; vertical-align: baseline;">WR: ${team.wrPoints.toFixed(0)} | RB: ${team.rbPoints.toFixed(0)} | TE: ${team.tePoints.toFixed(0)}</span>${changeHTML}</div>
`;
}).join('');
teamsTickerTrack.innerHTML = teamsTickerHTML + teamsTickerHTML;

// Generate team insights for rotating ticker
generateTeamInsights(teamsData);
}

// Team Insights State
const teamInsightsState = {
    insights: [],
    currentIndex: 0,
    autoRotateInterval: null
};

function generateTeamInsights(teamsData) {
    console.log('generateTeamInsights called with:', teamsData ? teamsData.length : 0, 'teams');
    
    if (!teamsData || teamsData.length === 0) {
        console.log('No teams data available');
        return;
    }
    
    // Update week display dynamically
    const weekEl = document.querySelector('#teams .heatmap-ticker-week');
    if (weekEl && wrData && wrData.length > 0) {
        const allWeeks = [...new Set(wrData.map(row => parseInt(row.Week)))];
        const latestWeek = Math.max(...allWeeks);
        weekEl.textContent = `WEEK ${latestWeek}`;
    }
    
    const insights = [];
    
    // Sort teams by total points (create a copy to avoid mutation issues)
    const sortedTeams = [...teamsData].sort((a, b) => b.totalPoints - a.totalPoints);
    
    console.log('Sorted teams:', sortedTeams.length, 'First team:', sortedTeams[0]);
    
    // 1. TOP OFFENSE - Highest scoring team
    if (sortedTeams.length > 0) {
        const topTeam = sortedTeams[0];
        insights.push({
            value: `#1`,
            label: `TOP OFFENSE: ${topTeam.team}`,
            text: `Leads the league with <strong>${topTeam.totalPoints.toFixed(1)} fantasy points</strong> this week. ${topTeam.wrPoints > topTeam.rbPoints ? 'Pass-first attack' : 'Ground-and-pound offense'} producing elite fantasy output.`
        });
    }
    
    // 2. MOST BALANCED - Closest to 50/50 split
    const teamsWithBalance = teamsData.map(t => {
        const passPoints = t.wrPoints + t.tePoints;
        const runPoints = t.rbPoints;
        const total = passPoints + runPoints;
        const passPct = total > 0 ? (passPoints / total) * 100 : 0;
        const balance = Math.abs(50 - passPct); // Distance from perfect 50/50
        return { ...t, passPct, runPct: 100 - passPct, balance };
    }).sort((a, b) => a.balance - b.balance);
    
    if (teamsWithBalance.length > 0) {
        const balanced = teamsWithBalance[0];
        insights.push({
            value: `${balanced.passPct.toFixed(0)}/${balanced.runPct.toFixed(0)}`,
            label: `MOST BALANCED: ${balanced.team}`,
            text: `Perfect offensive harmony with <strong>${balanced.passPct.toFixed(0)}% pass / ${balanced.runPct.toFixed(0)}% run</strong> split. Balanced attacks are harder to defend and provide consistent fantasy production.`
        });
    }
    
    // 3. PASS HEAVY - Highest pass percentage
    const passHeavyTeams = teamsWithBalance
        .filter(t => t.totalPoints > 20) // Filter out low-scoring teams
        .sort((a, b) => b.passPct - a.passPct);
    
    if (passHeavyTeams.length > 0) {
        const passHeavy = passHeavyTeams[0];
        insights.push({
            value: `${passHeavy.passPct.toFixed(0)}%`,
            label: `AIR RAID: ${passHeavy.team}`,
            text: `Throwing the ball <strong>${passHeavy.passPct.toFixed(0)}% of the time</strong> with ${passHeavy.wrPoints.toFixed(1)} WR points and ${passHeavy.tePoints.toFixed(1)} TE points. Elite environment for pass-catchers.`
        });
    }
    
    // 4. RUN HEAVY - Highest run percentage
    const runHeavyTeams = teamsWithBalance
        .filter(t => t.totalPoints > 20)
        .sort((a, b) => b.runPct - a.runPct);
    
    if (runHeavyTeams.length > 0) {
        const runHeavy = runHeavyTeams[0];
        insights.push({
            value: `${runHeavy.runPct.toFixed(0)}%`,
            label: `GROUND & POUND: ${runHeavy.team}`,
            text: `Commits to the run <strong>${runHeavy.runPct.toFixed(0)}% of the time</strong> generating ${runHeavy.rbPoints.toFixed(1)} RB points. Premium landing spot for workhorse backs.`
        });
    }
    
    // 5. TOP WR ROOM - Highest WR points
    const topWRTeams = [...teamsData].sort((a, b) => b.wrPoints - a.wrPoints);
    if (topWRTeams.length > 0) {
        const topWR = topWRTeams[0];
        insights.push({
            value: `${topWR.wrPoints.toFixed(0)}`,
            label: `BEST WR ROOM: ${topWR.team}`,
            text: `League-leading <strong>${topWR.wrPoints.toFixed(1)} WR fantasy points</strong> this week. Elite pass-catching environment with high-volume target distribution.`
        });
    }
    
    // 6. RB FACTORY - Highest RB points
    const topRBTeams = [...teamsData].sort((a, b) => b.rbPoints - a.rbPoints);
    if (topRBTeams.length > 0) {
        const topRB = topRBTeams[0];
        insights.push({
            value: `${topRB.rbPoints.toFixed(0)}`,
            label: `RB FACTORY: ${topRB.team}`,
            text: `Produced <strong>${topRB.rbPoints.toFixed(1)} RB fantasy points</strong> this week. Running backs thrive in this high-opportunity offense.`
        });
    }
    
    // 7. TE RELIANT - Highest TE percentage (if TE data exists)
    const teamsWithTE = teamsData.filter(t => t.tePoints > 0);
    if (teamsWithTE.length > 0) {
        const teReliantTeams = teamsWithTE.map(t => {
            const tePct = t.totalPoints > 0 ? (t.tePoints / t.totalPoints) * 100 : 0;
            return { ...t, tePct };
        }).sort((a, b) => b.tePct - a.tePct);
        
        if (teReliantTeams.length > 0 && teReliantTeams[0].tePct > 15) {
            const teReliant = teReliantTeams[0];
            insights.push({
                value: `${teReliant.tePct.toFixed(0)}%`,
                label: `TE RELIANT: ${teReliant.team}`,
                text: `Tight ends account for <strong>${teReliant.tePct.toFixed(0)}% of total offense</strong> (${teReliant.tePoints.toFixed(1)} pts). Heavy TE utilization signals target concentration.`
            });
        }
    }
    
    // Update state and start rotation
    console.log('Generated', insights.length, 'team insights');
    teamInsightsState.insights = insights;
    teamInsightsState.currentIndex = 0;
    displayTeamInsight(0);
    startTeamInsightRotation();
    console.log('Team insights rotation started');
}

function displayTeamInsight(index) {
    const valueEl = document.getElementById('teams-rotating-value');
    const labelEl = document.getElementById('teams-rotating-label');
    const textEl = document.getElementById('teams-rotating-text');
    
    console.log('displayTeamInsight called, index:', index, 'elements found:', !!valueEl, !!labelEl, !!textEl);
    
    if (!valueEl || !labelEl || !textEl) return;
    if (teamInsightsState.insights.length === 0) {
        valueEl.textContent = '...';
        labelEl.textContent = 'Loading';
        textEl.textContent = 'Analyzing team data...';
        return;
    }
    
    index = ((index % teamInsightsState.insights.length) + teamInsightsState.insights.length) % teamInsightsState.insights.length;
    teamInsightsState.currentIndex = index;
    const insight = teamInsightsState.insights[index];
    
    console.log('Displaying insight:', insight.label);
    
    // Fade out
    valueEl.style.opacity = '0';
    labelEl.style.opacity = '0';
    textEl.style.opacity = '0';
    
    setTimeout(() => {
        // Update content
        valueEl.textContent = insight.value;
        labelEl.textContent = insight.label;
        // Remove HTML tags from text for display
        textEl.innerHTML = insight.text.replace(/<strong>/g, '').replace(/<\/strong>/g, '');
        
        // Fade in
        valueEl.style.opacity = '1';
        labelEl.style.opacity = '1';
        textEl.style.opacity = '1';
    }, 300);
}

function startTeamInsightRotation() {
    stopTeamInsightRotation(); // Clear any existing interval
    teamInsightsState.autoRotateInterval = setInterval(() => {
        displayTeamInsight(teamInsightsState.currentIndex + 1);
    }, 15000); // 15 seconds
}

function stopTeamInsightRotation() {
    if (teamInsightsState.autoRotateInterval) {
        clearInterval(teamInsightsState.autoRotateInterval);
        teamInsightsState.autoRotateInterval = null;
    }
}

// ============================================
// SCATTER INSIGHTS FOR ADVANCED ANALYTICS PAGE
// ============================================

const scatterInsightsState = {
    insights: [],
    currentIndex: 0,
    autoRotateInterval: null,
    currentPosition: 'WR',
    currentXStat: '',
    currentYStat: ''
};

function generateScatterInsights(data, position, xStat, yStat) {
    console.log('generateScatterInsights called with:', data ? data.length : 0, 'players', position, xStat, yStat);
    
    if (!data || data.length === 0) {
        console.log('No scatter data available');
        return;
    }
    
    // Update week display dynamically
    const weekEl = document.querySelector('#advanced-analytics .heatmap-ticker-week');
    if (weekEl && wrData && wrData.length > 0) {
        const allWeeks = [...new Set(wrData.map(row => parseInt(row.Week)))];
        const latestWeek = Math.max(...allWeeks);
        weekEl.textContent = `WEEK ${latestWeek}`;
    }
    
    const insights = [];
    
    // Store current config
    scatterInsightsState.currentPosition = position;
    scatterInsightsState.currentXStat = xStat;
    scatterInsightsState.currentYStat = yStat;
    
    // Find the current preset
    const presets = scatterPresets[position];
    const currentPreset = presets.find(p => p.xAxis === xStat && p.yAxis === yStat);
    
    if (currentPreset) {
        // Use the preset name and description as the primary insight
        insights.push({
            headline: currentPreset.name,
            subheadline: currentPreset.description
        });
    }
    
    // Get stat labels for dynamic insights
    const xLabel = xStat.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
    const yLabel = yStat.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
    
    // Calculate medians for quadrant analysis
    const medianX = data.map(p => parseFloat(p[xStat]) || 0).sort((a, b) => a - b)[Math.floor(data.length / 2)];
    const medianY = data.map(p => parseFloat(p[yStat]) || 0).sort((a, b) => a - b)[Math.floor(data.length / 2)];
    
    // Elite performers (top-right quadrant)
    const elitePlayers = data.filter(p => (parseFloat(p[xStat]) || 0) >= medianX && (parseFloat(p[yStat]) || 0) >= medianY);
    if (elitePlayers.length > 0) {
        insights.push({
            headline: `${elitePlayers.length} Elite Performer${elitePlayers.length > 1 ? 's' : ''}`,
            subheadline: `Players excelling in both ${xLabel.toLowerCase()} and ${yLabel.toLowerCase()}`
        });
    }
    
    // Top performer by Y-axis
    const topPerformer = data.reduce((max, p) => ((parseFloat(p[yStat]) || 0) > (parseFloat(max[yStat]) || 0) ? p : max), data[0]);
    if (topPerformer && (parseFloat(topPerformer[yStat]) || 0) > 0) {
        const value = parseFloat(topPerformer[yStat]) || 0;
        insights.push({
            headline: `${topPerformer.Player_Name} leads in ${yLabel}`,
            subheadline: `${value.toFixed(1)} ${yLabel.toLowerCase()} - top performance in this metric`
        });
    }
    
    // Volume vs efficiency insight (if applicable)
    const highVolumeLowEff = data.filter(p => (parseFloat(p[xStat]) || 0) >= medianX && (parseFloat(p[yStat]) || 0) < medianY);
    if (highVolumeLowEff.length > 0) {
        insights.push({
            headline: `${highVolumeLowEff.length} High-Volume Opportunity`,
            subheadline: `Players with strong ${xLabel.toLowerCase()} showing room for efficiency growth`
        });
    }
    
    // Efficiency without volume (if applicable)
    const highEffLowVol = data.filter(p => (parseFloat(p[xStat]) || 0) < medianX && (parseFloat(p[yStat]) || 0) >= medianY);
    if (highEffLowVol.length > 0) {
        insights.push({
            headline: `${highEffLowVol.length} Efficiency Play${highEffLowVol.length > 1 ? 's' : ''}`,
            subheadline: `Strong ${yLabel.toLowerCase()} with potential for increased ${xLabel.toLowerCase()}`
        });
    }
    
    // Position average
    const avgX = (data.reduce((sum, p) => sum + (parseFloat(p[xStat]) || 0), 0) / data.length).toFixed(1);
    const avgY = (data.reduce((sum, p) => sum + (parseFloat(p[yStat]) || 0), 0) / data.length).toFixed(1);
    insights.push({
        headline: `${position} Position Average`,
        subheadline: `${avgX} ${xLabel.toLowerCase()}, ${avgY} ${yLabel.toLowerCase()} per game`
    });
    
    // Sample size insight
    insights.push({
        headline: `Analyzing ${data.length} ${position}s`,
        subheadline: `Comprehensive view of the ${position} position landscape`
    });
    
    // Update state and start rotation
    console.log('Generated', insights.length, 'scatter insights');
    scatterInsightsState.insights = insights;
    scatterInsightsState.currentIndex = 0;
    displayScatterInsight(0);
    startScatterInsightRotation();
    
    // Generate insight cards below the chart
    generateScatterInsightCards(data, position, xStat, yStat, xLabel, yLabel, medianX, medianY);
    
    console.log('Scatter insights rotation started');
}

function generateScatterInsightCards(data, position, xStat, yStat, xLabel, yLabel, medianX, medianY) {
    const cardsContainer = document.getElementById('scatter-insight-cards');
    if (!cardsContainer) {
        console.log('No scatter insight cards container found');
        return;
    }
    
    console.log('ðŸŽ¯ Generating insight cards with', data.length, 'players');
    
    // Rank all players by FPTS/G
    const rankedPlayers = data
        .sort((a, b) => b.player.avgPoints - a.player.avgPoints)
        .map((d, idx) => ({ ...d, rank: idx + 1 }));
    
    // Calculate most recent week
    const weekCounts = {};
    data.forEach(p => {
        if (p.player.weeks && p.player.weeks.length > 0) {
            const playerLatestWeek = Math.max(...p.player.weeks.map(w => w.week));
            weekCounts[playerLatestWeek] = (weekCounts[playerLatestWeek] || 0) + 1;
        }
    });
    
    let mostRecentWeek = 0;
    for (const [week, count] of Object.entries(weekCounts)) {
        if (count >= 10 && parseInt(week) > mostRecentWeek) {
            mostRecentWeek = parseInt(week);
        }
    }
    
    const last5Weeks = [
        mostRecentWeek,
        mostRecentWeek - 1,
        mostRecentWeek - 2,
        mostRecentWeek - 3,
        mostRecentWeek - 4
    ];
    
    console.log('ðŸ“… Current week:', mostRecentWeek, '| Last 5 weeks:', last5Weeks);
    
    // Top 10 players by FPTS/G
    const top10PlayerIds = rankedPlayers.slice(0, 10).map(p => p.player.id);
    
    // Filter eligible players
    const eligiblePlayers = rankedPlayers.filter(d => {
        // Check games played in last 5 weeks
        const weeksWithData = d.player.weeks.filter(w => last5Weeks.includes(w.week));
        const playedEnough = weeksWithData.length >= 3;
        
        // Check IR status from Sleeper API
        const injury = getPlayerInjuryStatus(d.player.name);
        const isIR = injury && injury.status === 'IR';
        
        // Debug first few players
        if (d.rank <= 15) {
            console.log(`Player ${d.player.name} (rank ${d.rank}):`, {
                weeksWithData: weeksWithData.length,
                playedEnough,
                injuryStatus: injury ? injury.status : 'None',
                isIR,
                eligible: playedEnough && !isIR
            });
        }
        
        return playedEnough && !isIR;
    });
    
    console.log('âœ… Eligible players:', eligiblePlayers.length, '/', rankedPlayers.length);
    
    // DEBUG: Log momentum distribution to understand the data
    const momentumValues = eligiblePlayers.slice(0, 20).map(d => ({
        name: d.player.name,
        rank: d.rank,
        momentum: d.player.momentum || 'N/A',
        avgPoints: d.player.avgPoints || 'N/A',
        consistency: d.player.consistency || 'N/A'
    }));
    console.table(momentumValues);
    
    // Define badge categories with their rules - VERY LENIENT
    const badgeCategories = {
        'BREAKOUT': {
            name: 'BREAKOUT',
            color: 'var(--accent-blue)',
            filter: (d) => {
                const notTop10 = !top10PlayerIds.includes(d.player.id);
                const risingPlayer = d.player.momentum != null && d.player.momentum > 0.3;
                const goodRank = d.rank >= 11 && d.rank <= 50;
                return notTop10 && risingPlayer && goodRank;
            }
        },
        'ELITE_SLEEPER': {
            name: 'ELITE SLEEPER',
            color: '#ff9500',
            filter: (d) => {
                const underRadar = d.player.avgPoints < 12 && d.player.avgPoints > 6;
                const decentRank = d.rank >= 15 && d.rank <= 70;
                return underRadar && decentRank;
            }
        },
        'BUY_LOW': {
            name: 'BUY LOW',
            color: 'var(--positive)',
            filter: (d) => {
                const notTop10 = !top10PlayerIds.includes(d.player.id);
                const hasNegMomentum = d.player.momentum != null && d.player.momentum < -0.2;
                const goodRank = d.rank >= 11 && d.rank <= 45;
                return notTop10 && hasNegMomentum && goodRank;
            }
        },
        'SELL_HIGH': {
            name: 'SELL HIGH',
            color: '#ff9500',
            filter: (d) => {
                const hasPosMomentum = d.player.momentum != null && d.player.momentum > 0.8;
                const goodRank = d.rank >= 11 && d.rank <= 50;
                return hasPosMomentum && goodRank;
            }
        },
        'WATCHLIST': {
            name: 'WATCHLIST',
            color: 'var(--negative)',
            filter: (d) => {
                const declining = d.player.momentum != null && d.player.momentum < -0.3;
                const goodRank = d.rank >= 11 && d.rank <= 60;
                return declining && goodRank;
            }
        }
    };
    
    // Collect candidates for each badge (max 3 per badge)
    const selectedPlayers = [];
    const usedPlayerIds = new Set();
    const badgeCounts = {};
    
    console.log('ðŸ” Badge filtering - eligible pool:', eligiblePlayers.length);
    
    // Iterate through each badge type
    for (const [badgeKey, badgeConfig] of Object.entries(badgeCategories)) {
        badgeCounts[badgeKey] = 0;
        
        const candidates = eligiblePlayers.filter(d => {
            return !usedPlayerIds.has(d.player.id) && badgeConfig.filter(d);
        });
        
        console.log(`ðŸ“‹ ${badgeConfig.name}: ${candidates.length} candidates`);
        
        // Take up to 3 from this category
        for (let i = 0; i < Math.min(3, candidates.length); i++) {
            if (selectedPlayers.length >= 9) break; // Max 9 total cards
            
            selectedPlayers.push({
                ...candidates[i],
                badge: badgeConfig.name,
                badgeColor: badgeConfig.color
            });
            usedPlayerIds.add(candidates[i].player.id);
            badgeCounts[badgeKey]++;
        }
        
        if (selectedPlayers.length >= 9) break;
    }
    
    console.log('ðŸ“Š After badge filtering:', selectedPlayers.length, 'cards selected');
    
    // If we have less than 6, add generic cards based on rank
    if (selectedPlayers.length < 6) {
        console.log('âš ï¸ Need more cards (have', selectedPlayers.length, '), adding fillers...');
        const fillerCandidates = eligiblePlayers.filter(d => {
            return !usedPlayerIds.has(d.player.id) && d.rank >= 11 && d.rank <= 80;
        });
        
        console.log('ðŸ”§ Filler candidates available:', fillerCandidates.length);
        
        // Add fillers until we reach at least 6 (but cap at 9)
        for (const candidate of fillerCandidates) {
            if (selectedPlayers.length >= 9) break;
            if (selectedPlayers.length >= 6 && selectedPlayers.length >= eligiblePlayers.length * 0.15) break; // At least 6, or 15% of eligible pool
            
            // Determine badge based on rank, respecting 3-per-badge limit
            let badge = 'WATCHLIST';
            let badgeColor = 'var(--negative)';
            
            if (candidate.player.avgPoints < 12 && candidate.rank >= 20 && (!badgeCounts['ELITE_SLEEPER'] || badgeCounts['ELITE_SLEEPER'] < 3)) {
                badge = 'ELITE SLEEPER';
                badgeColor = '#ff9500';
                badgeCounts['ELITE_SLEEPER'] = (badgeCounts['ELITE_SLEEPER'] || 0) + 1;
            } else if (candidate.rank >= 11 && candidate.rank <= 30 && (!badgeCounts['BREAKOUT'] || badgeCounts['BREAKOUT'] < 3)) {
                badge = 'BREAKOUT';
                badgeColor = 'var(--accent-blue)';
                badgeCounts['BREAKOUT'] = (badgeCounts['BREAKOUT'] || 0) + 1;
            } else {
                badgeCounts['WATCHLIST'] = (badgeCounts['WATCHLIST'] || 0) + 1;
            }
            
            selectedPlayers.push({
                ...candidate,
                badge: badge,
                badgeColor: badgeColor
            });
            usedPlayerIds.add(candidate.player.id);
        }
    }
    
    console.log('ðŸŽ´ Final card count:', selectedPlayers.length);
    console.log('Badge distribution:', badgeCounts);
    
    // Shuffle cards for variety
    for (let i = selectedPlayers.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [selectedPlayers[i], selectedPlayers[j]] = [selectedPlayers[j], selectedPlayers[i]];
    }
    
    // Render cards
    const cardsHTML = selectedPlayers.map((spotlight, idx) => {
        const player = spotlight.player;
        const teamColor = teamColors[player.team] || '#8e8e93';
        
        // Get rich analysis from the existing function
        const analysis = analyzePlayerAcrossMetrics(player, position, spotlight.rank, spotlight.badge.toLowerCase().replace(' ', ''), data);
        
        // Generate simple summary for collapsed view
        const fptsG = player.avgPoints ? player.avgPoints.toFixed(1) : '0.0';
        const momentumVal = (player.momentum != null && typeof player.momentum === 'number') ? player.momentum : 0;
        const momentum = momentumVal.toFixed(1);
        
        const cardId = `insight-card-${idx}`;
        
        return `
            <div class="scatter-insight-card" id="${cardId}" data-expanded="false">
                <div class="scatter-card-header" onclick="toggleInsightCard('${cardId}')">
                    <div style="flex: 1; min-width: 0;">
                        <!-- First row: Name and Category Badge -->
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 12px; margin-bottom: 6px;">
                            <h3 class="scatter-card-player-name" style="margin: 0;">${player.name}</h3>
                            <span style="display: inline-block; background: ${spotlight.badgeColor}; color: white; padding: 5px 13px; border-radius: 14px; font-size: 10px; font-weight: 700; letter-spacing: 0.6px; text-transform: uppercase; white-space: nowrap; flex-shrink: 0;">
                                ${spotlight.badge}
                            </span>
                        </div>
                        <!-- Second row: Team Badge -->
                        <div style="margin-bottom: 6px;">
                            <span style="display: inline-block; background: ${teamColor}; color: white; padding: 4px 12px; border-radius: 12px; font-size: 10px; font-weight: 700; letter-spacing: 0.5px;">
                                ${player.team}
                            </span>
                        </div>
                        <!-- Third row: Meta (smaller) -->
                        <div style="font-size: 10px; color: var(--text-tertiary);">
                            ${position} #${spotlight.rank} â€¢ ${fptsG} PPG â€¢ ${player.gamesPlayed} games
                        </div>
                    </div>
                </div>
                
                <div class="scatter-card-details">
                    <!-- Deep Narrative Analysis -->
                    <div class="scatter-section-narrative" style="margin-top: 16px; margin-bottom: 18px;">
                        <div style="font-size: 13px; color: var(--text-primary); line-height: 1.7; margin-bottom: 14px;">
                            ${analysis.narrative || 'Player analysis in progress.'}
                        </div>
                    </div>
                    
                    <!-- Key Metrics to Review -->
                    <div class="scatter-section-plots" style="border-top: 1px solid var(--border-color); padding-top: 16px; margin-bottom: 16px;">
                    ${analysis.scatterPlots && analysis.scatterPlots.length > 0 ? `
                        <div style="font-size: 11px; font-weight: 600; color: var(--text-secondary); margin-bottom: 12px; letter-spacing: 0.5px;">
                            KEY SCATTER PLOTS TO REVIEW
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            ${analysis.scatterPlots.map(plot => `
                                <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 12px; background: var(--bg-tertiary); border-radius: 8px; border-left: 3px solid ${plot.color};">
                                    <div style="flex: 1;">
                                        <div style="font-size: 12px; font-weight: 600; color: var(--text-primary); margin-bottom: 3px;">
                                            ${plot.yAxis} vs ${plot.xAxis}
                                        </div>
                                        <div style="font-size: 10px; color: var(--text-secondary); line-height: 1.4;">
                                            ${plot.reason}
                                        </div>
                                    </div>
                                    <div style="padding: 4px 8px; background: ${plot.color}; border-radius: 4px; font-size: 9px; font-weight: 700; color: white; white-space: nowrap; margin-left: 12px;">
                                        ${plot.label}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    </div>
                    
                    <!-- Strengths & Concerns -->
                    <div class="scatter-section-strengths" style="padding-top: 16px; border-top: 1px solid var(--border-color);">
                    ${(analysis.strengths && analysis.strengths.length > 0) || (analysis.concerns && analysis.concerns.length > 0) ? `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                        ${analysis.strengths && analysis.strengths.length > 0 ? `
                            <div>
                                <div style="font-size: 10px; font-weight: 600; color: var(--text-secondary); margin-bottom: 6px; letter-spacing: 0.5px;">STRENGTHS</div>
                                <div style="display: flex; flex-direction: column; gap: 4px;">
                                    ${analysis.strengths.map(strength => `
                                        <div style="padding: 4px 8px; background: var(--positive-bg); border-left: 2px solid var(--positive); border-radius: 4px; font-size: 10px; font-weight: 600; color: var(--positive);">
                                            ${strength}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        ` : '<div></div>'}
                        ${analysis.concerns && analysis.concerns.length > 0 ? `
                            <div>
                                <div style="font-size: 10px; font-weight: 600; color: var(--text-secondary); margin-bottom: 6px; letter-spacing: 0.5px;">MONITOR</div>
                                <div style="display: flex; flex-direction: column; gap: 4px;">
                                    ${analysis.concerns.map(concern => `
                                        <div style="padding: 4px 8px; background: var(--negative-bg); border-left: 2px solid var(--negative); border-radius: 4px; font-size: 10px; font-weight: 600; color: var(--negative);">
                                            ${concern}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        ` : '<div></div>'}
                    </div>
                    ` : ''}
                    </div>
                </div>
            </div>
        `;
    }).join('');
    
    console.log('ðŸ“„ Generated HTML length:', cardsHTML.length, 'characters');
    console.log('ðŸ“„ First 500 chars:', cardsHTML.substring(0, 500));
    
    cardsContainer.innerHTML = cardsHTML;
    
    if (selectedPlayers.length === 0) {
        cardsContainer.innerHTML = `
            <div style="grid-column: 1 / -1; text-align: center; padding: 40px; color: var(--text-secondary);">
                <div style="font-size: 14px; margin-bottom: 8px;">No insights available</div>
                <div style="font-size: 12px; color: var(--text-tertiary);">Check back after more data is available</div>
            </div>
        `;
    }
}

// Toggle card expansion
function toggleInsightCard(cardId) {
    const card = document.getElementById(cardId);
    if (!card) return;
    
    const isExpanded = card.getAttribute('data-expanded') === 'true';
    card.setAttribute('data-expanded', !isExpanded);
    
    if (!isExpanded) {
        card.classList.add('expanded');
    } else {
        card.classList.remove('expanded');
    }
}

// Generate dynamic summary for collapsed view
function generateCardSummary(player, badge, position) {
    const fptsG = player.avgPoints ? player.avgPoints.toFixed(1) : '0.0';
    const momentumVal = (player.momentum != null && typeof player.momentum === 'number') ? player.momentum : 0;
    const momentum = momentumVal.toFixed(1);
    const snapPct = player.snapPct ? (player.snapPct * 100).toFixed(0) : '0';
    
    if (badge === 'BUY LOW') {
        return `Averaging ${fptsG} FPTS/G with ${momentum} momentum. Recent underperformance despite ${snapPct}% snap share creates buy-low opportunity.`;
    } else if (badge === 'SELL HIGH') {
        return `Surging with +${momentum} momentum over ${fptsG} FPTS/G average. Production may be peakingâ€”consider selling high.`;
    } else if (badge === 'BREAKOUT') {
        return `Rising player averaging ${fptsG} FPTS/G with +${momentum} momentum. ${snapPct}% snaps signal expanding role.`;
    } else if (badge === 'ELITE SLEEPER') {
        return `Consistent ${fptsG} FPTS/G on ${snapPct}% snaps. Flying under the radar with solid floor and untapped upside.`;
    } else if (badge === 'WATCHLIST') {
        return `Declining with ${momentum} momentum from ${fptsG} FPTS/G. Monitor closely for further regression or opportunity.`;
    }
    
    return `Averaging ${fptsG} FPTS/G with ${momentum} momentum on ${snapPct}% snap share.`;
}

// Generate full narrative for expanded view
function generateFullNarrative(player, badge, position, rank) {
    const posLabel = position === 'WR' ? 'WR' : position === 'RB' ? 'RB' : 'TE';
    const fptsG = player.avgPoints ? player.avgPoints.toFixed(1) : '0.0';
    const momentumVal = (player.momentum != null && typeof player.momentum === 'number') ? player.momentum : 0;
    const momentum = momentumVal.toFixed(1);
    const snapPct = player.snapPct ? (player.snapPct * 100).toFixed(0) : '0';
    const consistency = (player.consistency != null && typeof player.consistency === 'number') ? player.consistency.toFixed(2) : 'N/A';
    
    if (badge === 'BUY LOW') {
        return `${player.name} presents a clear buy-low opportunity as the ${posLabel}${rank} at ${fptsG} FPTS/G. Despite recent struggles (${momentum} momentum), the underlying metrics remain strong with ${snapPct}% snap share maintaining a high usage floor. The negative momentum creates a perception gapâ€”managers may be willing to sell at a discount while the role security and volume remain intact. Target in trades before positive regression brings the price back up.`;
    } else if (badge === 'SELL HIGH') {
        return `${player.name} is currently riding hot momentum (+${momentum}) that has elevated them to ${fptsG} FPTS/G as the ${posLabel}${rank}. This surge creates an optimal sell-high windowâ€”production may be outpacing opportunity, making this an ideal time to capitalize on inflated value. Look to move ${player.name} to a manager chasing recent points before inevitable regression brings the averages back down.`;
    } else if (badge === 'BREAKOUT') {
        return `${player.name} is trending toward a breakout at the ${posLabel}${rank} position, averaging ${fptsG} FPTS/G with surging +${momentum} momentum. The ${snapPct}% snap rate indicates an expanding role, and recent production suggests the talent is starting to match the opportunity. This is the type of player who can win leagues in the second halfâ€”acquire now before they become too expensive or break into the top tier.`;
    } else if (badge === 'ELITE SLEEPER') {
        return `${player.name} is quietly operating as a high-floor option at ${fptsG} FPTS/G with a consistency score of ${consistency}. The ${snapPct}% snap share provides weekly stability, making them a perfect best-ball or flex play that often goes overlooked. In deeper leagues or as a bench stash, ${player.name} offers reliable production without the volatilityâ€”ideal for teams needing a safe floor with upside to spare.`;
    } else if (badge === 'WATCHLIST') {
        return `${player.name} is showing concerning trends with ${momentum} momentum from ${fptsG} FPTS/G at ${posLabel}${rank}. The declining production warrants close monitoringâ€”this could signal injury concerns, role regression, or scheme changes. Keep ${player.name} on your watchlist: if the slide continues, it may create buy-low opportunities for contrarian managers, or signal it's time to move on before value evaporates completely.`;
    }
    
    return `${player.name} is currently ranked ${posLabel}${rank}, averaging ${fptsG} FPTS/G with ${momentum} momentum and ${snapPct}% snap share. Monitor for role changes and opportunity trends.`;
}

function getAvailableStatsForPosition(position) {
    // Return the stat configurations for this position
    const statConfigs = {
        'WR': [
            { id: 'fantasy_points', label: 'Fantasy Points' },
            { id: 'targets', label: 'Targets' },
            { id: 'target_share', label: 'Target Share' },
            { id: 'air_yards', label: 'Air Yards' },
            { id: 'yac', label: 'YAC' },
            { id: 'red_zone_targets', label: 'RZ Targets' },
            { id: 'wopr', label: 'WOPR' },
            { id: 'racr', label: 'RACR' }
        ],
        'RB': [
            { id: 'fantasy_points', label: 'Fantasy Points' },
            { id: 'opportunities', label: 'Opportunities' },
            { id: 'usage_share', label: 'Usage Share' },
            { id: 'targets', label: 'Targets' },
            { id: 'target_share', label: 'Target Share' },
            { id: 'red_zone_opps', label: 'RZ Opportunities' },
            { id: 'rush_yards', label: 'Rush Yards' },
            { id: 'yacon', label: 'Yards After Contact' }
        ],
        'TE': [
            { id: 'fantasy_points', label: 'Fantasy Points' },
            { id: 'targets', label: 'Targets' },
            { id: 'target_share', label: 'Target Share' },
            { id: 'red_zone_targets', label: 'RZ Targets' },
            { id: 'air_yards', label: 'Air Yards' },
            { id: 'yac', label: 'YAC' }
        ]
    };
    
    return statConfigs[position] || [];
}

function analyzePlayerAcrossMetrics(player, position, rank, category, allData) {
    const analysis = {
        narrative: '',
        scatterPlots: [],
        strengths: [],
        concerns: []
    };
    
    // Calculate player's percentile ranks across key metrics
    const metrics = {};
    const positionPlayers = allData.map(d => d.player);
    
    // Key metrics to analyze based on position
    if (position === 'WR' || position === 'TE') {
        metrics.targetShare = calculatePercentile(player, positionPlayers, 'latestWeekOppShare');
        metrics.targets = calculatePercentile(player, positionPlayers, 'totalTargets');
        metrics.efficiency = calculatePercentile(player, positionPlayers, 'catchRate');
        metrics.rzTargets = calculatePercentile(player, positionPlayers, 'rzOpportunities');
        metrics.airYards = calculatePercentile(player, positionPlayers, 'totalAir');
        metrics.yac = calculatePercentile(player, positionPlayers, 'totalYAC');
    } else if (position === 'RB') {
        metrics.usageShare = calculatePercentile(player, positionPlayers, 'latestWeekOppShare');
        metrics.opportunities = calculatePercentile(player, positionPlayers, 'totalOpportunities');
        metrics.targets = calculatePercentile(player, positionPlayers, 'totalTargets');
        metrics.rzOpps = calculatePercentile(player, positionPlayers, 'rzOpportunities');
        metrics.rushYards = calculatePercentile(player, positionPlayers, 'totalRushYards');
        metrics.recYards = calculatePercentile(player, positionPlayers, 'totalRecYards');
    }
    
    // Build narrative and recommendations based on category
    const scatterRecommendations = [];
    const strongMetrics = [];
    const weakMetrics = [];
    
    if (position === 'WR' || position === 'TE') {
        // Identify strengths
        if (metrics.targetShare >= 70) strongMetrics.push('High Target Share');
        if (metrics.targets >= 70) strongMetrics.push('High Volume');
        if (metrics.efficiency >= 70) strongMetrics.push('Elite Efficiency');
        if (metrics.rzTargets >= 60) strongMetrics.push('RZ Usage');
        if (metrics.airYards >= 65) strongMetrics.push('Deep Threat');
        if (metrics.yac >= 65) strongMetrics.push('YAC Ability');
        
        // Identify concerns
        if (metrics.targetShare < 40) weakMetrics.push('Low Target Share');
        if (metrics.targets < 40) weakMetrics.push('Limited Volume');
        if (metrics.efficiency < 40) weakMetrics.push('Catch Rate Issues');
        if (metrics.rzTargets < 30) weakMetrics.push('No RZ Role');
        
        // Build scatter plot recommendations (mix of strengths and weaknesses)
        if (metrics.targetShare >= 60) {
            scatterRecommendations.push({
                xAxis: 'Targets',
                yAxis: 'Target Share',
                reason: `${player.name} commands ${player.latestWeekOppShare?.toFixed(1) || 'N/A'}% of targets, indicating clear WR1/${position}1 usage`,
                label: 'ELITE ROLE',
                color: 'var(--positive)'
            });
        }
        
        if (metrics.targets >= 60) {
            scatterRecommendations.push({
                xAxis: 'Targets',
                yAxis: 'Fantasy Points',
                reason: `Averaging ${(player.totalTargets / player.gamesPlayed).toFixed(1)} targets/game provides consistent fantasy floor`,
                label: 'VOLUME',
                color: 'var(--accent-blue)'
            });
        } else if (metrics.targets < 50) {
            scatterRecommendations.push({
                xAxis: 'Targets',
                yAxis: 'Fantasy Points',
                reason: `Only ${(player.totalTargets / player.gamesPlayed).toFixed(1)} targets/game - needs increased opportunity for ceiling games`,
                label: 'MONITOR',
                color: '#ff9500'
            });
        }
        
        if (metrics.rzTargets >= 50) {
            scatterRecommendations.push({
                xAxis: 'RZ Targets',
                yAxis: 'Fantasy Points',
                reason: `${(player.rzOpportunities / player.gamesPlayed).toFixed(1)} RZ targets/game creates TD upside in scoring position`,
                label: 'TD UPSIDE',
                color: 'var(--positive)'
            });
        } else if (metrics.rzTargets < 40) {
            scatterRecommendations.push({
                xAxis: 'RZ Targets',
                yAxis: 'Fantasy Points',
                reason: `Limited red zone involvement caps TD ceiling - monitor for increased usage near goal line`,
                label: 'CONCERN',
                color: '#ff453a'
            });
        }
        
        if (metrics.efficiency >= 60) {
            scatterRecommendations.push({
                xAxis: 'Targets',
                yAxis: 'Catch Rate',
                reason: `${player.catchRate?.toFixed(1) || 'N/A'}% catch rate shows reliable hands that maximize every opportunity`,
                label: 'EFFICIENT',
                color: 'var(--positive)'
            });
        } else if (metrics.efficiency < 45) {
            scatterRecommendations.push({
                xAxis: 'Targets',
                yAxis: 'Catch Rate',
                reason: `${player.catchRate?.toFixed(1) || 'N/A'}% catch rate indicates drops or contested targets limiting efficiency`,
                label: 'RISK',
                color: '#ff453a'
            });
        }
        
        // Build narrative based on category
        if (category === 'breakout') {
            const posLabel = position === 'WR' ? 'WR' : 'TE';
            const recentTrend = player.momentum > 0 ? 'trending upward with improved usage' : 'maintaining steady production';
            const volumeContext = metrics.targets >= 65 ? 'elite target volume' : metrics.targets >= 50 ? 'solid target volume' : 'limited but growing opportunity';
            const efficiencyContext = metrics.efficiency >= 65 ? 'and elite efficiency' : metrics.efficiency >= 50 ? 'with room for efficiency gains' : 'but needs to improve catch rate';
            
            analysis.narrative = `${player.name} sits at ${posLabel}${rank} (${player.avgPoints.toFixed(1)} PPG) but profiles as a <strong>legitimate breakout candidate</strong>. ${strongMetrics.length >= 2 ? `Their <strong>${strongMetrics.slice(0, 2).join(' and ').toLowerCase()}</strong> suggests featured-role status.` : `Underlying usage is trending positively.`} ${metrics.rzTargets >= 50 ? `Red zone involvement (<strong>${(player.rzOpportunities / player.gamesPlayed).toFixed(1)} RZ targets/game</strong>) provides clear ${posLabel}1 upside.` : `More red zone work would unlock ${posLabel}1 potential.`} ${metrics.targetShare >= 60 ? `Their <strong>${player.latestWeekOppShare?.toFixed(1)}% target share</strong> confirms alpha status.` : `Monitor target share - any move above 20% is a strong buy signal.`} <strong>One opportunity shift away from top-12 production.</strong>`;
            
        } else if (category === 'sleeper') {
            const posLabel = position === 'WR' ? 'WR' : 'TE';
            analysis.narrative = `${player.name} is <strong>flying under the radar</strong> at ${posLabel}${rank} (${player.avgPoints.toFixed(1)} PPG). ${strongMetrics.length > 0 ? `They excel in <strong>${strongMetrics[0].toLowerCase()}</strong>` : 'Limited opportunity currently'}, ${metrics.efficiency >= 60 ? `with a <strong>${player.catchRate?.toFixed(1)}% catch rate</strong> maximizing every target.` : `with room for efficiency gains.`} ${metrics.targets >= 50 ? `<strong>${(player.totalTargets / player.gamesPlayed).toFixed(1)} targets per game</strong> provides a solid floor.` : `${(player.totalTargets / player.gamesPlayed).toFixed(1)} targets per game and trending upward.`} ${metrics.rzTargets >= 40 ? `<strong>${(player.rzOpportunities / player.gamesPlayers).toFixed(1)} RZ targets/game</strong> creates TD upside.` : `Missing red zone work limits ceiling.`} In deeper leagues, ${player.name} represents <strong>exceptional value</strong> - the type of player who <strong>wins leagues in Weeks 15-17</strong>.`;
            
        } else if (category === 'buylow') {
            const posLabel = position === 'WR' ? 'WR' : 'TE';
            const momentumNote = player.momentum < -2 ? 'experiencing a multi-week cold streak' : 'cooling off recently';
            analysis.narrative = `${player.name} presents a <strong>classic buy-low opportunity</strong> at ${posLabel}${rank} (${player.avgPoints.toFixed(1)} PPG). Currently ${momentumNote}, but <strong>elite underlying metrics</strong> remain intact. ${strongMetrics.length >= 2 ? `<strong>${strongMetrics.slice(0, 2).join(' and ').toLowerCase()}</strong> unchanged despite PPG downturn` : `Core usage remains strong`} - this is variance, not a role change. ${metrics.targets >= 65 ? `<strong>${(player.totalTargets / player.gamesPlayed).toFixed(1)} targets/game</strong> keeps the volume safe.` : `${(player.totalTargets / player.gamesPlayed).toFixed(1)} targets/game maintains the floor.`} ${metrics.rzTargets >= 50 ? `<strong>${(player.rzOpportunities / player.gamesPlayed).toFixed(1)} RZ targets/game</strong> means TDs will come.` : `Overall opportunity keeps them in ${posLabel}1 conversation.`} Expect <strong>positive regression</strong> over the next 3-4 weeks.`;
            
        } else if (category === 'watchlist') {
            const posLabel = position === 'WR' ? 'WR' : 'TE';
            analysis.narrative = `${player.name} sits at ${posLabel}${rank} (${player.avgPoints.toFixed(1)} PPG) and deserves close monitoring over the next few weeks. ${strongMetrics.length >= 2 ? `They show ${strongMetrics.slice(0, 2).join(' and ').toLowerCase()}, which provides a foundation for upside.` : strongMetrics.length === 1 ? `They display ${strongMetrics[0].toLowerCase()} as a notable strength.` : `While metrics are mixed, opportunity trends are worth tracking.`} ${metrics.targets >= 55 ? `Volume is solid at ${(player.totalTargets / player.gamesPlayed).toFixed(1)} targets per game` : `Target volume (${(player.totalTargets / player.gamesPlayed).toFixed(1)} per game) could increase with continued involvement`}, ${metrics.efficiency >= 55 ? `and efficiency metrics suggest they're making the most of opportunities.` : `though efficiency improvements would unlock more consistent production.`} ${metrics.rzTargets >= 45 ? `Red zone usage of ${(player.rzOpportunities / player.gamesPlayed).toFixed(1)} targets per game adds TD potential.` : `Limited red zone work is the main ceiling cap - monitor for increased usage near the goal line.`} ${weakMetrics.length > 0 ? `Key area to track: ${weakMetrics[0].toLowerCase()} - improvement here signals a potential role expansion.` : `The usage trajectory is trending positively week over week.`} ${metrics.targetShare >= 55 ? `Their ${player.latestWeekOppShare?.toFixed(1)}% target share suggests growing offensive importance.` : `If target share climbs above 20%, that's a strong buy signal.`} This is a classic "watch and wait" candidate who could break out with one or two strong performances. Keep them on your radar in deeper leagues and best ball formats.`;
        }
        
    } else if (position === 'RB') {
        // Similar logic for RBs
        if (metrics.usageShare >= 70) strongMetrics.push('Workhorse Role');
        if (metrics.opportunities >= 70) strongMetrics.push('High Volume');
        if (metrics.targets >= 60) strongMetrics.push('Pass-Game Role');
        if (metrics.rzOpps >= 60) strongMetrics.push('RZ Touches');
        if (metrics.rushYards >= 65) strongMetrics.push('Rushing Efficiency');
        
        if (metrics.usageShare < 40) weakMetrics.push('Limited Usage');
        if (metrics.opportunities < 40) weakMetrics.push('Low Touch Count');
        if (metrics.targets < 30) weakMetrics.push('No Pass Game');
        if (metrics.rzOpps < 30) weakMetrics.push('No Goal Line Work');
        
        if (metrics.usageShare >= 60) {
            scatterRecommendations.push({
                xAxis: 'Opportunities',
                yAxis: 'Usage Share',
                reason: `Commands ${player.latestWeekOppShare?.toFixed(1) || 'N/A'}% of backfield work - clear RB1 role`,
                label: 'WORKHORSE',
                color: 'var(--positive)'
            });
        }
        
        if (metrics.opportunities >= 60) {
            scatterRecommendations.push({
                xAxis: 'Opportunities',
                yAxis: 'Fantasy Points',
                reason: `${(player.totalOpportunities / player.gamesPlayed).toFixed(1)} touches/game creates safe weekly floor`,
                label: 'VOLUME',
                color: 'var(--accent-blue)'
            });
        } else if (metrics.opportunities < 50) {
            scatterRecommendations.push({
                xAxis: 'Opportunities',
                yAxis: 'Fantasy Points',
                reason: `Only ${(player.totalOpportunities / player.gamesPlayed).toFixed(1)} touches/game - needs more work to reach RB1 status`,
                label: 'MONITOR',
                color: '#ff9500'
            });
        }
        
        if (metrics.targets >= 50) {
            scatterRecommendations.push({
                xAxis: 'Targets',
                yAxis: 'Target Share',
                reason: `${(player.totalTargets / player.gamesPlayed).toFixed(1)} targets/game adds PPR ceiling and safety`,
                label: 'PPR VALUE',
                color: 'var(--positive)'
            });
        } else if (metrics.targets < 35) {
            scatterRecommendations.push({
                xAxis: 'Targets',
                yAxis: 'Target Share',
                reason: `Minimal pass-game role limits PPR upside and ceiling outcomes`,
                label: 'CONCERN',
                color: '#ff453a'
            });
        }
        
        if (metrics.rzOpps >= 50) {
            scatterRecommendations.push({
                xAxis: 'RZ Opportunities',
                yAxis: 'Fantasy Points',
                reason: `${(player.rzOpportunities / player.gamesPlayed).toFixed(1)} red zone touches/game creates consistent TD opportunities`,
                label: 'TD UPSIDE',
                color: 'var(--positive)'
            });
        } else if (metrics.rzOpps < 40) {
            scatterRecommendations.push({
                xAxis: 'RZ Opportunities',
                yAxis: 'Fantasy Points',
                reason: `Limited goal-line work caps TD potential - key area needing improvement`,
                label: 'RISK',
                color: '#ff453a'
            });
        }
        
        // Build RB narratives
        if (category === 'breakout') {
            const touchVolume = metrics.opportunities >= 65 ? 'elite touch volume' : metrics.opportunities >= 50 ? 'solid workload' : 'growing opportunity share';
            const passGameRole = metrics.targets >= 50 ? 'and clear pass-game role' : metrics.targets >= 35 ? 'with decent pass-catching involvement' : 'but needs more targets';
            
            analysis.narrative = `${player.name} currently ranks RB${rank} (${player.avgPoints.toFixed(1)} PPG) but has the profile of a top-12 back waiting to happen. They're showing ${touchVolume} ${passGameRole}, combining for ${(player.totalOpportunities / player.gamesPlayed).toFixed(1)} total touches per game. ${strongMetrics.length >= 2 ? `The usage screams three-down back: ${strongMetrics.slice(0, 2).join(' and ').toLowerCase()}.` : `While they need to secure more ${weakMetrics[0]?.toLowerCase() || 'opportunities'}, the role is expanding weekly.`} ${metrics.usageShare >= 60 ? `Their ${player.latestWeekOppShare?.toFixed(1)}% usage share confirms workhorse status.` : `Usage share is trending up - a move above 60% would signal RB1 status.`} ${metrics.rzOpps >= 50 ? `Add in ${(player.rzOpportunities / player.gamesPlayed).toFixed(1)} red zone touches per game and you have consistent TD upside.` : `The missing piece is goal-line work - if they can take over inside the 5, the ceiling explodes.`} ${metrics.targets >= 40 ? `Their ${(player.totalTargets / player.gamesPlayed).toFixed(1)} targets per game adds a safe PPR floor that few backs offer.` : `If they can increase targets to 3+ per game, they'd be a top-15 lock.`} This is the classic "buy before the league notices" window. Everything points to RB1 production over the fantasy playoffs.`;
            
        } else if (category === 'sleeper') {
            analysis.narrative = `${player.name} sits at RB${rank} (${player.avgPoints.toFixed(1)} PPG) in what might be the deepest value of the season. ${strongMetrics.length > 0 ? `They already show ${strongMetrics[0].toLowerCase()}` : 'Despite being buried on depth charts'}, ${metrics.opportunities >= 45 ? `averaging ${(player.totalOpportunities / player.gamesPlayed).toFixed(1)} touches per game with upside for more` : `seeing limited touches (${(player.totalOpportunities / player.gamesPlayed).toFixed(1)} per game) but efficiency metrics are elite`}. ${metrics.rzOpps >= 40 ? `Red zone usage is surprisingly strong at ${(player.rzOpportunities / player.gamesPlayed).toFixed(1)} touches per game, creating weekly TD potential.` : `The red zone role is limited now, but one injury or hot streak could change that overnight.`} ${metrics.targets >= 40 ? `Pass-game involvement (${(player.totalTargets / player.gamesPlayed).toFixed(1)} targets/game) provides a PPR safety net` : `They need more targets, but the team is trending toward involving backs in the pass game`}. ${weakMetrics.length > 0 ? `Current weakness: ${weakMetrics[0].toLowerCase()} - but this is exactly why they're mispriced.` : `All the underlying metrics point to imminent volume increase.`} In best ball and dynasty, ${player.name} is a league-winner waiting to happen. This is the dart throw that hits in Week 14. Their playoff schedule is favorable, and one injury to the starter makes them an instant RB2 with RB1 upside.`;
            
        } else if (category === 'buylow') {
            analysis.narrative = `${player.name} presents elite buy-low value at RB${rank} (${player.avgPoints.toFixed(1)} PPG). Recent negative game script has panicked fantasy managers, but the underlying usage tells a different story. ${strongMetrics.length >= 2 ? `They maintain ${strongMetrics.slice(0, 2).join(' and ').toLowerCase()} despite the PPG dip` : `The backfield role hasn't changed`}, averaging ${(player.totalOpportunities / player.gamesPlayed).toFixed(1)} touches per game. ${metrics.usageShare >= 60 ? `Their ${player.latestWeekOppShare?.toFixed(1)}% usage share confirms they're still the guy.` : `Usage share has dipped slightly but remains RB2-viable at minimum.`} ${metrics.targets >= 50 ? `The ${(player.totalTargets / player.gamesPlayed).toFixed(1)} targets per game keeps the PPR floor safe` : `Target volume could be better (${(player.totalTargets / player.gamesPlayed).toFixed(1)} per game), but that's not why PPG is down`} - this is simply a TD drought or tough matchup stretch. ${metrics.rzOpps >= 50 ? `Red zone work (${(player.rzOpportunities / player.gamesPlayed).toFixed(1)} touches/game) remains strong, which means TDs are coming.` : `The concern is goal-line work has decreased, but game script explains most of it.`} ${weakMetrics.length > 0 ? `Area to watch: ${weakMetrics[0].toLowerCase()}, though this often normalizes over larger samples.` : `All signs point to positive touchdown regression.`} Savvy managers are buying this dip hard. Expect RB1 weeks to return within the next month.`;
            
        } else if (category === 'watchlist') {
            analysis.narrative = `${player.name} sits at RB${rank} (${player.avgPoints.toFixed(1)} PPG) and deserves close monitoring over the next few weeks. ${strongMetrics.length >= 2 ? `They show ${strongMetrics.slice(0, 2).join(' and ').toLowerCase()}, which provides a foundation for upside.` : strongMetrics.length === 1 ? `They display ${strongMetrics[0].toLowerCase()} as a notable strength.` : `While metrics are mixed, opportunity trends are worth tracking.`} ${metrics.opportunities >= 55 ? `Touch volume is solid at ${(player.totalOpportunities / player.gamesPlayed).toFixed(1)} per game` : `Touch volume (${(player.totalOpportunities / player.gamesPlayed).toFixed(1)} per game) could increase with continued involvement`}, ${metrics.targets >= 45 ? `and their ${(player.totalTargets / player.gamesPlayed).toFixed(1)} targets per game adds PPR safety.` : `though pass-game work (${(player.totalTargets / player.gamesPlayed).toFixed(1)} targets/game) needs to expand for consistent production.`} ${metrics.rzOpps >= 45 ? `Red zone usage of ${(player.rzOpportunities / player.gamesPlayed).toFixed(1)} touches per game adds TD potential.` : `Limited goal-line work is the main ceiling cap - monitor for increased usage inside the 10.`} ${weakMetrics.length > 0 ? `Key area to track: ${weakMetrics[0].toLowerCase()} - improvement here signals a potential role expansion.` : `The usage trajectory is trending positively week over week.`} ${metrics.usageShare >= 55 ? `Their ${player.latestWeekOppShare?.toFixed(1)}% backfield share suggests growing importance in the offense.` : `If backfield share climbs above 50%, that's a strong buy signal.`} This is a classic "watch and wait" candidate who could break out with one or two strong performances or an injury ahead of them. Keep them on your radar in deeper leagues and best ball formats.`;
        }
    }
    
    // Fallback narrative if nothing was generated (shouldn't happen, but safety net)
    if (!analysis.narrative || analysis.narrative.length === 0) {
        const posLabel = position === 'RB' ? 'RB' : position === 'WR' ? 'WR' : 'TE';
        analysis.narrative = `${player.name} ranks ${posLabel}${rank} with ${player.avgPoints.toFixed(1)} PPG over ${player.gamesPlayed} games. ${strongMetrics.length > 0 ? `Key strengths include ${strongMetrics.join(', ').toLowerCase()}.` : 'Showing mixed metrics across the board.'} ${weakMetrics.length > 0 ? `Areas to monitor: ${weakMetrics.join(', ').toLowerCase()}.` : 'Overall profile suggests stable production.'} Monitor their usage trends and matchup schedule for potential value plays.`;
    }
    
    analysis.strengths = strongMetrics.slice(0, 3);
    analysis.concerns = weakMetrics.slice(0, 3);
    analysis.scatterPlots = scatterRecommendations.slice(0, 4); // Show up to 4 plots
    
    return analysis;
}

function calculatePercentile(player, allPlayers, metric) {
    const value = player[metric] || 0;
    const validPlayers = allPlayers.filter(p => p[metric] !== undefined && p[metric] > 0);
    if (validPlayers.length === 0) return 0;
    
    const sorted = validPlayers.map(p => p[metric]).sort((a, b) => a - b);
    const index = sorted.findIndex(v => v >= value);
    
    if (index === -1) return 100;
    return (index / sorted.length) * 100;
}

function updateScatterInsights() {
    // Re-generate insights when data changes
    if (!advancedScatterChart || !advancedScatterChart.data.datasets[0]) return;
    const chartData = advancedScatterChart.data.datasets[0].data;
    if (chartData && chartData.length > 0) {
        const xStatId = scatterInsightsState.currentXStat;
        const yStatId = scatterInsightsState.currentYStat;
        const position = scatterInsightsState.currentPosition;
        if (xStatId && yStatId && position) {
            generateScatterInsights(chartData, position, xStatId, yStatId);
        }
    }
}

function displayScatterInsight(index) {
    const headlineEl = document.getElementById('scatter-rotating-headline');
    const subheadlineEl = document.getElementById('scatter-rotating-subheadline');
    
    if (!headlineEl || !subheadlineEl) return;
    if (scatterInsightsState.insights.length === 0) {
        headlineEl.textContent = 'Loading...';
        subheadlineEl.textContent = 'Analyzing scatter data...';
        return;
    }
    
    index = ((index % scatterInsightsState.insights.length) + scatterInsightsState.insights.length) % scatterInsightsState.insights.length;
    scatterInsightsState.currentIndex = index;
    const insight = scatterInsightsState.insights[index];
    
    // Fade out
    headlineEl.style.opacity = '0';
    subheadlineEl.style.opacity = '0';
    
    setTimeout(() => {
        // Update content
        headlineEl.textContent = insight.headline;
        subheadlineEl.textContent = insight.subheadline;
        
        // Fade in
        headlineEl.style.opacity = '1';
        subheadlineEl.style.opacity = '1';
    }, 300);
}

function startScatterInsightRotation() {
    stopScatterInsightRotation(); // Clear any existing interval
    scatterInsightsState.autoRotateInterval = setInterval(() => {
        displayScatterInsight(scatterInsightsState.currentIndex + 1);
    }, 15000); // 15 seconds
}

function stopScatterInsightRotation() {
    if (scatterInsightsState.autoRotateInterval) {
        clearInterval(scatterInsightsState.autoRotateInterval);
        scatterInsightsState.autoRotateInterval = null;
    }
}

// Helper function to switch position from dropdown
function switchAdvancedPositionFromFilter(position) {
    // Update the position buttons if they still exist
    document.querySelectorAll('.position-toggle-btn').forEach(btn => btn.classList.remove('active'));
    const btn = document.getElementById(`advanced-${position.toLowerCase()}-btn`);
    if (btn) btn.classList.add('active');
    
    // Update dropdown to match
    const select = document.getElementById('advanced-position-select');
    if (select) select.value = position;
    
    // Switch position
    switchAdvancedPosition(position);
}

function renderInsightsTicker() {
const insightsTickerTrack = document.getElementById('insights-ticker-track');
if (!insightsTickerTrack) return;
let globalMaxWeek = 0;
Object.values(window.aggregatedWRs).forEach(p => {
if (p.weeks && p.weeks.length > 0) {
const maxWeek = Math.max(...p.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
Object.values(window.aggregatedRBs).forEach(p => {
if (p.weeks && p.weeks.length > 0) {
const maxWeek = Math.max(...p.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
if (globalMaxWeek === 0) return;
const last3ActualWeeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
const prior3ActualWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];
const allMovers = [];
Object.values(window.aggregatedWRs).forEach(player => {
if (!player.weeks || player.weeks.length === 0) return;
const last3WeeksGames = player.weeks.filter(w =>
last3ActualWeeks.includes(w.week) && w.fpts > 0
);
if (last3WeeksGames.length < 2) return;
const allGameScores = player.weeks.map(w => w.fpts).sort((a, b) => b - a);
const top2Scores = allGameScores.slice(0, 2);
const recordGamesInLast3 = last3WeeksGames.filter(w =>
top2Scores.includes(w.fpts)
).length;
if (recordGamesInLast3 < 2) return;
const last3Shares = player.weeks
.filter(w => last3ActualWeeks.includes(w.week) && w.teamShare && w.teamShare > 0)
.map(w => w.teamShare);
const prior3Shares = player.weeks
.filter(w => prior3ActualWeeks.includes(w.week) && w.teamShare && w.teamShare > 0)
.map(w => w.teamShare);
if (last3Shares.length === 0) return;
const avgLast3 = last3Shares.reduce((sum, s) => sum + s, 0) / last3Shares.length;
const avgPrior3 = prior3Shares.length > 0
? prior3Shares.reduce((sum, s) => sum + s, 0) / prior3Shares.length
: 0;
allMovers.push({
name: player.name,
team: player.team,
position: 'WR',
shareChange: avgLast3 - avgPrior3,
avgPoints: player.avgPoints
});
});
Object.values(window.aggregatedRBs).forEach(player => {
if (!player.weeks || player.weeks.length === 0) return;
const last3WeeksGames = player.weeks.filter(w =>
last3ActualWeeks.includes(w.week) && w.fpts > 0
);
if (last3WeeksGames.length < 2) return;
const allGameScores = player.weeks.map(w => w.fpts).sort((a, b) => b - a);
const top2Scores = allGameScores.slice(0, 2);
const recordGamesInLast3 = last3WeeksGames.filter(w =>
top2Scores.includes(w.fpts)
).length;
if (recordGamesInLast3 < 2) return;
const last3Shares = [];
last3ActualWeeks.forEach(weekNum => {
const weekData = player.weeks.find(w => w.week === weekNum);
if (weekData && weekData.opportunities > 0) {
const teamRows = rbData.filter(row =>
row.Team === player.team &&
parseInt(row.Week) === weekNum &&
parseFloat(row['RB Opp']) > 0
);
const teamTotal = teamRows.reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);
if (teamTotal > 0) {
last3Shares.push((weekData.opportunities / teamTotal) * 100);
}
}
});
const prior3Shares = [];
prior3ActualWeeks.forEach(weekNum => {
const weekData = player.weeks.find(w => w.week === weekNum);
if (weekData && weekData.opportunities > 0) {
const teamRows = rbData.filter(row =>
row.Team === player.team &&
parseInt(row.Week) === weekNum &&
parseFloat(row['RB Opp']) > 0
);
const teamTotal = teamRows.reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);
if (teamTotal > 0) {
prior3Shares.push((weekData.opportunities / teamTotal) * 100);
}
}
});
if (last3Shares.length === 0) return;
const avgLast3 = last3Shares.reduce((sum, s) => sum + s, 0) / last3Shares.length;
const avgPrior3 = prior3Shares.length > 0
? prior3Shares.reduce((sum, s) => sum + s, 0) / prior3Shares.length
: 0;
allMovers.push({
name: player.name,
team: player.team,
position: 'RB',
shareChange: avgLast3 - avgPrior3,
avgPoints: player.avgPoints
});
});
const topMovers = allMovers
.sort((a, b) => Math.abs(b.shareChange) - Math.abs(a.shareChange))
.slice(0, 40);
const insightsTickerHTML = topMovers.map((player, index) => {
const changeClass = player.shareChange >= 0 ? 'positive' : 'negative';
const changeSymbol = player.shareChange >= 0 ? 'â–²' : 'â–¼';
const rank = index + 1;
return `
<div class="ticker-item"><span class="player-name">#${rank} ${player.name}</span><span style="color: var(--text-secondary); font-size: 11px;">${player.position} Â· ${player.team}</span><span class="change ${changeClass}">${changeSymbol} ${Math.abs(player.shareChange).toFixed(1)}%</span><span class="avg-pts">${player.avgPoints.toFixed(1)} pts</span></div>
`;
}).join('');
insightsTickerTrack.innerHTML = insightsTickerHTML + insightsTickerHTML;
}
function renderAnalyticsTicker() {
const analyticsInsightsTrack = document.getElementById('analytics-insights-track');
if (!analyticsInsightsTrack) return;
const topWRs = Object.values(window.aggregatedWRs)
.filter(p => p.gamesPlayed >= 3)
.sort((a, b) => b.avgPoints - a.avgPoints)
.slice(0, 10)
.map((p, idx) => ({ ...p, rank: idx + 1 }));
const topRBs = Object.values(window.aggregatedRBs)
.filter(p => p.gamesPlayed >= 3)
.sort((a, b) => b.avgPoints - a.avgPoints)
.slice(0, 10)
.map((p, idx) => ({ ...p, rank: idx + 1 }));
const topTEs = Object.values(window.aggregatedTEs)
.filter(p => p.gamesPlayed >= 3)
.sort((a, b) => b.avgPoints - a.avgPoints)
.slice(0, 10)
.map((p, idx) => ({ ...p, rank: idx + 1 }));
const allTopPlayers = [...topWRs, ...topRBs, ...topTEs];
const analyticsTickerHTML = allTopPlayers.map((player) => {
return `
<div class="ticker-item"><span style="font-weight: 700; color: var(--text-tertiary); font-size: 12px; min-width: 24px;">#${player.rank}</span><span class="player-name">${player.name}</span><span style="color: var(--text-secondary); font-size: 11px;">${player.position} Â· ${player.team}</span><span class="avg-pts">${player.avgPoints.toFixed(1)} PPG</span></div>
`;
}).join('');
analyticsInsightsTrack.innerHTML = analyticsTickerHTML + analyticsTickerHTML;
}
function toggleTicker(position) {
if (position === 'wr') return;
const content = document.getElementById(`${position}-ticker-content`);
const toggle = document.getElementById(`${position}-ticker-toggle`);
const section = document.getElementById(`${position}-ticker-section`);
content.classList.toggle('collapsed');
toggle.classList.toggle('collapsed');
section.classList.toggle('collapsed');
}
function calculatePlayerTags(position) {
const players = position === 'WR' ? Object.values(window.aggregatedWRs) :
position === 'RB' ? Object.values(window.aggregatedRBs) :
Object.values(window.aggregatedTEs);
const rawData = position === 'WR' ? wrData :
position === 'RB' ? rbData :
teData;
let globalMaxWeek = 0;
players.forEach(p => {
if (p.weeks && p.weeks.length > 0) {
const maxWeek = Math.max(...p.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
if (globalMaxWeek < 4) return {}; // Need at least 4 weeks of data
const last2Weeks = [globalMaxWeek, globalMaxWeek - 1];
const prior2Weeks = [globalMaxWeek - 2, globalMaxWeek - 3];
const tagCandidates = {
buy_low: [],
sell_high: [],
rz_trend_up: []
};
players.forEach(player => {
if (!player.weeks || player.weeks.length < 3) return;
if (player.avgPoints < 5) return;
const last2Games = player.weeks.filter(w => last2Weeks.includes(w.week) && w.fpts > 0);
const prior2Games = player.weeks.filter(w => prior2Weeks.includes(w.week) && w.fpts > 0);
if (last2Games.length === 0 || prior2Games.length === 0) return;
let last2Efficiency = 0, prior2Efficiency = 0;
let last2Volume = 0, prior2Volume = 0;
let last2RzShare = 0, prior2RzShare = 0;
if (position === 'WR' || position === 'TE') {
const last2Targets = last2Games.reduce((sum, w) => sum + (w.targets || 0), 0);
const last2Points = last2Games.reduce((sum, w) => sum + w.fpts, 0);
last2Volume = last2Targets / last2Games.length;
last2Efficiency = last2Targets > 0 ? last2Points / last2Targets : 0;
const prior2Targets = prior2Games.reduce((sum, w) => sum + (w.targets || 0), 0);
const prior2Points = prior2Games.reduce((sum, w) => sum + w.fpts, 0);
prior2Volume = prior2Targets / prior2Games.length;
prior2Efficiency = prior2Targets > 0 ? prior2Points / prior2Targets : 0;
let last2RzTargets = 0, prior2RzTargets = 0;
last2Weeks.forEach(weekNum => {
const weekRow = rawData.find(row =>
row.Team === player.team &&
row.Player === player.name &&
parseInt(row.Week) === weekNum
);
if (weekRow) {
last2RzTargets += parseFloat(weekRow.RZ_TGT) || parseFloat(weekRow['RZ TGT']) || 0;
}
});
prior2Weeks.forEach(weekNum => {
const weekRow = rawData.find(row =>
row.Team === player.team &&
row.Player === player.name &&
parseInt(row.Week) === weekNum
);
if (weekRow) {
prior2RzTargets += parseFloat(weekRow.RZ_TGT) || parseFloat(weekRow['RZ TGT']) || 0;
}
});
last2RzShare = last2RzTargets / last2Games.length;
prior2RzShare = prior2RzTargets / prior2Games.length;
} else {
const last2Opps = last2Games.reduce((sum, w) => sum + (w.opportunities || 0), 0);
const last2Points = last2Games.reduce((sum, w) => sum + w.fpts, 0);
last2Volume = last2Opps / last2Games.length;
last2Efficiency = last2Opps > 0 ? last2Points / last2Opps : 0;
const prior2Opps = prior2Games.reduce((sum, w) => sum + (w.opportunities || 0), 0);
const prior2Points = prior2Games.reduce((sum, w) => sum + w.fpts, 0);
prior2Volume = prior2Opps / prior2Games.length;
prior2Efficiency = prior2Opps > 0 ? prior2Points / prior2Opps : 0;
let last2RzOpps = 0, prior2RzOpps = 0;
last2Weeks.forEach(weekNum => {
const weekRow = rawData.find(row =>
row.Team === player.team &&
row.Player === player.name &&
parseInt(row.Week) === weekNum
);
if (weekRow) {
const rzAtt = parseFloat(weekRow.RZ_RUSH_ATT) || parseFloat(weekRow['RZ RUSH ATT']) || 0;
const rzTgt = parseFloat(weekRow.RZ_TGT) || parseFloat(weekRow['RZ TGT']) || 0;
last2RzOpps += rzAtt + rzTgt;
}
});
prior2Weeks.forEach(weekNum => {
const weekRow = rawData.find(row =>
row.Team === player.team &&
row.Player === player.name &&
parseInt(row.Week) === weekNum
);
if (weekRow) {
const rzAtt = parseFloat(weekRow.RZ_RUSH_ATT) || parseFloat(weekRow['RZ RUSH ATT']) || 0;
const rzTgt = parseFloat(weekRow.RZ_TGT) || parseFloat(weekRow['RZ TGT']) || 0;
prior2RzOpps += rzAtt + rzTgt;
}
});
last2RzShare = last2RzOpps / last2Games.length;
prior2RzShare = prior2RzOpps / prior2Games.length;
}
const efficiencyChange = prior2Efficiency > 0 ? ((last2Efficiency - prior2Efficiency) / prior2Efficiency) * 100 : 0;
const volumeChange = prior2Volume > 0 ? ((last2Volume - prior2Volume) / prior2Volume) * 100 : 0;
const rzChange = prior2RzShare > 0 ? ((last2RzShare - prior2RzShare) / prior2RzShare) * 100 : 0;
const topTierThreshold = position === 'WR' ? 20 : 22; // Elite WR1 / Elite RB1 threshold
if (efficiencyChange >= 5 && volumeChange <= -5 && player.avgPoints < topTierThreshold) {
tagCandidates.buy_low.push({
player: player,
score: efficiencyChange + Math.abs(volumeChange) // Combined magnitude
});
}
if (efficiencyChange <= -5 && volumeChange >= 5) {
tagCandidates.sell_high.push({
player: player,
score: Math.abs(efficiencyChange) + volumeChange // Combined magnitude
});
}
if (rzChange >= 5) {
tagCandidates.rz_trend_up.push({
player: player,
score: rzChange
});
}
});
const tags = {};
tagCandidates.buy_low.sort((a, b) => b.score - a.score).slice(0, 4).forEach(item => {
tags[item.player.id] = tags[item.player.id] || [];
tags[item.player.id].push('buy_low');
});
tagCandidates.sell_high.sort((a, b) => b.score - a.score).slice(0, 4).forEach(item => {
tags[item.player.id] = tags[item.player.id] || [];
tags[item.player.id].push('sell_high');
});
tagCandidates.rz_trend_up.sort((a, b) => b.score - a.score).slice(0, 4).forEach(item => {
tags[item.player.id] = tags[item.player.id] || [];
tags[item.player.id].push('rz_trend_up');
});
return tags;
}
function renderWRPlayerCards() {
const grid = document.getElementById('wr-players-grid');
let wrs = Object.values(window.aggregatedWRs).sort((a, b) => b.avgPoints - a.avgPoints);
const playerTags = calculatePlayerTags('WR');
wrs = wrs.filter(p => !['Malik Nabers', 'Tyreek Hill'].includes(p.name));
wrs = wrs.map(player => {
if (player.latestWeek && player.latestWeek < 5) {
return {
...player,
avgPoints: player.avgPoints * 0.5,
inactive: true
};
}
return player;
}).sort((a, b) => b.avgPoints - a.avgPoints);
wrs = wrs.map(player => {
if (player.gamesPlayed <= 2) {
return {
...player,
avgPoints: Math.min(player.avgPoints, 7.9),
lowSampleSize: true
};
}
return player;
}).sort((a, b) => b.avgPoints - a.avgPoints);
const top24 = wrs.slice(0, 24);
const top24AvgPoints = top24.reduce((sum, p) => sum + p.avgPoints, 0) / top24.length;
const top24AvgTargets = top24.reduce((sum, p) => sum + (p.totalTargets / p.gamesPlayed), 0) / top24.length;
let overallRank = 0;
const tiers = [
{ name: 'Elite WR1', class: 'elite', type: 'rank', maxPlayers: 4, color: '#30d158', showCharts: true },
{ name: 'High-End WR1', class: 'elite', type: 'rank', maxPlayers: 4, color: '#30d158', showCharts: true },
{ name: 'Solid WR1', class: 'elite', type: 'points', min: 17, max: 999, color: '#30d158', showCharts: true }, // Remaining WR1s (17+ ppg)
{ name: 'High Upside WR2', class: 'wr2', type: 'points', min: 14.5, max: 17, color: '#0a84ff', showCharts: true },
{ name: 'Solid WR2', class: 'wr2', type: 'points', min: 12, max: 14.5, color: '#0a84ff', showCharts: true },
{ name: 'Mid WR2', class: 'wr2', type: 'points', min: 10, max: 12, color: '#0a84ff', showCharts: true },
{ name: 'Low WR2/Flex', class: 'flex', type: 'points', min: 8, max: 10, color: '#FFD60A', showCharts: false },
{ name: 'WR3/Flex', class: 'flex', type: 'points', min: 5, max: 8, color: '#FFD60A', showCharts: false },
{ name: 'Depth/Streaming', class: 'depth', type: 'points', min: 0, max: 5, color: '#8e8e93', showCharts: false }
];
let html = '';
let chartIndex = 0;
let rankIndex = 0; // Track position for rank-based tiers
tiers.forEach(tier => {
let tierPlayers = [];
if (tier.type === 'rank') {
tierPlayers = wrs.slice(rankIndex, rankIndex + tier.maxPlayers);
rankIndex += tierPlayers.length;
} else {
const remainingPlayers = wrs.slice(rankIndex);
tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
rankIndex += tierPlayers.length;
}
if (tierPlayers.length === 0) return;
html += `
<div class="tier-section"><div class="tier-header" onclick="toggleTierCollapse(this)"><div class="tier-badge ${tier.class}">${tier.name}</div><div class="tier-count">Avg: ${(tierPlayers.reduce((sum, p) => sum + p.avgPoints, 0) / tierPlayers.length).toFixed(1)} pts/game</div><span class="tier-collapse-icon">â–¼</span></div><div class="tier-cards-container"><div class="cards-grid">
`;
tierPlayers.forEach(player => {
overallRank++;
const chartId = `wr-player-chart-${chartIndex++}`;
const escapedId = player.id.replace(/'/g, "\\'");
const sentiment = getSentimentScore(player.name);
const buyPct = sentiment.total > 0 ? (sentiment.buy / sentiment.total * 100) : 0;
const displayAvgPoints = player.inactive ? player.avgPoints * 2 : player.avgPoints;
const targetsPerGame = player.totalTargets / player.gamesPlayed;
const pointsDiff = displayAvgPoints - top24AvgPoints;
const targetsDiff = targetsPerGame - top24AvgTargets;
const pointsClass = pointsDiff >= 0 ? 'comparison-up' : 'comparison-down';
const pointsIcon = pointsDiff >= 0 ? 'â–²' : 'â–¼';
const targetsClass = targetsDiff >= 0 ? 'comparison-up' : 'comparison-down';
const targetsIcon = targetsDiff >= 0 ? 'â–²' : 'â–¼';
const includeChart = tier.showCharts;
const tags = playerTags[player.id] || [];
let tagElements = tags.map(tag => {
if (tag === 'rz_trend_up') return '<span class="player-tag rz-up" data-tooltip="Red Zone opportunities trending up - TD upside">RZâ†‘</span>';
return '';
}).filter(t => t);
const tagsHTML = tagElements.length > 0 ? `
<div class="player-tags">
${tagElements.join('')}
</div>
` : '';
html += `
<div class="player-card" onclick="openPlayerModal('${escapedId}')" ${player.inactive ? 'style="opacity: 0.6; border-left: 3px solid #ff453a;"' : ''}><div class="player-card-header"><div class="player-card-badge" style="background: ${teamColors[player.team] || '#666'}">${player.team}</div><div style="flex: 1;"><div class="player-card-name">
${player.name}${player.inactive ? ' <span style="color: #ff453a; font-size: 11px;">âš  INACTIVE</span>' : ''}
</div><div class="player-card-team">WR Â· ${player.team}${(() => {
let badges = '';
const injury = getPlayerInjuryStatus(player.name);
if (injury) {
const statusInfo = formatInjuryStatus(injury.status);
const injuryDetails = `${statusInfo.fullText} - ${injury.injuryBody}`;
badges += ` <span class="injury-badge ${statusInfo.class}" data-injury-details="${injuryDetails}">${statusInfo.badge}</span>`;
}
if (player.momentum && player.momentum.isValid && player.momentum.direction !== 'neutral') {
let showBadge = true;
if (player.momentum.direction === 'down') {
const highScorerThreshold = currentScoringFormat === 'ppr' ? 20 :
currentScoringFormat === 'half' ? 17 : 14.5;
if (player.avgPoints >= highScorerThreshold && player.momentum.score > -15) {
showBadge = false;
}
}
if (showBadge) {
badges += ` <span class="momentum-badge ${player.momentum.direction}" data-tooltip="Momentum: ${player.momentum.score > 0 ? '+' : ''}${player.momentum.score.toFixed(1)}% (last 3 vs prev 3 weeks)">${player.momentum.direction === 'up' ? 'â†‘' : 'â†“'}</span>`;
}
}
return badges;
})()}</div>
${tagsHTML}
</div></div><div class="player-card-stats"><div class="player-stat"><span class="player-stat-label">Avg Points</span><div class="player-stat-with-comparison"><span class="player-stat-value">${displayAvgPoints.toFixed(1)}</span><span class="player-comparison ${pointsClass}"><span class="comparison-icon">${pointsIcon}</span>
${Math.abs(pointsDiff).toFixed(1)}
</span><div class="comparison-tooltip"><div class="tooltip-label">vs Top 24 WR Avg</div><div class="tooltip-data">${displayAvgPoints.toFixed(1)} vs ${top24AvgPoints.toFixed(1)}</div><div class="tooltip-data">${pointsDiff >= 0 ? '+' : ''}${pointsDiff.toFixed(1)} pts</div></div></div><div class="stat-tooltip">Average fantasy points per game over ${player.gamesPlayed} games</div></div><div class="player-stat"><span class="player-stat-label">Targets/Game</span><div class="player-stat-with-comparison"><span class="player-stat-value">${targetsPerGame.toFixed(1)}</span><span class="player-comparison ${targetsClass}"><span class="comparison-icon">${targetsIcon}</span>
${Math.abs(targetsDiff).toFixed(1)}
</span><div class="comparison-tooltip"><div class="tooltip-label">vs Top 24 WR Avg</div><div class="tooltip-data">${targetsPerGame.toFixed(1)} vs ${top24AvgTargets.toFixed(1)}</div><div class="tooltip-data">${targetsDiff >= 0 ? '+' : ''}${targetsDiff.toFixed(1)} tgt/g</div></div></div><div class="stat-tooltip">Average targets per game (${player.totalTargets} total targets)</div></div><div class="player-stat" style="grid-column: 1 / -1;"><span class="player-stat-label">Community Sentiment</span><div style="margin-top: 4px;">
${sentiment.total > 0 ? (() => {
const totalVotes = sentiment.total;
const buyPct = Math.round((sentiment.buy / totalVotes) * 100);
const holdPct = Math.round((sentiment.hold / totalVotes) * 100);
const sellPct = Math.round((sentiment.sell / totalVotes) * 100);
const max = Math.max(buyPct, holdPct, sellPct);
let label, color, bgColor, icon;
if (buyPct === max) {
label = 'BUY';
color = 'var(--positive)';
bgColor = 'rgba(48, 209, 88, 0.15)';
icon = 'â–²';
} else if (sellPct === max) {
label = 'SELL';
color = 'var(--negative)';
bgColor = 'rgba(255, 69, 58, 0.15)';
icon = 'â–¼';
} else {
label = 'HOLD';
color = 'var(--text-secondary)';
bgColor = 'rgba(142, 142, 147, 0.15)';
icon = 'â€”';
}
return '<span style="padding: 3px 6px; background: ' + bgColor + '; color: ' + color + '; border-radius: 5px; font-size: 10px; font-weight: 600; display: inline-block;">' + icon + ' ' + max + '% ' + label + '</span>';
})() : '<span style="padding: 3px 6px; background: rgba(142, 142, 147, 0.15); color: var(--text-secondary); border-radius: 5px; font-size: 10px; font-weight: 600; display: inline-block;">No Votes</span>'}
</div><div class="stat-tooltip">${sentiment.total > 0 ? `Community voting: ${sentiment.total} total votes` : 'Be the first to vote! Open player modal to cast your vote.'}</div></div></div>
${includeChart ? `<div class="player-card-chart"><canvas id="${chartId}"></canvas></div>` : ''}
</div>
`;
});
html += `
</div></div></div>
`;
});
grid.innerHTML = html;
chartIndex = 0;
rankIndex = 0; // Reset rank index for chart rendering
tiers.forEach(tier => {
if (!tier.showCharts) {
let tierPlayers = [];
if (tier.type === 'rank') {
tierPlayers = wrs.slice(rankIndex, rankIndex + tier.maxPlayers);
rankIndex += tierPlayers.length;
} else {
const remainingPlayers = wrs.slice(rankIndex);
tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
rankIndex += tierPlayers.length;
}
chartIndex += tierPlayers.length;
return;
}
let tierPlayers = [];
if (tier.type === 'rank') {
tierPlayers = wrs.slice(rankIndex, rankIndex + tier.maxPlayers);
rankIndex += tierPlayers.length;
} else {
const remainingPlayers = wrs.slice(rankIndex);
tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
rankIndex += tierPlayers.length;
}
tierPlayers.forEach(player => {
renderPlayerCardChart(`wr-player-chart-${chartIndex}`, player, 'WR');
chartIndex++;
});
});
document.querySelectorAll('#wr-players-grid .cards-grid').forEach(cardsGrid => {
const playerCards = cardsGrid.querySelectorAll('.player-card');
if (playerCards.length === 1) {
cardsGrid.classList.add('two-or-less');
const spacer = document.createElement('div');
spacer.className = 'grid-spacer';
cardsGrid.appendChild(spacer);
} else if (playerCards.length === 2) {
cardsGrid.classList.add('two-or-less');
}
});
}
function renderRBPlayerCards() {
const grid = document.getElementById('rb-players-grid');
let rbs = Object.values(window.aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints);
const playerTags = calculatePlayerTags('RB');
rbs = rbs.map(player => {
if (player.name === 'Cam Skattebo') {
return {
...player,
latestWeek: 0, // Force inactive status
inactive: true
};
}
return player;
});
rbs = rbs.map(player => {
if (player.latestWeek && player.latestWeek < 5) {
return {
...player,
avgPoints: player.avgPoints * 0.5,
inactive: true
};
}
return player;
}).sort((a, b) => b.avgPoints - a.avgPoints);
rbs = rbs.map(player => {
if (player.gamesPlayed === 1) {
return {
...player,
avgPoints: Math.min(player.avgPoints, 7.9),
lowSampleSize: true
};
}
return player;
}).sort((a, b) => b.avgPoints - a.avgPoints);
const top24 = rbs.slice(0, 24);
const top24AvgPoints = top24.reduce((sum, p) => sum + p.avgPoints, 0) / top24.length;
const top24AvgOpps = top24.reduce((sum, p) => sum + (p.totalOpportunities / p.gamesPlayed), 0) / top24.length;
let overallRank = 0;
const tiers = [
{ name: 'Elite RB1', class: 'elite', min: 22, max: 999, color: '#30d158', showCharts: true },
{ name: 'High-End RB1', class: 'elite', min: 20, max: 22, color: '#30d158', showCharts: true },
{ name: 'Solid RB1', class: 'elite', min: 18, max: 20, color: '#30d158', showCharts: true },
{ name: 'Low RB1/High RB2', class: 'wr2', min: 15, max: 18, color: '#0a84ff', showCharts: true },
{ name: 'Mid RB2', class: 'wr2', min: 13, max: 15, color: '#0a84ff', showCharts: true },
{ name: 'Low RB2/Flex', class: 'flex', min: 10, max: 13, color: '#FFD60A', showCharts: true },
{ name: 'RB3/Flex', class: 'flex', min: 8, max: 10, color: '#FFD60A', showCharts: true },
{ name: 'Deep Flex', class: 'depth', min: 5, max: 8, color: '#8e8e93', showCharts: false },
{ name: 'Depth/Streaming', class: 'depth', min: 0, max: 5, color: '#8e8e93', showCharts: false }
];
let html = '';
let chartIndex = 0;
tiers.forEach(tier => {
const tierPlayers = rbs.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
if (tierPlayers.length === 0) return;
html += `
<div class="tier-section"><div class="tier-header" onclick="toggleTierCollapse(this)"><div class="tier-badge ${tier.class}">${tier.name}</div><div class="tier-count">Avg: ${(tierPlayers.reduce((sum, p) => sum + p.avgPoints, 0) / tierPlayers.length).toFixed(1)} pts/game</div><span class="tier-collapse-icon">â–¼</span></div><div class="tier-cards-container"><div class="cards-grid">
`;
tierPlayers.forEach(player => {
overallRank++;
const chartId = `rb-player-chart-${chartIndex++}`;
const escapedId = player.id.replace(/'/g, "\\'");
const sentiment = getSentimentScore(player.name);
const buyPct = sentiment.total > 0 ? (sentiment.buy / sentiment.total * 100) : 0;
const displayAvgPoints = player.inactive ? player.avgPoints * 2 : player.avgPoints;
const oppsPerGame = player.totalOpportunities / player.gamesPlayed;
const pointsDiff = displayAvgPoints - top24AvgPoints;
const oppsDiff = oppsPerGame - top24AvgOpps;
const pointsClass = pointsDiff >= 0 ? 'comparison-up' : 'comparison-down';
const pointsIcon = pointsDiff >= 0 ? 'â–²' : 'â–¼';
const oppsClass = oppsDiff >= 0 ? 'comparison-up' : 'comparison-down';
const oppsIcon = oppsDiff >= 0 ? 'â–²' : 'â–¼';
const includeChart = tier.showCharts;
const tags = playerTags[player.id] || [];
let tagElements = tags.map(tag => {
if (tag === 'rz_trend_up') return '<span class="player-tag rz-up" data-tooltip="Red Zone opportunities trending up - TD upside">RZâ†‘</span>';
return '';
}).filter(t => t);
const tagsHTML = tagElements.length > 0 ? `
<div class="player-tags">
${tagElements.join('')}
</div>
` : '';
html += `
<div class="player-card" onclick="openPlayerModal('${escapedId}')" ${player.inactive ? 'style="opacity: 0.6; border-left: 3px solid #ff453a;"' : ''}><div class="player-card-header"><div class="player-card-badge" style="background: ${teamColors[player.team] || '#666'}">${player.team}</div><div style="flex: 1;"><div class="player-card-name">
${player.name}${player.inactive ? ' <span style="color: #ff453a; font-size: 11px;">âš  INACTIVE</span>' : ''}
</div><div class="player-card-team">RB Â· ${player.team}${(() => {
let badges = '';
const injury = getPlayerInjuryStatus(player.name);
if (injury) {
const statusInfo = formatInjuryStatus(injury.status);
const injuryDetails = `${statusInfo.fullText} - ${injury.injuryBody}`;
badges += ` <span class="injury-badge ${statusInfo.class}" data-injury-details="${injuryDetails}">${statusInfo.badge}</span>`;
}
if (player.momentum && player.momentum.isValid && player.momentum.direction !== 'neutral') {
let showBadge = true;
if (player.momentum.direction === 'down') {
const highScorerThreshold = currentScoringFormat === 'ppr' ? 20 :
currentScoringFormat === 'half' ? 17 : 14.5;
if (player.avgPoints >= highScorerThreshold && player.momentum.score > -15) {
showBadge = false;
}
}
if (showBadge) {
badges += ` <span class="momentum-badge ${player.momentum.direction}" data-tooltip="Momentum: ${player.momentum.score > 0 ? '+' : ''}${player.momentum.score.toFixed(1)}% (last 3 vs prev 3 weeks)">${player.momentum.direction === 'up' ? 'â†‘' : 'â†“'}</span>`;
}
}
return badges;
})()}</div>
${tagsHTML}
</div></div><div class="player-card-stats"><div class="player-stat"><span class="player-stat-label">Avg Points</span><div class="player-stat-with-comparison"><span class="player-stat-value">${displayAvgPoints.toFixed(1)}</span><span class="player-comparison ${pointsClass}"><span class="comparison-icon">${pointsIcon}</span>
${Math.abs(pointsDiff).toFixed(1)}
</span><div class="comparison-tooltip"><div class="tooltip-label">vs Top 24 RB Avg</div><div class="tooltip-data">${displayAvgPoints.toFixed(1)} vs ${top24AvgPoints.toFixed(1)}</div><div class="tooltip-data">${pointsDiff >= 0 ? '+' : ''}${pointsDiff.toFixed(1)} pts</div></div></div><div class="stat-tooltip">Average fantasy points per game over ${player.gamesPlayed} games</div></div><div class="player-stat"><span class="player-stat-label">Opps/Game</span><div class="player-stat-with-comparison"><span class="player-stat-value">${oppsPerGame.toFixed(1)}</span><span class="player-comparison ${oppsClass}"><span class="comparison-icon">${oppsIcon}</span>
${Math.abs(oppsDiff).toFixed(1)}
</span><div class="comparison-tooltip"><div class="tooltip-label">vs Top 24 RB Avg</div><div class="tooltip-data">${oppsPerGame.toFixed(1)} vs ${top24AvgOpps.toFixed(1)}</div><div class="tooltip-data">${oppsDiff >= 0 ? '+' : ''}${oppsDiff.toFixed(1)} opp/g</div></div></div><div class="stat-tooltip">Average opportunities per game (${player.totalOpportunities} total opportunities)</div></div><div class="player-stat" style="grid-column: 1 / -1;"><span class="player-stat-label">Community Sentiment</span><div style="margin-top: 4px;">
${sentiment.total > 0 ? (() => {
const totalVotes = sentiment.total;
const buyPct = Math.round((sentiment.buy / totalVotes) * 100);
const holdPct = Math.round((sentiment.hold / totalVotes) * 100);
const sellPct = Math.round((sentiment.sell / totalVotes) * 100);
const max = Math.max(buyPct, holdPct, sellPct);
let label, color, bgColor, icon;
if (buyPct === max) {
label = 'BUY';
color = 'var(--positive)';
bgColor = 'rgba(48, 209, 88, 0.15)';
icon = 'â–²';
} else if (sellPct === max) {
label = 'SELL';
color = 'var(--negative)';
bgColor = 'rgba(255, 69, 58, 0.15)';
icon = 'â–¼';
} else {
label = 'HOLD';
color = 'var(--text-secondary)';
bgColor = 'rgba(142, 142, 147, 0.15)';
icon = 'â€”';
}
return '<span style="padding: 3px 6px; background: ' + bgColor + '; color: ' + color + '; border-radius: 5px; font-size: 10px; font-weight: 600; display: inline-block;">' + icon + ' ' + max + '% ' + label + '</span>';
})() : '<span style="padding: 3px 6px; background: rgba(142, 142, 147, 0.15); color: var(--text-secondary); border-radius: 5px; font-size: 10px; font-weight: 600; display: inline-block;">No Votes</span>'}
</div><div class="stat-tooltip">${sentiment.total > 0 ? `Community voting: ${sentiment.total} total votes` : 'Be the first to vote! Open player modal to cast your vote.'}</div></div></div>
${includeChart ? `<div class="player-card-chart"><canvas id="${chartId}"></canvas></div>` : ''}
</div>
`;
});
html += `
</div></div></div>
`;
});
grid.innerHTML = html;
chartIndex = 0;
overallRank = 0;
tiers.forEach(tier => {
const tierPlayers = rbs.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
tierPlayers.forEach(player => {
overallRank++;
if (overallRank <= 50) {
renderPlayerCardChart(`rb-player-chart-${chartIndex}`, player, 'RB');
}
chartIndex++;
});
});
document.querySelectorAll('#rb-players-grid .cards-grid').forEach(cardsGrid => {
const playerCards = cardsGrid.querySelectorAll('.player-card');
if (playerCards.length === 1) {
cardsGrid.classList.add('two-or-less');
const spacer = document.createElement('div');
spacer.className = 'grid-spacer';
cardsGrid.appendChild(spacer);
} else if (playerCards.length === 2) {
cardsGrid.classList.add('two-or-less');
}
});
}
function renderTEPlayerCards() {
const grid = document.getElementById('te-players-grid');
let tes = Object.values(window.aggregatedTEs).sort((a, b) => b.avgPoints - a.avgPoints);
const playerTags = calculatePlayerTags('TE');
tes = tes.map(player => {
if (player.latestWeek && player.latestWeek < 5) {
return {
...player,
avgPoints: player.avgPoints * 0.5,
inactive: true
};
}
return player;
}).sort((a, b) => b.avgPoints - a.avgPoints);
let globalMaxWeek = 0;
tes.forEach(p => {
if (p.weeks && p.weeks.length > 0) {
const maxWeek = Math.max(...p.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
tes = tes.map(player => {
if (player.latestWeek && globalMaxWeek - player.latestWeek >= 2) {
return {
...player,
avgPoints: Math.max(0, player.avgPoints - 3.5),
recentlyInactive: true
};
}
return player;
}).sort((a, b) => b.avgPoints - a.avgPoints);
tes = tes.map(player => {
if (player.name === 'Darren Waller') {
return {
...player,
avgPoints: Math.min(player.avgPoints, 5.9), // Just below TE2 threshold
wallerException: true
};
}
return player;
}).sort((a, b) => b.avgPoints - a.avgPoints);
tes = tes.map(player => {
if (player.name === 'Tucker Kraft') {
return {
...player,
inactive: true,
kraftInjury: true
};
}
return player;
}).sort((a, b) => b.avgPoints - a.avgPoints);
const eliteTwoAvg = tes.slice(0, 2).reduce((sum, p) => sum + p.avgPoints, 0) / 2;
tes = tes.map((player, idx) => {
if (idx < 2) return player;
if (player.avgPoints < eliteTwoAvg - 1.5) {
return {
...player,
avgPoints: Math.min(player.avgPoints, eliteTwoAvg - 1.6), // Push them down to next tier
notElite: true
};
}
return player;
}).sort((a, b) => b.avgPoints - a.avgPoints);
tes = tes.map(player => {
if (player.gamesPlayed === 1) {
const maxPpg = player.avgPoints >= 10 ? 7.9 : 5.9;
return {
...player,
avgPoints: Math.min(player.avgPoints, maxPpg),
lowSampleSize: true
};
}
return player;
}).sort((a, b) => b.avgPoints - a.avgPoints);
const top12 = tes.slice(0, 12);
const top12AvgPoints = top12.reduce((sum, p) => sum + p.avgPoints, 0) / top12.length;
const top12AvgTargets = top12.reduce((sum, p) => sum + (p.totalTargets / p.gamesPlayed), 0) / top12.length;
let overallRank = 0;
tes = tes.slice(0, 50);
const tiers = [
{ name: 'Elite', class: 'elite', type: 'rank', maxPlayers: 2, color: '#30d158', showCharts: true },
{ name: 'High-End TE1', class: 'elite', type: 'rank', maxPlayers: 3, color: '#30d158', showCharts: true },
{ name: 'Solid TE1', class: 'elite', type: 'rank', maxPlayers: 5, color: '#30d158', showCharts: true },
{ name: 'Low-End TE1/High-End TE2', class: 'wr2', type: 'rank', maxPlayers: 8, color: '#0a84ff', showCharts: true },
{ name: 'Solid TE2', class: 'wr2', type: 'points', min: 8, max: 999, color: '#0a84ff', showCharts: true },
{ name: 'Flex/Streamer', class: 'flex', type: 'points', min: 5.5, max: 8, color: '#FFD60A', showCharts: true },
{ name: 'Depth', class: 'depth', type: 'points', min: 0, max: 5.5, color: '#8e8e93', showCharts: false }
];
let html = '';
let chartIndex = 0;
let rankIndex = 0; // Track position for rank-based tiers
tiers.forEach(tier => {
let tierPlayers = [];
if (tier.type === 'rank') {
tierPlayers = tes.slice(rankIndex, rankIndex + tier.maxPlayers);
rankIndex += tierPlayers.length;
} else {
const remainingPlayers = tes.slice(rankIndex);
tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
rankIndex += tierPlayers.length;
}
if (tierPlayers.length === 0) return;
html += `
<div class="tier-section"><div class="tier-header" onclick="toggleTierCollapse(this)"><div class="tier-badge ${tier.class}">${tier.name}</div><div class="tier-count">Avg: ${(tierPlayers.reduce((sum, p) => sum + p.avgPoints, 0) / tierPlayers.length).toFixed(1)} pts/game</div><span class="tier-collapse-icon">â–¼</span></div><div class="tier-cards-container"><div class="cards-grid">
`;
tierPlayers.forEach(player => {
overallRank++;
const chartId = `te-player-chart-${chartIndex++}`;
const escapedId = player.id.replace(/'/g, "\\'");
const sentiment = getSentimentScore(player.name);
const buyPct = sentiment.total > 0 ? (sentiment.buy / sentiment.total * 100) : 0;
const displayAvgPoints = player.inactive ? player.avgPoints * 2 : player.avgPoints;
const targetsPerGame = player.totalTargets / player.gamesPlayed;
const pointsDiff = displayAvgPoints - top12AvgPoints;
const targetsDiff = targetsPerGame - top12AvgTargets;
const pointsClass = pointsDiff >= 0 ? 'comparison-up' : 'comparison-down';
const pointsIcon = pointsDiff >= 0 ? 'â–²' : 'â–¼';
const targetsClass = targetsDiff >= 0 ? 'comparison-up' : 'comparison-down';
const targetsIcon = targetsDiff >= 0 ? 'â–²' : 'â–¼';
const includeChart = tier.showCharts;
const tags = playerTags[player.id] || [];
let tagElements = tags.map(tag => {
if (tag === 'rz_trend_up') return '<span class="player-tag rz-up" data-tooltip="Red Zone opportunities trending up - TD upside">RZâ†‘</span>';
return '';
}).filter(t => t);
const tagsHTML = tagElements.length > 0 ? `
<div class="player-tags">
${tagElements.join('')}
</div>
` : '';
html += `
<div class="player-card" onclick="openPlayerModal('${escapedId}')" ${player.inactive ? 'style="opacity: 0.6; border-left: 3px solid #ff453a;"' : ''}><div class="player-card-header"><div class="player-card-badge" style="background: ${teamColors[player.team] || '#666'}">${player.team}</div><div style="flex: 1;"><div class="player-card-name">
${player.name}${player.inactive ? ' <span style="color: #ff453a; font-size: 11px;">âš  INACTIVE</span>' : ''}
</div><div class="player-card-team">TE Â· ${player.team}${(() => {
let badges = '';
const injury = getPlayerInjuryStatus(player.name);
if (injury) {
const statusInfo = formatInjuryStatus(injury.status);
const injuryDetails = `${statusInfo.fullText} - ${injury.injuryBody}`;
badges += ` <span class="injury-badge ${statusInfo.class}" data-injury-details="${injuryDetails}">${statusInfo.badge}</span>`;
}
if (player.momentum && player.momentum.isValid && player.momentum.direction !== 'neutral') {
let showBadge = true;
if (player.momentum.direction === 'down') {
const highScorerThreshold = currentScoringFormat === 'ppr' ? 20 :
currentScoringFormat === 'half' ? 17 : 14.5;
if (player.avgPoints >= highScorerThreshold && player.momentum.score > -15) {
showBadge = false;
}
}
if (showBadge) {
badges += ` <span class="momentum-badge ${player.momentum.direction}" data-tooltip="Momentum: ${player.momentum.score > 0 ? '+' : ''}${player.momentum.score.toFixed(1)}% (last 3 vs prev 3 weeks)">${player.momentum.direction === 'up' ? 'â†‘' : 'â†“'}</span>`;
}
}
return badges;
})()}</div>
${tagsHTML}
</div></div><div class="player-card-stats"><div class="player-stat"><span class="player-stat-label">Avg Points</span><div class="player-stat-with-comparison"><span class="player-stat-value">${displayAvgPoints.toFixed(1)}</span><span class="player-comparison ${pointsClass}"><span class="comparison-icon">${pointsIcon}</span>
${Math.abs(pointsDiff).toFixed(1)}
</span><div class="comparison-tooltip"><div class="tooltip-label">vs Top 12 TE Avg</div><div class="tooltip-data">${displayAvgPoints.toFixed(1)} vs ${top12AvgPoints.toFixed(1)}</div><div class="tooltip-data">${pointsDiff >= 0 ? '+' : ''}${pointsDiff.toFixed(1)} pts</div></div></div><div class="stat-tooltip">Average fantasy points per game over ${player.gamesPlayed} games</div></div><div class="player-stat"><span class="player-stat-label">Targets/Game</span><div class="player-stat-with-comparison"><span class="player-stat-value">${targetsPerGame.toFixed(1)}</span><span class="player-comparison ${targetsClass}"><span class="comparison-icon">${targetsIcon}</span>
${Math.abs(targetsDiff).toFixed(1)}
</span><div class="comparison-tooltip"><div class="tooltip-label">vs Top 12 TE Avg</div><div class="tooltip-data">${targetsPerGame.toFixed(1)} vs ${top12AvgTargets.toFixed(1)}</div><div class="tooltip-data">${targetsDiff >= 0 ? '+' : ''}${targetsDiff.toFixed(1)} tgt/g</div></div></div><div class="stat-tooltip">Average targets per game (${player.totalTargets} total targets)</div></div><div class="player-stat" style="grid-column: 1 / -1;"><span class="player-stat-label">Community Sentiment</span><div style="margin-top: 4px;">
${sentiment.total > 0 ? (() => {
const totalVotes = sentiment.total;
const buyPct = Math.round((sentiment.buy / totalVotes) * 100);
const holdPct = Math.round((sentiment.hold / totalVotes) * 100);
const sellPct = Math.round((sentiment.sell / totalVotes) * 100);
const max = Math.max(buyPct, holdPct, sellPct);
let label, color, bgColor, icon;
if (buyPct === max) {
label = 'BUY';
color = 'var(--positive)';
bgColor = 'rgba(48, 209, 88, 0.15)';
icon = 'â–²';
} else if (sellPct === max) {
label = 'SELL';
color = 'var(--negative)';
bgColor = 'rgba(255, 69, 58, 0.15)';
icon = 'â–¼';
} else {
label = 'HOLD';
color = 'var(--text-secondary)';
bgColor = 'rgba(142, 142, 147, 0.15)';
icon = 'â€”';
}
return '<span style="padding: 3px 6px; background: ' + bgColor + '; color: ' + color + '; border-radius: 5px; font-size: 10px; font-weight: 600; display: inline-block;">' + icon + ' ' + max + '% ' + label + '</span>';
})() : '<span style="padding: 3px 6px; background: rgba(142, 142, 147, 0.15); color: var(--text-secondary); border-radius: 5px; font-size: 10px; font-weight: 600; display: inline-block;">No Votes</span>'}
</div><div class="stat-tooltip">${sentiment.total > 0 ? `Community voting: ${sentiment.total} total votes` : 'Be the first to vote! Open player modal to cast your vote.'}</div></div></div>
${includeChart ? `<div class="player-card-chart"><canvas id="${chartId}"></canvas></div>` : ''}
</div>
`;
});
html += `
</div></div></div>
`;
});
grid.innerHTML = html;
chartIndex = 0;
rankIndex = 0; // Reset rank index for chart rendering
tiers.forEach(tier => {
if (!tier.showCharts) {
rankIndex += tier.type === 'rank' ? tier.maxPlayers :
tes.slice(rankIndex).filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max).length;
return;
}
let tierPlayers = [];
if (tier.type === 'rank') {
tierPlayers = tes.slice(rankIndex, rankIndex + tier.maxPlayers);
rankIndex += tierPlayers.length;
} else {
const remainingPlayers = tes.slice(rankIndex);
tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
rankIndex += tierPlayers.length;
}
tierPlayers.forEach(player => {
renderPlayerCardChart(`te-player-chart-${chartIndex}`, player, 'TE');
chartIndex++;
});
});
document.querySelectorAll('#te-players-grid .cards-grid').forEach(cardsGrid => {
const playerCards = cardsGrid.querySelectorAll('.player-card');
if (playerCards.length === 1) {
cardsGrid.classList.add('two-or-less');
const spacer = document.createElement('div');
spacer.className = 'grid-spacer';
cardsGrid.appendChild(spacer);
} else if (playerCards.length === 2) {
cardsGrid.classList.add('two-or-less');
}
});
}
function renderTeamsPage() {
const teamsGrid = document.getElementById('teams-grid');
teamStats = {};
const divisions = {
'AFC East': ['BUF', 'MIA', 'NE', 'NYJ'],
'AFC North': ['BAL', 'CIN', 'CLE', 'PIT'],
'AFC South': ['HOU', 'IND', 'JAC', 'TEN'],
'AFC West': ['DEN', 'KC', 'LAC', 'LV'],
'NFC East': ['DAL', 'NYG', 'PHI', 'WAS'],
'NFC North': ['CHI', 'DET', 'GB', 'MIN'],
'NFC South': ['ATL', 'CAR', 'NO', 'TB'],
'NFC West': ['ARI', 'LAR', 'SF', 'SEA']
};
Object.values(allPlayers).forEach(player => {
if (!teamStats[player.team]) {
teamStats[player.team] = {
team: player.team,
wrCount: 0,
rbCount: 0,
totalPoints: 0,
players: [],
totalTargets: 0,
totalRushAtts: 0,
totalGames: 0,
weeklyTargets: {}, // Track targets by week
weeklyRushAtts: {}, // Track rush attempts by week
weeklyRzOpps: {}, // Track RZ opportunities by week
totalRzOpps: 0
};
}
if (player.position === 'WR') {
teamStats[player.team].wrCount++;
} else {
teamStats[player.team].rbCount++;
}
teamStats[player.team].totalPoints += player.totalPoints;
teamStats[player.team].players.push(player);
player.weeks.forEach(week => {
const weekNum = week.week;
if (week.targets) {
if (!teamStats[player.team].weeklyTargets[weekNum]) {
teamStats[player.team].weeklyTargets[weekNum] = 0;
}
teamStats[player.team].weeklyTargets[weekNum] += week.targets;
teamStats[player.team].totalTargets += week.targets;
}
if (player.position === 'RB' && week.rushAttempts) {
if (!teamStats[player.team].weeklyRushAtts[weekNum]) {
teamStats[player.team].weeklyRushAtts[weekNum] = 0;
}
teamStats[player.team].weeklyRushAtts[weekNum] += week.rushAttempts;
teamStats[player.team].totalRushAtts += week.rushAttempts;
}
const rzField = player.position === 'RB' ? 'rzOpportunities' : 'rzTargets';
if (week[rzField]) {
if (!teamStats[player.team].weeklyRzOpps[weekNum]) {
teamStats[player.team].weeklyRzOpps[weekNum] = 0;
}
teamStats[player.team].weeklyRzOpps[weekNum] += week[rzField];
teamStats[player.team].totalRzOpps += week[rzField];
}
});
teamStats[player.team].totalGames = Math.max(
teamStats[player.team].totalGames,
player.weeks.length
);
});
Object.values(teamStats).forEach(team => {
let globalMaxWeek = 0;
team.players.forEach(p => {
if (p.weeks && p.weeks.length > 0) {
const maxWeek = Math.max(...p.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
const uniqueWeeks = new Set();
team.players.forEach(p => {
p.weeks.forEach(w => uniqueWeeks.add(w.week));
});
const numGames = uniqueWeeks.size;
team.avgTargetsPerGame = numGames > 0 ? team.totalTargets / numGames : 0;
team.avgRushAttsPerGame = numGames > 0 ? team.totalRushAtts / numGames : 0;
const lastWeek = globalMaxWeek;
let prevWeek = globalMaxWeek - 1;
let lastWeekTargets = team.weeklyTargets[lastWeek] || 0;
let lastWeekRushAtts = team.weeklyRushAtts[lastWeek] || 0;
if (lastWeekTargets === 0 && lastWeekRushAtts === 0) {
for (let w = lastWeek - 1; w >= 1; w--) {
if (team.weeklyTargets[w] || team.weeklyRushAtts[w]) {
lastWeekTargets = team.weeklyTargets[w] || 0;
lastWeekRushAtts = team.weeklyRushAtts[w] || 0;
prevWeek = w - 1; // Compare to week before that
break;
}
}
}
const prevWeekTargets = team.weeklyTargets[prevWeek] || 0;
const prevWeekRushAtts = team.weeklyRushAtts[prevWeek] || 0;
team.targetsChange = prevWeekTargets > 0 ? lastWeekTargets - prevWeekTargets : 0;
team.rushAttsChange = prevWeekRushAtts > 0 ? lastWeekRushAtts - prevWeekRushAtts : 0;
team.avgPoints = numGames > 0 ? team.totalPoints / numGames : 0;
});
let html = '';
let teamIndex = 0;
Object.entries(divisions).forEach(([divisionName, teamCodes]) => {
const divisionTeams = teamCodes
.map(code => teamStats[code])
.filter(team => team) // Filter out teams with no data
.sort((a, b) => b.totalPoints - a.totalPoints);
if (divisionTeams.length === 0) return;
html += `
<div style="grid-column: 1 / -1; margin-top: ${html ? '32px' : '0'};"><h2 style="font-size: 18px; font-weight: 700; color: var(--text-primary); margin-bottom: 16px; padding-bottom: 8px; border-bottom: 2px solid var(--border-color);">
${divisionName}
</h2></div>
`;
divisionTeams.forEach(team => {
const chartId = `team-chart-${teamIndex++}`;
html += `
<div class="team-card" onclick="openTeamModal('${team.team}')"><div class="team-card-header"><div class="team-card-badge" style="background: ${teamColors[team.team] || '#666'}">${team.team}</div><div class="team-card-name" style="font-weight: 700;">${team.team}</div></div><div class="team-card-stats"><div class="team-stat"><span class="team-stat-label">Total Points</span><span class="team-stat-value">${team.totalPoints.toFixed(1)}</span><span class="stat-tooltip">Combined fantasy points from all WRs and RBs this season</span></div><div class="team-stat"><span class="team-stat-label">Avg Targets/Game</span><div class="player-stat-with-comparison"><span class="team-stat-value">${team.avgTargetsPerGame.toFixed(1)}</span>
${team.targetsChange !== 0 ? `
<span class="player-comparison ${team.targetsChange > 0 ? 'comparison-up' : 'comparison-down'}"><span class="comparison-icon">${team.targetsChange > 0 ? 'â–²' : 'â–¼'}</span>
${Math.abs(team.targetsChange).toFixed(1)}
</span>
` : ''}
</div><span class="stat-tooltip">Average WR/RB targets per game (change vs last week)</span></div><div class="team-stat"><span class="team-stat-label">Avg Rush Atts/Game</span><div class="player-stat-with-comparison"><span class="team-stat-value">${team.avgRushAttsPerGame.toFixed(1)}</span>
${team.rushAttsChange !== 0 ? `
<span class="player-comparison ${team.rushAttsChange > 0 ? 'comparison-up' : 'comparison-down'}"><span class="comparison-icon">${team.rushAttsChange > 0 ? 'â–²' : 'â–¼'}</span>
${Math.abs(team.rushAttsChange).toFixed(1)}
</span>
` : ''}
</div><span class="stat-tooltip">Average RB rush attempts per game (change vs last week)</span></div></div><div class="team-card-chart"><canvas id="${chartId}"></canvas></div></div>
`;
});
});
teamsGrid.innerHTML = html;
teamIndex = 0;
Object.entries(divisions).forEach(([divisionName, teamCodes]) => {
const divisionTeams = teamCodes
.map(code => teamStats[code])
.filter(team => team)
.sort((a, b) => b.totalPoints - a.totalPoints);
divisionTeams.forEach(team => {
renderTeamCardChart(`team-chart-${teamIndex++}`, team);
});
});
}
function renderTeamCardChart(canvasId, team) {
const ctx = document.getElementById(canvasId);
if (!ctx) return;
const topPlayers = team.players
.sort((a, b) => b.avgPoints - a.avgPoints)
.slice(0, 5);
const labels = topPlayers.map(p => `${p.name} (${p.position})`);
const data = topPlayers.map(p => p.avgPoints);
const teamColor = teamColors[team.team] || '#0a84ff';
const colorPalette = getColorPalette(teamColor, topPlayers.length);
new Chart(ctx, {
type: 'bar',
data: {
labels: labels,
datasets: [{
data: data,
backgroundColor: colorPalette,
borderColor: '#0a0a0a',
borderWidth: 1
}]
},
options: {
indexAxis: 'y',
responsive: true,
maintainAspectRatio: false,
plugins: {
legend: { display: false },
tooltip: {
callbacks: {
label: (context) => `${context.parsed.x.toFixed(1)} PPG`
}
}
},
scales: {
x: {
display: false,
grid: { display: false }
},
y: {
ticks: {
color: '#8e8e93',
font: { size: 10 }
},
grid: { display: false }
}
}
}
});
}
function renderPlayerCardChart(canvasId, player, position) {
const ctx = document.getElementById(canvasId);
if (!ctx) return;
const weeks = player.weeks
.sort((a, b) => a.week - b.week)
.slice(-8); // Last 8 weeks
const labels = weeks.map(w => `W${w.week}`);
const actualData = weeks.map(w => w.fpts || 0);
const expectedData = weeks.map(w => w.expectedFpts || 0);
const teamColor = teamColors[player.team] || '#0a84ff';
new Chart(ctx, {
type: 'line',
data: {
labels: labels,
datasets: [
{
label: 'Actual Points',
data: actualData,
borderColor: teamColor,
backgroundColor: teamColor + '33',
borderWidth: 2,
fill: true,
tension: 0.3,
pointRadius: 3,
pointHoverRadius: 5,
pointBackgroundColor: teamColor,
pointBorderColor: '#fff',
pointBorderWidth: 1
},
{
label: 'Expected Points',
data: expectedData,
borderColor: '#8e8e93',
backgroundColor: 'transparent',
borderWidth: 2,
borderDash: [5, 5],
fill: false,
tension: 0.3,
pointRadius: 0,
pointHoverRadius: 4,
pointBackgroundColor: '#8e8e93',
pointBorderColor: '#fff',
pointBorderWidth: 1
}
]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: {
legend: { display: false },
tooltip: {
mode: 'index',
intersect: false,
callbacks: {
label: (context) => {
const label = context.dataset.label || '';
return `${label}: ${context.parsed.y.toFixed(1)} pts`;
}
}
}
},
scales: {
x: {
ticks: {
color: '#8e8e93',
font: { size: 9 }
},
grid: { display: false }
},
y: {
beginAtZero: true,
ticks: {
color: '#8e8e93',
font: { size: 9 }
},
grid: {
color: '#1c1c1e'
}
}
}
}
});
}
function openTeamModal(teamCode) {
const modal = document.getElementById('team-modal');
modal.style.display = 'flex';
const teamPlayers = Object.values(allPlayers).filter(p => p.team === teamCode);
if (teamPlayers.length === 0) return;
const wrs = teamPlayers.filter(p => p.position === 'WR');
const rbs = teamPlayers.filter(p => p.position === 'RB');
const tes = teamPlayers.filter(p => p.position === 'TE');
document.getElementById('team-modal-badge').style.background = teamColors[teamCode] || '#666';
document.getElementById('team-modal-badge').textContent = teamCode;
document.getElementById('team-modal-name').textContent = `${teamCode} Team Analysis`;
document.getElementById('team-modal-meta').textContent = `${wrs.length} WRs Â· ${rbs.length} RBs Â· ${tes.length} TEs`;
const allTeamPlayers = [...wrs, ...rbs, ...tes];
const totalPoints = allTeamPlayers.reduce((sum, p) => sum + (p.avgPoints * p.gamesPlayed), 0);
const totalGames = allTeamPlayers.reduce((sum, p) => sum + p.gamesPlayed, 0);
const avgPointsPerGame = totalGames > 0 ? totalPoints / totalGames : 0;
const topPlayer = allTeamPlayers.sort((a, b) => b.avgPoints - a.avgPoints)[0];
const topTargets = wrs.length > 0 ? Math.max(...wrs.map(w => w.totalTargets / w.gamesPlayed)) : 0;
const topOpps = rbs.length > 0 ? Math.max(...rbs.map(r => r.totalOpportunities / r.gamesPlayed)) : 0;
const statsHTML = `
<div class="team-stat-card"><div class="team-stat-value">${avgPointsPerGame.toFixed(1)}</div><div class="team-stat-label">Fantasy PPG</div></div><div class="team-stat-card"><div class="team-stat-value">${topPlayer ? topPlayer.avgPoints.toFixed(1) : '0'}</div><div class="team-stat-label">Top Player PPG</div></div><div class="team-stat-card"><div class="team-stat-value">${topTargets.toFixed(1)}</div><div class="team-stat-label">Top WR Targets</div></div><div class="team-stat-card"><div class="team-stat-value">${topOpps.toFixed(1)}</div><div class="team-stat-label">Top RB Opps</div></div>
`;
document.getElementById('team-stats-summary').innerHTML = statsHTML;
const keyPlayers = allTeamPlayers
.sort((a, b) => b.avgPoints - a.avgPoints)
.slice(0, 4);
const keyPlayersHTML = keyPlayers.map(player => {
const posColor = getPositionColor(player.position);
const statLabel = player.position === 'WR' || player.position === 'TE'
? `${(player.totalTargets / player.gamesPlayed).toFixed(1)} tgts/g`
: `${(player.totalOpportunities / player.gamesPlayed).toFixed(1)} opps/g`;
return `
<div class="key-player-card" onclick="openPlayerModal('${player.id.replace(/'/g, "\\'")}')"><div class="key-player-position" style="background: ${posColor};">
${player.position}
</div><div class="key-player-info"><div class="key-player-name">${player.name}</div><div class="key-player-stat">${player.avgPoints.toFixed(1)} PPG Â· ${statLabel}</div></div></div>
`;
}).join('');
document.getElementById('key-players-grid').innerHTML = keyPlayersHTML;
window.currentTeamModalCode = teamCode;
const weeks = [...new Set([...wrData, ...rbData, ...(teData || [])].map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);
const weekSelect = document.getElementById('team-modal-week');
weekSelect.innerHTML = weeks.map(w => `<option value="${w}">Week ${w}</option>`).join('');
if (weeks.length > 0) {
weekSelect.value = weeks[weeks.length - 1]; // Default to latest week
}
document.getElementById('team-modal-timeframe').value = 'season';
setTimeout(() => {
updateTeamModalCharts();
}, 50);
const playersSection = document.getElementById('key-players-section');
const playersIcon = document.getElementById('team-players-collapse-icon');
const playersText = document.getElementById('team-players-collapse-text');
if (playersSection) {
playersSection.style.display = '';
playersIcon.textContent = 'â–¼';
playersText.textContent = 'Hide Players';
}
}
function closeTeamModal() {
document.getElementById('team-modal').style.display = 'none';
if (window.teamModalPlayersChart) window.teamModalPlayersChart.destroy();
if (window.teamModalPositionChart) window.teamModalPositionChart.destroy();
}
function updateTeamModalCharts() {
const teamCode = window.currentTeamModalCode;
if (!teamCode) return;
const metric = document.getElementById('team-modal-metric').value;
const timeframe = document.getElementById('team-modal-timeframe').value;
const weekSelector = document.getElementById('team-modal-week-selector');
const selectedWeek = parseInt(document.getElementById('team-modal-week').value);
if (timeframe === 'single') {
weekSelector.style.display = 'block';
} else {
weekSelector.style.display = 'none';
}
const allWeeks = [...new Set([...wrData, ...rbData, ...(teData || [])].map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);
const latestWeek = Math.max(...allWeeks);
let filteredWRData, filteredRBData, filteredTEData;
if (timeframe === 'single') {
filteredWRData = wrData.filter(row => row.Team === teamCode && parseInt(row.Week) === selectedWeek);
filteredRBData = rbData.filter(row => row.Team === teamCode && parseInt(row.Week) === selectedWeek);
filteredTEData = teData ? teData.filter(row => row.Team === teamCode && parseInt(row.Week) === selectedWeek) : [];
} else if (timeframe === 'last3') {
const startWeek = latestWeek - 2;
filteredWRData = wrData.filter(row => row.Team === teamCode && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek);
filteredRBData = rbData.filter(row => row.Team === teamCode && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek);
filteredTEData = teData ? teData.filter(row => row.Team === teamCode && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek) : [];
} else if (timeframe === 'last5') {
const startWeek = latestWeek - 4;
filteredWRData = wrData.filter(row => row.Team === teamCode && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek);
filteredRBData = rbData.filter(row => row.Team === teamCode && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek);
filteredTEData = teData ? teData.filter(row => row.Team === teamCode && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek) : [];
} else { // season or season-avg
filteredWRData = wrData.filter(row => row.Team === teamCode);
filteredRBData = rbData.filter(row => row.Team === teamCode);
filteredTEData = teData ? teData.filter(row => row.Team === teamCode) : [];
}

const playerData = {};
filteredWRData.forEach(row => {
const player = row.Player;
if (!playerData[player]) {
playerData[player] = { name: player, position: 'WR', totalValue: 0, games: 0 };
}
let value = 0;
if (metric === 'points') {
value = parseFloat(row.FPTS || row.Fpts) || 0;
} else if (metric === 'targets') {
value = parseFloat(row.TGT) || 0;
} else if (metric === 'redzone') {
const rzTargets = parseFloat(row.RZ_TGT || row['RZ TGT']) || 0;
value = rzTargets; // WRs only have RZ targets
}
playerData[player].totalValue += value;
if (value > 0 || metric === 'points') playerData[player].games++;
});
filteredRBData.forEach(row => {
const player = row.Player;
if (!playerData[player]) {
playerData[player] = { name: player, position: 'RB', totalValue: 0, games: 0 };
}
let value = 0;
if (metric === 'points') {
value = parseFloat(row.FPTS || row.Fpts) || 0;
} else if (metric === 'targets') {
value = parseFloat(row.TGT) || 0;
} else if (metric === 'redzone') {
const rzAtt = parseFloat(row.RZ_RUSH_ATT || row['RZ RUSH ATT']) || 0;
const rzTargets = parseFloat(row.RZ_TGT || row['RZ TGT']) || 0;
value = rzAtt + rzTargets;
}
playerData[player].totalValue += value;
if (value > 0 || metric === 'points') playerData[player].games++;
});
filteredTEData.forEach(row => {
const player = row.Player;
if (!playerData[player]) {
playerData[player] = { name: player, position: 'TE', totalValue: 0, games: 0 };
}
let value = 0;
if (metric === 'points') {
value = parseFloat(row.FPTS || row.Fpts) || 0;
} else if (metric === 'targets') {
value = parseFloat(row.TGT) || 0;
} else if (metric === 'redzone') {
const rzTargets = parseFloat(row.RZ_TGT || row['RZ TGT']) || 0;
value = rzTargets; // TEs only have RZ targets
}
playerData[player].totalValue += value;
if (value > 0 || metric === 'points') playerData[player].games++;
});

// Check if this is a bye week (single week selected with no data or 0 total targets)
if (timeframe === 'single') {
const totalRows = filteredWRData.length + filteredRBData.length + filteredTEData.length;
const totalTargets = [...filteredWRData, ...filteredRBData, ...filteredTEData]
.reduce((sum, row) => sum + (parseFloat(row.TGT) || 0), 0);
const totalPoints = [...filteredWRData, ...filteredRBData, ...filteredTEData]
.reduce((sum, row) => sum + (parseFloat(row.FPTS || row.Fpts) || 0), 0);

// Debug logging
console.log(`Bye week check for ${teamCode} Week ${selectedWeek}:`, {
totalRows,
totalTargets,
totalPoints,
wrRows: filteredWRData.length,
rbRows: filteredRBData.length,
teRows: filteredTEData.length
});

// Bye week if no data rows OR both targets and points are 0
if (totalRows === 0 || (totalTargets === 0 && totalPoints === 0)) {
// Destroy existing charts before showing bye week message
if (window.teamModalPlayersChart) {
window.teamModalPlayersChart.destroy();
window.teamModalPlayersChart = null;
}
if (window.teamModalPositionChart) {
window.teamModalPositionChart.destroy();
window.teamModalPositionChart = null;
}

// Show "Bye Week" message
const byeWeekHTML = `
<div style="grid-column: span 2; text-align: center; padding: 60px 20px; color: var(--text-secondary);">
<div style="font-size: 48px; margin-bottom: 16px;">ðŸ–ï¸</div>
<div style="font-size: 20px; font-weight: 700; color: var(--text-primary); margin-bottom: 8px;">Bye Week</div>
<div style="font-size: 14px;">No data available for ${teamCode} in Week ${selectedWeek}</div>
</div>
`;
const chartsGrid = document.querySelector('.team-modal-charts-grid');
if (chartsGrid) {
chartsGrid.innerHTML = byeWeekHTML;
}
console.log('Bye week message displayed');
return;
}
}

let players = Object.values(playerData);
if (timeframe === 'season-avg') {
players = players.map(p => ({
...p,
displayValue: p.games > 0 ? p.totalValue / p.games : 0
}));
} else {
players = players.map(p => ({
...p,
displayValue: p.totalValue
}));
}
players.sort((a, b) => b.displayValue - a.displayValue);
const top6Players = players.slice(0, 6);
const positionTotals = {
WR: 0,
RB: 0,
TE: 0
};
players.forEach(p => {
if (timeframe === 'season-avg') {
positionTotals[p.position] += p.displayValue;
} else {
positionTotals[p.position] += p.totalValue;
}
});
let metricLabel = '';
if (metric === 'points') metricLabel = 'Points';
else if (metric === 'targets') metricLabel = 'Targets';
else if (metric === 'redzone') metricLabel = 'Red Zone Opps';
document.getElementById('team-modal-players-chart-header').textContent = `Top 6 Players by ${metricLabel}`;
document.getElementById('team-modal-position-chart-header').textContent = `${metricLabel} by Position`;
renderTeamModalPlayersChart(top6Players, teamCode, timeframe, metric);
renderTeamModalPositionChart(positionTotals, teamCode, timeframe, metric, filteredWRData, filteredRBData, filteredTEData);
}
function toggleTeamChartMetric(metric) {
window.currentTeamChartMetric = metric;
// Update button styles
const usageBtn = document.getElementById('usage-btn');
const rzBtn = document.getElementById('rz-btn');
if (metric === 'usage') {
usageBtn.style.background = 'var(--positive)';
usageBtn.style.borderColor = 'var(--positive)';
usageBtn.style.color = 'white';
rzBtn.style.background = 'var(--bg-tertiary)';
rzBtn.style.borderColor = 'var(--border-color)';
rzBtn.style.color = 'var(--text-secondary)';
} else {
rzBtn.style.background = 'var(--positive)';
rzBtn.style.borderColor = 'var(--positive)';
rzBtn.style.color = 'white';
usageBtn.style.background = 'var(--bg-tertiary)';
usageBtn.style.borderColor = 'var(--border-color)';
usageBtn.style.color = 'var(--text-secondary)';
}
updateTeamModalCharts();
}
function toggleMainTeamChartMetric(metric) {
window.currentMainTeamChartMetric = metric;
// Update button styles
const usageBtn = document.getElementById('main-usage-btn');
const rzBtn = document.getElementById('main-rz-btn');
const metricToggle = document.getElementById('main-rz-metric-toggle');
if (metric === 'usage') {
usageBtn.style.background = 'var(--positive)';
usageBtn.style.borderColor = 'var(--positive)';
usageBtn.style.color = 'white';
rzBtn.style.background = 'var(--bg-tertiary)';
rzBtn.style.borderColor = 'var(--border-color)';
rzBtn.style.color = 'var(--text-secondary)';
// Hide metric toggle
if (metricToggle) metricToggle.style.display = 'none';
} else {
rzBtn.style.background = 'var(--positive)';
rzBtn.style.borderColor = 'var(--positive)';
rzBtn.style.color = 'white';
usageBtn.style.background = 'var(--bg-tertiary)';
usageBtn.style.borderColor = 'var(--border-color)';
usageBtn.style.color = 'var(--text-secondary)';
// Show metric toggle
if (metricToggle) metricToggle.style.display = 'flex';
}
// Re-render the chart
updateTeamAnalysis();
}
function toggleMainRZMetric(metricType) {
window.currentMainRZMetric = metricType;
// Update button styles
const pctBtn = document.getElementById('main-pct-btn');
const numBtn = document.getElementById('main-num-btn');
if (metricType === 'pct') {
pctBtn.style.background = 'var(--positive)';
pctBtn.style.borderColor = 'var(--positive)';
pctBtn.style.color = 'white';
numBtn.style.background = 'var(--bg-tertiary)';
numBtn.style.borderColor = 'var(--border-color)';
numBtn.style.color = 'var(--text-secondary)';
} else {
numBtn.style.background = 'var(--positive)';
numBtn.style.borderColor = 'var(--positive)';
numBtn.style.color = 'white';
pctBtn.style.background = 'var(--bg-tertiary)';
pctBtn.style.borderColor = 'var(--border-color)';
pctBtn.style.color = 'var(--text-secondary)';
}
// Re-render the chart
updateTeamAnalysis();
}
function renderTeamModalPlayersChart(players, teamCode, timeframe, metric) {
const ctx = document.getElementById('team-modal-players-chart');
if (!ctx) return;
if (window.teamModalPlayersChart) {
window.teamModalPlayersChart.destroy();
}
const teamColor = teamColors[teamCode] || '#0a84ff';
const colorPalette = getColorPalette(teamColor, 6);
const labels = players.map(p => p.name);
const data = players.map(p => p.displayValue);
const positions = players.map(p => p.position);
const isAvg = timeframe === 'season-avg';

// Set metric-specific labels
let yAxisLabel, metricUnit;
if (metric === 'points') {
yAxisLabel = isAvg ? 'Points Per Game' : 'Total Points';
metricUnit = isAvg ? 'PPG' : 'pts';
} else if (metric === 'targets') {
yAxisLabel = isAvg ? 'Targets Per Game' : 'Total Targets';
metricUnit = isAvg ? 'TPG' : 'targets';
} else if (metric === 'redzone') {
yAxisLabel = isAvg ? 'RZ Opps Per Game' : 'Total RZ Opps';
metricUnit = isAvg ? 'RZ/G' : 'RZ Opps';
}

window.teamModalPlayersChart = new Chart(ctx, {
type: 'bar',
data: {
labels: labels,
datasets: [{
data: data,
backgroundColor: colorPalette,
borderColor: colorPalette.map(c => c),
borderWidth: 0
}]
},
options: {
indexAxis: 'y',
responsive: true,
maintainAspectRatio: false,
plugins: {
legend: { display: false },
tooltip: {
callbacks: {
label: (context) => {
const pos = positions[context.dataIndex];
const val = context.parsed.x.toFixed(1);
return `${pos} - ${val} ${metricUnit}`;
}
}
}
},
scales: {
x: {
beginAtZero: true,
title: {
display: true,
text: yAxisLabel,
color: getThemeColors().textSecondary,
font: { size: 11 }
},
ticks: {
color: getThemeColors().textSecondary,
font: { size: 10 }
},
grid: {
color: getThemeColors().grid
}
},
y: {
ticks: {
color: getThemeColors().text,
font: { size: 11, weight: '600' }
},
grid: {
display: false
}
}
}
}
});
}
function renderTeamModalPositionChart(positionTotals, teamCode, timeframe, metric, filteredWRData, filteredRBData, filteredTEData) {
const ctx = document.getElementById('team-modal-position-chart');
if (!ctx) return;
if (window.teamModalPositionChart) {
window.teamModalPositionChart.destroy();
}
// Always show position-based chart
const positions = ['WR', 'RB', 'TE'];
const data = positions.map(pos => positionTotals[pos]);
const total = data.reduce((sum, val) => sum + val, 0);
const colors = {
WR: '#0a84ff',
RB: '#30d158',
TE: '#ff9500'
};
const labels = positions;
const backgroundColors = positions.map(pos => {
const color = colors[pos];
const r = parseInt(color.slice(1, 3), 16);
const g = parseInt(color.slice(3, 5), 16);
const b = parseInt(color.slice(5, 7), 16);
return `rgba(${r}, ${g}, ${b}, 0.45)`;
});
const borderColors = positions.map(pos => colors[pos]);
const isAvg = timeframe === 'season-avg';

// Set metric-specific labels
let metricUnit;
if (metric === 'points') {
metricUnit = isAvg ? 'PPG' : 'pts';
} else if (metric === 'targets') {
metricUnit = isAvg ? 'TPG' : 'targets';
} else if (metric === 'redzone') {
metricUnit = isAvg ? 'RZ/G' : 'RZ Opps';
}

window.teamModalPositionChart = new Chart(ctx, {
type: 'pie',
data: {
labels: labels,
datasets: [{
data: data,
backgroundColor: backgroundColors,
borderColor: borderColors,
borderWidth: 2
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
animation: {
animateRotate: true,
animateScale: true,
duration: 1200,
easing: 'easeInOutQuart'
},
plugins: {
legend: {
position: 'bottom',
labels: {
color: getThemeColors().text,
padding: 12,
font: { size: 12, weight: 'bold' },
generateLabels: (chart) => {
const data = chart.data;
const textColor = getThemeColors().text;
return data.labels.map((label, i) => {
const value = data.datasets[0].data[i];
const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
const displayText = `${label}: ${value.toFixed(1)} ${metricUnit} (${percentage}%)`;
return {
text: displayText,
fillStyle: data.datasets[0].backgroundColor[i],
fontColor: textColor,
hidden: false,
index: i
};
});
}
}
},
tooltip: {
callbacks: {
label: (context) => {
const value = context.parsed;
const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
return `${context.label}: ${value.toFixed(1)} ${metricUnit} (${percentage}%)`;
}
}
}
}
}
});
}

function renderScatterPlots() {
renderTeamBalanceScatter();
initializeTeamAnalysis();
}
function switchMatrix(matrixType) {
document.querySelectorAll('.matrix-tab').forEach(btn => {
btn.classList.remove('active');
btn.style.background = 'var(--bg-tertiary)';
btn.style.color = 'var(--text-secondary)';
});
event.target.classList.add('active');
event.target.style.background = 'var(--positive)';
event.target.style.color = 'white';
document.querySelectorAll('.matrix-section').forEach(section => {
section.style.display = 'none';
});
document.getElementById(matrixType).style.display = 'block';
}
function switchWRMatrix(chartType) {
document.querySelectorAll('.wr-matrix-tab').forEach(btn => {
btn.classList.remove('active');
btn.style.color = 'var(--text-secondary)';
btn.style.borderBottomColor = 'transparent';
});
event.target.classList.add('active');
event.target.style.color = 'var(--text-primary)';
event.target.style.borderBottomColor = 'var(--positive)';
document.querySelectorAll('.wr-matrix-content').forEach(content => {
content.style.display = 'none';
});
const targetChart = document.getElementById(`wr-matrix-${chartType}`);
targetChart.style.display = 'block';
targetChart.style.animation = 'fadeIn 0.3s ease';
}
function switchRBMatrix(chartType) {
document.querySelectorAll('.rb-matrix-tab').forEach(btn => {
btn.classList.remove('active');
btn.style.color = 'var(--text-secondary)';
btn.style.borderBottomColor = 'transparent';
});
event.target.classList.add('active');
event.target.style.color = 'var(--text-primary)';
event.target.style.borderBottomColor = 'var(--positive)';
document.querySelectorAll('.rb-matrix-content').forEach(content => {
content.style.display = 'none';
});
const targetChart = document.getElementById(`rb-matrix-${chartType}`);
targetChart.style.display = 'block';
targetChart.style.animation = 'fadeIn 0.3s ease';
}
function switchMatrixChart(chartType) {
const activeSection = document.querySelector('.matrix-section:not([style*="display: none"])');
activeSection.querySelectorAll('.matrix-chart-tab').forEach(btn => {
btn.classList.remove('active');
btn.style.color = 'var(--text-secondary)';
btn.style.borderBottomColor = 'transparent';
});
event.target.classList.add('active');
event.target.style.color = 'var(--text-primary)';
event.target.style.borderBottomColor = 'var(--positive)';
activeSection.querySelectorAll('.matrix-chart-content').forEach(content => {
content.style.display = 'none';
});
activeSection.querySelector(`#matrix-${chartType}`).style.display = 'block';
}
function renderMatrices() {
renderEfficiencyMatrix('wr');
renderShareMatrix('wr');
renderFloorMatrix('wr');
renderVolumeMonsterMatrix();
renderCatchRateMatrix();
renderRedzoneMatrix('wr');
renderEfficiencyMatrix('rb');
renderTalentSituationMatrix();
renderOpportunityEfficiencyMatrix();
renderShareMatrix('rb');
renderFloorMatrix('rb');
renderRedzoneMatrix('rb');
}
function renderEfficiencyMatrix(position) {
const canvasId = position === 'wr' ? 'wr-efficiency-matrix' : 'rb-efficiency-matrix';
const ctx = document.getElementById(canvasId);
if (!ctx) return;
const players = position === 'wr' ?
Object.values(window.aggregatedWRs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50) :
Object.values(window.aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);
const data = players.map(player => {
const volume = position === 'wr' ? player.totalTargets : player.totalOpportunities;
const efficiency = player.avgPoints / (volume / player.gamesPlayed); // Points per opportunity per game
return {
x: volume,
y: efficiency,
label: player.name,
player: player
};
});
const xValues = data.map(d => d.x).sort((a, b) => a - b);
const yValues = data.map(d => d.y).sort((a, b) => a - b);
const medianX = xValues[Math.floor(xValues.length / 2)];
const medianY = yValues[Math.floor(yValues.length / 2)];
const chartVar = position === 'wr' ? 'wrEfficiencyMatrix' : 'rbEfficiencyMatrix';
if (window[chartVar]) {
window[chartVar].destroy();
}
window[chartVar] = new Chart(ctx, {
type: 'scatter',
data: {
datasets: [
{
label: position.toUpperCase() + 's',
data: data,
backgroundColor: data.map(d => {
const color = teamColors[d.player.team] || '#666';
const r = parseInt(color.slice(1, 3), 16);
const g = parseInt(color.slice(3, 5), 16);
const b = parseInt(color.slice(5, 7), 16);
return `rgba(${r}, ${g}, ${b}, 0.6)`;
}),
borderColor: data.map(d => teamColors[d.player.team] || '#666'),
borderWidth: 2,
pointRadius: 8,
pointHoverRadius: 10,
pointStyle: 'circle',
pointBorderWidth: 2,
shadowOffsetX: 0,
shadowOffsetY: 0,
shadowBlur: 12,
shadowColor: data.map(d => teamColors[d.player.team] || '#666')
}
]
},
options: {
responsive: true,
maintainAspectRatio: false,
layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
onClick: (event, elements) => {
if (elements.length > 0) {
const player = data[elements[0].index].player;
openPlayerModal(player.id);
}
},
plugins: {
legend: { display: false },
tooltip: {
callbacks: {
label: function(context) {
const player = context.raw.player;
return [
player.name,
`Volume: ${context.parsed.x.toFixed(0)}`,
`Efficiency: ${context.parsed.y.toFixed(2)} pts/opp`,
`AVG: ${player.avgPoints.toFixed(1)}`
];
}
}
},
annotation: {
annotations: {
vLine: {
type: 'line',
xMin: medianX,
xMax: medianX,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
},
hLine: {
type: 'line',
yMin: medianY,
yMax: medianY,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
},
topRight: {
type: 'label',
xValue: Math.max(...xValues) * 0.9,
yValue: Math.max(...yValues) * 0.9,
content: [position === 'wr' ? 'Safe Floor' : 'Volume RBs'],
color: '#FFD60A',
font: { size: 9, weight: 'bold' }
},
topLeft: {
type: 'label',
xValue: Math.min(...xValues) * 1.1,
yValue: Math.max(...yValues) * 0.9,
content: ['Efficient'],
color: '#0a84ff',
font: { size: 9, weight: 'bold' }
},
bottomRight: {
type: 'label',
xValue: Math.max(...xValues) * 0.9,
yValue: Math.min(...yValues) * 1.1,
content: [''],
color: '#FFD60A',
font: { size: 9, weight: 'bold' }
},
bottomLeft: {
type: 'label',
xValue: Math.min(...xValues) * 1.1,
yValue: Math.min(...yValues) * 1.1,
content: [''],
color: '#ff453a',
font: { size: 9, weight: 'bold' }
}
}
}
},
scales: {
x: {
title: {
display: true,
text: position === 'wr' ? 'Total Targets â†’' : 'Total Opportunities â†’',
color: '#8e8e93',
font: { weight: 'bold' }
},
grid: { color: '#2c2c2e', lineWidth: function(context) {
return Math.abs(context.tick.value - medianX) < 1 ? 2 : 1;
}},
ticks: { color: '#8e8e93' }
},
y: {
title: {
display: true,
text: 'Efficiency (Points per Opportunity) â†’',
color: '#8e8e93',
font: { weight: 'bold' }
},
grid: { color: '#2c2c2e', lineWidth: function(context) {
return Math.abs(context.tick.value - medianY) < 0.1 ? 2 : 1;
}},
ticks: { color: '#8e8e93' }
}
}
}
});
}
function renderShareMatrix(position) {
const canvasId = position === 'wr' ? 'wr-share-matrix' : 'rb-share-matrix';
const ctx = document.getElementById(canvasId);
if (!ctx) return;
const players = position === 'wr' ?
Object.values(window.aggregatedWRs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50) :
Object.values(window.aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);
const teamTotals = {};
Object.values(allPlayers).forEach(p => {
if (!teamTotals[p.team]) teamTotals[p.team] = 0;
teamTotals[p.team] += p.totalPoints;
});
const data = players.map(player => ({
x: player.latestWeekOppShare,
y: teamTotals[player.team] || 0,
label: player.name,
player: player
}));
const xValues = data.map(d => d.x).sort((a, b) => a - b);
const yValues = data.map(d => d.y).sort((a, b) => a - b);
const medianX = xValues[Math.floor(xValues.length / 2)];
const medianY = yValues[Math.floor(yValues.length / 2)];
const chartVar = position === 'wr' ? 'wrShareMatrix' : 'rbShareMatrix';
if (window[chartVar]) window[chartVar].destroy();
window[chartVar] = new Chart(ctx, {
type: 'scatter',
data: {
datasets: [{
data: data,
backgroundColor: data.map(d => {
const color = teamColors[d.player.team] || '#666';
const r = parseInt(color.slice(1, 3), 16);
const g = parseInt(color.slice(3, 5), 16);
const b = parseInt(color.slice(5, 7), 16);
return `rgba(${r}, ${g}, ${b}, 0.6)`;
}),
borderColor: data.map(d => teamColors[d.player.team] || '#666'),
borderWidth: 2,
pointRadius: 8,
pointHoverRadius: 10
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
onClick: (event, elements) => {
if (elements.length > 0) {
openPlayerModal(data[elements[0].index].player.id);
}
},
plugins: {
legend: { display: false },
tooltip: {
callbacks: {
label: (context) => {
const p = context.raw.player;
return [p.name, `Share: ${context.parsed.x.toFixed(1)}%`, `Team Total: ${context.parsed.y.toFixed(0)}`, `AVG: ${p.avgPoints.toFixed(1)}`];
}
}
},
annotation: {
annotations: {
vLine: {
type: 'line',
xMin: medianX,
xMax: medianX,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
},
hLine: {
type: 'line',
yMin: medianY,
yMax: medianY,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
},
topRight: {
type: 'label',
xValue: Math.max(...xValues) * 0.9,
yValue: Math.max(...yValues) * 0.9,
content: [position === 'rb' ? 'Elite RB1' : ''],
color: '#30d158',
font: { size: 9, weight: 'bold' }
},
topLeft: {
type: 'label',
xValue: Math.min(...xValues) * 1.1,
yValue: Math.max(...yValues) * 0.9,
content: [position === 'wr' ? 'Big piece of small pie' : 'Good offense low share'],
color: position === 'wr' ? '#FFD60A' : '#0a84ff',
font: { size: 9, weight: 'bold' }
},
bottomRight: {
type: 'label',
xValue: Math.max(...xValues) * 0.9,
yValue: Math.min(...yValues) * 1.1,
content: [position === 'wr' ? 'Small piece of big pie' : 'Bellcow, bad offense'],
color: position === 'wr' ? '#0a84ff' : '#FFD60A',
font: { size: 9, weight: 'bold' }
},
bottomLeft: {
type: 'label',
xValue: Math.min(...xValues) * 1.1,
yValue: Math.min(...yValues) * 1.1,
content: [position === 'wr' ? 'Limited role on bad offense' : 'Avoid'],
color: '#ff453a',
font: { size: 9, weight: 'bold' }
}
}
}
},
scales: {
x: {
title: { display: true, text: 'Opportunity Share % â†’', color: '#8e8e93', font: { weight: 'bold' } },
grid: { color: '#2c2c2e', lineWidth: function(context) {
return Math.abs(context.tick.value - medianX) < 1 ? 2 : 1;
}},
ticks: { color: '#8e8e93' }
},
y: {
title: { display: true, text: 'Team Total Points â†’', color: '#8e8e93', font: { weight: 'bold' } },
grid: { color: '#2c2c2e', lineWidth: function(context) {
return Math.abs(context.tick.value - medianY) < 1 ? 2 : 1;
}},
ticks: { color: '#8e8e93' }
}
}
}
});
}
function renderFloorMatrix(position) {
const canvasId = position === 'wr' ? 'wr-floor-matrix' : 'rb-floor-matrix';
const ctx = document.getElementById(canvasId);
if (!ctx) return;
const players = position === 'wr' ?
Object.values(window.aggregatedWRs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50) :
Object.values(window.aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);
const data = players.map(player => {
const variances = player.weeks.map(w => w.variance);
const stdDev = Math.sqrt(variances.reduce((sum, v) => sum + Math.pow(v, 2), 0) / variances.length);
const consistency = 10 / (stdDev + 1); // Higher is more consistent
return {
x: player.avgPoints,
y: consistency,
label: player.name,
player: player,
stdDev: stdDev
};
});
const xValues = data.map(d => d.x).sort((a, b) => a - b);
const yValues = data.map(d => d.y).sort((a, b) => a - b);
const medianX = xValues[Math.floor(xValues.length / 2)];
const medianY = yValues[Math.floor(yValues.length / 2)];
const chartVar = position === 'wr' ? 'wrFloorMatrix' : 'rbFloorMatrix';
if (window[chartVar]) window[chartVar].destroy();
window[chartVar] = new Chart(ctx, {
type: 'scatter',
data: {
datasets: [{
data: data,
backgroundColor: data.map(d => {
const color = teamColors[d.player.team] || '#666';
const r = parseInt(color.slice(1, 3), 16);
const g = parseInt(color.slice(3, 5), 16);
const b = parseInt(color.slice(5, 7), 16);
return `rgba(${r}, ${g}, ${b}, 0.6)`;
}),
borderColor: data.map(d => teamColors[d.player.team] || '#666'),
borderWidth: 2,
pointRadius: 8,
pointHoverRadius: 10
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
onClick: (event, elements) => {
if (elements.length > 0) {
openPlayerModal(data[elements[0].index].player.id);
}
},
plugins: {
legend: { display: false },
tooltip: {
callbacks: {
label: (context) => {
const d = data[context.dataIndex];
return [d.player.name, `Ceiling: ${context.parsed.x.toFixed(1)}`, `Floor Score: ${context.parsed.y.toFixed(1)}`, `Std Dev: ${d.stdDev.toFixed(2)}`];
}
}
},
annotation: {
annotations: {
vLine: {
type: 'line',
xMin: medianX,
xMax: medianX,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
},
hLine: {
type: 'line',
yMin: medianY,
yMax: medianY,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
}
}
}
},
scales: {
x: {
title: { display: true, text: 'Average Points (Ceiling) â†’', color: '#8e8e93', font: { weight: 'bold' } },
grid: { color: '#2c2c2e', lineWidth: function(context) {
return Math.abs(context.tick.value - medianX) < 1 ? 2 : 1;
}},
ticks: { color: '#8e8e93' }
},
y: {
title: { display: true, text: 'Consistency Score (Floor) â†’', color: '#8e8e93', font: { weight: 'bold' } },
grid: { color: '#2c2c2e', lineWidth: function(context) {
return Math.abs(context.tick.value - medianY) < 0.1 ? 2 : 1;
}},
ticks: { color: '#8e8e93' }
}
}
}
});
}
function renderRedzoneMatrix(position) {
const canvasId = position === 'wr' ? 'wr-redzone-matrix' : 'rb-redzone-matrix';
const ctx = document.getElementById(canvasId);
if (!ctx) return;
const players = position === 'wr' ?
Object.values(window.aggregatedWRs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50) :
Object.values(window.aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);
const data = players.map(player => {
let xValue, yValue;
if (position === 'wr') {
xValue = player.totalTargets;
yValue = player.rzOpportunities;
} else {
xValue = player.rzOpportunities / player.gamesPlayed; // RZ opps per game
yValue = player.avgPoints / player.gamesPlayed; // Points per game
}
return {
x: xValue,
y: yValue,
label: player.name,
player: player
};
});
const xValues = data.map(d => d.x).sort((a, b) => a - b);
const yValues = data.map(d => d.y).sort((a, b) => a - b);
const medianX = xValues[Math.floor(xValues.length / 2)];
const medianY = yValues[Math.floor(yValues.length / 2)];
const chartVar = position === 'wr' ? 'wrRedzoneMatrix' : 'rbRedzoneMatrix';
if (window[chartVar]) window[chartVar].destroy();
window[chartVar] = new Chart(ctx, {
type: 'scatter',
data: {
datasets: [{
data: data,
backgroundColor: data.map(d => {
const color = teamColors[d.player.team] || '#666';
const r = parseInt(color.slice(1, 3), 16);
const g = parseInt(color.slice(3, 5), 16);
const b = parseInt(color.slice(5, 7), 16);
return `rgba(${r}, ${g}, ${b}, 0.6)`;
}),
borderColor: data.map(d => teamColors[d.player.team] || '#666'),
borderWidth: 2,
pointRadius: 8,
pointHoverRadius: 10
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
onClick: (event, elements) => {
if (elements.length > 0) {
openPlayerModal(data[elements[0].index].player.id);
}
},
plugins: {
legend: { display: false },
tooltip: {
callbacks: {
label: (context) => {
const p = context.raw.player;
if (position === 'wr') {
return [p.name, `Total Targets: ${context.parsed.x}`, `RZ Targets: ${context.parsed.y}`, `AVG: ${p.avgPoints.toFixed(1)}`];
} else {
return [p.name, `RZ/Game: ${context.parsed.x.toFixed(1)}`, `PPG: ${context.parsed.y.toFixed(1)}`, `Total RZ: ${p.rzOpportunities}`];
}
}
}
},
annotation: {
annotations: {
vLine: {
type: 'line',
xMin: medianX,
xMax: medianX,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
},
hLine: {
type: 'line',
yMin: medianY,
yMax: medianY,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
},
topRight: {
type: 'label',
xValue: Math.max(...xValues) * 0.9,
yValue: Math.max(...yValues) * 0.9,
content: ['Elite RZ usage'],
color: '#30d158',
font: { size: 13, weight: 'bold' }
},
topLeft: {
type: 'label',
xValue: Math.min(...xValues) * 1.2,
yValue: Math.max(...yValues) * 0.9,
content: position === 'wr' ? ['High scoring low RZ'] : ['Efficient but no RZ'],
color: '#0a84ff',
font: { size: 13, weight: 'bold' }
},
bottomRight: {
type: 'label',
xValue: Math.max(...xValues) * 0.9,
yValue: Math.min(...yValues) + (Math.max(...yValues) - Math.min(...yValues)) * 0.15,
content: position === 'rb' ? ['Buy low candidates'] : [''],
color: '#FFD60A',
font: { size: 13, weight: 'bold' }
},
bottomLeft: {
type: 'label',
xValue: Math.min(...xValues) * 1.2,
yValue: Math.min(...yValues) + (Math.max(...yValues) - Math.min(...yValues)) * 0.15,
content: ['Low production'],
color: '#ff453a',
font: { size: 13, weight: 'bold' }
}
}
}
},
scales: {
x: {
title: {
display: true,
text: position === 'wr' ? 'Total Targets â†’' : 'Red Zone Opportunities per Game â†’',
color: '#8e8e93',
font: { weight: 'bold' }
},
grid: { color: '#2c2c2e', lineWidth: function(context) {
return Math.abs(context.tick.value - medianX) < 0.1 ? 2 : 1;
}},
ticks: { color: '#8e8e93' }
},
y: {
title: {
display: true,
text: position === 'wr' ? 'Red Zone Targets â†’' : 'Total Fantasy Points per Game â†’',
color: '#8e8e93',
font: { weight: 'bold' }
},
grid: { color: '#2c2c2e', lineWidth: function(context) {
return Math.abs(context.tick.value - medianY) < 1 ? 2 : 1;
}},
ticks: { color: '#8e8e93' }
}
}
}
});
}
function renderVolumeMonsterMatrix() {
const ctx = document.getElementById('wr-volume-monster-matrix');
if (!ctx) return;
const wrs = Object.values(window.aggregatedWRs)
.filter(p => p.gamesPlayed >= 3)
.sort((a, b) => b.avgPoints - a.avgPoints)
.slice(0, 50);
const data = wrs.map(player => ({
x: player.latestWeekOppShare,
y: player.tgtPerGame,
label: player.name,
player: player
}));
const xValues = data.map(d => d.x).sort((a, b) => a - b);
const yValues = data.map(d => d.y).sort((a, b) => a - b);
const medianX = xValues[Math.floor(xValues.length / 2)];
const medianY = yValues[Math.floor(yValues.length / 2)];
if (wrVolumeMonsterMatrix) wrVolumeMonsterMatrix.destroy();
wrVolumeMonsterMatrix = new Chart(ctx, {
type: 'scatter',
data: {
datasets: [{
data: data,
backgroundColor: data.map(d => {
const color = teamColors[d.player.team] || '#666';
const r = parseInt(color.slice(1, 3), 16);
const g = parseInt(color.slice(3, 5), 16);
const b = parseInt(color.slice(5, 7), 16);
return `rgba(${r}, ${g}, ${b}, 0.6)`;
}),
borderColor: data.map(d => teamColors[d.player.team] || '#666'),
borderWidth: 2,
pointRadius: 8,
pointHoverRadius: 10
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
onClick: (event, elements) => {
if (elements.length > 0) openPlayerModal(data[elements[0].index].player.id);
},
plugins: {
legend: { display: false },
tooltip: {
callbacks: {
label: (context) => {
const p = context.raw.player;
return [p.name, `Target Share: ${context.parsed.x.toFixed(1)}%`, `TGT/G: ${context.parsed.y.toFixed(1)}`, `AVG: ${p.avgPoints.toFixed(1)}`];
}
}
},
annotation: {
annotations: {
vLine: {
type: 'line',
xMin: medianX,
xMax: medianX,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
},
hLine: {
type: 'line',
yMin: medianY,
yMax: medianY,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
},
topRight: {
type: 'label',
xValue: Math.max(...xValues) * 0.9,
yValue: Math.max(...yValues) * 0.9,
content: ['Volume Monster'],
color: '#30d158',
font: { size: 9, weight: 'bold' }
},
topLeft: {
type: 'label',
xValue: Math.min(...xValues) * 1.1,
yValue: Math.max(...yValues) * 0.9,
content: ['High Volume, Low Share'],
color: '#0a84ff',
font: { size: 9, weight: 'bold' }
},
bottomRight: {
type: 'label',
xValue: Math.max(...xValues) * 0.9,
yValue: Math.min(...yValues) * 1.1,
content: ['Concentrated Targets'],
color: '#FFD60A',
font: { size: 9, weight: 'bold' }
},
bottomLeft: {
type: 'label',
xValue: Math.min(...xValues) * 1.1,
yValue: Math.min(...yValues) * 1.1,
content: ['Limited Role'],
color: '#ff453a',
font: { size: 9, weight: 'bold' }
}
}
}
},
scales: {
x: {
title: { display: true, text: 'Target Share % (Latest Week) â†’', color: '#8e8e93', font: { weight: 'bold' } },
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
},
y: {
title: { display: true, text: 'Targets per Game â†’', color: '#8e8e93', font: { weight: 'bold' } },
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
}
}
}
});
}
function renderCatchRateMatrix() {
const ctx = document.getElementById('wr-catch-rate-matrix');
if (!ctx) return;
const wrs = Object.values(window.aggregatedWRs)
.filter(p => p.gamesPlayed >= 3)
.sort((a, b) => b.avgPoints - a.avgPoints)
.slice(0, 50);
const data = wrs.map(player => ({
x: player.airYardsPerGame,
y: player.catchRate,
label: player.name,
player: player
}));
const xValues = data.map(d => d.x).sort((a, b) => a - b);
const yValues = data.map(d => d.y).sort((a, b) => a - b);
const medianX = xValues[Math.floor(xValues.length / 2)];
const medianY = yValues[Math.floor(yValues.length / 2)];
if (wrCatchRateMatrix) wrCatchRateMatrix.destroy();
wrCatchRateMatrix = new Chart(ctx, {
type: 'scatter',
data: {
datasets: [{
data: data,
backgroundColor: data.map(d => {
const color = teamColors[d.player.team] || '#666';
const r = parseInt(color.slice(1, 3), 16);
const g = parseInt(color.slice(3, 5), 16);
const b = parseInt(color.slice(5, 7), 16);
return `rgba(${r}, ${g}, ${b}, 0.6)`;
}),
borderColor: data.map(d => teamColors[d.player.team] || '#666'),
borderWidth: 2,
pointRadius: 8,
pointHoverRadius: 10
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
onClick: (event, elements) => {
if (elements.length > 0) openPlayerModal(data[elements[0].index].player.id);
},
plugins: {
legend: { display: false },
tooltip: {
callbacks: {
label: (context) => {
const p = context.raw.player;
return [p.name, `Air Yds/G: ${context.parsed.x.toFixed(1)}`, `Catch Rate: ${context.parsed.y.toFixed(1)}%`, `AVG: ${p.avgPoints.toFixed(1)}`];
}
}
},
annotation: {
annotations: {
vLine: {
type: 'line',
xMin: medianX,
xMax: medianX,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
},
hLine: {
type: 'line',
yMin: medianY,
yMax: medianY,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
},
topRight: {
type: 'label',
xValue: Math.max(...xValues) * 0.9,
yValue: Math.max(...yValues) * 0.9,
content: ['Deep Threats'],
color: '#30d158',
font: { size: 9, weight: 'bold' }
},
topLeft: {
type: 'label',
xValue: Math.min(...xValues) * 1.1,
yValue: Math.max(...yValues) * 0.9,
content: ['Reliable Hands'],
color: '#0a84ff',
font: { size: 9, weight: 'bold' }
},
bottomRight: {
type: 'label',
xValue: Math.max(...xValues) * 0.9,
yValue: Math.min(...yValues) * 1.1,
content: ['Contested Catches'],
color: '#FFD60A',
font: { size: 9, weight: 'bold' }
},
bottomLeft: {
type: 'label',
xValue: Math.min(...xValues) * 1.1,
yValue: Math.min(...yValues) * 1.1,
content: ['Drop Issues'],
color: '#ff453a',
font: { size: 9, weight: 'bold' }
}
}
}
},
scales: {
x: {
title: { display: true, text: 'Air Yards per Game â†’', color: '#8e8e93', font: { weight: 'bold' } },
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
},
y: {
title: { display: true, text: 'Catch Rate % â†’', color: '#8e8e93', font: { weight: 'bold' } },
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
}
}
}
});
}
function renderTalentSituationMatrix() {
const ctx = document.getElementById('rb-talent-matrix');
if (!ctx) return;
const rbs = Object.values(window.aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);
const data = rbs.map(player => {
const playerRows = rbData.filter(row => row.Team === player.team && row.Player === player.name);
let totalYBCON = 0, totalYACON = 0, totalATT = 0;
playerRows.forEach(row => {
totalYBCON += parseFloat(row.YBCON) || 0;
totalYACON += parseFloat(row.YACON) || 0;
totalATT += parseFloat(row.ATT) || 0;
});
return {
x: totalATT > 0 ? totalYBCON / totalATT : 0,
y: totalATT > 0 ? totalYACON / totalATT : 0,
label: player.name,
player: player
};
});
const xValues = data.map(d => d.x).sort((a, b) => a - b);
const yValues = data.map(d => d.y).sort((a, b) => a - b);
const medianX = xValues[Math.floor(xValues.length / 2)];
const medianY = yValues[Math.floor(yValues.length / 2)];
if (rbTalentMatrix) rbTalentMatrix.destroy();
rbTalentMatrix = new Chart(ctx, {
type: 'scatter',
data: {
datasets: [{
data: data,
backgroundColor: data.map(d => {
const color = teamColors[d.player.team] || '#666';
const r = parseInt(color.slice(1, 3), 16);
const g = parseInt(color.slice(3, 5), 16);
const b = parseInt(color.slice(5, 7), 16);
return `rgba(${r}, ${g}, ${b}, 0.6)`;
}),
borderColor: data.map(d => teamColors[d.player.team] || '#666'),
borderWidth: 2,
pointRadius: 8,
pointHoverRadius: 10
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
onClick: (event, elements) => {
if (elements.length > 0) openPlayerModal(data[elements[0].index].player.id);
},
plugins: {
legend: { display: false },
tooltip: {
mode: 'point',
intersect: true,
callbacks: {
label: (context) => {
const p = context.raw.player;
return [p.name, `YBCON/ATT: ${context.parsed.x.toFixed(2)}`, `YACON/ATT: ${context.parsed.y.toFixed(2)}`, `AVG: ${p.avgPoints.toFixed(1)}`];
}
}
}
},
scales: {
x: {
title: { display: true, text: 'Yards Before Contact per Attempt (O-Line Quality) â†’', color: '#8e8e93' },
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
},
y: {
title: { display: true, text: 'Yards After Contact per Attempt (RB Talent) â†’', color: '#8e8e93' },
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
}
}
},
plugins: [{
id: 'quadrantLabels',
afterDraw: (chart) => {
const ctx = chart.ctx;
const chartArea = chart.chartArea;
const xAxis = chart.scales.x;
const yAxis = chart.scales.y;
const xMid = xAxis.getPixelForValue(medianX);
const yMid = yAxis.getPixelForValue(medianY);
ctx.strokeStyle = '#8e8e93';
ctx.setLineDash([5, 5]);
ctx.lineWidth = 2;
ctx.beginPath();
ctx.moveTo(xMid, chartArea.top);
ctx.lineTo(xMid, chartArea.bottom);
ctx.moveTo(chartArea.left, yMid);
ctx.lineTo(chartArea.right, yMid);
ctx.stroke();
ctx.setLineDash([]);
ctx.font = 'bold 9px -apple-system, BlinkMacSystemFont, sans-serif';
ctx.fillStyle = '#30d158';
ctx.textAlign = 'right';
ctx.textBaseline = 'top';
ctx.fillText('Elite', chartArea.right - 5, chartArea.top + 5);
ctx.fillStyle = '#0a84ff';
ctx.textAlign = 'left';
ctx.textBaseline = 'top';
ctx.fillText('Elite Talent', chartArea.left + 5, chartArea.top + 5);
ctx.fillStyle = '#FFD60A';
ctx.textAlign = 'right';
ctx.textBaseline = 'bottom';
ctx.fillText('Elite Situation', chartArea.right - 5, chartArea.bottom - 5);
ctx.fillStyle = '#ff453a';
ctx.textAlign = 'left';
ctx.textBaseline = 'bottom';
ctx.fillText('Avoid', chartArea.left + 5, chartArea.bottom - 5);
}
}]
});
}
function renderOpportunityEfficiencyMatrix() {
const ctx = document.getElementById('rb-opportunity-matrix');
if (!ctx) return;
const rbs = Object.values(window.aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);
const data = rbs.map(player => {
const playerRows = rbData.filter(row => row.Team === player.team && row.Player === player.name);
let totalYACON = 0, totalATT = 0;
playerRows.forEach(row => {
totalYACON += parseFloat(row.YACON) || 0;
totalATT += parseFloat(row.ATT) || 0;
});
return {
x: player.latestWeekOppShare,
y: totalATT > 0 ? totalYACON / totalATT : 0,
label: player.name,
player: player
};
});
const xValues = data.map(d => d.x).sort((a, b) => a - b);
const yValues = data.map(d => d.y).sort((a, b) => a - b);
const medianX = xValues[Math.floor(xValues.length / 2)];
const medianY = yValues[Math.floor(yValues.length / 2)];
if (rbOpportunityMatrix) rbOpportunityMatrix.destroy();
rbOpportunityMatrix = new Chart(ctx, {
type: 'scatter',
data: {
datasets: [{
data: data,
backgroundColor: data.map(d => {
const color = teamColors[d.player.team] || '#666';
const r = parseInt(color.slice(1, 3), 16);
const g = parseInt(color.slice(3, 5), 16);
const b = parseInt(color.slice(5, 7), 16);
return `rgba(${r}, ${g}, ${b}, 0.6)`;
}),
borderColor: data.map(d => teamColors[d.player.team] || '#666'),
borderWidth: 2,
pointRadius: 8,
pointHoverRadius: 10
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
onClick: (event, elements) => {
if (elements.length > 0) openPlayerModal(data[elements[0].index].player.id);
},
plugins: {
legend: { display: false },
tooltip: {
callbacks: {
label: (context) => {
const p = context.raw.player;
return [p.name, `Touch Share: ${context.parsed.x.toFixed(1)}%`, `YAC/ATT: ${context.parsed.y.toFixed(2)}`, `AVG: ${p.avgPoints.toFixed(1)}`];
}
}
}
},
scales: {
x: {
title: { display: true, text: 'Touch Share % â†’', color: '#8e8e93' },
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
},
y: {
title: { display: true, text: 'Yards After Contact per Attempt â†’', color: '#8e8e93' },
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
}
}
},
plugins: [{
id: 'quadrantLabels',
afterDraw: (chart) => {
const ctx = chart.ctx;
const chartArea = chart.chartArea;
const xAxis = chart.scales.x;
const yAxis = chart.scales.y;
const xMid = xAxis.getPixelForValue(medianX);
const yMid = yAxis.getPixelForValue(medianY);
ctx.strokeStyle = '#8e8e93';
ctx.setLineDash([5, 5]);
ctx.lineWidth = 2;
ctx.beginPath();
ctx.moveTo(xMid, chartArea.top);
ctx.lineTo(xMid, chartArea.bottom);
ctx.moveTo(chartArea.left, yMid);
ctx.lineTo(chartArea.right, yMid);
ctx.stroke();
ctx.setLineDash([]);
ctx.font = 'bold 9px -apple-system, BlinkMacSystemFont, sans-serif';
ctx.fillStyle = '#30d158';
ctx.textAlign = 'right';
ctx.textBaseline = 'top';
ctx.fillText('Elite', chartArea.right - 5, chartArea.top + 5);
ctx.fillStyle = '#0a84ff';
ctx.textAlign = 'left';
ctx.textBaseline = 'top';
ctx.fillText('Inefficient', chartArea.left + 5, chartArea.top + 5);
ctx.fillStyle = '#FFD60A';
ctx.textAlign = 'right';
ctx.textBaseline = 'bottom';
ctx.fillText('Boom-Bust', chartArea.right - 5, chartArea.bottom - 5);
ctx.fillStyle = '#ff453a';
ctx.textAlign = 'left';
ctx.textBaseline = 'bottom';
ctx.fillText('Fade', chartArea.left + 5, chartArea.bottom - 5);
}
}]
});
}
function renderWRScatter() {
const ctx = document.getElementById('wr-scatter-chart');
if (!ctx) return;
const wrs = Object.values(window.aggregatedWRs)
.sort((a, b) => b.avgPoints - a.avgPoints)
.slice(0, 50);
const data = wrs.map(player => ({
x: player.totalTargets,
y: player.rzOpportunities,
label: player.name,
player: player
}));
const regression = calculateLinearRegression(data);
const minX = Math.min(...data.map(d => d.x));
const maxX = Math.max(...data.map(d => d.x));
const trendlineData = [
{ x: minX, y: regression.slope * minX + regression.intercept },
{ x: maxX, y: regression.slope * maxX + regression.intercept }
];
if (wrScatterChart) {
wrScatterChart.destroy();
}
wrScatterChart = new Chart(ctx, {
type: 'scatter',
data: {
datasets: [
{
label: 'Wide Receivers',
data: data,
backgroundColor: data.map(d => {
const color = teamColors[d.player.team] || '#666';
const r = parseInt(color.slice(1, 3), 16);
const g = parseInt(color.slice(3, 5), 16);
const b = parseInt(color.slice(5, 7), 16);
return `rgba(${r}, ${g}, ${b}, 0.6)`;
}),
borderColor: data.map(d => teamColors[d.player.team] || '#666'),
borderWidth: 2,
pointRadius: 8,
pointHoverRadius: 10
},
{
label: 'Trendline',
type: 'line',
data: trendlineData,
borderColor: '#FFD60A',
borderWidth: 2,
borderDash: [5, 5],
pointRadius: 0,
fill: false
}
]
},
options: {
responsive: true,
maintainAspectRatio: false,
onClick: (event, elements) => {
if (elements.length > 0 && elements[0].datasetIndex === 0) {
const index = elements[0].index;
const player = data[index].player;
openPlayerModal(player.id);
}
},
plugins: {
legend: { display: false },
tooltip: {
callbacks: {
label: function(context) {
if (context.datasetIndex === 1) return 'Trendline';
const player = context.raw.player;
return [
player.name,
`Targets: ${player.totalTargets}`,
`RZ Targets: ${player.rzOpportunities}`,
`AVG: ${player.avgPoints.toFixed(1)}`
];
}
}
}
},
scales: {
x: {
title: {
display: true,
text: 'Total Season Targets',
color: '#8e8e93'
},
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
},
y: {
title: {
display: true,
text: 'Red Zone Targets',
color: '#8e8e93'
},
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
}
}
}
});
const chartArea = wrScatterChart.chartArea;
const ctx2d = wrScatterChart.ctx;
wrs.slice(0, 8).forEach((player, idx) => {
const meta = wrScatterChart.getDatasetMeta(0);
const point = meta.data[idx];
if (point && chartArea) {
ctx2d.save();
ctx2d.fillStyle = '#fff';
ctx2d.font = '11px -apple-system, sans-serif';
ctx2d.textAlign = 'center';
ctx2d.fillText(player.name.split(' ').pop(), point.x, point.y - 12);
ctx2d.restore();
}
});
}
function renderRBScatter() {
const ctx = document.getElementById('rb-scatter-chart');
if (!ctx) return;
const rbs = Object.values(window.aggregatedRBs)
.sort((a, b) => b.avgPoints - a.avgPoints)
.slice(0, 50);
const data = rbs.map(player => ({
x: player.totalOpportunities,
y: player.rzOpportunities,
label: player.name,
player: player
}));
const regression = calculateLinearRegression(data);
const minX = Math.min(...data.map(d => d.x));
const maxX = Math.max(...data.map(d => d.x));
const trendlineData = [
{ x: minX, y: regression.slope * minX + regression.intercept },
{ x: maxX, y: regression.slope * maxX + regression.intercept }
];
if (rbScatterChart) {
rbScatterChart.destroy();
}
rbScatterChart = new Chart(ctx, {
type: 'scatter',
data: {
datasets: [
{
label: 'Running Backs',
data: data,
backgroundColor: data.map(d => {
const color = teamColors[d.player.team] || '#666';
const r = parseInt(color.slice(1, 3), 16);
const g = parseInt(color.slice(3, 5), 16);
const b = parseInt(color.slice(5, 7), 16);
return `rgba(${r}, ${g}, ${b}, 0.6)`;
}),
borderColor: data.map(d => teamColors[d.player.team] || '#666'),
borderWidth: 2,
pointRadius: 8,
pointHoverRadius: 10
},
{
label: 'Trendline',
type: 'line',
data: trendlineData,
borderColor: '#FFD60A',
borderWidth: 2,
borderDash: [5, 5],
pointRadius: 0,
fill: false
}
]
},
options: {
responsive: true,
maintainAspectRatio: false,
onClick: (event, elements) => {
if (elements.length > 0 && elements[0].datasetIndex === 0) {
const index = elements[0].index;
const player = data[index].player;
openPlayerModal(player.id);
}
},
plugins: {
legend: { display: false },
tooltip: {
callbacks: {
label: function(context) {
if (context.datasetIndex === 1) return 'Trendline';
const player = context.raw.player;
return [
player.name,
`Opportunities: ${player.totalOpportunities}`,
`RZ Opportunities: ${player.rzOpportunities}`,
`AVG: ${player.avgPoints.toFixed(1)}`
];
}
}
}
},
scales: {
x: {
title: {
display: true,
text: 'Total Season Opportunities',
color: '#8e8e93'
},
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
},
y: {
title: {
display: true,
text: 'Red Zone Opportunities',
color: '#8e8e93'
},
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
}
}
}
});
const chartArea = rbScatterChart.chartArea;
const ctx2d = rbScatterChart.ctx;
rbs.slice(0, 8).forEach((player, idx) => {
const meta = rbScatterChart.getDatasetMeta(0);
const point = meta.data[idx];
if (point && chartArea) {
ctx2d.save();
ctx2d.fillStyle = '#fff';
ctx2d.font = '11px -apple-system, sans-serif';
ctx2d.textAlign = 'center';
ctx2d.fillText(player.name.split(' ').pop(), point.x, point.y - 12);
ctx2d.restore();
}
});
}
function renderTeamBalanceScatter(highlightTeam = null) {
const ctx = document.getElementById('team-balance-scatter');
if (!ctx) { return;
}
if (!wrData || !rbData) { return;
}
const existingChart = Chart.getChart(ctx);
if (existingChart) {
existingChart.destroy();
}
const teamData = {};
wrData.forEach(row => {
const team = row.Team;
if (team === 'FA' || !team) return;
if (!teamData[team]) {
teamData[team] = { team: team, targets: 0, rushOpps: 0, totalPoints: 0 };
}
teamData[team].targets += parseFloat(row.TGT) || 0;
teamData[team].totalPoints += parseFloat(row.FPTS || row.Fpts) || 0; // Handle both cases
});
rbData.forEach(row => {
const team = row.Team;
if (team === 'FA' || !team) return;
if (!teamData[team]) {
teamData[team] = { team: team, targets: 0, rushOpps: 0, totalPoints: 0 };
}
teamData[team].rushOpps += parseFloat(row['RB Opp']) || 0;
teamData[team].totalPoints += parseFloat(row.FPTS || row.Fpts) || 0; // Handle both cases
});
if (teData) {
teData.forEach(row => {
const team = row.Team;
if (team === 'FA' || !team) return;
if (!teamData[team]) {
teamData[team] = { team: team, targets: 0, rushOpps: 0, totalPoints: 0 };
}
teamData[team].targets += parseFloat(row.TGT) || 0;
teamData[team].totalPoints += parseFloat(row.FPTS || row.Fpts) || 0; // Handle both cases
});
}
const teams = Object.values(teamData);
const allPoints = teams.map(t => t.totalPoints);
const minPoints = Math.min(...allPoints);
const maxPoints = Math.max(...allPoints);
const scatterData = teams.map(team => {
const normalizedPoints = (team.totalPoints - minPoints) / (maxPoints - minPoints);
const radius = 8 + (normalizedPoints * 12); // Range: 8-20
return {
x: team.targets,
y: team.rushOpps,
r: radius, // For bubble chart
team: team.team,
totalPoints: team.totalPoints
};
});
const sortedTargets = teams.map(t => t.targets).sort((a, b) => a - b);
const sortedOpps = teams.map(t => t.rushOpps).sort((a, b) => a - b);
const medianTargets = sortedTargets[Math.floor(sortedTargets.length / 2)];
const medianOpps = sortedOpps[Math.floor(sortedOpps.length / 2)];
let datasets = [];
if (highlightTeam) {
const regularData = scatterData.filter(d => d.team !== highlightTeam);
const highlightedData = scatterData.filter(d => d.team === highlightTeam);
datasets.push({
data: regularData,
backgroundColor: regularData.map(d => {
const color = teamColors[d.team] || '#0a84ff';
return color + '66'; // 40% opacity for non-highlighted
}),
borderColor: regularData.map(d => {
const color = teamColors[d.team] || '#0a84ff';
return color + '99'; // 60% opacity for border
}),
borderWidth: 2
});
if (highlightedData.length > 0) {
const highlightColor = teamColors[highlightTeam] || '#0a84ff';
datasets.push({
data: highlightedData,
backgroundColor: highlightColor,
borderColor: '#ffffff',
borderWidth: 4,
pointRadius: highlightedData.map(d => d.r * 1.3), // 30% larger
pointHoverRadius: highlightedData.map(d => d.r * 1.5)
});
}
} else {
datasets.push({
data: scatterData,
backgroundColor: scatterData.map(d => {
const color = teamColors[d.team] || '#0a84ff';
return color + '99'; // 60% opacity
}),
borderColor: scatterData.map(d => teamColors[d.team] || '#0a84ff'),
borderWidth: 2
});
}
// Team Labels Plugin (similar to Advanced Analytics)
const teamLabelsPlugin = {
id: 'teamLabels',
afterDatasetsDraw(chart) {
const ctx = chart.ctx;
const allPoints = [];
chart.data.datasets.forEach((dataset, datasetIndex) => {
const datasetMeta = chart.getDatasetMeta(datasetIndex);
if (!datasetMeta || !datasetMeta.data) return;
datasetMeta.data.forEach((point, index) => {
const dataPoint = dataset.data[index];
if (!dataPoint || !dataPoint.team) return;
allPoints.push({
x: point.x,
y: point.y,
dataX: dataPoint.x,
dataY: dataPoint.y,
team: dataPoint.team,
totalPoints: dataPoint.totalPoints,
teamColor: teamColors[dataPoint.team] || '#0a84ff',
isHighlighted: highlightTeam && dataPoint.team === highlightTeam
});
});
});
// Sort by total points and distance from center
const pointsWithPriority = allPoints.map(p => ({
...p
})).sort((a, b) => {
// Prioritize highlighted team
if (a.isHighlighted) return -1;
if (b.isHighlighted) return 1;
// Then sort by distance from center for non-highlighted
const centerX = (chart.scales.x.min + chart.scales.x.max) / 2;
const centerY = (chart.scales.y.min + chart.scales.y.max) / 2;
const distA = Math.sqrt(Math.pow(a.dataX - centerX, 2) + Math.pow(a.dataY - centerY, 2));
const distB = Math.sqrt(Math.pow(b.dataX - centerX, 2) + Math.pow(b.dataY - centerY, 2));
return distB - distA;
});
const maxLabels = window.innerWidth <= 768 ? 8 : 12;
const minSpacing = 40;
const labelPadding = 5;
const lineLength = 14;
const labelBounds = [];
const wouldCollide = (x, y, width, height) => {
for (const bounds of labelBounds) {
if (!(x + width + minSpacing < bounds.x ||
x - minSpacing > bounds.x + bounds.width ||
y + height + minSpacing < bounds.y ||
y - minSpacing > bounds.y + bounds.height)) {
return true;
}
}
return false;
};
ctx.save();
let labelsDrawn = 0;
for (const point of pointsWithPriority) {
if (labelsDrawn >= maxLabels) break;
const teamAbbr = point.team;
ctx.font = window.innerWidth <= 768 ? '500 10px sans-serif' : '600 11px sans-serif';
const textWidth = ctx.measureText(teamAbbr).width;
const textHeight = 14;
const labelX = point.x + lineLength + 2;
const labelY = point.y;
if (!wouldCollide(labelX - labelPadding, labelY - textHeight/2 - labelPadding,
textWidth + labelPadding * 2, textHeight + labelPadding * 2)) {
// Draw connecting line
ctx.strokeStyle = 'rgba(200, 200, 200, 0.25)';
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(point.x + 10, point.y);
ctx.lineTo(point.x + lineLength, point.y);
ctx.stroke();
// Parse team color
let r = 10, g = 132, b = 255;
if (point.teamColor.startsWith('#')) {
r = parseInt(point.teamColor.slice(1, 3), 16);
g = parseInt(point.teamColor.slice(3, 5), 16);
b = parseInt(point.teamColor.slice(5, 7), 16);
}
// Draw label background
ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.3)`;
ctx.shadowBlur = 12;
const gradient = ctx.createLinearGradient(
labelX - labelPadding,
labelY - textHeight/2 - labelPadding,
labelX + textWidth + labelPadding,
labelY + textHeight/2 + labelPadding
);
gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.18)`);
gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0.12)`);
ctx.fillStyle = gradient;
ctx.fillRect(
labelX - labelPadding,
labelY - textHeight/2 - labelPadding,
textWidth + labelPadding * 2,
textHeight + labelPadding * 2
);
ctx.shadowBlur = 0;
// Draw border
ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.35)`;
ctx.lineWidth = 1;
ctx.strokeRect(
labelX - labelPadding,
labelY - textHeight/2 - labelPadding,
textWidth + labelPadding * 2,
textHeight + labelPadding * 2
);
// Draw text
ctx.fillStyle = '#fff';
ctx.textAlign = 'left';
ctx.textBaseline = 'middle';
ctx.fillText(teamAbbr, labelX, labelY);
labelBounds.push({
x: labelX - labelPadding,
y: labelY - textHeight/2 - labelPadding,
width: textWidth + labelPadding * 2,
height: textHeight + labelPadding * 2
});
labelsDrawn++;
}
}
ctx.restore();
}
};
new Chart(ctx, {
type: 'bubble',
data: { datasets },
plugins: [teamLabelsPlugin],
options: {
responsive: true,
maintainAspectRatio: false,
layout: {
padding: window.innerWidth <= 768
? { left: 20, right: 20, top: 30, bottom: 30 }
: { left: 50, right: 50, top: 50, bottom: 50 }
},
plugins: {
legend: { display: false },
tooltip: {
callbacks: {
label: (context) => {
const data = context.raw;
return [
data.team,
`Targets: ${data.x.toFixed(0)}`,
`Rush Opps: ${data.y.toFixed(0)}`,
`Total Points: ${data.totalPoints.toFixed(1)}`
];
}
}
},
annotation: {
annotations: {
vLine: {
type: 'line',
xMin: medianTargets,
xMax: medianTargets,
borderColor: getThemeColors().textSecondary,
borderWidth: 2,
borderDash: [5, 5]
},
hLine: {
type: 'line',
yMin: medianOpps,
yMax: medianOpps,
borderColor: getThemeColors().textSecondary,
borderWidth: 2,
borderDash: [5, 5]
}
}
},
zoom: {
pan: {
enabled: window.innerWidth <= 768, // Enable pan on mobile only
mode: 'xy',
modifierKey: null
},
zoom: {
wheel: {
enabled: false // Disable wheel zoom
},
pinch: {
enabled: window.innerWidth <= 768 // Enable pinch zoom on mobile only
},
mode: 'xy'
}
}
},
scales: {
x: {
title: {
display: true,
text: 'Total Pass Targets',
color: getThemeColors().textSecondary,
font: {
size: window.innerWidth <= 768 ? 10 : 12,
weight: 'bold'
}
},
grid: { color: getThemeColors().grid },
ticks: {
color: getThemeColors().textSecondary,
font: { size: window.innerWidth <= 768 ? 9 : 11 }
}
},
y: {
title: {
display: true,
text: 'Total Rush Opportunities',
color: getThemeColors().textSecondary,
font: {
size: window.innerWidth <= 768 ? 10 : 12,
weight: 'bold'
}
},
grid: { color: getThemeColors().grid },
ticks: {
color: getThemeColors().textSecondary,
font: { size: window.innerWidth <= 768 ? 9 : 11 }
}
}
},
onClick: (event, elements) => {
if (elements.length > 0) {
const element = elements[0];
const datasetIndex = element.datasetIndex;
const dataIndex = element.index;
const clickedData = datasets[datasetIndex].data[dataIndex];
const teamCode = clickedData.team;
openTeamModal(teamCode);
}
}
}
});
}
function generateTeamColorVariations(team, count) {
const primaryColor = teamColors[team];
if (!primaryColor) {
return Array.from({length: count}, (_, i) => {
const lightness = 50 + (i * (50 / count));
return `hsl(0, 0%, ${lightness}%)`;
});
}
// Helper to convert hex to HSL
function hexToHSL(hex) {
hex = hex.replace('#', '');
const r = parseInt(hex.substr(0, 2), 16) / 255;
const g = parseInt(hex.substr(2, 2), 16) / 255;
const b = parseInt(hex.substr(4, 2), 16) / 255;
const max = Math.max(r, g, b);
const min = Math.min(r, g, b);
let h, s, l = (max + min) / 2;
if (max === min) {
h = s = 0;
} else {
const d = max - min;
s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
switch (max) {
case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
case g: h = ((b - r) / d + 2) / 6; break;
case b: h = ((r - g) / d + 4) / 6; break;
}
}
return [h * 360, s * 100, l * 100];
}
const [h, s, l] = hexToHSL(primaryColor);
// Generate variations using only the primary color with different lightness
// Make them brighter and more vibrant
const colors = [];
for (let i = 0; i < count; i++) {
// Start at 60% lightness for darkest, go up to 85% for lightest
// This creates a nice gradient from the primary color
const lightnessValue = 60 + (i * (25 / Math.max(1, count - 1)));
// Keep saturation high for vibrancy (boost it by 10% if it's low)
const saturationValue = Math.min(100, s + 10);
colors.push(`hsl(${h}, ${saturationValue}%, ${lightnessValue}%)`);
}
return colors;
}
function initializeTeamAnalysis() {
if (!wrData || !rbData) return;
const teams = [...new Set([...wrData, ...rbData].map(row => row.Team).filter(t => t && t !== 'FA'))].sort();
console.log('[Team Outlook Debug] All teams in data:', teams);
console.log('[Team Outlook Debug] RB teams:', [...new Set(rbData.map(row => row.Team).filter(t => t && t !== 'FA'))].sort());
const teamSelect = document.getElementById('team-select');
teamSelect.innerHTML = '';
const placeholderOption = document.createElement('option');
placeholderOption.value = '';
placeholderOption.textContent = '(Select a Team)';
placeholderOption.selected = true;
teamSelect.appendChild(placeholderOption);
teams.forEach(team => {
const option = document.createElement('option');
option.value = team;
option.textContent = team;
teamSelect.appendChild(option);
});
currentTeamAnalysisTeam = null;
const weeks = [...new Set([...wrData, ...rbData].map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);
const weekSelect = document.getElementById('week-select');
weekSelect.innerHTML = '';
weeks.forEach(week => {
const option = document.createElement('option');
option.value = week;
option.textContent = `Week ${week}`;
weekSelect.appendChild(option);
});
if (weeks.length > 0) {
weekSelect.value = weeks[weeks.length - 1];
}
leagueComparisonEnabled = true;
const toggleBtn = document.getElementById('league-comparison-toggle');
const icon = document.getElementById('league-comparison-icon');
toggleBtn.style.background = 'var(--positive)';
toggleBtn.style.borderColor = 'var(--positive)';
toggleBtn.style.color = 'white';
icon.textContent = 'â—';
updateTeamAnalysis();
}
function toggleLeagueComparison() {
leagueComparisonEnabled = !leagueComparisonEnabled;
const toggleBtn = document.getElementById('league-comparison-toggle');
const icon = document.getElementById('league-comparison-icon');
if (leagueComparisonEnabled) {
toggleBtn.style.background = 'var(--positive)';
toggleBtn.style.borderColor = 'var(--positive)';
toggleBtn.style.color = 'white';
icon.textContent = 'â—';
} else {
toggleBtn.style.background = 'var(--bg-tertiary)';
toggleBtn.style.borderColor = 'var(--border-color)';
toggleBtn.style.color = 'var(--text-secondary)';
icon.textContent = 'â—‹';
}
updateTeamAnalysis();
}
function updateTeamAnalysis() {
const team = document.getElementById('team-select').value;
const position = document.getElementById('position-group-select').value;
const timeFrame = document.getElementById('time-frame-select').value;
const week = parseInt(document.getElementById('week-select').value);
const placeholder = document.getElementById('team-chart-placeholder');
const pieChartWrapper = document.querySelector('#team-charts-container .chart-wrapper:nth-child(2)');
const secondaryChartWrapper = document.getElementById('team-secondary-chart-wrapper');
const weekContainer = document.getElementById('week-select-container');
weekContainer.style.display = timeFrame === 'single' ? 'block' : 'none';
// Show/hide RZ toggles for Season Long on main page (both WR and RB)
const mainRzToggleContainer = document.getElementById('main-rz-toggle-container');
const mainRzMetricToggle = document.getElementById('main-rz-metric-toggle');
if (mainRzToggleContainer) {
if (timeFrame === 'season') {
mainRzToggleContainer.style.display = 'flex';
} else {
mainRzToggleContainer.style.display = 'none';
if (mainRzMetricToggle) mainRzMetricToggle.style.display = 'none';
window.currentMainTeamChartMetric = 'usage'; // Reset to usage when not season long
window.currentMainRZMetric = 'pct'; // Reset to percentage
}
}
const leagueToggleBtn = document.getElementById('league-comparison-toggle');
if (timeFrame === 'season') {
leagueToggleBtn.disabled = true;
leagueToggleBtn.style.opacity = '0.4';
leagueToggleBtn.style.cursor = 'not-allowed';
} else {
leagueToggleBtn.disabled = false;
leagueToggleBtn.style.opacity = '1';
leagueToggleBtn.style.cursor = 'pointer';
}
if (!team || team === '') {
placeholder.style.display = 'flex';
pieChartWrapper.style.display = 'none';
if (leagueComparisonEnabled && timeFrame !== 'season') {
secondaryChartWrapper.style.display = 'block';
setTimeout(() => {
renderLeagueComparison(null, position, timeFrame, week, 0);
}, 50);
} else {
secondaryChartWrapper.style.display = 'none';
}
return;
}
placeholder.style.display = 'none';
pieChartWrapper.style.display = 'block';
// Only show secondary chart if not in season long mode
if (timeFrame !== 'season') {
secondaryChartWrapper.style.display = 'block';
} else {
secondaryChartWrapper.style.display = 'none';
}
currentTeamAnalysisTeam = team;
const titleEl = document.getElementById('team-chart-title');
const descEl = document.getElementById('team-chart-description');
const positionLabel = (position === 'WR' || position === 'TE') ? 'Target' : 'Opportunity';
let timeLabel = '';
if (timeFrame === 'single') {
timeLabel = `Week ${week}`;
} else if (timeFrame === 'last3') {
timeLabel = 'Last 3 Weeks';
} else if (timeFrame === 'last5') {
timeLabel = 'Last 5 Weeks';
} else {
timeLabel = 'Season Long';
}
titleEl.textContent = `${team} ${position} ${positionLabel} Distribution - ${timeLabel}`;
if (position === 'WR' || position === 'TE') {
descEl.textContent = `Showing top 4 pass catchers (WR/RB/TE) by target share - all positions compete for targets`;
} else {
descEl.textContent = `Showing RB opportunity distribution (rush attempts + targets)`;
}
setTimeout(() => {
if (timeFrame === 'season') {
renderSeasonLongChart(team, position);
} else {
renderPieAndBarCharts(team, position, timeFrame, week);
}
}, 50);
renderTeamBalanceScatter(team);
}
function renderPieAndBarCharts(team, position, timeFrame, week) {
const container = document.getElementById('team-charts-container');
container.style.gridTemplateColumns = '1fr 1fr';
document.getElementById('team-secondary-chart-wrapper').style.display = 'block';
let combinedData;
if (position === 'WR' || position === 'TE') {
combinedData = [...wrData, ...rbData];
if (teData) {
combinedData = [...combinedData, ...teData];
}
} else {
combinedData = rbData;
}
let filteredData;
if (timeFrame === 'single') {
filteredData = combinedData.filter(row => row.Team === team && parseInt(row.Week) === week);
} else {
const weeks = [...new Set(combinedData.map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);
const latestWeek = Math.max(...weeks);
const weeksToInclude = timeFrame === 'last3' ? 3 : 5;
const startWeek = latestWeek - weeksToInclude + 1;
filteredData = combinedData.filter(row => row.Team === team && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek);
}
const playerStats = {};
filteredData.forEach(row => {
const player = row.Player;
if (!playerStats[player]) {
playerStats[player] = { targets: 0, opportunities: 0, position: row.Pos };
}
if (position === 'WR' || position === 'TE') {
playerStats[player].targets += parseFloat(row.TGT) || 0;
} else {
playerStats[player].opportunities += parseFloat(row['RB Opp']) || 0;
}
});
const playerArray = Object.entries(playerStats).map(([name, stats]) => ({
name,
value: (position === 'WR' || position === 'TE') ? stats.targets : stats.opportunities,
position: stats.position
})).sort((a, b) => b.value - a.value);
const totalValue = playerArray.reduce((sum, p) => sum + p.value, 0);
const topCount = (position === 'WR' || position === 'TE') ? 4 : 5;
const topPlayers = playerArray.slice(0, topCount);
const otherValue = playerArray.slice(topCount).reduce((sum, p) => sum + p.value, 0);
let chartData = [...topPlayers];
if (otherValue > 0) {
chartData.push({ name: 'Other', value: otherValue, position: 'Other' });
}
renderTeamPieChart(chartData, totalValue, position);
if (leagueComparisonEnabled) {
renderLeagueComparison(team, position, timeFrame, week, totalValue);
} else {
renderTeamBarChart(chartData, position);
}
}
function renderTeamPieChart(chartData, totalValue, position) {
const canvas = document.getElementById('team-pie-chart');
if (!canvas) return;
const ctx = canvas.getContext('2d');
if (teamAnalysisCharts.pie) {
teamAnalysisCharts.pie.destroy();
}
const labels = chartData.map(d => d.name);
const values = chartData.map(d => d.value);
const percentages = chartData.map(d => ((d.value / totalValue) * 100).toFixed(1));
const playerCount = chartData.filter(d => d.name !== 'Other').length;
const teamColorVariations = generateTeamColorVariations(currentTeamAnalysisTeam, playerCount);
const opacity = 0.75; // Brighter, less transparent
const fillColors = chartData.map((d, i) => {
if (d.name === 'Other') return 'rgba(99, 99, 102, 0.5)';
const baseColor = teamColorVariations[i];
if (baseColor.startsWith('#')) {
const r = parseInt(baseColor.slice(1, 3), 16);
const g = parseInt(baseColor.slice(3, 5), 16);
const b = parseInt(baseColor.slice(5, 7), 16);
return `rgba(${r}, ${g}, ${b}, ${opacity})`;
} else if (baseColor.startsWith('hsl')) {
return baseColor.replace('hsl', 'hsla').replace(')', `, ${opacity})`);
}
return baseColor;
});
const borderColors = chartData.map((d, i) => {
if (d.name === 'Other') return '#636366';
return teamColorVariations[i];
});
const metric = position === 'WR' ? 'Targets' : 'Opportunities';
teamAnalysisCharts.pie = new Chart(ctx, {
type: 'pie',
data: {
labels: labels,
datasets: [{
data: values,
backgroundColor: fillColors,
borderColor: borderColors,
borderWidth: 2
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
animation: {
animateRotate: true,
animateScale: true,
duration: 1400,
easing: 'easeInOutQuart'
},
plugins: {
title: {
display: true,
text: `Total ${metric}: ${totalValue.toFixed(0)}`,
color: '#8e8e93',
font: { size: 13, weight: '600' },
padding: { top: 0, bottom: 10 }
},
legend: {
position: 'bottom',
labels: {
color: getThemeColors().text,
padding: 15,
font: { size: 12, weight: 'bold' },
generateLabels: (chart) => {
const data = chart.data;
const legendColor = getThemeColors().text;
return data.labels.map((label, i) => ({
text: `${label} (${percentages[i]}%)`,
fillStyle: data.datasets[0].backgroundColor[i],
fontColor: legendColor,
hidden: false,
index: i
}));
}
}
},
tooltip: {
callbacks: {
label: (context) => {
const label = context.label || '';
const value = context.parsed;
const percentage = ((value / totalValue) * 100).toFixed(1);
return `${label}: ${value.toFixed(1)} (${percentage}%)`;
}
}
}
}
}
});
}
function renderTeamBarChart(chartData, position) {
const canvas = document.getElementById('team-secondary-chart');
if (!canvas) return;
const ctx = canvas.getContext('2d');
if (teamAnalysisCharts.secondary) {
teamAnalysisCharts.secondary.destroy();
}
const labels = chartData.map(d => d.name);
const values = chartData.map(d => d.value);
const playerCount = chartData.filter(d => d.name !== 'Other').length;
const teamColorVariations = generateTeamColorVariations(currentTeamAnalysisTeam, playerCount);
const fillColors = chartData.map((d, i) => {
if (d.name === 'Other') return 'rgba(99, 99, 102, 0.5)';
const baseColor = teamColorVariations[i];
if (baseColor.startsWith('#')) {
const r = parseInt(baseColor.slice(1, 3), 16);
const g = parseInt(baseColor.slice(3, 5), 16);
const b = parseInt(baseColor.slice(5, 7), 16);
return `rgba(${r}, ${g}, ${b}, 0.75)`;
} else if (baseColor.startsWith('hsl')) {
return baseColor.replace('hsl', 'hsla').replace(')', ', 0.75)');
}
return baseColor;
});
const borderColors = chartData.map((d, i) => {
if (d.name === 'Other') return '#636366';
return teamColorVariations[i];
});
const totalValue = chartData.reduce((sum, d) => sum + d.value, 0);
const metric = position === 'WR' ? 'Targets' : 'Opportunities';
teamAnalysisCharts.secondary = new Chart(ctx, {
type: 'bar',
data: {
labels: labels,
datasets: [{
label: metric,
data: values,
backgroundColor: fillColors,
borderColor: borderColors,
borderWidth: 2
}]
},
options: {
indexAxis: 'y',
responsive: true,
maintainAspectRatio: false,
plugins: {
title: {
display: true,
text: `Total ${metric}: ${totalValue.toFixed(0)}`,
color: '#8e8e93',
font: { size: 13, weight: '600' },
padding: { top: 0, bottom: 10 }
},
legend: { display: false },
tooltip: {
callbacks: {
label: (context) => {
return `${context.parsed.x.toFixed(1)} ${position === 'WR' ? 'targets' : 'opportunities'}`;
}
}
}
},
scales: {
x: {
grid: { color: getThemeColors().grid },
ticks: { color: getThemeColors().textSecondary }
},
y: {
grid: { display: false },
ticks: { color: getThemeColors().text }
}
}
}
});
}
function renderLeagueComparison(team, position, timeFrame, week, teamTotal) {
let data;
if (position === 'WR') {
data = [...wrData, ...rbData]; // Include RBs in WR league comparison
} else {
data = rbData;
}
const teamTotals = {};
if (timeFrame === 'single') {
data.filter(row => parseInt(row.Week) === week).forEach(row => {
const t = row.Team;
if (t && t !== 'FA') {
if (!teamTotals[t]) teamTotals[t] = 0;
teamTotals[t] += position === 'WR' ? (parseFloat(row.TGT) || 0) : (parseFloat(row['RB Opp']) || 0);
}
});
} else {
const weeks = [...new Set(data.map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);
const latestWeek = Math.max(...weeks);
const weeksToInclude = timeFrame === 'last3' ? 3 : 5;
const startWeek = latestWeek - weeksToInclude + 1;
data.filter(row => parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek).forEach(row => {
const t = row.Team;
if (t && t !== 'FA') {
if (!teamTotals[t]) teamTotals[t] = 0;
teamTotals[t] += position === 'WR' ? (parseFloat(row.TGT) || 0) : (parseFloat(row['RB Opp']) || 0);
}
});
}
const leagueData = Object.entries(teamTotals)
.map(([t, total]) => ({ team: t, total }))
.sort((a, b) => b.total - a.total);
const canvas = document.getElementById('team-secondary-chart');
if (!canvas) return;
const ctx = canvas.getContext('2d');
if (teamAnalysisCharts.secondary) {
teamAnalysisCharts.secondary.destroy();
}
const labels = leagueData.map(d => d.team);
const values = leagueData.map(d => d.total);
const selectedTeamColor = team ? (teamColors[team] || '#666') : '#666';
let selectedBgColor, selectedBorderColor;
if (selectedTeamColor.startsWith('#')) {
const r = parseInt(selectedTeamColor.slice(1, 3), 16);
const g = parseInt(selectedTeamColor.slice(3, 5), 16);
const b = parseInt(selectedTeamColor.slice(5, 7), 16);
selectedBgColor = `rgba(${r}, ${g}, ${b}, 0.75)`;
selectedBorderColor = selectedTeamColor;
}
const backgroundColors = leagueData.map(d => {
if (team && d.team === team) {
return selectedBgColor;
}
const color = teamColors[d.team] || '#666';
if (color.startsWith('#')) {
const r = parseInt(color.slice(1, 3), 16);
const g = parseInt(color.slice(3, 5), 16);
const b = parseInt(color.slice(5, 7), 16);
return `rgba(${r}, ${g}, ${b}, 0.65)`;
}
return color;
});
const borderColors = leagueData.map(d => {
if (team && d.team === team) return selectedBorderColor;
return teamColors[d.team] || '#666';
});
const borderWidths = leagueData.map(d => (team && d.team === team) ? 3 : 2);
const metric = position === 'WR' ? 'Targets' : 'Opportunities';
const titleText = team
? `${team} Total ${metric}: ${teamTotal.toFixed(0)}`
: `League Comparison - Total ${metric}`;
teamAnalysisCharts.secondary = new Chart(ctx, {
type: 'bar',
data: {
labels: labels,
datasets: [
{
label: `Total ${metric}`,
data: values,
backgroundColor: backgroundColors,
borderColor: borderColors,
borderWidth: borderWidths,
barThickness: 'flex',
maxBarThickness: 30
}
]
},
options: {
indexAxis: 'y',
responsive: true,
maintainAspectRatio: false,
aspectRatio: 0.8,
plugins: {
title: {
display: true,
text: titleText,
color: '#8e8e93',
font: { size: 13, weight: '600' },
padding: { top: 0, bottom: 10 }
},
legend: { display: false },
tooltip: {
callbacks: {
label: (context) => {
const value = context.parsed.x;
if (value === null || value === 0) return null;
return `${value.toFixed(1)} ${position === 'WR' ? 'targets' : 'opportunities'}`;
},
title: (context) => {
return context[0].label;
}
},
filter: (tooltipItem) => {
return tooltipItem.parsed.x !== null && tooltipItem.parsed.x !== 0;
}
}
},
scales: {
x: {
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
},
y: {
grid: { display: false },
ticks: {
autoSkip: false, // Show all team labels
maxRotation: 0,
minRotation: 0,
color: (context) => {
return context.tick.label === team ? '#ffffff' : '#8e8e93';
},
font: (context) => {
const isSelected = context.tick.label === team;
if (isSelected) {
return { size: 13, weight: 'bold' };
} else {
return { size: 10, weight: 'normal' };
}
},
align: (context) => {
return context.index % 2 === 0 ? 'end' : 'start';
},
crossAlign: 'near',
padding: (context) => {
return context.index % 2 === 0 ? 4 : 12;
}
}
}
},
onClick: (event, elements) => {
if (elements.length > 0) {
const index = elements[0].index;
const clickedTeam = labels[index];
openTeamModal(clickedTeam);
} else {
openTeamModal(team);
}
}
}
});
}
function renderSeasonLongChart(team, position) {
let data;
if (position === 'WR' || position === 'TE') {
data = [...wrData, ...rbData];
if (teData) {
data = [...data, ...teData];
}
} else {
data = rbData;
}
const filteredData = data.filter(row => row.Team === team);
console.log(`[Team Outlook Debug] Team: ${team}, Position: ${position}, Filtered Data Count: ${filteredData.length}`);
if (filteredData.length > 0) {
console.log(`[Team Outlook Debug] Sample row:`, filteredData[0]);
}
const weeks = [...new Set(filteredData.map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);
console.log(`[Team Outlook Debug] Weeks found:`, weeks);
// Check if we should show RZ share for both WRs and RBs
const showRzShare = window.currentMainTeamChartMetric === 'rz';
let seasonTotal = 0;
const weeklyTotals = {};
const weeklyShares = {};
weeks.forEach(week => {
const weekData = filteredData.filter(row => parseInt(row.Week) === week);
const totalValue = weekData.reduce((sum, row) => {
let val;
if (showRzShare) {
// For RZ share: RZ Targets for WR/TE, RZ Rush Attempts + RZ Targets for RB
if (position === 'WR' || position === 'TE') {
val = parseFloat(row.RZ_TGT || row['RZ TGT']) || 0;
} else {
const rzAtt = parseFloat(row.RZ_RUSH_ATT || row['RZ RUSH ATT']) || 0;
const rzTgt = parseFloat(row.RZ_TGT || row['RZ TGT']) || 0;
val = rzAtt + rzTgt;
}
} else {
// For regular usage: Targets for WR/TE, RB Opp for RB
if (position === 'WR' || position === 'TE') {
val = parseFloat(row.TGT) || 0;
} else {
val = parseFloat(row['RB Opp']) || 0;
}
}
return sum + val;
}, 0);
weeklyTotals[week] = totalValue;
seasonTotal += totalValue;
weekData.forEach(row => {
const player = row.Player;
let value;
if (showRzShare) {
// For RZ share: RZ Targets for WR/TE, RZ Rush Attempts + RZ Targets for RB
if (position === 'WR' || position === 'TE') {
value = parseFloat(row.RZ_TGT || row['RZ TGT']) || 0;
} else {
const rzAtt = parseFloat(row.RZ_RUSH_ATT || row['RZ RUSH ATT']) || 0;
const rzTgt = parseFloat(row.RZ_TGT || row['RZ TGT']) || 0;
value = rzAtt + rzTgt;
}
} else {
// For regular usage: Targets for WR/TE, RB Opp for RB
if (position === 'WR' || position === 'TE') {
value = parseFloat(row.TGT) || 0;
} else {
value = parseFloat(row['RB Opp']) || 0;
}
}
const share = totalValue > 0 ? (value / totalValue) * 100 : 0;
if (!weeklyShares[player]) {
weeklyShares[player] = [];
}
weeklyShares[player].push({ week, share, value });
});
});
const playerAverages = Object.entries(weeklyShares).map(([player, shares]) => {
const avgShare = shares.reduce((sum, s) => sum + s.share, 0) / shares.length;
const maxShare = Math.max(...shares.map(s => s.share));
return { player, avgShare, maxShare, shares };
}).sort((a, b) => b.avgShare - a.avgShare);
console.log(`[Team Outlook Debug] Weekly shares entries:`, Object.keys(weeklyShares).length);
console.log(`[Team Outlook Debug] Player averages:`, playerAverages.length);
console.log(`[Team Outlook Debug] Season total:`, seasonTotal);
// For RBs, show top 5 if position is RB, otherwise top 4 for WR/TE
const topCount = (position === 'RB') ? 5 : 4;
const topPlayers = playerAverages.slice(0, topCount);
const container = document.getElementById('team-charts-container');
container.style.gridTemplateColumns = '1fr';
document.getElementById('team-secondary-chart-wrapper').style.display = 'none';
const canvas = document.getElementById('team-pie-chart');
if (!canvas) return;
const ctx = canvas.getContext('2d');
if (teamAnalysisCharts.pie) {
teamAnalysisCharts.pie.destroy();
}

// Check if there's no data to display
if (topPlayers.length === 0 || seasonTotal === 0) {
const chartTitle = document.getElementById('team-chart-title');
const chartDescription = document.getElementById('team-chart-description');
if (chartTitle) chartTitle.textContent = 'No Data Available';
if (chartDescription) chartDescription.textContent = 'This team has no recorded data for the selected position and time frame.';
return;
}

const metric = (position === 'WR' || position === 'TE') ? 'Targets' : (showRzShare ? 'RZ Opportunities' : 'Opportunities');
if (position === 'WR' || position === 'TE') {
const teamPalette = teamColorPalettes[team] || ['#666', '#888', '#aaa', '#ccc'];
const teamColorVariations = generateTeamColorVariations(team, topPlayers.length);
const showNumbers = showRzShare && (window.currentMainRZMetric === 'num');
// For RZ Usage, show pie chart; for Total Usage, show stacked bar
if (showRzShare) {
// Pie chart for RZ Usage
const pieData = topPlayers.map(p => {
const totalValue = p.shares.reduce((sum, s) => sum + s.value, 0);
return { player: p.player, value: totalValue };
});
const totalRZ = pieData.reduce((sum, p) => sum + p.value, 0);
const labels = pieData.map(p => p.player);
const data = showNumbers ? pieData.map(p => p.value) : pieData.map(p => (p.value / totalRZ) * 100);
const backgroundColors = pieData.map((p, i) => {
const baseColor = teamColorVariations[i];
if (baseColor.startsWith('#')) {
const r = parseInt(baseColor.slice(1, 3), 16);
const g = parseInt(baseColor.slice(3, 5), 16);
const b = parseInt(baseColor.slice(5, 7), 16);
return `rgba(${r}, ${g}, ${b}, 0.75)`;
} else if (baseColor.startsWith('hsl')) {
return baseColor.replace('hsl', 'hsla').replace(')', ', 0.75)');
}
return baseColor;
});
const borderColors = teamColorVariations;
teamAnalysisCharts.pie = new Chart(ctx, {
type: 'pie',
data: {
labels: labels,
datasets: [{
data: data,
backgroundColor: backgroundColors,
borderColor: borderColors,
borderWidth: 2
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
animation: {
animateRotate: true,
animateScale: true,
duration: 1200,
easing: 'easeInOutQuart'
},
plugins: {
title: {
display: true,
text: showNumbers ? `Total ${metric} (Season): ${totalRZ.toFixed(0)}` : `${metric} Distribution`,
color: '#8e8e93',
font: { size: 13, weight: '600' },
padding: { top: 5, bottom: 15 }
},
legend: {
position: 'bottom',
labels: {
color: getThemeColors().text,
padding: 12,
font: { size: 11 },
generateLabels: (chart) => {
return chart.data.labels.map((label, i) => {
const value = chart.data.datasets[0].data[i];
const displayText = showNumbers ? 
`${label}: ${value.toFixed(1)}` :
`${label}: ${value.toFixed(1)}%`;
return {
text: displayText,
fillStyle: chart.data.datasets[0].backgroundColor[i],
fontColor: getThemeColors().text,
hidden: false,
index: i
};
});
}
}
},
tooltip: {
callbacks: {
label: (context) => {
const label = context.label;
const value = context.parsed;
if (showNumbers) {
return `${label}: ${value.toFixed(1)}`;
} else {
return `${label}: ${value.toFixed(1)}%`;
}
}
}
}
},
onClick: (event, elements) => {
openTeamModal(team);
}
}
});
} else {
// Stacked bar chart for Total Usage
const datasets = topPlayers.map((p, i) => {
const baseColor = teamColorVariations[i];
let fillColor = baseColor;
if (baseColor.startsWith('#')) {
const r = parseInt(baseColor.slice(1, 3), 16);
const g = parseInt(baseColor.slice(3, 5), 16);
const b = parseInt(baseColor.slice(5, 7), 16);
fillColor = `rgba(${r}, ${g}, ${b}, 0.75)`;
} else if (baseColor.startsWith('hsl')) {
fillColor = baseColor.replace('hsl', 'hsla').replace(')', ', 0.75)');
}
return {
label: p.player,
data: weeks.map(week => {
const weekShare = p.shares.find(s => s.week === week);
return weekShare ? weekShare.share : 0;
}),
backgroundColor: fillColor,
borderColor: baseColor,
borderWidth: 2
};
});

// Calculate "Other" data and track which players are in "Other" for each week
const otherPlayersData = {};
const otherData = weeks.map(week => {
const weekTotal = 100;
const topPlayerNames = topPlayers.map(p => p.player);

// Calculate top players' total share
const topTotal = topPlayers.reduce((sum, p) => {
const weekShare = p.shares.find(s => s.week === week);
return sum + (weekShare ? weekShare.share : 0);
}, 0);

// Find all "Other" players for this week
const otherPlayers = playerAverages
.filter(p => !topPlayerNames.includes(p.player))
.map(p => {
const weekShare = p.shares.find(s => s.week === week);
return {
player: p.player,
share: weekShare ? weekShare.share : 0
};
})
.filter(p => p.share > 0)
.sort((a, b) => b.share - a.share);

otherPlayersData[week] = otherPlayers;

return Math.max(0, weekTotal - topTotal);
});

datasets.push({
label: 'Other',
data: otherData,
backgroundColor: 'rgba(99, 99, 102, 0.5)',
borderColor: '#636366',
borderWidth: 2,
otherPlayersData: otherPlayersData  // Store for tooltip access
});
teamAnalysisCharts.pie = new Chart(ctx, {
type: 'bar',
data: {
labels: weeks.map(w => `Week ${w} (${Math.round(weeklyTotals[w])})`),
datasets: datasets
},
options: {
responsive: true,
maintainAspectRatio: false,
aspectRatio: 2.5,
animation: {
duration: 1400,
easing: 'easeInOutQuart'
},
plugins: {
title: {
display: true,
text: `Total ${metric} (Season): ${seasonTotal.toFixed(0)}`,
color: '#8e8e93',
font: { size: 13, weight: '600' },
padding: { top: 5, bottom: 15 }
},
legend: {
position: 'bottom',
labels: { color: getThemeColors().text, padding: 10, font: { size: 11 } }
},
tooltip: {
mode: 'point',
intersect: true,
callbacks: {
title: (tooltipItems) => {
const weekIndex = tooltipItems[0].dataIndex;
const week = weeks[weekIndex];
const weekLabel = `Week ${week} (${Math.round(weeklyTotals[week])})`;
return weekLabel;
},
label: (context) => {
const datasetLabel = context.dataset.label;
const value = context.parsed.y;

// Check if this is the "Other" category
if (datasetLabel === 'Other') {
const weekIndex = context.dataIndex;
const week = weeks[weekIndex];
const otherPlayers = context.dataset.otherPlayersData[week] || [];
const showAsterisk = value > 60; // Flag if >60% went to Other

let label = showNumbers ? 
`Other: ${value.toFixed(1)}` :
`Other: ${value.toFixed(1)}%`;

// Add asterisk if top players inactive (>60% to Other)
if (showAsterisk) {
label += ' *';
}

// Add breakdown of who "Other" players are (top 3)
if (otherPlayers.length > 0) {
const breakdown = otherPlayers.slice(0, 3).map(p => 
`  ${p.player}: ${p.share.toFixed(1)}%`
).join('\n');

label += '\n' + breakdown;

if (otherPlayers.length > 3) {
label += `\n  +${otherPlayers.length - 3} more`;
}
}

// Add note about asterisk
if (showAsterisk) {
label += '\n  * Top players inactive';
}

return label;
} else {
// Regular player tooltip
if (showNumbers) {
return `${datasetLabel}: ${value.toFixed(1)}`;
} else {
return `${datasetLabel}: ${value.toFixed(1)}%`;
}
}
}
}
}
},
scales: {
x: {
stacked: !showNumbers,
grid: { color: getThemeColors().grid },
ticks: { color: getThemeColors().textSecondary, font: { size: 10 } }
},
y: {
stacked: !showNumbers,
max: showNumbers ? undefined : 100,
grid: { color: getThemeColors().grid },
ticks: { color: getThemeColors().textSecondary },
title: {
display: true,
text: showRzShare ? (showNumbers ? 'RZ Opportunities' : 'RZ Target Share %') : 'Target Share %',
color: getThemeColors().textSecondary
}
}
},
onClick: (event, elements) => {
openTeamModal(team);
}
}
});
} // End of if (showRzShare) else block for WR
} else {
// RB line chart section
const teamColorVariations = generateTeamColorVariations(team, topPlayers.length);
const showNumbers = showRzShare && (window.currentMainRZMetric === 'num');
const datasets = topPlayers.map((p, i) => {
const baseColor = teamColorVariations[i];
let fillColor = baseColor + '85';
if (baseColor.startsWith('#')) {
const r = parseInt(baseColor.slice(1, 3), 16);
const g = parseInt(baseColor.slice(3, 5), 16);
const b = parseInt(baseColor.slice(5, 7), 16);
fillColor = `rgba(${r}, ${g}, ${b}, 0.75)`;
} else if (baseColor.startsWith('hsl')) {
fillColor = baseColor.replace('hsl', 'hsla').replace(')', ', 0.75)');
}
// Check if player has ANY touches in ANY week
const hasAnyTouches = p.shares.some(s => s.value > 0);
return {
label: p.player,
data: weeks.map(week => {
const weekShare = p.shares.find(s => s.week === week);
// If player has touches in any week, show their line for all weeks (0 for weeks with no touches)
// Only return null if player never had touches in any week
if (hasAnyTouches) {
if (showNumbers) {
return weekShare ? weekShare.value : 0;
} else {
return weekShare ? weekShare.share : 0;
}
} else {
if (showNumbers) {
return weekShare ? weekShare.value : null;
} else {
return weekShare ? weekShare.share : null;
}
}
}),
borderColor: baseColor,
backgroundColor: fillColor,
borderWidth: 3,
pointRadius: 5,
pointHoverRadius: 7,
pointBackgroundColor: fillColor,
pointBorderColor: baseColor,
pointBorderWidth: 2,
tension: 0.3,
spanGaps: false // Don't connect across null values
};
});
teamAnalysisCharts.pie = new Chart(ctx, {
type: 'line',
data: {
labels: weeks.map(w => `Week ${w} (${Math.round(weeklyTotals[w])})`),
datasets: datasets
},
options: {
responsive: true,
maintainAspectRatio: false,
aspectRatio: 2.5,
animation: {
duration: 1400,
easing: 'easeInOutQuart'
},
plugins: {
title: {
display: true,
text: `Total ${metric} (Season): ${seasonTotal.toFixed(0)}`,
color: '#8e8e93',
font: { size: 13, weight: '600' },
padding: { top: 5, bottom: 15 }
},
legend: {
position: 'bottom',
labels: { color: getThemeColors().text, padding: 10, font: { size: 11 } }
},
tooltip: {
mode: 'index',
intersect: false,
callbacks: {
label: (context) => {
if (showNumbers) {
return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}`;
} else {
return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;
}
}
}
}
},
scales: {
x: {
grid: { color: getThemeColors().grid },
ticks: { color: getThemeColors().textSecondary }
},
y: {
grid: { color: getThemeColors().grid },
ticks: { color: getThemeColors().textSecondary },
title: {
display: true,
text: showRzShare ? (showNumbers ? 'RZ Opportunities' : 'RZ Opportunity Share %') : 'Opportunity Share %',
color: getThemeColors().textSecondary
}
}
},
onClick: (event, elements) => {
openTeamModal(team);
}
}
});
}
}
function renderCollapsibleDivisions() {
if (!wrData || !rbData) return;
const divisionsContainer = document.getElementById('divisions-grid');
divisionsContainer.innerHTML = '';
const teamStatsMap = {};
const allData = [...wrData, ...rbData];
allData.forEach(row => {
const team = row.Team;
if (team && team !== 'FA') {
if (!teamStatsMap[team]) {
teamStatsMap[team] = { totalPoints: 0, games: 0 };
}
teamStatsMap[team].totalPoints += parseFloat(row.FPTS || row.Fpts) || 0;
}
});
const uniqueTeamWeeks = {};
allData.forEach(row => {
const team = row.Team;
const week = row.Week;
if (team && team !== 'FA' && week) {
const key = `${team}-${week}`;
uniqueTeamWeeks[key] = true;
}
});
Object.keys(uniqueTeamWeeks).forEach(key => {
const team = key.split('-')[0];
if (teamStatsMap[team]) {
teamStatsMap[team].games++;
}
});
Object.entries(nflDivisions).forEach(([divisionName, teams]) => {
const divSection = document.createElement('div');
divSection.className = 'division-section';
const header = document.createElement('div');
header.className = 'division-header';
header.onclick = () => toggleDivision(divisionName);
const title = document.createElement('div');
title.className = 'division-title';
title.textContent = divisionName;
const arrow = document.createElement('div');
arrow.className = 'division-arrow';
arrow.id = `arrow-${divisionName.replace(/\s+/g, '-')}`;
arrow.textContent = 'â–¼';
header.appendChild(title);
header.appendChild(arrow);
const content = document.createElement('div');
content.className = 'division-content';
content.id = `content-${divisionName.replace(/\s+/g, '-')}`;
const teamsGrid = document.createElement('div');
teamsGrid.className = 'division-teams-grid';
teams.forEach(team => {
const stats = teamStatsMap[team] || { totalPoints: 0, games: 1 };
const ppg = stats.games > 0 ? (stats.totalPoints / stats.games).toFixed(1) : '0.0';
const teamCard = document.createElement('div');
teamCard.className = 'division-team-card';
teamCard.onclick = () => selectTeamFromDivision(team);
const logo = document.createElement('div');
logo.className = 'division-team-logo';
logo.style.background = teamColors[team] || '#666';
logo.textContent = team;
const info = document.createElement('div');
info.className = 'division-team-info';
const name = document.createElement('div');
name.className = 'division-team-name';
name.textContent = team;
const statsDiv = document.createElement('div');
statsDiv.className = 'division-team-stats';
statsDiv.textContent = `${ppg} PPG Â· ${stats.games} games`;
info.appendChild(name);
info.appendChild(statsDiv);
teamCard.appendChild(logo);
teamCard.appendChild(info);
teamsGrid.appendChild(teamCard);
});
content.appendChild(teamsGrid);
divSection.appendChild(header);
divSection.appendChild(content);
divisionsContainer.appendChild(divSection);
});
}
function toggleDivision(divisionName) {
const contentId = `content-${divisionName.replace(/\s+/g, '-')}`;
const arrowId = `arrow-${divisionName.replace(/\s+/g, '-')}`;
const content = document.getElementById(contentId);
const arrow = document.getElementById(arrowId);
if (content && arrow) {
content.classList.toggle('expanded');
arrow.classList.toggle('expanded');
}
}
function selectTeamFromDivision(team) {
const teamSelect = document.getElementById('team-select');
teamSelect.value = team;
currentTeamAnalysisTeam = team;
updateTeamAnalysis();
document.querySelector('.advanced-analytics-container').scrollIntoView({ behavior: 'smooth', block: 'start' });
}
let wrAnalyticsRendered = false;
let rbAnalyticsRendered = false;
function switchWRSubTab(tab) {
const tabs = document.querySelectorAll('#wide-receivers .sub-nav-tab');
tabs.forEach(t => {
t.style.color = 'var(--text-secondary)';
t.style.borderBottomColor = 'transparent';
t.classList.remove('active');
});
event.target.classList.add('active');
event.target.style.color = 'var(--text-primary)';
event.target.style.borderBottomColor = 'var(--positive)';
if (tab === 'rankings') {
document.getElementById('wr-rankings-content').style.display = 'block';
document.getElementById('wr-analytics-content').style.display = 'none';
} else if (tab === 'analytics') {
document.getElementById('wr-rankings-content').style.display = 'none';
document.getElementById('wr-analytics-content').style.display = 'block';
if (!wrAnalyticsRendered) {
renderWRScatter();
renderMatrices(); // This will render WR matrices
if (Object.keys(evaluationDataWR).length > 0) {
initSmoothTrendAnimation('wr-eval-volume-efficiency');
initSmoothTrendAnimation('wr-eval-share-rz');
initSmoothTrendAnimation('wr-eval-production-volume');
}
wrAnalyticsRendered = true;
}
}
}
function switchRBSubTab(tab) {
const tabs = document.querySelectorAll('#running-backs .sub-nav-tab');
tabs.forEach(t => {
t.style.color = 'var(--text-secondary)';
t.style.borderBottomColor = 'transparent';
t.classList.remove('active');
});
event.target.classList.add('active');
event.target.style.color = 'var(--text-primary)';
event.target.style.borderBottomColor = 'var(--positive)';
if (tab === 'rankings') {
document.getElementById('rb-rankings-content').style.display = 'block';
document.getElementById('rb-analytics-content').style.display = 'none';
} else if (tab === 'analytics') {
document.getElementById('rb-rankings-content').style.display = 'none';
document.getElementById('rb-analytics-content').style.display = 'block';
if (!rbAnalyticsRendered) {
renderRBScatter();
renderMatrices(); // This will render RB matrices
if (Object.keys(evaluationDataRB).length > 0) {
initSmoothTrendAnimation('rb-eval-total-rz');
initSmoothTrendAnimation('rb-eval-volume-efficiency');
initSmoothTrendAnimation('rb-eval-production-volume');
}
rbAnalyticsRendered = true;
}
}
}
document.querySelectorAll('.nav-tab').forEach(tab => {
tab.addEventListener('click', function() {
const pageName = this.getAttribute('data-page');
document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
this.classList.add('active');
document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
document.getElementById(pageName).classList.add('active');
if (pageName === 'top-movers') {
setTimeout(() => {
renderDashboardCategories();
setTimeout(renderMiniScatterPlots, 100);
}, 100);
}
window.scrollTo({ top: 0, behavior: 'smooth' });
});
});
let currentModalPlayer = null;
function openPlayerModalWithCategory(playerId, categoryTitle, explanation, rank, metricLabel, metricValue) {
openPlayerModal(playerId);
const contextDiv = document.getElementById('modal-category-context');
if (contextDiv && categoryTitle) {
contextDiv.style.display = 'block';
document.getElementById('modal-category-title').textContent = categoryTitle;
document.getElementById('modal-category-rank').textContent = `#${rank}`;
document.getElementById('modal-category-explanation').textContent = explanation;
document.getElementById('modal-category-metric-label').textContent = metricLabel;
document.getElementById('modal-category-metric-value').textContent = metricValue;
}
}
function openPlayerModal(playerId) {
const player = allPlayers[playerId];
if (!player) return;
const contextDiv = document.getElementById('modal-category-context');
if (contextDiv) {
contextDiv.style.display = 'none';
}
currentModalPlayer = player;
const modalNameEl = document.getElementById('modal-player-name');
modalNameEl.textContent = player.name;
modalNameEl.style.color = '#ffffff';
const injury = getPlayerInjuryStatus(player.name);
let metaHTML = `${player.position} Â· ${player.team} Â· Rank #${player.rosRank}`;
if (injury) {
const statusInfo = formatInjuryStatus(injury.status);
const injuryDetails = `${statusInfo.fullText} - ${injury.injuryBody}`;
metaHTML += ` <span class="injury-badge ${statusInfo.class}" data-injury-details="${injuryDetails}" style="font-size: 13px; padding: 3px 8px;">${statusInfo.fullText}</span>`;
}
if (player.momentum && player.momentum.isValid && player.momentum.direction !== 'neutral') {
let showBadge = true;
if (player.momentum.direction === 'down') {
const highScorerThreshold = currentScoringFormat === 'ppr' ? 20 :
currentScoringFormat === 'half' ? 17 : 14.5;
if (player.avgPoints >= highScorerThreshold && player.momentum.score > -15) {
showBadge = false;
}
}
if (showBadge) {
metaHTML += ` <span class="momentum-badge ${player.momentum.direction}" data-tooltip="Momentum: ${player.momentum.score > 0 ? '+' : ''}${player.momentum.score.toFixed(1)}% (last 3 vs prev 3 weeks)" style="font-size: 13px; padding: 3px 8px;">${player.momentum.direction === 'up' ? 'â†‘' : 'â†“'}</span>`;
}
}
document.getElementById('modal-player-meta').innerHTML = metaHTML;
document.getElementById('modal-team-badge').textContent = player.team;
document.getElementById('modal-team-badge').style.background = teamColors[player.team] || '#666';
const latestWeek = player.weeks[player.weeks.length - 1];
const latestWeekNum = latestWeek.week;
const actualPts = latestWeek.fpts;
const expectedPts = latestWeek.expectedFpts;
const diffPct = expectedPts > 0 ? ((actualPts - expectedPts) / expectedPts) * 100 : 0;
const prevWeek = player.weeks.length > 1 ? player.weeks[player.weeks.length - 2] : null;
let allPositionPlayers, top24Players;
if (player.position === 'WR') {
allPositionPlayers = Object.values(window.aggregatedWRs);
} else if (player.position === 'RB') {
allPositionPlayers = Object.values(window.aggregatedRBs);
} else {
allPositionPlayers = Object.values(window.aggregatedTEs);
}
top24Players = allPositionPlayers
.filter(p => p.gamesPlayed >= 3)
.sort((a, b) => b.avgPoints - a.avgPoints)
.slice(0, 24);
const top24AvgPts = top24Players.reduce((sum, p) => sum + p.avgPoints, 0) / top24Players.length;
document.getElementById('modal-avg-pts').textContent = player.avgPoints.toFixed(1);
const ptsDiff = player.avgPoints - top24AvgPts;
const ptsColor = ptsDiff >= 0 ? '#30d158' : '#ff453a';
const ptsSymbol = ptsDiff >= 0 ? 'â–²' : 'â–¼';
document.getElementById('modal-avg-pts-comparison').innerHTML =
`<span style="color: ${ptsColor};">${ptsSymbol} ${Math.abs(ptsDiff).toFixed(1)} pts</span>`;
document.getElementById('modal-actual-pts-label').textContent = `Actual Pts (W${latestWeekNum})`;
document.getElementById('modal-actual-pts').textContent = actualPts.toFixed(1);
if (prevWeek) {
const prevWeekPts = prevWeek.fpts;
const weekOverWeekDiff = actualPts - prevWeekPts;
const actualDiffColor = weekOverWeekDiff >= 0 ? '#30d158' : '#ff453a';
const actualDiffSymbol = weekOverWeekDiff >= 0 ? 'â–²' : 'â–¼';
document.getElementById('modal-actual-comparison').innerHTML =
`<span style="color: ${actualDiffColor};">${actualDiffSymbol} ${Math.abs(weekOverWeekDiff).toFixed(1)} vs W${prevWeek.week}</span>`;
} else {
document.getElementById('modal-actual-comparison').innerHTML = '';
}
if (player.momentum && player.momentum.isValid) {
let momentumIcon = '';
let momentumColor = '';
if (player.momentum.direction === 'up') {
momentumIcon = 'â†‘ Hot';
momentumColor = '#30d158';
} else if (player.momentum.direction === 'down') {
momentumIcon = 'â†“ Cold';
momentumColor = '#ff453a';
} else {
momentumIcon = 'â†’ Steady';
momentumColor = 'rgba(235, 235, 245, 0.6)';
}
document.getElementById('modal-momentum').textContent = momentumIcon;
document.getElementById('modal-momentum').style.color = momentumColor;
const momentumScore = player.momentum.score;
const momentumScoreColor = momentumScore >= 0 ? '#30d158' : '#ff453a';
const momentumSymbol = momentumScore >= 0 ? 'â–²' : 'â–¼';
document.getElementById('modal-momentum-comparison').innerHTML =
`<span style="color: ${momentumScoreColor};">${momentumSymbol} ${Math.abs(momentumScore).toFixed(1)}%</span>`;
} else {
document.getElementById('modal-momentum').textContent = 'â†’ Steady';
document.getElementById('modal-momentum').style.color = 'rgba(235, 235, 245, 0.6)';
document.getElementById('modal-momentum-comparison').innerHTML =
`<span style="color: rgba(235, 235, 245, 0.6);">Insufficient data</span>`;
}
const totalActual = player.weeks.reduce((sum, w) => sum + w.fpts, 0);
const totalExpected = player.weeks.reduce((sum, w) => sum + (w.expectedFpts || w.fpts), 0);
const avgActual = totalActual / player.gamesPlayed;
const avgExpected = totalExpected / player.gamesPlayed;
const ppgDiff = avgActual - avgExpected;
const ppgDiffPct = avgExpected > 0 ? (ppgDiff / avgExpected) * 100 : 0;
document.getElementById('modal-ppg-expected').textContent = avgActual.toFixed(1);
const ppgColor = ppgDiff >= 0 ? '#30d158' : '#ff453a';
const ppgSymbol = ppgDiff >= 0 ? 'â–²' : 'â–¼';
document.getElementById('modal-ppg-expected-comparison').innerHTML =
`<span style="color: ${ppgColor};">${ppgSymbol} ${Math.abs(ppgDiffPct).toFixed(1)}% vs exp</span>`;
if (player.position === 'WR' || player.position === 'TE') {
const thisWeekShare = latestWeek.teamShare || 0;
const lastWeekShare = prevWeek ? (prevWeek.teamShare || 0) : 0;
const shareChange = thisWeekShare - lastWeekShare;
document.getElementById('modal-opp-share-label').textContent = `Tgt Share (W${latestWeekNum})`;
document.getElementById('modal-opp-share').textContent = thisWeekShare.toFixed(1) + '%';
if (prevWeek) {
const shareColor = shareChange >= 0 ? '#30d158' : '#ff453a';
const shareSymbol = shareChange >= 0 ? 'â–²' : 'â–¼';
document.getElementById('modal-opp-share-comparison').innerHTML =
`<span style="color: ${shareColor};">${shareSymbol} ${Math.abs(shareChange).toFixed(1)}% vs W${prevWeek.week}</span>`;
} else {
document.getElementById('modal-opp-share-comparison').innerHTML = '';
}
document.getElementById('modal-opp-share-tooltip').textContent =
'Player\'s share of team targets in the most recent week';
} else {
// For RBs, opportunities field stores the Opp Share percentage directly from CSV
const thisWeekShare = latestWeek.opportunities || 0;
const lastWeekShare = prevWeek ? (prevWeek.opportunities || 0) : 0;
const shareChange = thisWeekShare - lastWeekShare;
document.getElementById('modal-opp-share-label').textContent = `Opp Share (W${latestWeekNum})`;
document.getElementById('modal-opp-share').textContent = thisWeekShare.toFixed(1) + '%';
if (prevWeek) {
const shareColor = shareChange >= 0 ? '#30d158' : '#ff453a';
const shareSymbol = shareChange >= 0 ? 'â–²' : 'â–¼';
document.getElementById('modal-opp-share-comparison').innerHTML =
`<span style="color: ${shareColor};">${shareSymbol} ${Math.abs(shareChange).toFixed(1)}% vs W${prevWeek.week}</span>`;
} else {
document.getElementById('modal-opp-share-comparison').innerHTML = '';
}
document.getElementById('modal-opp-share-tooltip').textContent =
'Player\'s share of team opportunities (carries + targets) in the most recent week';
}
if (player.position === 'WR' || player.position === 'TE') {
const avgTargets = player.totalTargets / player.gamesPlayed;
const top24AvgTargets = top24Players.reduce((sum, p) =>
sum + (p.totalTargets / p.gamesPlayed), 0) / top24Players.length;
const targetsDiff = avgTargets - top24AvgTargets;
document.getElementById('modal-avg-volume-label').textContent =
`Avg Tgt vs Top ${player.position === 'TE' ? '12' : '24'}`;
document.getElementById('modal-avg-volume').textContent = avgTargets.toFixed(1);
const targetsColor = targetsDiff >= 0 ? '#30d158' : '#ff453a';
const targetsSymbol = targetsDiff >= 0 ? 'â–²' : 'â–¼';
document.getElementById('modal-avg-volume-comparison').innerHTML =
`<span style="color: ${targetsColor};">${targetsSymbol} ${Math.abs(targetsDiff).toFixed(1)} vs avg (${top24AvgTargets.toFixed(1)})</span>`;
document.getElementById('modal-avg-volume-tooltip').textContent =
`Average targets per game compared to Top ${player.position === 'TE' ? '12' : '24'} ${player.position} average`;
} else {
const avgOpps = player.totalOpportunities / player.gamesPlayed;
const top24AvgOpps = top24Players.reduce((sum, p) =>
sum + (p.totalOpportunities / p.gamesPlayed), 0) / top24Players.length;
const oppsDiff = avgOpps - top24AvgOpps;
document.getElementById('modal-avg-volume-label').textContent = 'Avg Opp vs Top 24';
document.getElementById('modal-avg-volume').textContent = avgOpps.toFixed(1);
const oppsColor = oppsDiff >= 0 ? '#30d158' : '#ff453a';
const oppsSymbol = oppsDiff >= 0 ? 'â–²' : 'â–¼';
document.getElementById('modal-avg-volume-comparison').innerHTML =
`<span style="color: ${oppsColor};">${oppsSymbol} ${Math.abs(oppsDiff).toFixed(1)} vs avg (${top24AvgOpps.toFixed(1)})</span>`;
document.getElementById('modal-avg-volume-tooltip').textContent =
'Average opportunities (carries + targets) per game compared to Top 24 RB average';
}
const rzShare = (player.rzOpportunities / player.teamRzOpportunities) * 100 || 0;
// Show as "12/45 (26.7%)" format
document.getElementById('modal-rz-share').textContent = 
`${player.rzOpportunities}/${player.teamRzOpportunities} (${rzShare.toFixed(1)}%)`;

const top24AvgRzShare = top24Players.reduce((sum, p) =>
sum + ((p.rzOpportunities / p.teamRzOpportunities) * 100 || 0), 0) / top24Players.length;
const top24AvgRzOpps = top24Players.reduce((sum, p) =>
sum + (p.rzOpportunities / p.gamesPlayed), 0) / top24Players.length;

const rzShareDiff = rzShare - top24AvgRzShare;
const rzShareColor = rzShareDiff >= 0 ? '#30d158' : '#ff453a';
const rzShareSymbol = rzShareDiff >= 0 ? 'â–²' : 'â–¼';

// Show both percentage difference and vs avg Top 24 share
document.getElementById('modal-rz-share-comparison').innerHTML =
`<span style="color: ${rzShareColor};">${rzShareSymbol} ${Math.abs(rzShareDiff).toFixed(1)}% vs avg (${top24AvgRzShare.toFixed(1)}%)</span>`;

const rzOppsPerGame = player.rzOpportunities / player.gamesPlayed;
const rzOppsDiff = rzOppsPerGame - top24AvgRzOpps;
document.getElementById('modal-rz-avg-label').textContent =
`RZ Opp/G vs Top ${player.position === 'TE' ? '12' : '24'}`;
document.getElementById('modal-rz-avg').textContent = rzOppsPerGame.toFixed(1);
const rzOppsColor = rzOppsDiff >= 0 ? '#30d158' : '#ff453a';
const rzOppsSymbol = rzOppsDiff >= 0 ? 'â–²' : 'â–¼';
document.getElementById('modal-rz-avg-comparison').innerHTML =
`<span style="color: ${rzOppsColor};">${rzOppsSymbol} ${Math.abs(rzOppsDiff).toFixed(1)} vs avg (${top24AvgRzOpps.toFixed(1)})</span>`;
document.getElementById('modal-rz-avg-tooltip').textContent =
`Average red zone opportunities per game compared to Top ${player.position === 'TE' ? '12' : '24'} ${player.position} average`;
updateModalSentiment(player.name);
loadComments(player.name);
loadPlayerSchedule(player.team, player.position);
document.getElementById('player-modal').classList.add('active');
if (window.innerWidth <= 768) {
statsCurrentPage = 0;
setTimeout(() => {
initStatsSwipe();
updateStatsPage();
}, 100);
}
renderModalVarianceChart(player);
renderModalSpiderChart(player);
renderModalPRSChart(player);
renderFloorMetricsChart(player);
renderModalCandlesChart(player);
setTimeout(() => {
renderModalOutcomesChart(player);
}, 50);
document.querySelectorAll('.chart-tab').forEach(tab => tab.classList.remove('active'));
document.querySelectorAll('.chart-content').forEach(content => content.classList.remove('active'));
document.querySelector('.chart-tab[onclick*="outcomes"]').classList.add('active');
document.getElementById('modal-chart-outcomes').classList.add('active');
const statsContainer = document.getElementById('modal-stats-container');
const statsIcon = document.getElementById('stats-collapse-icon');
const statsText = document.getElementById('stats-collapse-text');
if (statsContainer) {
statsContainer.style.display = '';
statsIcon.textContent = 'â–¼';
statsText.textContent = 'Hide Stats';
}
const explanation = document.getElementById('spider-explanation');
const icon = document.getElementById('spider-explanation-icon');
if (explanation) {
explanation.style.display = 'none'; // Collapsed by default
icon.textContent = 'â„¹ï¸';
const wrMetrics = document.getElementById('spider-wr-metrics');
const rbMetrics = document.getElementById('spider-rb-metrics');
const teMetrics = document.getElementById('spider-te-metrics');
if (player.position === 'WR') {
wrMetrics.style.display = 'block';
rbMetrics.style.display = 'none';
teMetrics.style.display = 'none';
} else if (player.position === 'RB') {
wrMetrics.style.display = 'none';
rbMetrics.style.display = 'block';
teMetrics.style.display = 'none';
} else if (player.position === 'TE') {
wrMetrics.style.display = 'none';
rbMetrics.style.display = 'none';
teMetrics.style.display = 'block';
}
}
setTimeout(() => {
const modalBody = document.querySelector('#player-modal .modal');
if (modalBody) {
modalBody.scrollTop = 0;
}
}, 100);
}
function updateModalSentiment(playerName) {
const sentiment = getSentimentScore(playerName);
console.log('ðŸ“Š updateModalSentiment called for', playerName, ':', sentiment);
const total = sentiment.total;
const buyPct = total > 0 ? (sentiment.buy / total * 100) : 0;
const sellPct = total > 0 ? (sentiment.sell / total * 100) : 0;
const holdPct = total > 0 ? (sentiment.hold / total * 100) : 0;
console.log(' Percentages - Buy:', buyPct.toFixed(1), '% Sell:', sellPct.toFixed(1), '% Hold:', holdPct.toFixed(1), '%');
const buySegment = document.getElementById('modal-sentiment-segment-buy');
const holdSegment = document.getElementById('modal-sentiment-segment-hold');
const sellSegment = document.getElementById('modal-sentiment-segment-sell');
if (!buySegment || !holdSegment || !sellSegment) {
console.warn(' âš ï¸ Sentiment bar segments not found in DOM');
return;
}
if (total > 0) {
buySegment.style.width = buyPct + '%';
holdSegment.style.width = holdPct + '%';
sellSegment.style.width = sellPct + '%';
console.log(' âœ… Updated sentiment bar widths');
} else {
buySegment.style.width = '0%';
holdSegment.style.width = '100%';
sellSegment.style.width = '0%';
console.log(' â„¹ï¸ No votes - showing default grey bar');
}
const voteCountEl = document.getElementById('modal-sentiment-vote-count');
if (voteCountEl) {
voteCountEl.textContent = total === 1 ? '1 vote' : `${total} votes`;
console.log(' âœ… Updated vote count:', voteCountEl.textContent);
}
document.querySelectorAll('.vote-btn').forEach(btn => btn.classList.remove('active'));
const userVote = userVoteCache[playerName];
if (userVote) {
const btn = document.querySelector(`.vote-btn.${userVote}-btn`);
if (btn) {
btn.classList.add('active');
console.log(' âœ… Highlighted user vote button:', userVote);
}
}
}
function castVote(voteType) {
if (!currentModalPlayer) return;
const playerName = currentModalPlayer.name;
const userId = getUserId();
if (!firebaseInitialized) {
console.error('Firebase not initialized - voting disabled');
alert('Voting system temporarily unavailable. Please try again later.');
return;
}
const previousVote = userVoteCache[playerName];
if (previousVote === voteType) {
const votesRef = database.ref('votes/' + playerName + '/' + previousVote);
const userVoteRef = database.ref('userVotes/' + userId + '/' + playerName);
if (playerVotes[playerName]) {
playerVotes[playerName][previousVote] = Math.max(0, (playerVotes[playerName][previousVote] || 0) - 1);
playerVotes[playerName].lastVote = Date.now();
}
delete userVoteCache[playerName];
updateModalSentiment(playerName);
refreshPlayerCards();
votesRef.transaction((currentCount) => {
return Math.max(0, (currentCount || 0) - 1);
}).then(() => {
return userVoteRef.remove();
}).then(() => {
return database.ref('votes/' + playerName + '/lastVote').set(Date.now());
}).then(() => {
console.log('âœ… Vote removed successfully and synced to Firebase');
}).catch((error) => {
console.error('Error removing vote:', error);
if (playerVotes[playerName]) {
playerVotes[playerName][previousVote] = (playerVotes[playerName][previousVote] || 0) + 1;
}
userVoteCache[playerName] = previousVote;
updateModalSentiment(playerName);
refreshPlayerCards();
});
return; // Exit early
}
if (!playerVotes[playerName]) {
playerVotes[playerName] = { buy: 0, sell: 0, hold: 0, lastVote: Date.now() };
}
if (previousVote) {
playerVotes[playerName][previousVote] = Math.max(0, (playerVotes[playerName][previousVote] || 0) - 1);
}
playerVotes[playerName][voteType] = (playerVotes[playerName][voteType] || 0) + 1;
playerVotes[playerName].lastVote = Date.now();
userVoteCache[playerName] = voteType;
updateModalSentiment(playerName);
refreshPlayerCards();
if (previousVote) {
const prevVoteRef = database.ref('votes/' + playerName + '/' + previousVote);
prevVoteRef.transaction((currentCount) => {
return Math.max(0, (currentCount || 0) - 1);
});
}
const newVoteRef = database.ref('votes/' + playerName + '/' + voteType);
newVoteRef.transaction((currentCount) => {
return (currentCount || 0) + 1;
}).then(() => {
return database.ref('userVotes/' + userId + '/' + playerName).set(voteType);
}).then(() => {
return database.ref('votes/' + playerName + '/lastVote').set(Date.now());
}).then(() => {
console.log('âœ… Vote synced to Firebase successfully');
}).catch((error) => {
console.error('âŒ Error syncing vote to Firebase:', error);
if (playerVotes[playerName]) {
playerVotes[playerName][voteType] = Math.max(0, (playerVotes[playerName][voteType] || 0) - 1);
if (previousVote) {
playerVotes[playerName][previousVote] = (playerVotes[playerName][previousVote] || 0) + 1;
}
}
if (previousVote) {
userVoteCache[playerName] = previousVote;
} else {
delete userVoteCache[playerName];
}
updateModalSentiment(playerName);
refreshPlayerCards();
alert('Failed to save vote. Please try again.');
});
}
function refreshPlayerCards() {
const currentPage = document.querySelector('.page.active');
if (currentPage) {
const pageId = currentPage.id;
console.log('ðŸ”„ Refreshing player cards for page:', pageId);
if (pageId === 'wide-receivers') {
renderWRPlayerCards();
} else if (pageId === 'running-backs') {
renderRBPlayerCards();
} else if (pageId === 'tight-ends') {
renderTEPlayerCards();
} else {
console.log(' No player cards to refresh on this page');
}
} else {
console.log(' No active page found, skipping refresh');
}
}
function loadComments(playerName) {
if (!playerComments[playerName]) {
playerComments[playerName] = [];
}
const commentList = document.getElementById('comment-list');
const comments = playerComments[playerName].sort((a, b) => b.timestamp - a.timestamp);
if (comments.length === 0) {
commentList.innerHTML = '<div style="color: var(--text-secondary); font-size: 13px; text-align: center; padding: 20px;">No comments yet. Be the first!</div>';
return;
}
commentList.innerHTML = comments.slice(0, 10).map(comment => {
const timeAgo = getTimeAgo(comment.timestamp);
return `
<div class="comment-item"><div>${comment.text}</div><div class="comment-meta">${timeAgo}</div></div>
`;
}).join('');
const input = document.getElementById('comment-input');
input.onkeypress = function(e) {
if (e.key === 'Enter') {
submitComment();
}
};
}
function submitComment() {
if (!currentModalPlayer) return;
const input = document.getElementById('comment-input');
const text = input.value.trim();
if (!text) return;
const playerName = currentModalPlayer.name;
if (!playerComments[playerName]) {
playerComments[playerName] = [];
}
playerComments[playerName].push({
text: text,
timestamp: Date.now(),
user: 'Anonymous' // Could be enhanced with user system
});
localStorage.setItem('ffse_player_comments', JSON.stringify(playerComments));
input.value = '';
loadComments(playerName);
}
function getTimeAgo(timestamp) {
const seconds = Math.floor((Date.now() - timestamp) / 1000);
if (seconds < 60) return 'Just now';
if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
if (seconds < 86400) return Math.floor(seconds / 3600) + 'h ago';
return Math.floor(seconds / 86400) + 'd ago';
}
function closeModal() {
document.getElementById('player-modal').classList.remove('active');
if (modalVarianceChart) modalVarianceChart.destroy();
if (modalOutcomesChart) modalOutcomesChart.destroy();
if (modalSpiderChart) modalSpiderChart.destroy();
if (modalShareChart) modalShareChart.destroy();
if (modalTrendsChart) modalTrendsChart.destroy();
if (window.innerWidth <= 768) {
statsCurrentPage = 0;
updateStatsPage();
}
}
let statsCurrentPage = 0;
let statsStartX = 0;
let statsCurrentX = 0;
let statsStartY = 0;
let statsDragging = false;
function initStatsSwipe() {
const wrapper = document.getElementById('modal-stats-wrapper');
if (!wrapper || window.innerWidth > 768) return; // Desktop - no swipe
wrapper.addEventListener('touchstart', handleStatsStart, { passive: true });
wrapper.addEventListener('touchmove', handleStatsMove, { passive: false });
wrapper.addEventListener('touchend', handleStatsEnd, { passive: true });
wrapper.addEventListener('mousedown', handleStatsStart);
wrapper.addEventListener('mousemove', handleStatsMove);
wrapper.addEventListener('mouseup', handleStatsEnd);
wrapper.addEventListener('mouseleave', handleStatsEnd);
document.querySelectorAll('.stats-dot').forEach(dot => {
dot.addEventListener('click', () => {
statsCurrentPage = parseInt(dot.dataset.page);
updateStatsPage();
});
});
}
function handleStatsStart(e) {
if (window.innerWidth > 768) return;
statsDragging = true;
statsStartX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
statsStartY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
statsCurrentX = statsStartX;
}
function handleStatsMove(e) {
if (!statsDragging || window.innerWidth > 768) return;
const currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
const diffX = Math.abs(currentX - statsStartX);
const diffY = Math.abs(currentY - statsStartY);
if (diffX > diffY && diffX > 10) {
e.preventDefault();
statsCurrentX = currentX;
const diff = statsCurrentX - statsStartX;
const wrapper = document.getElementById('modal-stats-wrapper');
const currentTranslate = -statsCurrentPage * 100;
const dragPercent = (diff / wrapper.offsetWidth) * 100;
wrapper.style.transform = `translateX(${currentTranslate + dragPercent}%)`;
} else if (diffY > 10) {
statsDragging = false;
}
}
function handleStatsEnd(e) {
if (!statsDragging || window.innerWidth > 768) return;
statsDragging = false;
const diff = statsCurrentX - statsStartX;
const threshold = 50; // pixels
if (diff > threshold && statsCurrentPage > 0) {
statsCurrentPage--;
} else if (diff < -threshold && statsCurrentPage < 1) {
statsCurrentPage++;
}
updateStatsPage();
}
function updateStatsPage() {
const wrapper = document.getElementById('modal-stats-wrapper');
if (!wrapper) return;
wrapper.style.transform = `translateX(-${statsCurrentPage * 100}%)`;
document.querySelectorAll('.stats-dot').forEach((dot, index) => {
dot.classList.toggle('active', index === statsCurrentPage);
});
}
function switchModalChart(chartName) {
document.querySelectorAll('.chart-tab').forEach(tab => tab.classList.remove('active'));
event.target.classList.add('active');
document.querySelectorAll('.chart-content').forEach(content => content.classList.remove('active'));
document.getElementById(`modal-chart-${chartName}`).classList.add('active');
}
function toggleSpiderExplanation() {
const explanation = document.getElementById('spider-explanation');
const icon = document.getElementById('spider-explanation-icon');
if (explanation.style.display === 'none') {
explanation.style.display = 'block';
icon.textContent = 'â–¼';
} else {
explanation.style.display = 'none';
icon.textContent = 'â„¹ï¸';
}
}
function toggleStatsCollapse() {
const container = document.getElementById('modal-stats-container');
const icon = document.getElementById('stats-collapse-icon');
const text = document.getElementById('stats-collapse-text');
if (container.style.display === 'none') {
container.style.display = '';
icon.textContent = 'â–¼';
text.textContent = 'Hide Stats';
} else {
container.style.display = 'none';
icon.textContent = 'â–¶';
text.textContent = 'Show Stats';
}
}
function toggleTeamPlayers() {
const container = document.getElementById('key-players-section');
const icon = document.getElementById('team-players-collapse-icon');
const text = document.getElementById('team-players-collapse-text');
if (container.style.display === 'none') {
container.style.display = '';
icon.textContent = 'â–¼';
text.textContent = 'Hide Players';
} else {
container.style.display = 'none';
icon.textContent = 'â–¶';
text.textContent = 'Show Players';
}
}
function renderModalVarianceChart(player) {
const ctx = document.getElementById('modal-variance-chart');
if (modalVarianceChart) {
modalVarianceChart.destroy();
}
const weeks = player.weeks.map(w => `W${w.week}`);
const actuals = player.weeks.map(w => w.fpts);
const expected = player.weeks.map(w => w.expectedFpts);
const variance = player.weeks.map(w => w.variance);
modalVarianceChart = new Chart(ctx, {
type: 'bar',
data: {
labels: weeks,
datasets: [
{
type: 'line',
label: 'Actual',
data: actuals,
borderColor: '#fff',
borderWidth: 2,
fill: false,
pointRadius: 4,
pointBackgroundColor: '#fff',
yAxisID: 'y'
},
{
type: 'line',
label: 'Expected',
data: expected,
borderColor: '#8e8e93',
borderDash: [5, 5],
borderWidth: 2,
fill: false,
pointRadius: 4,
pointBackgroundColor: '#8e8e93',
yAxisID: 'y'
},
{
type: 'bar',
label: 'Variance',
data: variance,
backgroundColor: variance.map(v =>
v >= 0 ? 'rgba(48, 209, 88, 0.6)' : 'rgba(255, 69, 58, 0.6)'
),
yAxisID: 'y1'
}
]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: {
legend: {
display: true,
labels: { color: '#8e8e93' }
}
},
scales: {
y: {
type: 'linear',
position: 'left',
title: {
display: true,
text: 'Fantasy Points',
color: '#8e8e93'
},
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
},
y1: {
type: 'linear',
position: 'right',
title: {
display: true,
text: 'Variance',
color: '#8e8e93'
},
grid: { display: false },
ticks: { color: '#8e8e93' }
},
x: {
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
}
}
}
});
}
function renderModalOutcomesChart(player, showAllWeeks = false) {
const ctx = document.getElementById('modal-outcomes-chart');
if (modalOutcomesChart) {
modalOutcomesChart.destroy();
}

// Mobile detection
const isMobile = window.innerWidth <= 768;

// Get weeks data
let weeksToShow = player.weeks;
let isLimited = false;

// On mobile, show only last 4 weeks unless showAllWeeks is true
if (isMobile && !showAllWeeks && player.weeks.length > 4) {
weeksToShow = player.weeks.slice(-4);
isLimited = true;
}

const teamColor = teamColors[player.team] || '#0a84ff';
const teamColorRgba = hexToRgba(teamColor, 0.1);
const variances = weeksToShow.map(w => w.variance);
const avgVariance = variances.reduce((sum, v) => sum + v, 0) / variances.length;
const weeksOverExpected = variances.filter(v => v > 0).length;
const consistency = (weeksOverExpected / variances.length * 100).toFixed(0);
const weeks = weeksToShow.map(w => `W${w.week}`);
const actuals = weeksToShow.map(w => w.fpts);
const expected = weeksToShow.map(w => w.expectedFpts);

// Add toggle button for mobile if data is limited
const chartWrapper = ctx.parentElement;
let toggleBtn = chartWrapper.parentElement.querySelector('.mobile-weeks-toggle');
if (isMobile && player.weeks.length > 4) {
if (!toggleBtn) {
toggleBtn = document.createElement('button');
toggleBtn.className = 'mobile-weeks-toggle';
toggleBtn.style.cssText = 'width: 100%; padding: 10px; margin-top: 16px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s;';
chartWrapper.parentElement.appendChild(toggleBtn);
}
toggleBtn.textContent = showAllWeeks ? `Show Last 4 Weeks` : `Show All ${player.weeks.length} Weeks`;
toggleBtn.onclick = () => renderModalOutcomesChart(player, !showAllWeeks);
toggleBtn.style.display = 'block';
} else if (toggleBtn) {
toggleBtn.style.display = 'none';
}

modalOutcomesChart = new Chart(ctx, {
type: 'line',
data: {
labels: weeks,
datasets: [
{
label: 'Actual',
data: actuals,
borderColor: teamColor,
backgroundColor: teamColorRgba,
borderWidth: 3,
fill: true,
tension: 0.3,
pointRadius: 5,
pointBackgroundColor: teamColor,
pointBorderColor: '#fff',
pointBorderWidth: 2
},
{
label: 'Expected',
data: expected,
borderColor: '#8e8e93',
borderDash: [5, 5],
borderWidth: 2,
fill: false,
tension: 0.3,
pointRadius: 4,
pointBackgroundColor: '#8e8e93'
}
]
},
options: {
responsive: true,
maintainAspectRatio: false,
interaction: {
mode: 'index',
intersect: false
},
plugins: {
legend: {
display: true,
labels: {
color: '#8e8e93',
font: { size: 12 },
usePointStyle: true,
pointStyle: 'line'
}
},
title: {
display: true,
text: [
`Avg ${avgVariance >= 0 ? '+' : ''}${avgVariance.toFixed(1)} vs Expected`,
`Beats Expectations: ${consistency}% of weeks (${weeksOverExpected}/${variances.length})`
],
color: avgVariance >= 0 ? '#30d158' : '#ff453a',
padding: { bottom: 15 },
font: { size: 13, weight: '600' }
},
tooltip: {
backgroundColor: 'rgba(0, 0, 0, 0.9)',
titleColor: '#fff',
bodyColor: '#fff',
borderColor: teamColor,
borderWidth: 1,
padding: 12,
displayColors: true, // Show color boxes
callbacks: {
title: function(context) {
const actualIndex = isMobile && isLimited ? context[0].dataIndex + (player.weeks.length - 4) : context[0].dataIndex;
return `Week ${player.weeks[actualIndex].week}`;
},
label: function(context) {
const actualIndex = isMobile && isLimited ? context.dataIndex + (player.weeks.length - 4) : context.dataIndex;
const week = player.weeks[actualIndex];
const datasetIndex = context.datasetIndex;

// Show Actual and Expected with their values
if (datasetIndex === 0) {
return `Actual: ${week.fpts.toFixed(1)} pts`;
} else if (datasetIndex === 1) {
return `Expected: ${week.expectedFpts.toFixed(1)} pts`;
}
},
afterBody: function(context) {
// Add detailed stats after both labels
const actualIndex = isMobile && isLimited ? context[0].dataIndex + (player.weeks.length - 4) : context[0].dataIndex;
const week = player.weeks[actualIndex];
const position = player.position;
const lines = ['']; // One blank line for spacing

// Position-specific stats
if (position === 'RB') {
lines.push(`Rush Att: ${week.rushAttempts || 0}`);
lines.push(`Rush Yds: ${Math.round(week.rushYards || 0)}`);
lines.push(`Targets: ${week.targets || 0}`);
lines.push(`Rec: ${week.receptions || 0}`);
lines.push(`Rec Yds: ${Math.round(week.recYards || 0)}`);
lines.push(`Total TDs: ${(week.rec_td || 0) + (week.rush_td || 0)}`);
} else if (position === 'WR' || position === 'TE') {
lines.push(`Rush Att: ${week.rushAttempts || week.carries || 0}`);
lines.push(`Rush Yds: ${Math.round(week.rushYards || 0)}`);
lines.push(`Targets: ${week.targets || 0}`);
lines.push(`Rec: ${week.receptions || 0}`);
lines.push(`Rec Yds: ${Math.round(week.recYards || week.yds || 0)}`);
lines.push(`Total TDs: ${(week.rec_td || 0) + (week.rush_td || 0)}`);
}

return lines;
}
}
}
},
scales: {
y: {
title: {
display: true,
text: 'Fantasy Points',
color: '#8e8e93'
},
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
},
x: {
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
}
}
}
});
}
function hexToRgba(hex, alpha) {
const r = parseInt(hex.slice(1, 3), 16);
const g = parseInt(hex.slice(3, 5), 16);
const b = parseInt(hex.slice(5, 7), 16);
return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}
function renderModalSpiderChart(player) {
const ctx = document.getElementById('modal-spider-chart');
if (modalSpiderChart) {
modalSpiderChart.destroy();
modalSpiderChart = null;
}
const teamColor = teamColors[player.team] || '#0a84ff';
const teamColorRgba = hexToRgba(teamColor, 0.2);
const allPlayers = player.position === 'WR' ?
Object.values(window.aggregatedWRs).filter(p => p.gamesPlayed >= 3) :
player.position === 'RB' ?
Object.values(window.aggregatedRBs).filter(p => p.gamesPlayed >= 3) :
Object.values(window.aggregatedTEs).filter(p => p.gamesPlayed >= 3);
let metrics = {};
let rankings = {};
if (player.position === 'WR') {
const targetsPerGameData = allPlayers.map(p => ({
player: p,
value: p.totalTargets / p.gamesPlayed
})).sort((a, b) => b.value - a.value);
const efficiencyData = allPlayers.map(p => ({
player: p,
value: p.avgPoints / (p.totalTargets / p.gamesPlayed) // pts per target
})).sort((a, b) => b.value - a.value);
const redZoneData = allPlayers.map(p => ({
player: p,
value: p.rzOpportunities / p.gamesPlayed
})).sort((a, b) => b.value - a.value);
const teamShareData = allPlayers.map(p => ({
player: p,
value: p.latestWeekOppShare || 0
})).sort((a, b) => b.value - a.value);
const catchRateData = allPlayers.map(p => {
const playerRows = wrData.filter(row => row.Team === p.team && row.Player === p.name);
let totalReceptions = 0;
let totalTargets = 0;
playerRows.forEach(row => {
totalReceptions += parseFloat(row.REC) || 0;
totalTargets += parseFloat(row.TGT) || 0;
});
const catchRate = totalTargets > 0 ? (totalReceptions / totalTargets) * 100 : 0;
return { player: p, value: catchRate };
}).sort((a, b) => b.value - a.value);
rankings = {
'Volume': targetsPerGameData.findIndex(p => p.player.id === player.id) + 1,
'Efficiency': efficiencyData.findIndex(p => p.player.id === player.id) + 1,
'Red Zone': redZoneData.findIndex(p => p.player.id === player.id) + 1,
'Team Share': teamShareData.findIndex(p => p.player.id === player.id) + 1,
'Catch Rate': catchRateData.findIndex(p => p.player.id === player.id) + 1
};
} else if (player.position === 'RB') {
const oppsPerGameData = allPlayers.map(p => ({
player: p,
value: p.totalOpportunities / p.gamesPlayed
})).sort((a, b) => b.value - a.value);
const efficiencyData = allPlayers.map(p => ({
player: p,
value: p.avgPoints / (p.totalOpportunities / p.gamesPlayed) // pts per opp
})).sort((a, b) => b.value - a.value);
const redZoneData = allPlayers.map(p => ({
player: p,
value: p.rzOpportunities / p.gamesPlayed
})).sort((a, b) => b.value - a.value);
const teamShareData = allPlayers.map(p => ({
player: p,
value: p.latestWeekOppShare || 0
})).sort((a, b) => b.value - a.value);
const yacData = allPlayers.map(p => {
const playerRows = rbData.filter(row => row.Team === p.team && row.Player === p.name);
let totalYACON = 0;
let totalATT = 0;
playerRows.forEach(row => {
totalYACON += parseFloat(row.YACON) || 0;
totalATT += parseFloat(row.ATT) || 0;
});
const yacPerAtt = totalATT > 0 ? totalYACON / totalATT : 0;
return { player: p, value: yacPerAtt };
}).sort((a, b) => b.value - a.value);
rankings = {
'Volume': oppsPerGameData.findIndex(p => p.player.id === player.id) + 1,
'Efficiency': efficiencyData.findIndex(p => p.player.id === player.id) + 1,
'Red Zone': redZoneData.findIndex(p => p.player.id === player.id) + 1,
'Team Share': teamShareData.findIndex(p => p.player.id === player.id) + 1,
'Yards After Contact': yacData.findIndex(p => p.player.id === player.id) + 1
};
} else if (player.position === 'TE') {
const targetsPerGameData = allPlayers.map(p => ({
player: p,
value: p.totalTargets / p.gamesPlayed
})).sort((a, b) => b.value - a.value);
const efficiencyData = allPlayers.map(p => ({
player: p,
value: p.avgPoints / (p.totalTargets / p.gamesPlayed) // pts per target
})).sort((a, b) => b.value - a.value);
const redZoneData = allPlayers.map(p => ({
player: p,
value: p.rzOpportunities / p.gamesPlayed
})).sort((a, b) => b.value - a.value);
const teamShareData = allPlayers.map(p => ({
player: p,
value: p.latestWeekOppShare || 0
})).sort((a, b) => b.value - a.value);
const catchRateData = allPlayers.map(p => {
const playerRows = teData.filter(row => row.Team === p.team && row.Player === p.name);
let totalReceptions = 0;
let totalTargets = 0;
playerRows.forEach(row => {
totalReceptions += parseFloat(row.REC) || 0;
totalTargets += parseFloat(row.TGT) || 0;
});
const catchRate = totalTargets > 0 ? (totalReceptions / totalTargets) * 100 : 0;
return { player: p, value: catchRate };
}).sort((a, b) => b.value - a.value);
rankings = {
'Volume': targetsPerGameData.findIndex(p => p.player.id === player.id) + 1,
'Efficiency': efficiencyData.findIndex(p => p.player.id === player.id) + 1,
'Red Zone': redZoneData.findIndex(p => p.player.id === player.id) + 1,
'Team Share': teamShareData.findIndex(p => p.player.id === player.id) + 1,
'Catch Rate': catchRateData.findIndex(p => p.player.id === player.id) + 1
};
}
const isTop200 = Object.values(rankings).every(rank => rank <= 200);
if (!isTop200) {
if (ctx) {
const context = ctx.getContext('2d');
if (context) {
context.clearRect(0, 0, ctx.width, ctx.height);
context.fillStyle = '#8e8e93';
context.font = '14px -apple-system, BlinkMacSystemFont, SF Pro Display';
context.textAlign = 'center';
context.fillText('Player Profile Not Available', ctx.width / 2, ctx.height / 2 - 10);
context.fillText('Rankings shown for Top 200 players only', ctx.width / 2, ctx.height / 2 + 10);
}
}
return;
}
const labels = Object.keys(rankings);
const data = labels.map(label => {
const rank = rankings[label];
return Math.max(0.5, 100 - ((rank - 1) / 199 * 99.5));
});
modalSpiderChart = new Chart(ctx, {
type: 'radar',
data: {
labels: labels,
datasets: [{
label: player.name,
data: data,
backgroundColor: teamColorRgba,
borderColor: teamColor,
borderWidth: 3,
pointBackgroundColor: teamColor,
pointBorderColor: '#fff',
pointHoverBackgroundColor: '#fff',
pointHoverBorderColor: teamColor,
pointRadius: 5,
pointHoverRadius: 7,
pointBorderWidth: 2
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
animation: false,
plugins: {
legend: { display: false },
title: {
display: true,
text: 'Rankings vs Top 200 (Higher = Better Rank)',
color: '#8e8e93',
font: { size: 12 }
},
tooltip: {
callbacks: {
label: function(context) {
const rank = rankings[context.label];
const score = context.parsed.r.toFixed(0);
return `${context.label}: #${rank} (Score: ${score}/100)`;
}
}
}
},
scales: {
r: {
beginAtZero: true,
min: 0,
max: 100,
ticks: {
stepSize: 20,
color: getThemeColors().textSecondary,
backdropColor: 'transparent',
font: { size: 10 }
},
grid: {
color: getThemeColors().grid
},
pointLabels: {
color: getThemeColors().text,
font: {
size: 12,
weight: 'bold'
}
},
angleLines: {
color: getThemeColors().grid
}
}
}
}
});
}
function renderModalPRSChart(player) {
const ctx = document.getElementById('prs-gauge-chart');
if (!ctx) return;
const positionPlayers = Object.values(allPlayers).filter(p =>
p.position === player.position && p.gamesPlayed >= 3 && p.weeks && p.weeks.length > 0
);
if (positionPlayers.length < 2) {
console.warn(`Not enough ${player.position} players with valid data for PRS calculation`);
document.getElementById('prs-usage-value').textContent = '--';
document.getElementById('prs-rz-value').textContent = '--';
document.getElementById('prs-consistency-value').textContent = '--';
document.getElementById('prs-games-value').textContent = '--';
document.getElementById('prs-score-value').textContent = '--';
return;
}
if (!player.weeks || player.weeks.length === 0) {
console.warn(`No week data available for ${player.name} - cannot calculate PRS`);
document.getElementById('prs-usage-value').textContent = '--';
document.getElementById('prs-rz-value').textContent = '--';
document.getElementById('prs-consistency-value').textContent = '--';
document.getElementById('prs-games-value').textContent = '--';
document.getElementById('prs-score-value').textContent = '--';
return;
}
let usageShare = player.weeks.reduce((sum, w) => sum + (w.usageShare || 0), 0) / player.weeks.length;
let rzShare = player.weeks.reduce((sum, w) => sum + (w.rzShare || 0), 0) / player.weeks.length;
if (usageShare === 0 || rzShare === 0) {
console.warn(`${player.name} missing usageShare/rzShare in CSV, using calculated values`);
if (usageShare === 0) {
if (player.position === 'WR' || player.position === 'TE') {
const avgTeamShare = player.weeks.reduce((sum, w) => sum + (w.teamShare || 0), 0) / player.weeks.length;
usageShare = avgTeamShare;
console.log(` â†³ Calculated usageShare from teamShare: ${usageShare.toFixed(1)}%`);
} else {
usageShare = player.latestWeekOppShare || 0;
console.log(` â†³ Using RB latestWeekOppShare: ${usageShare.toFixed(1)}%`);
}
}
if (rzShare === 0 && player.rzOpportunities > 0 && player.teamRzOpportunities > 0) {
rzShare = (player.rzOpportunities / player.teamRzOpportunities) * 100;
console.log(` â†³ Calculated rzShare from opportunities: ${rzShare.toFixed(1)}%`);
}
}
const fpVariance = player.weeks.reduce((sum, w) => sum + (w.variance || 0), 0) / player.weeks.length;
console.log(`PRS Debug for ${player.name}:`, {
position: player.position,
avgPoints: player.avgPoints,
usageShare: usageShare,
usageScore: usageShare * player.avgPoints,
rzShare: rzShare,
rzScore: rzShare * player.avgPoints,
fpVariance: fpVariance,
weeksData: player.weeks.length,
sampleWeek: player.weeks[0] || null,
hasUsageShare: player.weeks.some(w => w.usageShare > 0),
hasRzShare: player.weeks.some(w => w.rzShare > 0)
});
const maxGames = Math.max(...positionPlayers.map(p => p.gamesPlayed));
const gamesPlayedPct = player.gamesPlayed / maxGames;
const usageValues = positionPlayers.map(p => {
const avgUsage = p.weeks.reduce((sum, w) => sum + (w.usageShare || 0), 0) / p.weeks.length;
return avgUsage * p.avgPoints; // Weight usage by production
});
const minUsage = Math.min(...usageValues);
const maxUsage = Math.max(...usageValues);
const playerUsageScore = usageShare * player.avgPoints;
const usageNorm = maxUsage > minUsage ? (playerUsageScore - minUsage) / (maxUsage - minUsage) : 0;
const rzValues = positionPlayers.map(p => {
const avgRZ = p.weeks.reduce((sum, w) => sum + (w.rzShare || 0), 0) / p.weeks.length;
return avgRZ * p.avgPoints; // Weight RZ share by production
});
const minRZ = Math.min(...rzValues);
const maxRZ = Math.max(...rzValues);
const playerRZScore = rzShare * player.avgPoints;
const rzNorm = maxRZ > minRZ ? (playerRZScore - minRZ) / (maxRZ - minRZ) : 0;
const floorReliabilityValues = positionPlayers.map(p => {
let hitCount = 0;
let totalDiff = 0;
let validWeeks = 0;
p.weeks.forEach(w => {
if (w.expectedFpts > 0 && w.fpts !== undefined) {
const diff = w.fpts - w.expectedFpts;
const diffPct = diff / w.expectedFpts;
const threshold = p.avgPoints >= 14 ? -0.15 : -0.10;
if (diffPct >= threshold) {
hitCount++;
}
totalDiff += diffPct;
validWeeks++;
}
});
if (validWeeks === 0) return 0;
const hitRate = hitCount / validWeeks;
const avgDiffPct = totalDiff / validWeeks;
const expectedBonus = p.avgPoints >= 14 ? 0.15 : 0;
const diffComponent = Math.min(0.50, Math.max(0, avgDiffPct + 0.25));
return (0.60 * hitRate) + (0.40 * diffComponent) + expectedBonus;
});
const minFloor = Math.min(...floorReliabilityValues);
const maxFloor = Math.max(...floorReliabilityValues);
let playerHitCount = 0;
let playerTotalDiff = 0;
let playerValidWeeks = 0;
const playerThreshold = player.avgPoints >= 14 ? -0.15 : -0.10;
player.weeks.forEach(w => {
if (w.expectedFpts > 0 && w.fpts !== undefined) {
const diff = w.fpts - w.expectedFpts;
const diffPct = diff / w.expectedFpts;
if (diffPct >= playerThreshold) {
playerHitCount++;
}
playerTotalDiff += diffPct;
playerValidWeeks++;
}
});
let consistencyNorm = 0;
if (playerValidWeeks > 0) {
const playerHitRate = playerHitCount / playerValidWeeks;
const playerAvgDiffPct = playerTotalDiff / playerValidWeeks;
const playerExpectedBonus = player.avgPoints >= 14 ? 0.15 : 0;
const playerDiffComponent = Math.min(0.50, Math.max(0, playerAvgDiffPct + 0.25));
const playerFloorScore = (0.60 * playerHitRate) + (0.40 * playerDiffComponent) + playerExpectedBonus;
consistencyNorm = maxFloor > minFloor ? (playerFloorScore - minFloor) / (maxFloor - minFloor) : 0;
console.log(`PRS Debug for ${player.name}:`, {
position: player.position,
avgPoints: player.avgPoints,
validWeeks: playerValidWeeks,
hitCount: playerHitCount,
hitRate: (playerHitRate * 100).toFixed(1) + '%',
avgDiffPct: (playerAvgDiffPct * 100).toFixed(1) + '%',
expectedBonus: playerExpectedBonus,
rawFloorScore: playerFloorScore.toFixed(3),
minFloorInPosition: minFloor.toFixed(3),
maxFloorInPosition: maxFloor.toFixed(3),
normalizedScore: consistencyNorm.toFixed(3),
finalScore: Math.round(consistencyNorm * 100)
});
} else {
console.log(`PRS Debug for ${player.name}:`, {
position: player.position,
avgPoints: player.avgPoints,
validWeeks: 0,
floorReliabilityScore: 'N/A - no valid weeks'
});
}
let prsRaw;
if (player.position === 'WR') {
prsRaw = (0.40 * usageNorm) + (0.20 * rzNorm) + (0.30 * consistencyNorm) + (0.10 * gamesPlayedPct);
} else {
prsRaw = (0.40 * usageNorm) + (0.30 * rzNorm) + (0.20 * consistencyNorm) + (0.10 * gamesPlayedPct);
}
const prs = Math.round(prsRaw * 100);
if (player.position === 'WR') {
document.getElementById('prs-usage-weight').textContent = '40%';
document.getElementById('prs-rz-weight').textContent = '20%';
document.getElementById('prs-consistency-weight').textContent = '30%';
document.getElementById('prs-games-weight').textContent = '10%';
} else {
document.getElementById('prs-usage-weight').textContent = '40%';
document.getElementById('prs-rz-weight').textContent = '30%';
document.getElementById('prs-consistency-weight').textContent = '20%';
document.getElementById('prs-games-weight').textContent = '10%';
}
function getScoreColor(score) {
if (score >= 80) return '#30d158'; // Green (high)
if (score >= 60) return '#0a84ff'; // Blue (high-middle)
if (score >= 40) return '#ffd60a'; // Yellow (low-middle)
return '#ff453a'; // Red (low)
}
const usageScore = Math.round(usageNorm * 100);
const rzScore = Math.round(rzNorm * 100);
const consistencyScore = Math.round(consistencyNorm * 100);
const gamesScore = Math.round(gamesPlayedPct * 100);
console.log(`PRS Scores for ${player.name} (${player.position}):`, {
usage: usageScore,
rz: rzScore,
consistency: consistencyScore,
games: gamesScore,
isMobile: window.innerWidth <= 768
});
const usageColor = getScoreColor(usageScore);
const usageValueEl = document.getElementById('prs-usage-value');
const usageBarEl = document.getElementById('prs-usage-bar');
if (usageValueEl && usageBarEl) {
const valueText = usageScore + '/100';
usageValueEl.textContent = valueText;
usageValueEl.innerHTML = valueText;
usageValueEl.setAttribute('data-value', valueText);
usageValueEl.setAttribute('aria-label', valueText);
usageValueEl.style.setProperty('color', usageColor, 'important');
usageValueEl.style.setProperty('display', 'block', 'important');
usageValueEl.style.setProperty('visibility', 'visible', 'important');
usageValueEl.style.setProperty('font-size', '16px', 'important');
usageValueEl.style.setProperty('opacity', '1', 'important');
usageValueEl.style.setProperty('height', 'auto', 'important');
usageValueEl.style.setProperty('width', 'auto', 'important');
usageValueEl.style.setProperty('position', 'relative', 'important');
usageBarEl.style.background = usageColor;
usageBarEl.style.width = usageScore + '%';
console.log(`âœ“ Usage value set: ${valueText}, innerHTML: ${usageValueEl.innerHTML}, textContent: ${usageValueEl.textContent}`);
setTimeout(() => {
usageValueEl.textContent = valueText;
usageValueEl.innerHTML = valueText;
console.log(`ðŸ”„ Re-applied usage (100ms): ${usageValueEl.textContent}`);
}, 100);
setTimeout(() => {
usageValueEl.textContent = valueText;
usageValueEl.innerHTML = valueText;
console.log(`ðŸ”„ðŸ”„ Re-applied usage (500ms): ${usageValueEl.textContent}`);
}, 500);
setTimeout(() => {
usageValueEl.textContent = valueText;
usageValueEl.innerHTML = valueText;
console.log(`ðŸ”„ðŸ”„ðŸ”„ Re-applied usage (1000ms): ${usageValueEl.textContent}`);
}, 1000);
} else {
console.warn('âš ï¸ PRS usage elements not found in DOM');
}
const rzColor = getScoreColor(rzScore);
const rzValueEl = document.getElementById('prs-rz-value');
const rzBarEl = document.getElementById('prs-rz-bar');
if (rzValueEl && rzBarEl) {
const valueText = rzScore + '/100';
rzValueEl.textContent = valueText;
rzValueEl.innerHTML = valueText;
rzValueEl.setAttribute('data-value', valueText);
rzValueEl.setAttribute('aria-label', valueText);
rzValueEl.style.setProperty('color', rzColor, 'important');
rzValueEl.style.setProperty('display', 'block', 'important');
rzValueEl.style.setProperty('visibility', 'visible', 'important');
rzValueEl.style.setProperty('font-size', '16px', 'important');
rzValueEl.style.setProperty('opacity', '1', 'important');
rzValueEl.style.setProperty('height', 'auto', 'important');
rzValueEl.style.setProperty('width', 'auto', 'important');
rzValueEl.style.setProperty('position', 'relative', 'important');
rzBarEl.style.background = rzColor;
rzBarEl.style.width = rzScore + '%';
console.log(`âœ“ RZ value set: ${valueText}, innerHTML: ${rzValueEl.innerHTML}, textContent: ${rzValueEl.textContent}`);
setTimeout(() => {
rzValueEl.textContent = valueText;
rzValueEl.innerHTML = valueText;
console.log(`ðŸ”„ Re-applied RZ (100ms): ${rzValueEl.textContent}`);
}, 100);
setTimeout(() => {
rzValueEl.textContent = valueText;
rzValueEl.innerHTML = valueText;
console.log(`ðŸ”„ðŸ”„ Re-applied RZ (500ms): ${rzValueEl.textContent}`);
}, 500);
setTimeout(() => {
rzValueEl.textContent = valueText;
rzValueEl.innerHTML = valueText;
console.log(`ðŸ”„ðŸ”„ðŸ”„ Re-applied RZ (1000ms): ${rzValueEl.textContent}`);
}, 1000);
} else {
console.warn('âš ï¸ PRS RZ elements not found in DOM');
}
const consistencyColor = getScoreColor(consistencyScore);
const consistencyValueEl = document.getElementById('prs-consistency-value');
const consistencyBarEl = document.getElementById('prs-consistency-bar');
if (consistencyValueEl && consistencyBarEl) {
consistencyValueEl.textContent = consistencyScore + '/100';
consistencyValueEl.style.color = consistencyColor;
consistencyBarEl.style.background = consistencyColor;
consistencyBarEl.style.width = consistencyScore + '%';
} else {
console.warn('âš ï¸ PRS consistency elements not found in DOM');
}
const gamesColor = getScoreColor(gamesScore);
const gamesValueEl = document.getElementById('prs-games-value');
const gamesBarEl = document.getElementById('prs-games-bar');
if (gamesValueEl && gamesBarEl) {
gamesValueEl.textContent = gamesScore + '/100';
gamesValueEl.style.color = gamesColor;
gamesBarEl.style.background = gamesColor;
gamesBarEl.style.width = gamesScore + '%';
} else {
console.warn('âš ï¸ PRS games elements not found in DOM');
}
if (window.modalPRSGauge) {
window.modalPRSGauge.destroy();
}
let gaugeColor = '#30d158'; // Green
if (prs < 40) {
gaugeColor = '#ff453a'; // Red
} else if (prs < 70) {
gaugeColor = '#ffd60a'; // Yellow
}
const isDarkMode = !document.documentElement.getAttribute('data-theme') || document.documentElement.getAttribute('data-theme') === 'dark';
const bgColor = isDarkMode ? '#1c1c1e' : '#eceae5';
window.modalPRSGauge = new Chart(ctx, {
type: 'doughnut',
data: {
datasets: [{
data: [prs, 100 - prs],
backgroundColor: [gaugeColor, bgColor],
borderWidth: 0,
circumference: 270,
rotation: 225
}]
},
options: {
responsive: true,
maintainAspectRatio: true,
cutout: '75%',
plugins: {
legend: { display: false },
tooltip: { enabled: false }
}
},
plugins: [{
id: 'centerText',
afterDraw: (chart) => {
const ctx = chart.ctx;
const centerX = chart.chartArea.left + (chart.chartArea.right - chart.chartArea.left) / 2;
const centerY = chart.chartArea.top + (chart.chartArea.bottom - chart.chartArea.top) / 2;
const isMobile = window.innerWidth <= 768;
const scoreFontSize = isMobile ? 32 : 48;
const labelFontSize = isMobile ? 11 : 14;
const scoreOffset = isMobile ? -6 : -10;
const labelOffset = isMobile ? 18 : 25;
ctx.save();
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
const isDarkMode = !document.documentElement.getAttribute('data-theme') || document.documentElement.getAttribute('data-theme') === 'dark';
const textColor = isDarkMode ? '#fff' : '#1a1a1a';
const labelColor = isDarkMode ? '#8e8e93' : '#5a5a5a';
ctx.fillStyle = textColor;
ctx.font = `700 ${scoreFontSize}px -apple-system, BlinkMacSystemFont, SF Pro Display`;
ctx.fillText(prs, centerX, centerY + scoreOffset);
ctx.fillStyle = labelColor;
ctx.font = `600 ${labelFontSize}px -apple-system, BlinkMacSystemFont, SF Pro Display`;
ctx.fillText('PRS', centerX, centerY + labelOffset);
ctx.restore();
}
}]
});
}
function renderFloorMetricsChart(player) {
const totalTDs = player.weeks.reduce((sum, w) => sum + (w.tds || 0), 0);
const tdPoints = totalTDs * 6;
const totalPoints = player.avgPoints * player.gamesPlayed;
const tdDependency = (tdPoints / totalPoints) * 100;
const points = player.weeks.map(w => w.fpts);
const mean = points.reduce((sum, p) => sum + p, 0) / points.length;
const variance = points.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / points.length;
const stdDev = Math.sqrt(variance);
const coefficientOfVariation = (stdDev / mean) * 100;
let volumeMetric;
if (player.position === 'WR' || player.position === 'TE') {
volumeMetric = player.totalTargets / player.gamesPlayed;
} else {
volumeMetric = player.totalOpportunities / player.gamesPlayed;
}
const volumePenalty = volumeMetric < (player.position === 'RB' ? 12 : 5) ? 20 : 0;
const fragilityScore = Math.min(100, (tdDependency * 0.5) + (coefficientOfVariation * 0.3) + volumePenalty);
const playableGames = player.weeks.filter(w => w.fpts >= 8).length;
const boomGames = player.weeks.filter(w => w.fpts >= 15).length;
const bustGames = player.weeks.filter(w => w.fpts < 8).length;
const ghostRate = (bustGames / player.gamesPlayed) * 100;
const fragilityValue = Math.round(fragilityScore);
let fragilityColor, fragilityLabel;
if (fragilityValue < 33) {
fragilityColor = '#30d158'; // Green - LOW fragility = GOOD
fragilityLabel = ''; // No label for low risk
} else if (fragilityValue < 67) {
fragilityColor = '#FFD60A'; // Yellow - MEDIUM fragility
fragilityLabel = 'MEDIUM RISK';
} else {
fragilityColor = '#ff453a'; // Red - HIGH fragility = BAD
fragilityLabel = 'HIGH RISK';
}
document.getElementById('floor-fragility-value').innerHTML =
`<span style="color: ${fragilityColor};">${fragilityValue}</span><span style="font-size: 16px; color: rgba(235, 235, 245, 0.5);">/100</span>`;
const fragilityPill = document.getElementById('floor-fragility-pill');
if (fragilityLabel) {
fragilityPill.textContent = fragilityLabel;
fragilityPill.style.display = '';
} else {
fragilityPill.style.display = 'none';
}
// Render fragility gauge
renderFloorGauge('floor-fragility-gauge', fragilityValue, fragilityColor);
document.getElementById('floor-fragility-value').innerHTML = `<span style="color: ${fragilityColor};">${Math.round(fragilityValue)}</span>`;
document.getElementById('floor-fragility-td').textContent = `TD Dependency: ${tdDependency.toFixed(1)}%`;
document.getElementById('floor-fragility-var').textContent = `Variance: ${coefficientOfVariation.toFixed(1)}%`;
document.getElementById('floor-fragility-vol').textContent = `Volume Penalty: ${volumePenalty}`;
const ghostValue = Math.round(ghostRate);
let ghostColor, ghostLabel;
if (ghostValue < 25) {
ghostColor = '#30d158'; // Green - LOW ghost rate = GOOD
ghostLabel = 'LOW RISK';
} else if (ghostValue < 50) {
ghostColor = '#FFD60A'; // Yellow - MEDIUM ghost rate
ghostLabel = 'MEDIUM RISK';
} else {
ghostColor = '#ff453a'; // Red - HIGH ghost rate = BAD
ghostLabel = 'HIGH RISK';
}
document.getElementById('floor-ghost-value').innerHTML = `<span style="color: ${ghostColor};">${ghostValue}%</span>`;
document.getElementById('floor-ghost-pill').textContent = ghostLabel;
// Render ghost gauge
renderFloorGauge('floor-ghost-gauge', ghostValue, ghostColor);
document.getElementById('floor-ghost-playable').textContent = `Playable: ${playableGames} games`;
document.getElementById('floor-ghost-boom').textContent = `Boom: ${boomGames} games`;
document.getElementById('floor-ghost-bust').textContent = `Bust: ${bustGames} games`;
}
function renderFloorGauge(canvasId, value, color) {
const canvas = document.getElementById(canvasId);
if (!canvas) return;
const ctx = canvas.getContext('2d');
const width = canvas.width;
const height = canvas.height;
const centerX = width / 2;
const centerY = height - 10;
const radius = 80;
const lineWidth = 20;
// Clear canvas
ctx.clearRect(0, 0, width, height);
// Background arc (gray)
ctx.beginPath();
ctx.arc(centerX, centerY, radius, Math.PI, 2 * Math.PI, false);
ctx.lineWidth = lineWidth;
ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
ctx.lineCap = 'round';
ctx.stroke();
// Value arc (colored) - inverted: lower values = better (green on left)
// Convert value (0-100) to angle (PI to 2*PI)
const valueAngle = Math.PI + (value / 100) * Math.PI;
ctx.beginPath();
ctx.arc(centerX, centerY, radius, Math.PI, valueAngle, false);
ctx.lineWidth = lineWidth;
ctx.strokeStyle = color;
ctx.lineCap = 'round';
ctx.stroke();
}
function renderModalCandlesChart(player) {
const ctx = document.getElementById('modal-candles-chart');
if (window.modalCandlesChart) {
window.modalCandlesChart.destroy();
}
document.getElementById('candles-scoring-format').textContent = currentScoringFormat.toUpperCase();
const weeks = player.weeks.map(w => `Week ${w.week}`);
const variance = player.weeks.map(w => w.variance || 0);
const actuals = player.weeks.map(w => w.fpts || 0);
const expected = player.weeks.map(w => w.expectedFpts || 0);
const candleData = player.weeks.map((w, i) => {
const actual = w.fpts || 0;
const exp = w.expectedFpts || 0;
// Floating bar format: [low, high] - bar fills from low value to high value
// For green candles (actual >= expected): low=expected, high=actual (bar extends UP from line)
// For red candles (actual < expected): low=actual, high=expected (bar extends UP to line from below)
// Both candles should touch the expected line - green extends above it, red stays below it
return [Math.min(actual, exp), Math.max(actual, exp)];
});
window.modalCandlesChart = new Chart(ctx, {
type: 'bar',
data: {
labels: weeks,
datasets: [
{
label: 'Expected Baseline',
data: expected,
type: 'line',
borderColor: '#636366',
borderWidth: 2,
borderDash: [5, 5],
fill: false,
pointRadius: 0,
pointHoverRadius: 0,
order: 1
},
{
label: 'Performance Range',
data: candleData,
backgroundColor: function(context) {
const index = context.dataIndex;
const actual = actuals[index];
const exp = expected[index];
return actual >= exp ? 'rgba(48, 209, 88, 0.25)' : 'rgba(255, 69, 58, 0.25)';
},
borderColor: function(context) {
const index = context.dataIndex;
const actual = actuals[index];
const exp = expected[index];
return actual >= exp ? 'rgba(48, 209, 88, 1)' : 'rgba(255, 69, 58, 1)';
},
borderWidth: 2,
borderRadius: 2,
borderSkipped: false,
barPercentage: 0.6,
categoryPercentage: 0.85,
order: 2
}
]
},
options: {
responsive: true,
maintainAspectRatio: true,
aspectRatio: window.innerWidth <= 768 ? 1.5 : 2.5,
interaction: {
mode: 'index',
intersect: false
},
plugins: {
legend: {
display: window.innerWidth > 768,
position: 'top',
align: 'end',
labels: {
color: '#8e8e93',
font: {
size: 11
},
padding: 12,
usePointStyle: true,
filter: function(item) {
return item.text !== 'Expected Baseline';
}
}
},
tooltip: {
backgroundColor: 'rgba(0, 0, 0, 0.9)',
titleColor: '#fff',
bodyColor: '#8e8e93',
padding: 12,
displayColors: false,
callbacks: {
title: function(context) {
return weeks[context[0].dataIndex];
},
label: function(context) {
const index = context.dataIndex;
const actual = actuals[index];
const exp = expected[index];
const diff = actual - exp;
const pct = exp > 0 ? ((diff / exp) * 100).toFixed(1) : '0.0';
return [
`Actual: ${actual.toFixed(1)} pts`,
`Expected: ${exp.toFixed(1)} pts`,
`Variance: ${diff >= 0 ? '+' : ''}${diff.toFixed(1)} (${diff >= 0 ? '+' : ''}${pct}%)`
];
}
}
}
},
scales: {
x: {
grid: {
color: 'rgba(255, 255, 255, 0.05)',
drawBorder: false
},
ticks: {
color: '#8e8e93',
font: {
size: window.innerWidth <= 768 ? 9 : 11
},
maxRotation: 45,
minRotation: 0
}
},
y: {
beginAtZero: true,
grid: {
color: 'rgba(255, 255, 255, 0.05)',
drawBorder: false
},
ticks: {
color: '#8e8e93',
font: {
size: window.innerWidth <= 768 ? 9 : 11
},
callback: function(value) {
return value.toFixed(1);
}
},
title: {
display: window.innerWidth > 768,
text: 'Fantasy Points',
color: '#8e8e93',
font: {
size: 12,
weight: '600'
}
}
}
}
}
});
const aboveCount = variance.filter(v => v > 0).length;
const belowCount = variance.filter(v => v < 0).length;
const avgVariance = variance.reduce((sum, v) => sum + v, 0) / variance.length;
const hitRate = ((aboveCount / variance.length) * 100).toFixed(0);
const summaryHTML = `
<div style="background: var(--bg-elevated); border-radius: 8px; padding: 16px; text-align: center;"><div style="font-size: 28px; font-weight: 700; color: var(--positive); margin-bottom: 4px;">${aboveCount}</div><div style="font-size: 12px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px;">Weeks Above Expected</div></div><div style="background: var(--bg-elevated); border-radius: 8px; padding: 16px; text-align: center;"><div style="font-size: 28px; font-weight: 700; color: var(--negative); margin-bottom: 4px;">${belowCount}</div><div style="font-size: 12px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px;">Weeks Below Expected</div></div><div style="background: var(--bg-elevated); border-radius: 8px; padding: 16px; text-align: center;"><div style="font-size: 28px; font-weight: 700; color: ${avgVariance >= 0 ? 'var(--positive)' : 'var(--negative)'}; margin-bottom: 4px;">
${avgVariance >= 0 ? '+' : ''}${avgVariance.toFixed(1)}
</div><div style="font-size: 12px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px;">Avg Weekly Variance</div></div><div style="background: var(--bg-elevated); border-radius: 8px; padding: 16px; text-align: center;"><div style="font-size: 28px; font-weight: 700; color: ${hitRate >= 50 ? 'var(--positive)' : 'var(--text-primary)'}; margin-bottom: 4px;">
${hitRate}%
</div><div style="font-size: 12px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px;">Hit Rate</div></div>
`;
document.getElementById('candles-summary').innerHTML = summaryHTML;
}
function renderModalShareChart(player) {
const ctx = document.getElementById('modal-share-chart');
if (modalShareChart) {
modalShareChart.destroy();
modalShareChart = null;
}
const latestWeek = player.latestWeek;
let teamData = [];
if (player.position === 'WR') {
teamData = wrData.filter(row =>
row.Team === player.team &&
parseInt(row.Week) === latestWeek &&
row.Player &&
parseFloat(row.TGT) > 0
);
} else {
teamData = rbData.filter(row =>
row.Team === player.team &&
parseInt(row.Week) === latestWeek &&
row.Player &&
parseFloat(row['RB Opp']) > 0
);
}
const playerShares = teamData.map(row => {
let share = 0;
if (player.position === 'WR') {
share = parseFloat(row['% TM']) || 0;
} else {
const playerOpp = parseFloat(row['RB Opp']) || 0;
const teamTotal = teamData.reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);
share = teamTotal > 0 ? (playerOpp / teamTotal) * 100 : 0;
}
return {
name: row.Player,
share: share,
isTarget: row.Player === player.name
};
});
playerShares.sort((a, b) => b.share - a.share);
const top3 = playerShares.slice(0, 3);
const others = playerShares.slice(3);
const othersTotal = others.reduce((sum, p) => sum + p.share, 0);
const labels = top3.map(p => p.name);
const data = top3.map(p => p.share);
const teamColor = teamColors[player.team] || '#0a84ff';
const colorPalette = getColorPalette(teamColor, 3);
const colors = colorPalette.slice(0, top3.length);
if (othersTotal > 0) {
labels.push('Everyone Else');
data.push(othersTotal);
colors.push('#1c1c1e');
}
modalShareChart = new Chart(ctx, {
type: 'pie',
data: {
labels: labels,
datasets: [{
data: data,
backgroundColor: colors,
borderColor: '#0a0a0a',
borderWidth: 2
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
animation: {
animateRotate: true,
animateScale: true,
duration: 1200,
easing: 'easeInOutQuart'
},
plugins: {
legend: {
display: true,
labels: {
color: '#8e8e93',
font: { weight: 'bold' }
},
position: 'bottom'
},
tooltip: {
callbacks: {
label: function(context) {
return `${context.label}: ${context.parsed.toFixed(1)}%`;
}
}
}
}
}
});
}
function renderModalTrendsChart(player) {
const ctx = document.getElementById('modal-trends-chart');
if (modalTrendsChart) {
modalTrendsChart.destroy();
}
if (player.position === 'RB') {
const teamRBs = Object.values(window.aggregatedRBs).filter(rb => rb.team === player.team);
const allWeeks = [...new Set(player.weeks.map(w => w.week))].sort((a, b) => a - b);
const weekTotals = {};
allWeeks.forEach(weekNum => {
const weekData = rbData.filter(row =>
row.Team === player.team &&
parseInt(row.Week) === weekNum &&
parseFloat(row['RB Opp']) > 0
);
weekTotals[weekNum] = weekData.reduce((sum, row) => sum + (parseFloat(row['RB Opp']) || 0), 0);
});
const rbTotalShares = teamRBs.map(rb => {
const totalShare = allWeeks.reduce((sum, weekNum) => {
const weekData = rbData.filter(row =>
row.Team === rb.team &&
parseInt(row.Week) === weekNum &&
parseFloat(row['RB Opp']) > 0
);
const rbWeek = weekData.find(row => row.Player === rb.name);
const totalOpp = weekData.reduce((sum, row) => sum + (parseFloat(row['RB Opp']) || 0), 0);
const weekShare = rbWeek && totalOpp > 0 ? (parseFloat(rbWeek['RB Opp']) / totalOpp * 100) : 0;
return sum + weekShare;
}, 0);
return { rb, totalShare };
});
rbTotalShares.sort((a, b) => b.totalShare - a.totalShare);
const top3RBs = rbTotalShares.slice(0, 3).map(item => item.rb);
const teamColor = teamColors[player.team] || '#0a84ff';
const colorPalette = getColorPalette(teamColor, 3);
const datasets = top3RBs.map((rb, index) => {
const rbColor = colorPalette[index];
const shareData = allWeeks.map(weekNum => {
const weekData = rbData.filter(row =>
row.Team === rb.team &&
parseInt(row.Week) === weekNum &&
parseFloat(row['RB Opp']) > 0
);
const rbWeek = weekData.find(row => row.Player === rb.name);
const totalOpp = weekData.reduce((sum, row) => sum + (parseFloat(row['RB Opp']) || 0), 0);
return rbWeek && totalOpp > 0 ? (parseFloat(rbWeek['RB Opp']) / totalOpp * 100) : null;
});
return {
label: rb.name,
data: shareData,
borderColor: rbColor, // Use full color for all top 3
backgroundColor: 'transparent',
borderWidth: rb.id === player.id ? 4 : 2, // Only thickness varies
tension: 0.3,
pointRadius: rb.id === player.id ? 6 : 3, // Point size varies
pointBackgroundColor: rbColor,
pointBorderColor: '#0a0a0a',
pointBorderWidth: 2,
spanGaps: true
};
});
if (teamRBs.length > 3) {
const everyoneElseData = allWeeks.map(weekNum => {
const weekData = rbData.filter(row =>
row.Team === player.team &&
parseInt(row.Week) === weekNum &&
parseFloat(row['RB Opp']) > 0
);
const totalOpp = weekData.reduce((sum, row) => sum + (parseFloat(row['RB Opp']) || 0), 0);
const top3Share = top3RBs.reduce((sum, rb) => {
const rbWeek = weekData.find(row => row.Player === rb.name);
const rbOpp = rbWeek ? parseFloat(rbWeek['RB Opp']) || 0 : 0;
return sum + (totalOpp > 0 ? (rbOpp / totalOpp * 100) : 0);
}, 0);
return totalOpp > 0 ? Math.max(0, 100 - top3Share) : null;
});
datasets.push({
label: 'Everyone Else',
data: everyoneElseData,
borderColor: '#1c1c1e',
backgroundColor: 'transparent',
borderWidth: 2,
tension: 0.3,
pointRadius: 2,
pointBackgroundColor: '#1c1c1e',
pointBorderColor: '#0a0a0a',
pointBorderWidth: 2,
spanGaps: true,
borderDash: [5, 5]
});
}
modalTrendsChart = new Chart(ctx, {
type: 'line',
data: {
labels: allWeeks.map(w => `Week ${w}`),
datasets: datasets
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: {
legend: {
display: true,
position: 'bottom',
labels: {
color: '#8e8e93',
font: { size: 12 },
boxWidth: 15,
padding: 10
}
},
tooltip: {
callbacks: {
title: (context) => {
const weekNum = allWeeks[context[0].dataIndex];
const totalOpps = weekTotals[weekNum];
return `Week ${weekNum} (${totalOpps.toFixed(0)} Total RB Opps)`;
},
label: (context) => `${context.dataset.label}: ${context.parsed.y ? context.parsed.y.toFixed(1) : '0'}% share`
}
}
},
scales: {
x: {
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
},
y: {
beginAtZero: true,
max: 100,
title: {
display: true,
text: 'Opportunity Share %',
color: '#8e8e93'
},
grid: { color: '#2c2c2e' },
ticks: {
color: '#8e8e93',
callback: (value) => value + '%'
}
}
}
}
});
} else {
const weeks = player.weeks.map(w => w.week);
const weeklyShares = {};
const weekTotals = {};
weeks.forEach(weekNum => {
const teamData = wrData.filter(row =>
row.Team === player.team &&
parseInt(row.Week) === weekNum &&
row.Player &&
parseFloat(row.TGT) > 0
);
weekTotals[weekNum] = teamData.reduce((sum, row) => sum + (parseFloat(row.TGT) || 0), 0);
const playerShares = teamData.map(row => {
const share = parseFloat(row['% TM']) || 0;
return {
name: row.Player,
share: share
};
});
playerShares.sort((a, b) => b.share - a.share);
weeklyShares[weekNum] = playerShares;
});
const allPlayers = new Map();
Object.values(weeklyShares).forEach(weekData => {
weekData.forEach(p => {
if (!allPlayers.has(p.name)) {
allPlayers.set(p.name, 0);
}
allPlayers.set(p.name, allPlayers.get(p.name) + p.share);
});
});
const sortedPlayers = Array.from(allPlayers.entries())
.sort((a, b) => b[1] - a[1])
.slice(0, 3)
.map(entry => entry[0]);
const labels = weeks.map(w => `W${w}`);
const datasets = [];
const teamColor = teamColors[player.team] || '#0a84ff';
const colorPalette = getColorPalette(teamColor, 3);
sortedPlayers.forEach((playerName, idx) => {
const color = colorPalette[idx];
const weeklyData = weeks.map(weekNum => {
const weekData = weeklyShares[weekNum];
const playerWeekData = weekData.find(p => p.name === playerName);
return playerWeekData ? playerWeekData.share : 0;
});
datasets.push({
label: playerName,
data: weeklyData,
backgroundColor: color,
borderColor: '#0a0a0a',
borderWidth: 1
});
});
const othersData = weeks.map(weekNum => {
const weekData = weeklyShares[weekNum];
const top3Total = weekData
.filter(p => sortedPlayers.includes(p.name))
.reduce((sum, p) => sum + p.share, 0);
return Math.max(0, 100 - top3Total);
});
datasets.push({
label: 'Everyone Else',
data: othersData,
backgroundColor: '#1c1c1e',
borderColor: '#0a0a0a',
borderWidth: 1
});
modalTrendsChart = new Chart(ctx, {
type: 'bar',
data: {
labels: labels,
datasets: datasets
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: {
legend: {
display: true,
labels: { color: '#8e8e93' },
position: 'bottom'
},
tooltip: {
callbacks: {
title: function(context) {
const weekNum = weeks[context[0].dataIndex];
const totalTargets = weekTotals[weekNum];
return `W${weekNum} (${totalTargets.toFixed(0)} Total Targets)`;
},
label: function(context) {
return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;
}
}
}
},
scales: {
x: {
stacked: true,
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
},
y: {
stacked: true,
beginAtZero: true,
max: 100,
title: {
display: true,
text: 'Opportunity Share %',
color: '#8e8e93'
},
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
}
}
}
});
}
}


function renderWREvalVolumeEfficiency(week = null) {
const ctx = document.getElementById('wr-eval-volume-efficiency');
if (!ctx) return;
const weekData = getEvaluationWeekData(evaluationDataWR, week);
const topPlayers = weekData
.filter(p => p.aggregate.gamesPlayed >= 3)
.sort((a, b) => b.aggregate.totalFpts - a.aggregate.totalFpts)
.slice(0, 50);
const data = topPlayers.map(player => ({
x: player.targetsPerGame || player.targets || 0,
y: player.fptsPerTarget || 0,
label: player.player,
player: player
}));
const xValues = data.map(d => d.x).filter(x => x > 0).sort((a, b) => a - b);
const yValues = data.map(d => d.y).filter(y => y > 0).sort((a, b) => a - b);
const medianX = xValues[Math.floor(xValues.length / 2)] || 5;
const medianY = yValues[Math.floor(yValues.length / 2)] || 1.5;
if (wrEvalVolumeEfficiencyChart) wrEvalVolumeEfficiencyChart.destroy();
wrEvalVolumeEfficiencyChart = new Chart(ctx, {
type: 'scatter',
data: {
datasets: [{
data: data,
backgroundColor: data.map(d => {
const color = teamColors[d.player.team] || '#666';
const r = parseInt(color.slice(1, 3), 16);
const g = parseInt(color.slice(3, 5), 16);
const b = parseInt(color.slice(5, 7), 16);
return `rgba(${r}, ${g}, ${b}, 0.7)`;
}),
borderColor: data.map(d => teamColors[d.player.team] || '#666'),
borderWidth: 2,
pointRadius: 8,
pointHoverRadius: 12
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
plugins: {
legend: { display: false },
tooltip: {
callbacks: {
label: (context) => {
const p = context.raw.player;
return [
p.player,
`Tgts/G: ${context.parsed.x.toFixed(1)}`,
`Pts/Tgt: ${context.parsed.y.toFixed(2)}`,
`Total: ${p.aggregate.totalFpts.toFixed(1)} pts`
];
}
}
},
annotation: {
annotations: {
vLine: {
type: 'line',
xMin: medianX,
xMax: medianX,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
},
hLine: {
type: 'line',
yMin: medianY,
yMax: medianY,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
},
topRight: {
type: 'label',
xValue: Math.max(...xValues) * 0.70,
yValue: Math.max(...yValues) * 0.70,
content: ['Reliable Studs', '(Hold)'],
color: '#30d158',
font: { size: 13, weight: 'bold' }
},
topLeft: {
type: 'label',
xValue: Math.min(...xValues) * 1.5,
yValue: Math.max(...yValues) * 0.70,
content: ['Efficient Sleepers', '(Buy Low)'],
color: '#0a84ff',
font: { size: 13, weight: 'bold' }
},
bottomRight: {
type: 'label',
xValue: Math.max(...xValues) * 0.70,
yValue: Math.min(...yValues) * 2.0,
content: ['Volume, Poor Efficiency', '(Sell Window)'],
color: '#FFD60A',
font: { size: 13, weight: 'bold' }
},
bottomLeft: {
type: 'label',
xValue: Math.min(...xValues) * 1.5,
yValue: Math.min(...yValues) * 2.0,
content: ['Bench Fodder'],
color: '#ff453a',
font: { size: 13, weight: 'bold' }
}
}
}
},
scales: {
x: {
title: { display: true, text: 'Targets per Game â†’', color: '#8e8e93', font: { weight: 'bold' } },
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
},
y: {
title: { display: true, text: 'Fantasy Points per Target â†’', color: '#8e8e93', font: { weight: 'bold' } },
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
}
}
}
});
}

function renderWREvalShareRZ(week = null) {
const ctx = document.getElementById('wr-eval-share-rz');
if (!ctx) return;
const weekData = getEvaluationWeekData(evaluationDataWR, week);
const topPlayers = weekData
.filter(p => p.aggregate.gamesPlayed >= 3)
.sort((a, b) => b.aggregate.totalFpts - a.aggregate.totalFpts)
.slice(0, 50);
const data = topPlayers.map(player => ({
x: player.targetShare || 0,
y: player.rzTargetShare || 0,
label: player.player,
player: player
}));
const xValues = data.map(d => d.x).filter(x => x > 0).sort((a, b) => a - b);
const yValues = data.map(d => d.y).filter(y => y > 0).sort((a, b) => a - b);
const medianX = xValues[Math.floor(xValues.length / 2)] || 20;
const medianY = yValues[Math.floor(yValues.length / 2)] || 20;
if (wrEvalShareRZChart) wrEvalShareRZChart.destroy();
wrEvalShareRZChart = new Chart(ctx, {
type: 'scatter',
data: {
datasets: [{
data: data,
backgroundColor: data.map(d => {
const color = teamColors[d.player.team] || '#666';
const r = parseInt(color.slice(1, 3), 16);
const g = parseInt(color.slice(3, 5), 16);
const b = parseInt(color.slice(5, 7), 16);
return `rgba(${r}, ${g}, ${b}, 0.7)`;
}),
borderColor: data.map(d => teamColors[d.player.team] || '#666'),
borderWidth: 2,
pointRadius: 8,
pointHoverRadius: 12
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
plugins: {
legend: { display: false },
tooltip: {
callbacks: {
label: (context) => {
const p = context.raw.player;
return [
p.player,
`Tgt Share: ${context.parsed.x.toFixed(1)}%`,
`RZ Share: ${context.parsed.y.toFixed(1)}%`,
`Total: ${p.aggregate.totalFpts.toFixed(1)} pts`
];
}
}
},
annotation: {
annotations: {
vLine: {
type: 'line',
xMin: medianX,
xMax: medianX,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
},
hLine: {
type: 'line',
yMin: medianY,
yMax: medianY,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
},
topRight: {
type: 'label',
xValue: Math.max(...xValues) * 0.70,
yValue: Math.max(...yValues) * 0.70,
content: ['Alpha WR1s'],
color: '#30d158',
font: { size: 13, weight: 'bold' }
},
topLeft: {
type: 'label',
xValue: Math.min(...xValues) * 1.3,
yValue: Math.max(...yValues) * 0.70,
content: ['TD-Dependent', 'Boom/Busts'],
color: '#FFD60A',
font: { size: 13, weight: 'bold' }
},
bottomRight: {
type: 'label',
xValue: Math.max(...xValues) * 0.70,
yValue: Math.min(...yValues) * 2.0,
content: ['Chain Movers'],
color: '#0a84ff',
font: { size: 13, weight: 'bold' }
},
bottomLeft: {
type: 'label',
xValue: Math.min(...xValues) * 1.3,
yValue: Math.min(...yValues) * 2.0,
content: ['Background Noise'],
color: '#ff453a',
font: { size: 13, weight: 'bold' }
}
}
}
},
scales: {
x: {
title: { display: true, text: 'Target Share (% of Team) â†’', color: '#8e8e93', font: { weight: 'bold' } },
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93', callback: (value) => value + '%' }
},
y: {
title: { display: true, text: 'Red Zone Target Share (% of Team) â†’', color: '#8e8e93', font: { weight: 'bold' } },
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93', callback: (value) => value + '%' }
}
}
}
});
}

function renderRBEvalTotalRZ(week = null) {
const ctx = document.getElementById('rb-eval-total-rz');
if (!ctx) return;
const weekData = getEvaluationWeekData(evaluationDataRB, week);
const topPlayers = weekData
.filter(p => p.aggregate.gamesPlayed >= 3)
.sort((a, b) => b.aggregate.totalFpts - a.aggregate.totalFpts)
.slice(0, 50);
const data = topPlayers.map(player => ({
x: player.opportunitiesPerGame || 0,
y: player.rzOpportunitiesPerGame || 0,
label: player.player,
player: player
}));
const xValues = data.map(d => d.x).filter(x => x > 0).sort((a, b) => a - b);
const yValues = data.map(d => d.y).filter(y => y > 0).sort((a, b) => a - b);
const medianX = xValues[Math.floor(xValues.length / 2)] || 12;
const medianY = yValues[Math.floor(yValues.length / 2)] || 2;
if (rbEvalTotalRZChart) rbEvalTotalRZChart.destroy();
rbEvalTotalRZChart = new Chart(ctx, {
type: 'scatter',
data: {
datasets: [{
data: data,
backgroundColor: data.map(d => {
const color = teamColors[d.player.team] || '#666';
const r = parseInt(color.slice(1, 3), 16);
const g = parseInt(color.slice(3, 5), 16);
const b = parseInt(color.slice(5, 7), 16);
return `rgba(${r}, ${g}, ${b}, 0.7)`;
}),
borderColor: data.map(d => teamColors[d.player.team] || '#666'),
borderWidth: 2,
pointRadius: 8,
pointHoverRadius: 12
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
plugins: {
legend: { display: false },
tooltip: {
callbacks: {
label: (context) => {
const p = context.raw.player;
return [
p.player,
`Opps/G: ${context.parsed.x.toFixed(1)}`,
`RZ Opps/G: ${context.parsed.y.toFixed(1)}`,
`Total: ${p.aggregate.totalFpts.toFixed(1)} pts`
];
}
}
},
annotation: {
annotations: {
vLine: {
type: 'line',
xMin: medianX,
xMax: medianX,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
},
hLine: {
type: 'line',
yMin: medianY,
yMax: medianY,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
},
topRight: {
type: 'label',
xValue: Math.max(...xValues) * 0.70,
yValue: Math.max(...yValues) * 0.70,
content: ['True Workhorses', '(Buy/Hold)'],
color: '#30d158',
font: { size: 13, weight: 'bold' }
},
topLeft: {
type: 'label',
xValue: Math.min(...xValues) * 1.2,
yValue: Math.max(...yValues) * 0.70,
content: ['TD Vultures', '(Sell High)'],
color: '#FFD60A',
font: { size: 13, weight: 'bold' }
},
bottomRight: {
type: 'label',
xValue: Math.max(...xValues) * 0.70,
yValue: Math.min(...yValues) * 1.5,
content: ['Between-the-20s Backs', '(Neutral)'],
color: '#0a84ff',
font: { size: 13, weight: 'bold' }
},
bottomLeft: {
type: 'label',
xValue: Math.min(...xValues) * 1.2,
yValue: Math.min(...yValues) * 1.5,
content: ['Irrelevant Depth'],
color: '#ff453a',
font: { size: 13, weight: 'bold' }
}
}
}
},
scales: {
x: {
title: { display: true, text: 'Opportunities per Game (Rush + Targets) â†’', color: '#8e8e93', font: { weight: 'bold' } },
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
},
y: {
title: { display: true, text: 'Red Zone Opportunities per Game â†’', color: '#8e8e93', font: { weight: 'bold' } },
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
}
}
}
});
}

function renderRBEvalVolumeEfficiency(week = null) {
const ctx = document.getElementById('rb-eval-volume-efficiency');
if (!ctx) return;
const weekData = getEvaluationWeekData(evaluationDataRB, week);
const topPlayers = weekData
.filter(p => p.aggregate.gamesPlayed >= 3)
.sort((a, b) => b.aggregate.totalFpts - a.aggregate.totalFpts)
.slice(0, 50);
const data = topPlayers.map(player => ({
x: player.opportunitiesPerGame || 0,
y: player.efficiency || 0,
label: player.player,
player: player
}));
const xValues = data.map(d => d.x).filter(x => x > 0).sort((a, b) => a - b);
const yValues = data.map(d => d.y).filter(y => y > 0).sort((a, b) => a - b);
const medianX = xValues[Math.floor(xValues.length / 2)] || 12;
const medianY = yValues[Math.floor(yValues.length / 2)] || 1;
if (rbEvalVolumeEfficiencyChart) rbEvalVolumeEfficiencyChart.destroy();
rbEvalVolumeEfficiencyChart = new Chart(ctx, {
type: 'scatter',
data: {
datasets: [{
data: data,
backgroundColor: data.map(d => {
const color = teamColors[d.player.team] || '#666';
const r = parseInt(color.slice(1, 3), 16);
const g = parseInt(color.slice(3, 5), 16);
const b = parseInt(color.slice(5, 7), 16);
return `rgba(${r}, ${g}, ${b}, 0.7)`;
}),
borderColor: data.map(d => teamColors[d.player.team] || '#666'),
borderWidth: 2,
pointRadius: 8,
pointHoverRadius: 12
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
plugins: {
legend: { display: false },
tooltip: {
callbacks: {
label: (context) => {
const p = context.raw.player;
return [
p.player,
`Opps/G: ${context.parsed.x.toFixed(1)}`,
`Efficiency: ${context.parsed.y.toFixed(2)} pts/opp`,
`Total: ${p.aggregate.totalFpts.toFixed(1)} pts`
];
}
}
},
annotation: {
annotations: {
vLine: {
type: 'line',
xMin: medianX,
xMax: medianX,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
},
hLine: {
type: 'line',
yMin: medianY,
yMax: medianY,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
},
topRight: {
type: 'label',
xValue: Math.max(...xValues) * 0.70,
yValue: Math.max(...yValues) * 0.70,
content: ['Elite Dual Threats'],
color: '#30d158',
font: { size: 13, weight: 'bold' }
},
topLeft: {
type: 'label',
xValue: Math.min(...xValues) * 1.2,
yValue: Math.max(...yValues) * 0.70,
content: ['Breakout Candidates'],
color: '#0a84ff',
font: { size: 13, weight: 'bold' }
},
bottomRight: {
type: 'label',
xValue: Math.max(...xValues) * 0.70,
yValue: Math.min(...yValues) * 2.0,
content: ['Inefficient', 'Workhorses'],
color: '#FFD60A',
font: { size: 13, weight: 'bold' }
},
bottomLeft: {
type: 'label',
xValue: Math.min(...xValues) * 1.2,
yValue: Math.min(...yValues) * 2.0,
content: ['Bench Fodder'],
color: '#ff453a',
font: { size: 13, weight: 'bold' }
}
}
}
},
scales: {
x: {
title: { display: true, text: 'Opportunities per Game (Rush + Targets) â†’', color: '#8e8e93', font: { weight: 'bold' } },
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
},
y: {
title: { display: true, text: 'Efficiency (Fantasy Points per Opportunity) â†’', color: '#8e8e93', font: { weight: 'bold' } },
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' }
}
}
}
});
}

let smoothTrendState = {};
let smoothTrendAnimationFrames = {};
let smoothTrendPlayerTrails = {};
let smoothTrendMoversFilter = {}; // Track movers filter state for each chart


function initSmoothTrendAnimation(chartId) {
const isWR = chartId.includes('wr-eval');
const segmentData = isWR ? segmentDataWR : segmentDataRB; // v7: use segmentData
const segments = getAvailableSegments(segmentData); // v7: use segments
if (segments.length === 0) return;
smoothTrendState[chartId] = {
isPlaying: false,
currentSegmentFloat: segments[segments.length - 1], // v7: segment instead of week
segments: segments, // v7: segments instead of weeks
fps: 30,
speedMultiplier: 0.01, // Segments per frame (500% slower - was 0.05)
maxTrailLength: 20 // Longer trail (was 5)
};
smoothTrendPlayerTrails[chartId] = {};
const scrubber = document.getElementById(`${chartId}-scrubber`);
if (scrubber) {
scrubber.min = segments[0];
scrubber.max = segments[segments.length - 1];
scrubber.value = segments[segments.length - 1];
scrubber.addEventListener('input', (e) => {
const segmentFloat = parseFloat(e.target.value); // v7: segment naming
smoothTrendState[chartId].currentSegmentFloat = segmentFloat;
smoothTrendState[chartId].isPlaying = false;
updatePlayButton(chartId, false);
renderSmoothTrendFrame(chartId, segmentFloat); // v7: pass segment
updateSegmentLabel(chartId, segmentFloat); // v7: update segment label
});
}
renderSmoothTrendFrame(chartId, smoothTrendState[chartId].currentSegmentFloat);
updateSegmentLabel(chartId, smoothTrendState[chartId].currentSegmentFloat);
}

function toggleSmoothTrendPlayback(chartId) {
if (!smoothTrendState[chartId]) {
initSmoothTrendAnimation(chartId);
}
const state = smoothTrendState[chartId];
state.isPlaying = !state.isPlaying;
updatePlayButton(chartId, state.isPlaying);
if (state.isPlaying) {
startSmoothAnimation(chartId);
} else {
stopSmoothAnimation(chartId);
}
}


function toggleMoversFilter(chartId, mode) {
smoothTrendMoversFilter[chartId] = mode;
const allBtn = document.getElementById(`${chartId}-filter-all`);
const positiveBtn = document.getElementById(`${chartId}-filter-positive`);
const negativeBtn = document.getElementById(`${chartId}-filter-negative`);
[allBtn, positiveBtn, negativeBtn].forEach(btn => {
if (btn) {
btn.style.background = 'var(--bg-elevated)';
btn.style.color = 'var(--text-primary)';
btn.style.border = '1px solid var(--border-color)';
}
});
let activeBtn;
if (mode === 'all') activeBtn = allBtn;
else if (mode === 'positive') activeBtn = positiveBtn;
else if (mode === 'negative') activeBtn = negativeBtn;
if (activeBtn) {
activeBtn.style.background = 'var(--positive)';
activeBtn.style.color = '#000';
activeBtn.style.border = 'none';
}
if (smoothTrendState[chartId]) {
renderSmoothTrendFrame(chartId, smoothTrendState[chartId].currentSegmentFloat);
}
}

function calculateTopMovers(allPlayers, segmentData, segments, chartId) {
if (segments.length < 2) return { topPositive: [], topNegative: [] };
const firstSegment = segments[0];
const lastSegment = segments[segments.length - 1];
const firstData = getEvaluationSegmentData(segmentData, firstSegment);
const lastData = getEvaluationSegmentData(segmentData, lastSegment);
const movements = [];
allPlayers.forEach(player => {
const playerFirst = firstData.find(p => p.player === player.player);
const playerLast = lastData.find(p => p.player === player.player);
if (!playerFirst || !playerLast) return;
let xFirst, yFirst, xLast, yLast;
if (chartId === 'wr-eval-volume-efficiency') {
xFirst = playerFirst.targets || 0;
yFirst = playerFirst.fptsPerTarget || 0;
xLast = playerLast.targets || 0;
yLast = playerLast.fptsPerTarget || 0;
} else if (chartId === 'wr-eval-share-rz') {
xFirst = playerFirst.targetShare || 0;
yFirst = playerFirst.rzTargetShare || 0;
xLast = playerLast.targetShare || 0;
yLast = playerLast.rzTargetShare || 0;
} else if (chartId === 'rb-eval-total-rz') {
xFirst = playerFirst.opportunities || 0;
yFirst = playerFirst.rzOpportunities || 0;
xLast = playerLast.opportunities || 0;
yLast = playerLast.rzOpportunities || 0;
} else if (chartId === 'rb-eval-volume-efficiency') {
xFirst = playerFirst.opportunities || 0;
yFirst = playerFirst.efficiency || 0;
xLast = playerLast.opportunities || 0;
yLast = playerLast.efficiency || 0;
} else if (chartId === 'wr-eval-production-volume') {
xFirst = (playerFirst.targets || 0) / (playerFirst.weeksInSegment || 1);
yFirst = (playerFirst.fpts || 0) / (playerFirst.weeksInSegment || 1);
xLast = (playerLast.targets || 0) / (playerLast.weeksInSegment || 1);
yLast = (playerLast.fpts || 0) / (playerLast.weeksInSegment || 1);
} else if (chartId === 'rb-eval-production-volume') {
xFirst = (playerFirst.opportunities || 0) / (playerFirst.weeksInSegment || 1);
yFirst = (playerFirst.fpts || 0) / (playerFirst.weeksInSegment || 1);
xLast = (playerLast.opportunities || 0) / (playerLast.weeksInSegment || 1);
yLast = (playerLast.fpts || 0) / (playerLast.weeksInSegment || 1);
}
const xChange = xLast - xFirst;
const yChange = yLast - yFirst;
const distance = Math.sqrt(xChange * xChange + (yChange * yChange * 4)); // Y weighted more
const direction = (xChange + yChange * 2) >= 0 ? 1 : -1;
const signedDistance = distance * direction;
movements.push({
player: player.player,
distance: signedDistance,
absDistance: Math.abs(signedDistance)
});
});
movements.sort((a, b) => b.distance - a.distance);
const topPositive = movements.slice(0, 5).map(m => m.player);
const topNegative = movements.slice(-5).reverse().map(m => m.player);
return { topPositive, topNegative };
}

function startSmoothAnimation(chartId) {
const state = smoothTrendState[chartId];
if (state.currentSegmentFloat >= state.segments[state.segments.length - 1]) {
state.currentSegmentFloat = state.segments[0];
smoothTrendPlayerTrails[chartId] = {}; // Clear trails on restart
}
function animationLoop() {
if (!state.isPlaying) return;
state.currentSegmentFloat += state.speedMultiplier;
if (state.currentSegmentFloat >= state.segments[state.segments.length - 1]) {
state.currentSegmentFloat = state.segments[state.segments.length - 1];
state.isPlaying = false;
updatePlayButton(chartId, false);
renderSmoothTrendFrame(chartId, state.currentSegmentFloat, true); // Pass showFullTrail flag
updateSegmentLabel(chartId, state.currentSegmentFloat);
updateScrubberPosition(chartId, state.currentSegmentFloat);
return; // Stop animation
}
renderSmoothTrendFrame(chartId, state.currentSegmentFloat);
updateSegmentLabel(chartId, state.currentSegmentFloat);
updateScrubberPosition(chartId, state.currentSegmentFloat);
smoothTrendAnimationFrames[chartId] = requestAnimationFrame(animationLoop);
}
smoothTrendAnimationFrames[chartId] = requestAnimationFrame(animationLoop);
}

function stopSmoothAnimation(chartId) {
const state = smoothTrendState[chartId];
state.isPlaying = false;
if (smoothTrendAnimationFrames[chartId]) {
cancelAnimationFrame(smoothTrendAnimationFrames[chartId]);
delete smoothTrendAnimationFrames[chartId];
}
}

function renderSmoothTrendFrame(chartId, segmentFloat, showFullTrail = false) {
const isWR = chartId.includes('wr-eval');
const segmentData = isWR ? segmentDataWR : segmentDataRB; // v7: use segmentData
const state = smoothTrendState[chartId];
const segmentBefore = Math.floor(segmentFloat);
const segmentAfter = Math.ceil(segmentFloat);
const interpolationFactor = segmentFloat - segmentBefore;
const dataBefore = getEvaluationSegmentData(segmentData, segmentBefore); // v7: use segment function
const dataAfter = segmentBefore !== segmentAfter ?
getEvaluationSegmentData(segmentData, segmentAfter) :
dataBefore;
const playerSet = new Set();
dataBefore.forEach(p => playerSet.add(p.player));
dataAfter.forEach(p => playerSet.add(p.player));
const allPlayers = Array.from(playerSet).map(playerName => {
const pBefore = dataBefore.find(p => p.player === playerName);
const pAfter = dataAfter.find(p => p.player === playerName);
return pBefore || pAfter;
});
let topPlayers;
if (smoothTrendMoversFilter[chartId] === 'positive' || smoothTrendMoversFilter[chartId] === 'negative') {
const segments = getAvailableSegments(segmentData);
const movers = calculateTopMovers(allPlayers, segmentData, segments, chartId);
let moverNames;
if (smoothTrendMoversFilter[chartId] === 'positive') {
moverNames = movers.topPositive; // Top 5 positive movers
} else {
moverNames = movers.topNegative; // Top 5 negative movers
}
topPlayers = allPlayers.filter(p =>
p && p.aggregate && p.aggregate.gamesPlayed >= 3 && moverNames.includes(p.player)
);
} else {
topPlayers = allPlayers
.filter(p => p && p.aggregate && p.aggregate.gamesPlayed >= 3)
.sort((a, b) => b.aggregate.totalFpts - a.aggregate.totalFpts)
.slice(0, 50);
}
const interpolatedData = topPlayers.map(player => {
const pBefore = dataBefore.find(p => p.player === player.player);
const pAfter = dataAfter.find(p => p.player === player.player);
let xBefore, yBefore, xAfter, yAfter;
if (chartId === 'wr-eval-volume-efficiency') {
xBefore = pBefore ? (pBefore.targets || 0) : 0;
yBefore = pBefore ? (pBefore.fptsPerTarget || 0) : 0;
xAfter = pAfter ? (pAfter.targets || 0) : xBefore;
yAfter = pAfter ? (pAfter.fptsPerTarget || 0) : yBefore;
} else if (chartId === 'wr-eval-share-rz') {
xBefore = pBefore ? (pBefore.targetShare || 0) : 0;
yBefore = pBefore ? (pBefore.rzTargetShare || 0) : 0;
xAfter = pAfter ? (pAfter.targetShare || 0) : xBefore;
yAfter = pAfter ? (pAfter.rzTargetShare || 0) : yBefore;
} else if (chartId === 'rb-eval-total-rz') {
xBefore = pBefore ? (pBefore.opportunities || 0) : 0;
yBefore = pBefore ? (pBefore.rzOpportunities || 0) : 0;
xAfter = pAfter ? (pAfter.opportunities || 0) : xBefore;
yAfter = pAfter ? (pAfter.rzOpportunities || 0) : yBefore;
} else if (chartId === 'rb-eval-volume-efficiency') {
xBefore = pBefore ? (pBefore.opportunities || 0) : 0;
yBefore = pBefore ? (pBefore.efficiency || 0) : 0;
xAfter = pAfter ? (pAfter.opportunities || 0) : xBefore;
yAfter = pAfter ? (pAfter.efficiency || 0) : yBefore;
} else if (chartId === 'wr-eval-production-volume') {
xBefore = pBefore ? ((pBefore.targets || 0) / (pBefore.weeksInSegment || 1)) : 0;
yBefore = pBefore ? ((pBefore.fpts || 0) / (pBefore.weeksInSegment || 1)) : 0;
xAfter = pAfter ? ((pAfter.targets || 0) / (pAfter.weeksInSegment || 1)) : xBefore;
yAfter = pAfter ? ((pAfter.fpts || 0) / (pAfter.weeksInSegment || 1)) : yBefore;
} else if (chartId === 'rb-eval-production-volume') {
xBefore = pBefore ? ((pBefore.opportunities || 0) / (pBefore.weeksInSegment || 1)) : 0;
yBefore = pBefore ? ((pBefore.fpts || 0) / (pBefore.weeksInSegment || 1)) : 0;
xAfter = pAfter ? ((pAfter.opportunities || 0) / (pAfter.weeksInSegment || 1)) : xBefore;
yAfter = pAfter ? ((pAfter.fpts || 0) / (pAfter.weeksInSegment || 1)) : yBefore;
}
const x = xBefore + (xAfter - xBefore) * interpolationFactor;
const y = yBefore + (yAfter - yBefore) * interpolationFactor;
if (!smoothTrendPlayerTrails[chartId][player.player]) {
smoothTrendPlayerTrails[chartId][player.player] = [];
}
const trail = smoothTrendPlayerTrails[chartId][player.player];
trail.push({ x, y, segment: segmentFloat }); // v7: segment instead of week
if (!showFullTrail && trail.length > state.maxTrailLength) {
trail.shift();
}
return {
x: x,
y: y,
label: player.player,
player: player,
trail: [...trail] // Copy trail for rendering
};
});
renderSmoothTrendChart(chartId, interpolatedData);
}

function renderSmoothTrendChart(chartId, data) {
const ctx = document.getElementById(chartId);
if (!ctx) return;
const isWR = chartId.includes('wr-eval');
const segmentData = isWR ? segmentDataWR : segmentDataRB; // v7: use segmentData
const segments = getAvailableSegments(segmentData); // v7: use segments
let allXValues = [];
let allYValues = [];
segments.forEach(segment => { // v7: iterate segments
const segmentPlayers = getEvaluationSegmentData(segmentData, segment); // v7: get segment data
segmentPlayers.forEach(player => {
if (chartId === 'wr-eval-volume-efficiency') {
allXValues.push(player.targets || 0);
allYValues.push(player.fptsPerTarget || 0);
} else if (chartId === 'wr-eval-share-rz') {
allXValues.push(player.targetShare || 0);
allYValues.push(player.rzTargetShare || 0);
} else if (chartId === 'rb-eval-total-rz') {
allXValues.push(player.opportunities || 0);
allYValues.push(player.rzOpportunities || 0);
} else if (chartId === 'rb-eval-volume-efficiency') {
allXValues.push(player.opportunities || 0);
allYValues.push(player.efficiency || 0);
} else if (chartId === 'wr-eval-production-volume') {
allXValues.push((player.targets || 0) / (player.weeksInSegment || 1));
allYValues.push((player.fpts || 0) / (player.weeksInSegment || 1));
} else if (chartId === 'rb-eval-production-volume') {
allXValues.push((player.opportunities || 0) / (player.weeksInSegment || 1));
allYValues.push((player.fpts || 0) / (player.weeksInSegment || 1));
}
});
});
const xMin = Math.min(...allXValues.filter(v => v > 0));
const xMax = Math.max(...allXValues);
const yMin = Math.min(...allYValues.filter(v => v > 0));
const yMax = Math.max(...allYValues);
const xValues = allXValues.filter(v => v > 0).sort((a, b) => a - b);
const yValues = allYValues.filter(v => v > 0).sort((a, b) => a - b);
const medianX = xValues[Math.floor(xValues.length / 2)] || 5;
const medianY = yValues[Math.floor(yValues.length / 2)] || 1.5;
let chart = window[`${chartId}Chart`];
if (!chart) {
chart = createSmoothTrendChart(ctx, chartId, medianX, medianY, xMin, xMax, yMin, yMax);
window[`${chartId}Chart`] = chart;
}
const datasets = [];
data.forEach(point => {
if (point.trail && point.trail.length > 1) {
const trailData = point.trail.map((t, idx) => ({
x: t.x,
y: t.y
}));
const teamColor = teamColors[point.player.team] || '#666';
const r = parseInt(teamColor.slice(1, 3), 16);
const g = parseInt(teamColor.slice(3, 5), 16);
const b = parseInt(teamColor.slice(5, 7), 16);
datasets.push({
type: 'line',
data: trailData,
borderColor: `rgba(${r}, ${g}, ${b}, 0.6)`, // More opaque (was 0.4)
backgroundColor: 'transparent',
borderWidth: 4, // Thicker trail (was 2)
pointRadius: 0,
showLine: true,
tension: 0.4
});
}
});
datasets.push({
type: 'scatter',
data: data.map(d => ({ x: d.x, y: d.y, label: d.label, player: d.player })),
backgroundColor: data.map(d => {
const color = teamColors[d.player.team] || '#666';
const r = parseInt(color.slice(1, 3), 16);
const g = parseInt(color.slice(3, 5), 16);
const b = parseInt(color.slice(5, 7), 16);
return `rgba(${r}, ${g}, ${b}, 0.85)`;
}),
borderColor: data.map(d => teamColors[d.player.team] || '#666'),
borderWidth: 2,
pointRadius: 8,
pointHoverRadius: 12
});
chart.data.datasets = datasets;
chart.update('none'); // No animation for smooth movement
}

function createSmoothTrendChart(ctx, chartId, medianX, medianY, xMin, xMax, yMin, yMax) {
let xLabel, yLabel, quadrantLabels;
if (chartId === 'wr-eval-volume-efficiency') {
xLabel = 'Targets per Game â†’';
yLabel = 'Fantasy Points per Target â†’';
quadrantLabels = {
topRight: ['Reliable Studs', '(Hold)'],
topLeft: ['Efficient Sleepers', '(Buy Low)'],
bottomRight: ['Volume, Poor Efficiency', '(Sell Window)'],
bottomLeft: ['Bench Fodder']
};
} else if (chartId === 'wr-eval-share-rz') {
xLabel = 'Target Share (% of Team) â†’';
yLabel = 'Red Zone Target Share (% of Team) â†’';
quadrantLabels = {
topRight: ['Alpha WR1s'],
topLeft: ['TD-Dependent', 'Boom/Busts'],
bottomRight: ['Chain Movers'],
bottomLeft: ['Background Noise']
};
} else if (chartId === 'rb-eval-total-rz') {
xLabel = 'Opportunities per Game (Rush + Targets) â†’';
yLabel = 'Red Zone Opportunities per Game â†’';
quadrantLabels = {
topRight: ['True Workhorses', '(Buy/Hold)'],
topLeft: ['TD Vultures', '(Sell High)'],
bottomRight: ['Between-the-20s Backs', '(Neutral)'],
bottomLeft: ['Irrelevant Depth']
};
} else if (chartId === 'rb-eval-volume-efficiency') {
xLabel = 'Opportunities per Game (Rush + Targets) â†’';
yLabel = 'Efficiency (Fantasy Points per Opportunity) â†’';
quadrantLabels = {
topRight: ['Elite Dual Threats'],
topLeft: ['Breakout Candidates'],
bottomRight: ['Inefficient', 'Workhorses'],
bottomLeft: ['Bench Fodder']
};
} else if (chartId === 'wr-eval-production-volume') {
xLabel = 'Targets per Game â†’';
yLabel = 'Fantasy Points per Game (FPPG) â†’';
quadrantLabels = {
topRight: ['Elite WR1s'],
topLeft: ['Efficient Sleepers'],
bottomRight: ['Volume Drags'],
bottomLeft: ['Irrelevant']
};
} else if (chartId === 'rb-eval-production-volume') {
xLabel = 'Opportunities per Game â†’';
yLabel = 'Fantasy Points per Game (FPPG) â†’';
quadrantLabels = {
topRight: ['Elite Bellcows'],
topLeft: ['Efficient Backups'],
bottomRight: ['Plodding Workhorses'],
bottomLeft: ['Irrelevant']
};
}
return new Chart(ctx, {
type: 'scatter',
data: { datasets: [] },
options: {
responsive: true,
maintainAspectRatio: false,
animation: false, // Disable default animations
layout: {
padding: {
left: 50,
right: 50,
top: 50,
bottom: 50
}
},
plugins: {
legend: { display: false },
tooltip: {
callbacks: {
label: (context) => {
const p = context.raw.player;
if (!p) return '';
return [
p.player,
`X: ${context.parsed.x.toFixed(1)}`,
`Y: ${context.parsed.y.toFixed(2)}`,
`Total: ${p.aggregate.totalFpts.toFixed(1)} pts`
];
}
}
},
annotation: {
annotations: {
vLine: {
type: 'line',
xMin: medianX,
xMax: medianX,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
},
hLine: {
type: 'line',
yMin: medianY,
yMax: medianY,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5]
},
topRight: {
type: 'label',
xValue: xMax * 0.70, // Much closer to center (was 0.82)
yValue: yMax * 0.70, // Much closer to center (was 0.82)
content: quadrantLabels.topRight,
color: '#30d158',
font: { size: 13, weight: 'bold' } // Larger (was 10)
},
topLeft: {
type: 'label',
xValue: xMin * 1.5, // Much closer to center (was 1.3)
yValue: yMax * 0.70, // Much closer to center (was 0.82)
content: quadrantLabels.topLeft,
color: '#0a84ff',
font: { size: 13, weight: 'bold' } // Larger (was 10)
},
bottomRight: {
type: 'label',
xValue: xMax * 0.70, // Much closer to center (was 0.82)
yValue: yMin * 2.0, // Much closer to center (was 1.5)
content: quadrantLabels.bottomRight,
color: '#FFD60A',
font: { size: 13, weight: 'bold' } // Larger (was 10)
},
bottomLeft: {
type: 'label',
xValue: xMin * 1.5, // Much closer to center (was 1.3)
yValue: yMin * 2.0, // Much closer to center (was 1.5)
content: quadrantLabels.bottomLeft,
color: '#ff453a',
font: { size: 13, weight: 'bold' } // Larger (was 10)
}
}
}
},
scales: {
x: {
title: { display: true, text: xLabel, color: '#8e8e93', font: { weight: 'bold' } },
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' },
min: xMin * 0.9,
max: xMax * 1.1
},
y: {
title: { display: true, text: yLabel, color: '#8e8e93', font: { weight: 'bold' } },
grid: { color: '#2c2c2e' },
ticks: { color: '#8e8e93' },
min: yMin * 0.9,
max: chartId === 'wr-eval-share-rz' ? 110 : yMax * 1.1 // Special case for WR RZ Share
}
}
}
});
}

function updatePlayButton(chartId, isPlaying) {
const btn = document.getElementById(`${chartId}-play-btn`);
if (btn) {
if (isPlaying) {
btn.classList.add('playing');
btn.querySelector('.play-icon').textContent = 'â¸';
} else {
btn.classList.remove('playing');
btn.querySelector('.play-icon').textContent = 'â–¶';
}
}
}

function updateSegmentLabel(chartId, segmentFloat) {
const label = document.getElementById(`${chartId}-week-label`);
if (label && smoothTrendState[chartId]) {
const isWR = chartId.includes('wr-eval');
const segmentData = isWR ? segmentDataWR : segmentDataRB;
const segmentIndex = Math.floor(segmentFloat);
const weeks = getSegmentWeekRange(segmentData, segmentIndex);
if (weeks.length > 0) {
const firstWeek = weeks[0];
const lastWeek = weeks[weeks.length - 1];
label.textContent = `Segments ${firstWeek}-${lastWeek}`;
} else {
label.textContent = `Segment ${segmentIndex}`;
}
}
}

function updateWeekLabel(chartId, weekFloat) {
updateSegmentLabel(chartId, weekFloat);
}
function updateScrubberPosition(chartId, segmentFloat) {
const scrubber = document.getElementById(`${chartId}-scrubber`);
if (scrubber) {
scrubber.value = segmentFloat;
}
}
function sortTable(position, column) {
if (position === 'wr') {
renderWRPlayerCards();
} else {
renderRBPlayerCards();
}
}
document.getElementById('player-modal').addEventListener('click', function(e) {
if (e.target === this) {
closeModal();
}
});
document.getElementById('team-modal').addEventListener('click', function(e) {
if (e.target === this) {
closeTeamModal();
}
});
document.addEventListener('keydown', function(e) {
if (e.key === 'Escape') {
closeModal();
closeTeamModal();
}
});

function generateHomeInsights() {
console.log('ðŸ” generateHomeInsights called');
const allInsightCategories = [];

// Get all players
const allPlayersList = [];
if (window.aggregatedWRs) allPlayersList.push(...Object.values(window.aggregatedWRs));
if (window.aggregatedRBs) allPlayersList.push(...Object.values(window.aggregatedRBs));
if (window.aggregatedTEs) allPlayersList.push(...Object.values(window.aggregatedTEs));

console.log('ðŸ“Š Total players loaded:', allPlayersList.length);
console.log('WRs:', window.aggregatedWRs ? Object.keys(window.aggregatedWRs).length : 0);
console.log('RBs:', window.aggregatedRBs ? Object.keys(window.aggregatedRBs).length : 0);
console.log('TEs:', window.aggregatedTEs ? Object.keys(window.aggregatedTEs).length : 0);

if (allPlayersList.length === 0) {
console.warn('âš ï¸ No players data available yet');
return [];
}

// Chart size options
const chartSizes = ['small', 'medium', 'large', 'tall'];

// 1. TARGET SHARE MOVERS
const targetShareMovers = allPlayersList
.filter(p => p.weeks && p.weeks.length >= 4 && p.position === 'WR')
.map(p => {
const recentWeeks = p.weeks.slice(-3);
const olderWeeks = p.weeks.slice(-6, -3);
if (recentWeeks.length < 3 || olderWeeks.length < 3) return null;
const recentAvg = recentWeeks.reduce((sum, w) => sum + (w.teamShare || 0), 0) / recentWeeks.length;
const olderAvg = olderWeeks.reduce((sum, w) => sum + (w.teamShare || 0), 0) / olderWeeks.length;
const change = recentAvg - olderAvg;
return { player: p, change, recentAvg, impact: Math.abs(change) * 1.5 };
})
.filter(x => x && x.change > 3)
.sort((a, b) => b.impact - a.impact)[0];

if (targetShareMovers) {
const weeklyShares = targetShareMovers.player.weeks.slice(-6).map(w => w.teamShare || 0);
allInsightCategories.push({
category: 'Target Share Movers',
label: 'Rising Target Share',
value: `+${targetShareMovers.change.toFixed(1)}%`,
valueClass: 'positive',
title: `${targetShareMovers.player.name} gaining volume`,
description: `Target share up ${targetShareMovers.change.toFixed(1)}% over last 3 weeks. Now commanding ${targetShareMovers.recentAvg.toFixed(1)}% of targets. Quiet breakout forming before rankings adjust.`,
page: 'teams',
player: targetShareMovers.player,
chartType: 'line',
chartData: weeklyShares,
chartSize: 'large',
impact: targetShareMovers.impact,
badges: [
{ label: 'Current Rank', value: `#${targetShareMovers.player.rosRank || '?'}` },
{ label: 'Targets/Game', value: (targetShareMovers.player.tgtPerGame || 0).toFixed(1) }
]
});
}

// 2. EFFICIENCY LEADERS
const efficiencyLeaders = allPlayersList
.filter(p => p.gamesPlayed >= 4 && p.totalYDS && p.totalRec && p.totalRec > 0)
.map(p => {
const yardsPerTouch = p.totalYDS / (p.totalRec + (p.totalCarries || 0));
const ppTouch = p.totalPoints / (p.totalRec + (p.totalCarries || 0));
return { player: p, yardsPerTouch, ppTouch, score: yardsPerTouch * 0.6 + ppTouch * 0.4, impact: yardsPerTouch * 0.8 };
})
.filter(x => x.yardsPerTouch > 8)
.sort((a, b) => b.score - a.score);

if (efficiencyLeaders.length > 0) {
const topEfficiency = efficiencyLeaders[0];
const comparisonData = efficiencyLeaders.slice(0, 5).map(e => ({
name: e.player.name.split(' ').pop(),
value: e.yardsPerTouch
}));
allInsightCategories.push({
category: 'Efficiency Leaders',
label: 'Elite Efficiency',
value: `${topEfficiency.yardsPerTouch.toFixed(1)} YPT`,
valueClass: 'positive',
title: `${topEfficiency.player.name} maximizing touches`,
description: `${topEfficiency.yardsPerTouch.toFixed(1)} yards per touch with ${topEfficiency.ppTouch.toFixed(2)} points per opportunity. Elite production efficiency signals sustainable output.`,
page: 'advanced-analytics',
player: topEfficiency.player,
chartType: 'horizontalBar',
chartData: comparisonData,
chartSize: 'small',
impact: topEfficiency.impact
});
}

// 3. BREAKOUT CANDIDATES
const breakoutCandidate = allPlayersList
.filter(p => p.rosRank && p.rosRank > 10 && p.rosRank < 36 && p.momentum && p.momentum.score > 8 && p.avgPoints > 8)
.sort((a, b) => (b.momentum.score || 0) - (a.momentum.score || 0))[0];

if (breakoutCandidate) {
const actualPoints = breakoutCandidate.weeks.slice(-5).map(w => w.fpts || 0);
const expectedPoints = breakoutCandidate.weeks.slice(-5).map(w => w.expectedFpts || w.fpts * 0.85);
allInsightCategories.push({
category: 'Breakout Candidates',
label: 'Breakout Alert',
value: `#${breakoutCandidate.rosRank}`,
valueClass: 'positive',
title: `${breakoutCandidate.name} trending into elite tier`,
description: `Currently ranked #${breakoutCandidate.rosRank} but momentum score of ${breakoutCandidate.momentum.score.toFixed(1)} suggests top-12 trajectory. Strike before the market catches up.`,
page: 'analytics-dashboard',
player: breakoutCandidate,
chartType: 'dualLine',
chartData: { actual: actualPoints, expected: expectedPoints },
chartSize: 'tall',
impact: breakoutCandidate.momentum.score,
badges: [
{ label: 'Momentum', value: `+${breakoutCandidate.momentum.score.toFixed(1)}` },
{ label: 'Avg PPG', value: breakoutCandidate.avgPoints.toFixed(1) }
]
});
}

// 4. UNDER-THE-RADAR CONSISTENCY
const consistentPlayer = allPlayersList
.filter(p => p.gamesPlayed >= 5 && p.avgPoints >= 10 && p.avgPoints <= 15 && p.rosRank > 18)
.map(p => {
const weeklyPoints = p.weeks.map(w => w.fpts || 0);
const mean = weeklyPoints.reduce((a, b) => a + b, 0) / weeklyPoints.length;
const variance = weeklyPoints.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / weeklyPoints.length;
const stdDev = Math.sqrt(variance);
const consistency = mean / (stdDev + 1);
return { player: p, consistency, stdDev, impact: consistency * 0.6 };
})
.filter(x => x.stdDev < 6)
.sort((a, b) => b.consistency - a.consistency)[0];

if (consistentPlayer) {
const recentPoints = consistentPlayer.player.weeks.slice(-5).map(w => w.fpts || 0);
const recentTargets = consistentPlayer.player.weeks.slice(-5).map(w => w.targets || w.rushAttempts || 0);
allInsightCategories.push({
category: 'Under-the-Radar Consistency',
label: 'Steady Producer',
value: `${consistentPlayer.player.avgPoints.toFixed(1)} PPG`,
valueClass: 'positive',
title: `${consistentPlayer.player.name} reliable floor`,
description: `Averaging ${consistentPlayer.player.avgPoints.toFixed(1)} PPG with low variance (Â±${consistentPlayer.stdDev.toFixed(1)}). Steady usage and reliable output flying under the radar.`,
page: 'top-movers',
player: consistentPlayer.player,
chartType: 'splitMini',
chartData: { points: recentPoints, targets: recentTargets },
chartSize: 'medium',
impact: consistentPlayer.impact
});
}

// 5. MATCHUP HIGHLIGHTS - Red Zone Usage
const matchupHighlight = allPlayersList
.filter(p => p.rzOpportunities && p.teamRzOpportunities && p.rzOpportunities > 6)
.map(p => {
const rzShare = (p.rzOpportunities / p.teamRzOpportunities) * 100;
const effScore = (p.avgPoints || 0) + (rzShare * 0.3);
return { player: p, rzShare, effScore, impact: rzShare * 0.5 };
})
.sort((a, b) => b.effScore - a.effScore)[0];

if (matchupHighlight) {
// Get team RZ distribution
const teamPlayers = allPlayersList.filter(p => p.team === matchupHighlight.player.team && p.rzOpportunities > 0)
.sort((a, b) => b.rzOpportunities - a.rzOpportunities)
.slice(0, 4);
const rzDistribution = teamPlayers.map(p => ({
name: p.name.split(' ').pop(),
value: p.rzOpportunities
}));
const othersRZ = matchupHighlight.player.teamRzOpportunities - teamPlayers.reduce((sum, p) => sum + p.rzOpportunities, 0);
if (othersRZ > 0) rzDistribution.push({ name: 'Others', value: othersRZ });

allInsightCategories.push({
category: 'Matchup Highlights',
label: 'Red Zone Weapon',
value: `${matchupHighlight.rzShare.toFixed(0)}%`,
valueClass: 'positive',
title: `${matchupHighlight.player.name} dominates scoring zone`,
description: `Commands ${matchupHighlight.rzShare.toFixed(0)}% of team's red zone opportunities. High-efficiency usage with ${matchupHighlight.player.rzOpportunities} RZ touches. Elite touchdown upside week to week.`,
page: 'teams',
player: matchupHighlight.player,
chartType: 'doughnut',
chartData: rzDistribution,
chartSize: 'medium',
impact: matchupHighlight.impact
});
}

// 6. RISING STARS - Young players gaining role
const risingStar = allPlayersList
.filter(p => p.momentum && p.momentum.direction === 'up' && p.gamesPlayed >= 3 && p.avgPoints > 7 && p.avgPoints < 16)
.sort((a, b) => (b.momentum.score || 0) - (a.momentum.score || 0))[0];

if (risingStar) {
const recentWeeks = risingStar.weeks.slice(-5);
const routesData = recentWeeks.map(w => {
// Estimate routes from snaps/targets
const routes = (w.targets || 0) * 3.5;
return Math.round(routes);
});
const targetsData = recentWeeks.map(w => w.targets || w.rushAttempts || 0);

allInsightCategories.push({
category: 'Rising Stars',
label: 'Emerging Role',
value: `+${risingStar.momentum.score.toFixed(1)}`,
valueClass: 'positive',
title: `${risingStar.name} role expanding`,
description: `Momentum score of +${risingStar.momentum.score.toFixed(1)} signals growing role. Averaging ${risingStar.avgPoints.toFixed(1)} PPG with upward trajectory. Future league-winner potential.`,
page: 'analytics-dashboard',
player: risingStar,
chartType: 'stackedBar',
chartData: { routes: routesData, targets: targetsData },
chartSize: 'medium',
impact: risingStar.momentum.score
});
}

// 7. TOP PPG PERFORMER (bonus insight)
const topScorer = allPlayersList
.filter(p => p.avgPoints && p.gamesPlayed >= 4)
.sort((a, b) => (b.avgPoints || 0) - (a.avgPoints || 0))[0];
if (topScorer && allInsightCategories.length < 7) {
const weeklyPoints = topScorer.weeks.slice(-5).map(w => w.fpts || 0);
allInsightCategories.push({
category: 'Top Performers',
label: 'League Leader',
value: `${topScorer.avgPoints.toFixed(1)} PPG`,
valueClass: 'positive',
title: `${topScorer.name} dominating`,
description: `Leading all players with ${topScorer.avgPoints.toFixed(1)} PPG. Elite weekly production makes them a cornerstone fantasy asset.`,
page: topScorer.position === 'WR' ? 'wide-receivers' : topScorer.position === 'RB' ? 'running-backs' : 'tight-ends',
player: topScorer,
chartType: 'line',
chartData: weeklyPoints,
chartSize: 'small',
impact: topScorer.avgPoints
});
}

// 8. USAGE SPIKE (bonus insight)
const usageSpike = allPlayersList
.filter(p => p.weeks && p.weeks.length >= 2 && p.position === 'WR')
.map(p => {
const latest = p.weeks[p.weeks.length - 1];
const previous = p.weeks[p.weeks.length - 2];
const spike = (latest.teamShare || 0) - (previous.teamShare || 0);
return { player: p, spike, latest: latest.teamShare, impact: Math.abs(spike) * 1.2 };
})
.filter(x => x.spike > 5)
.sort((a, b) => b.spike - a.spike)[0];

if (usageSpike && allInsightCategories.length < 8) {
const recentShares = usageSpike.player.weeks.slice(-5).map(w => w.teamShare || 0);
allInsightCategories.push({
category: 'Usage Spike',
label: 'Rising Usage',
value: `+${usageSpike.spike.toFixed(1)}%`,
valueClass: 'positive',
title: `${usageSpike.player.name} target spike`,
description: `Week-over-week target share jump of ${usageSpike.spike.toFixed(1)}%. Offense pivoting toward high-efficiency weapons.`,
page: 'wide-receivers',
player: usageSpike.player,
chartType: 'sparkline',
chartData: recentShares,
chartSize: 'small',
impact: usageSpike.impact
});
}

// Sort by impact (most important first) and return 6-8
allInsightCategories.sort((a, b) => b.impact - a.impact);
console.log('âœ… Generated insights:', allInsightCategories.length, allInsightCategories.map(i => i.category));
return allInsightCategories.slice(0, Math.min(8, allInsightCategories.length));
}


// function renderHomeInsights() { // Disabled - new homepage
// console.log('ðŸŽ¨ renderHomeInsights called');
// const grid = document.getElementById('home-insights-grid');
// if (!grid) {
// console.error('âŒ home-insights-grid element not found');
// return;
// }

// const insights = generateHomeInsights();
// console.log('ðŸ“‹ Insights to render:', insights.length);
// if (insights.length === 0) {
// grid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: var(--text-secondary); padding: 48px;">Loading insights...</div>';
// return;
// }

// grid.innerHTML = insights.map((insight, index) => {
// const chartId = `home-chart-${index}`;

// Assign layout classes
// let layoutClass = '';
// let adjustedChartSize = insight.chartSize;
// let showChart = false; // Only show charts in larger boxes

// if (index === 0) {
// layoutClass = 'large-feature';
// adjustedChartSize = 'large'; // First card is 2x2, needs large chart
// showChart = true;
// } else if (index === insights.length - 1 && insights.length > 5) {
// layoutClass = 'horizontal-wide';
// adjustedChartSize = 'medium'; // Last card is 2x1 horizontal
// showChart = true;
// }

// let badgesHTML = '';
// if (insight.badges) {
// badgesHTML = `<div class="insight-stat-badges">${insight.badges.map(b => `
// <div class="insight-stat-badge">
// <div class="insight-stat-badge-label">${b.label}</div>
// <div class="insight-stat-badge-value">${b.value}</div>
// </div>
// `).join('')}</div>`;
// }

// let chartHTML = '';
// Only render charts for large boxes
// if (showChart) {
// if (insight.chartType === 'splitMini') {
// chartHTML = `<div class="insight-split-charts">
// <div class="insight-mini-chart">
// <div class="insight-mini-chart-label">Weekly Points</div>
// <canvas id="${chartId}-1"></canvas>
// </div>
// <div class="insight-mini-chart">
// <div class="insight-mini-chart-label">Opportunities</div>
// <canvas id="${chartId}-2"></canvas>
// </div>
// </div>`;
// } else {
// chartHTML = `<div class="insight-chart-container ${adjustedChartSize}">
// <canvas id="${chartId}"></canvas>
// </div>`;
// }
// }

// return `
// <div class="home-insight-card ${layoutClass}" onclick="navigateToPage('${insight.page}')">
// <div class="insight-card-header">
// <div class="insight-card-label">${insight.label}</div>
// <div class="insight-card-arrow">â†’</div>
// </div>
// <div class="insight-card-value ${insight.valueClass}">${insight.value}</div>
// <div class="insight-card-title">${insight.title}</div>
// <div class="insight-card-description">${insight.description}</div>
// ${badgesHTML}
// ${chartHTML}
// </div>
// `;
// }).join('');

// Render charts after DOM is updated
// setTimeout(() => {
// insights.forEach((insight, index) => {
// const chartId = `home-chart-${index}`;
// Check if chart element exists before trying to render
// const chartElement = document.getElementById(chartId);
// if (!chartElement) return; // Skip if no chart element

// if (insight.chartType === 'line') {
// renderLineChart(chartId, insight.chartData);
// } else if (insight.chartType === 'horizontalBar') {
// renderHorizontalBarChart(chartId, insight.chartData);
// } else if (insight.chartType === 'dualLine') {
// renderDualLineChart(chartId, insight.chartData);
// } else if (insight.chartType === 'doughnut') {
// renderDoughnutChart(chartId, insight.chartData);
// } else if (insight.chartType === 'stackedBar') {
// renderStackedBarChart(chartId, insight.chartData);
// } else if (insight.chartType === 'sparkline') {
// renderSparklineChart(chartId, insight.chartData);
// } else if (insight.chartType === 'splitMini') {
// renderSplitMiniCharts(chartId, insight.chartData);
// }
// });
// }, 100);
// }

function renderLineChart(chartId, data) {
const ctx = document.getElementById(chartId);
if (!ctx) return;
new Chart(ctx.getContext('2d'), {
type: 'line',
data: {
labels: data.map((_, i) => `W${i+1}`),
datasets: [{
data: data,
borderColor: '#30d158',
backgroundColor: 'rgba(48, 209, 88, 0.15)',
borderWidth: 3,
tension: 0.4,
fill: true,
pointBackgroundColor: '#30d158',
pointBorderColor: '#000',
pointBorderWidth: 2,
pointRadius: 4
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: { legend: { display: false } },
scales: {
y: { grid: { color: '#1c1c1e' } },
x: { grid: { display: false } }
}
}
});
}

function renderHorizontalBarChart(chartId, data) {
const ctx = document.getElementById(chartId);
if (!ctx) return;
new Chart(ctx.getContext('2d'), {
type: 'bar',
data: {
labels: data.map(d => d.name),
datasets: [{
data: data.map(d => d.value),
backgroundColor: data.map((_, i) => i < 3 ? '#30d158' : '#636366'),
borderRadius: 4
}]
},
options: {
indexAxis: 'y',
responsive: true,
maintainAspectRatio: false,
plugins: { legend: { display: false } },
scales: {
x: { display: false },
y: { grid: { display: false }, ticks: { font: { size: 10 } } }
}
}
});
}

function renderDualLineChart(chartId, data) {
const ctx = document.getElementById(chartId);
if (!ctx) return;
new Chart(ctx.getContext('2d'), {
type: 'line',
data: {
labels: data.actual.map((_, i) => `W${i+1}`),
datasets: [{
label: 'Actual',
data: data.actual,
borderColor: '#30d158',
backgroundColor: 'rgba(48, 209, 88, 0.1)',
borderWidth: 3,
tension: 0.3,
fill: true,
pointRadius: 4
}, {
label: 'Expected',
data: data.expected,
borderColor: '#8e8e93',
borderWidth: 2,
borderDash: [5, 5],
tension: 0.3,
pointRadius: 4
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: {
legend: { 
display: true, 
position: 'bottom',
labels: { boxWidth: 10, padding: 8, font: { size: 10 }, usePointStyle: true }
}
},
scales: {
y: { grid: { color: '#1c1c1e' } },
x: { grid: { display: false } }
}
}
});
}

function renderDoughnutChart(chartId, data) {
const ctx = document.getElementById(chartId);
if (!ctx) return;
const colors = ['#30d158', '#0a84ff', '#ff9500', '#af52de', '#2c2c2e'];
new Chart(ctx.getContext('2d'), {
type: 'doughnut',
data: {
labels: data.map(d => `${d.name}`),
datasets: [{
data: data.map(d => d.value),
backgroundColor: data.map((_, i) => colors[i % colors.length]),
borderWidth: 3,
borderColor: '#0a0a0a'
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: {
legend: {
display: true,
position: 'bottom',
labels: { boxWidth: 10, padding: 6, font: { size: 10 }, usePointStyle: true, pointStyle: 'circle' }
}
}
}
});
}

function renderStackedBarChart(chartId, data) {
const ctx = document.getElementById(chartId);
if (!ctx) return;
new Chart(ctx.getContext('2d'), {
type: 'bar',
data: {
labels: data.routes.map((_, i) => `W${i+1}`),
datasets: [{
label: 'Routes',
data: data.routes,
backgroundColor: '#0a84ff',
borderRadius: 4
}, {
label: 'Targets',
data: data.targets,
backgroundColor: '#30d158',
borderRadius: 4
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: {
legend: {
display: true,
position: 'bottom',
labels: { boxWidth: 10, padding: 8, font: { size: 10 }, usePointStyle: true }
}
},
scales: {
y: { grid: { color: '#1c1c1e' } },
x: { grid: { display: false } }
}
}
});
}

function renderSparklineChart(chartId, data) {
const ctx = document.getElementById(chartId);
if (!ctx) return;
new Chart(ctx.getContext('2d'), {
type: 'line',
data: {
labels: data.map((_, i) => `W${i+1}`),
datasets: [{
data: data,
borderColor: '#30d158',
borderWidth: 2,
tension: 0.3,
pointRadius: 0
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: { legend: { display: false } },
scales: {
y: { display: false },
x: { display: false }
}
}
});
}

function renderSplitMiniCharts(chartId, data) {
// Points chart
const ctx1 = document.getElementById(`${chartId}-1`);
if (ctx1) {
new Chart(ctx1.getContext('2d'), {
type: 'line',
data: {
labels: data.points.map((_, i) => `W${i+1}`),
datasets: [{
data: data.points,
borderColor: '#30d158',
backgroundColor: 'rgba(48, 209, 88, 0.2)',
borderWidth: 2,
tension: 0.4,
fill: true,
pointRadius: 3
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: { legend: { display: false } },
scales: {
y: { display: false },
x: { display: true, grid: { display: false }, ticks: { font: { size: 8 } } }
}
}
});
}

// Targets chart
const ctx2 = document.getElementById(`${chartId}-2`);
if (ctx2) {
new Chart(ctx2.getContext('2d'), {
type: 'bar',
data: {
labels: data.targets.map((_, i) => `W${i+1}`),
datasets: [{
data: data.targets,
backgroundColor: '#0a84ff',
borderRadius: 3
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: { legend: { display: false } },
scales: {
y: { display: false },
x: { display: true, grid: { display: false }, ticks: { font: { size: 8 } } }
}
}
});
}
}

function renderMarketTicker() {
    console.log('ðŸŽ« Rendering home ticker - Recent week performers');
    const homeTickerTrack = document.getElementById('home-ticker-track');
    if (!homeTickerTrack) {
        console.log('home-ticker-track not found');
        return;
    }
    
    // Check if data is loaded
    if (!window.aggregatedWRs || !window.aggregatedRBs || !window.aggregatedTEs) {
        console.log('Player data not yet loaded');
        return;
    }
    
    try {
        // Find the most recent week across ALL positions
        let mostRecentWeek = 0;
        
        [window.aggregatedWRs, window.aggregatedRBs, window.aggregatedTEs].forEach(positionData => {
            Object.values(positionData).forEach(player => {
                if (player.weeks && player.weeks.length > 0) {
                    const maxWeek = Math.max(...player.weeks.map(w => w.week));
                    if (maxWeek > mostRecentWeek) mostRecentWeek = maxWeek;
                }
            });
        });
        
        if (mostRecentWeek === 0) {
            console.log('No week data found');
            return;
        }
        
        console.log(`Most recent week: ${mostRecentWeek}`);
        
        // Collect all players who played in the most recent week
        const allPlayers = [];
        
        const processPosition = (positionData, position) => {
            Object.values(positionData).forEach(player => {
                if (!player.weeks || player.weeks.length === 0) return;
                
                // Get data specifically from the most recent week
                const recentWeekData = player.weeks.find(w => w.week === mostRecentWeek);
                
                if (recentWeekData && recentWeekData.fpts != null && recentWeekData.fpts > 0) {
                    // Calculate raw difference from expected
                    const actual = recentWeekData.fpts;
                    const expected = recentWeekData.expectedFpts || 0;
                    const rawDifference = actual - expected;
                    
                    allPlayers.push({
                        name: player.name,
                        team: player.team,
                        position: position,
                        fpts: actual,
                        expectedFpts: expected,
                        rawDifference: rawDifference,
                        week: mostRecentWeek
                    });
                }
            });
        };
        
        processPosition(window.aggregatedWRs, 'WR');
        processPosition(window.aggregatedRBs, 'RB');
        processPosition(window.aggregatedTEs, 'TE');
        
        if (allPlayers.length === 0) {
            homeTickerTrack.innerHTML = '<div class="ticker-stat">No player data available for recent week</div>';
            return;
        }
        
        // Sort by FPTS (descending) to get rankings
        allPlayers.sort((a, b) => b.fpts - a.fpts);
        
        // Take top 25 players
        const topPlayers = allPlayers.slice(0, 25);
        
        console.log(`Top 25 players for week ${mostRecentWeek}:`, topPlayers.slice(0, 5).map(p => `${p.name} ${p.fpts.toFixed(1)}`).join(', '));
        
        // Create ticker HTML
        const tickerHTML = topPlayers.map((player, index) => {
            const rank = index + 1;
            const diffSign = player.rawDifference >= 0 ? '+' : '';
            const deltaClass = player.rawDifference >= 0 ? 'positive' : 'negative';
            
            return `
                <div class="ticker-stat">
                    <span class="ticker-stat-label">#${rank} ${player.name}</span>
                    <span class="ticker-stat-team">${player.position}</span>
                    <span class="ticker-stat-value">${player.fpts.toFixed(1)} pts</span>
                    <span class="ticker-stat-change ${deltaClass}">${diffSign}${player.rawDifference.toFixed(1)} vs exp</span>
                </div>
            `;
        }).join('');
        
        // Set the HTML
        homeTickerTrack.innerHTML = tickerHTML;
        
        console.log('âœ“ Home ticker rendered successfully');
        
    } catch (error) {
        console.error('Error rendering home ticker:', error);
    }
}

function rotateHomeMessages() {
const headlines = [
'Find value before your league does.',
'Buy low. Sell high. Win leagues.',
'Signal > Hype.',
'Smarter signals. Better timing. No noise.'
];
const subheadlines = [
'See the trends before your league mates do.',
'Make moves with data, not vibes.',
'The edge you need, without the noise.'
];

let headlineIndex = 0;
let subheadlineIndex = 0;

setInterval(() => {
const homePage = document.getElementById('home');
if (!homePage || !homePage.classList.contains('active')) {
return; // Don't animate if not on home page
}

const headlineEl = document.getElementById('home-headline');
const subheadlineEl = document.getElementById('home-subheadline');
if (headlineEl && subheadlineEl) {
headlineIndex = (headlineIndex + 1) % headlines.length;
subheadlineIndex = (subheadlineIndex + 1) % subheadlines.length;

// Simple fade out
headlineEl.style.opacity = '0';
subheadlineEl.style.opacity = '0';

// Wait for fade complete, change text, fade in
setTimeout(() => {
headlineEl.textContent = headlines[headlineIndex];
subheadlineEl.textContent = subheadlines[subheadlineIndex];

setTimeout(() => {
headlineEl.style.opacity = '1';
subheadlineEl.style.opacity = '1';
}, 50);
}, 500);
}
}, 8000);
}

window.addEventListener('DOMContentLoaded', function() {
loadSentimentData();
const storedComments = localStorage.getItem('ffse_player_comments');
if (storedComments) {
playerComments = JSON.parse(storedComments);
}
const hasLocalData = localStorage.getItem('wrData') &&
localStorage.getItem('rbData') &&
localStorage.getItem('teData');
if (hasLocalData) {
loadStoredData();
setTimeout(() => {
const dashboardPage = document.getElementById('top-movers');
if (dashboardPage && dashboardPage.classList.contains('active')) {
renderDashboardCategories();
setTimeout(renderMiniScatterPlots, 100);
}
}, 200);
fetchDataFromGitHub().catch(err => { });
} else {
showLoadingIndicator();
fetchDataFromGitHub();
}
});
document.addEventListener('visibilitychange', function() {
if (typeof animationStates === 'undefined') return;
if (document.hidden) {
Object.keys(animationStates).forEach(chartId => {
if (animationStates[chartId].isPlaying) {
animationStates[chartId].wasPlayingBeforeHidden = true;
pauseSmoothTrendAnimation(chartId);
}
});
} else {
Object.keys(animationStates).forEach(chartId => {
if (animationStates[chartId].wasPlayingBeforeHidden) {
playSmoothTrendAnimation(chartId);
animationStates[chartId].wasPlayingBeforeHidden = false;
}
});
}
});
let heatmapState = {
position: 'WR',
period: 'last3',
metric: 'actual-vs-expected',
display: window.innerWidth > 768 ? '36' : '24' // Top 36 on desktop, Top 24 on mobile
};

function updateHeatmapTicker() {
const tickerInsight = document.getElementById('heatmap-ticker-insight');
if (!tickerInsight) return;

// Get top movers from current data
const position = heatmapState.position;
const players = getPlayersForPosition(position);
if (players.length === 0) return;

const playersWithMetric = players.map(player => {
const metricData = calculatePlayerMetric(player, heatmapState.metric, heatmapState.period);
return {
...player,
metricDelta: metricData.delta
};
}).filter(p => p.metricDelta !== null);

// Sort by change (delta)
playersWithMetric.sort((a, b) => Math.abs(b.metricDelta) - Math.abs(a.metricDelta));
const topMovers = playersWithMetric.slice(0, 3);

// Create ticker text
const tickerText = topMovers.map(p => {
const sign = p.metricDelta > 0 ? '+' : '';
return `${p.name} ${sign}${p.metricDelta.toFixed(0)}%`;
}).join(' â€¢ ');

tickerInsight.textContent = tickerText;
}

function initializeAnalyticsDashboard() {
if (!aggregatedWRs || Object.keys(aggregatedWRs).length === 0) {
console.log('Analytics Dashboard: Data not yet loaded');
return;
}
console.log('Analytics Dashboard: Initializing with data', {
WRs: Object.keys(aggregatedWRs).length,
RBs: Object.keys(aggregatedRBs).length,
TEs: Object.keys(aggregatedTEs).length
});

// Set dropdown values to match state
const displaySelect = document.getElementById('heatmap-display-select-new');
if (displaySelect) {
displaySelect.value = heatmapState.display;
}

updateHeatmap();
updateMarketOpportunities();
initializeMetricTooltip();
}
function initializeMetricTooltip() {
const infoIcon = document.getElementById('metric-info-icon');
const tooltip = document.getElementById('metric-tooltip');
const metricSelect = document.getElementById('heatmap-metric-select');
if (!infoIcon || !tooltip || !metricSelect) {
console.log('Metric tooltip elements not found, will retry when page is shown');
return false;
}
const newInfoIcon = infoIcon.cloneNode(true);
infoIcon.parentNode.replaceChild(newInfoIcon, infoIcon);
newInfoIcon.addEventListener('click', (e) => {
e.stopPropagation();
const currentTooltip = document.getElementById('metric-tooltip');
if (!currentTooltip) return;
const isVisible = currentTooltip.style.display === 'block';
currentTooltip.style.display = isVisible ? 'none' : 'block';
if (!isVisible) {
const currentSelect = document.getElementById('heatmap-metric-select');
if (currentSelect) {
updateMetricTooltipContent(currentSelect.value);
}
}
});
metricSelect.addEventListener('change', () => {
const currentTooltip = document.getElementById('metric-tooltip');
if (currentTooltip && currentTooltip.style.display === 'block') {
updateMetricTooltipContent(metricSelect.value);
}
});
document.addEventListener('click', (e) => {
const currentTooltip = document.getElementById('metric-tooltip');
const currentInfoIcon = document.getElementById('metric-info-icon');
if (currentTooltip && !currentTooltip.contains(e.target) && e.target !== currentInfoIcon) {
currentTooltip.style.display = 'none';
}
});
console.log('Metric tooltip initialized successfully');
return true;
}
function updateMetricTooltipContent(metric) {
const content = document.getElementById('metric-tooltip-content');
if (!content) return;
const tooltips = {
'actual-vs-expected': `
<strong>Actual vs Expected Points</strong><div class="tooltip-section"><div class="tooltip-label">The Number (e.g., "15.2 pts")</div>
Player's average fantasy points per game for the selected time period (Last 3 or Last 5 weeks).
</div><div class="tooltip-section"><div class="tooltip-label">The Delta & Color (e.g., "+12%" = Green)</div><strong>Period vs Season comparison:</strong> How much better (green) or worse (red) the player is performing in this period compared to their season average vs expected.
<br><br><strong>Example Calculation:</strong><br>
â€¢ Last 3 weeks: Player averaged 15 pts vs 12 expected = +25% over expected<br>
â€¢ Season average: Player averaged 14 pts vs 13 expected = +7.7% over expected<br>
â€¢ <strong>Delta: +25% - 7.7% = +17.3%</strong> (Strong positive = green card)<br><br><strong>Color Thresholds:</strong><br>
â€¢ Dark Green: +20% or more<br>
â€¢ Light Green: +10% to +15%<br>
â€¢ Gray: Â±5% (on target)<br>
â€¢ Light Red: -10% to -15%<br>
â€¢ Dark Red: -20% or worse
</div><div class="tooltip-section"><div class="tooltip-label">What It Means</div>
â€¢ Positive (+) = Recently performing BETTER vs expectations than season average<br>
â€¢ Negative (-) = Recently performing WORSE vs expectations than season average<br>
â€¢ Shows if player is heating up or cooling down relative to projections
</div>
`,
'target-share': `
<strong>Target/Opportunity Share</strong><div class="tooltip-section"><div class="tooltip-label">The Number (e.g., "22.5%")</div>
Average usage share for the selected time period (Last 3 or Last 5 weeks):
<br>
â€¢ <strong>WR/TE:</strong> Target share (% of team's targets)
<br>
â€¢ <strong>RB:</strong> Opportunity share (% of team's touches)
</div><div class="tooltip-section"><div class="tooltip-label">The Delta & Color (e.g., "+4.5%" = Green)</div><strong>Period vs Season comparison:</strong> Difference between recent usage and season average usage (in percentage points).
<br><br><strong>Example Calculation:</strong><br>
â€¢ Last 3 weeks: Player averaged 28% target share<br>
â€¢ Season average: Player averaged 22% target share<br>
â€¢ <strong>Delta: 28% - 22% = +6%</strong> (Strong positive = green card)<br><br><strong>Color Thresholds:</strong><br>
â€¢ Dark Green: +8% or more<br>
â€¢ Light Green: +3% to +5%<br>
â€¢ Gray: Â±1.5% (stable)<br>
â€¢ Light Red: -3% to -5%<br>
â€¢ Dark Red: -8% or worse
</div><div class="tooltip-section"><div class="tooltip-label">What It Means</div>
â€¢ 20%+ with positive delta = Elite usage trending up<br>
â€¢ Rising usage = Role expanding, buy candidate<br>
â€¢ Falling usage from high level = Monitor closely
</div>
`,
'rz-opp-share': `
<strong>RZ Opportunity Share</strong><div class="tooltip-section"><div class="tooltip-label">The Number (e.g., "35.2%")</div>
Player's share of their team's red zone opportunities for the selected time period (Last 3 or Last 5 weeks).
<br>
â€¢ <strong>WR/TE:</strong> % of team's RZ targets
<br>
â€¢ <strong>RB:</strong> % of team's RZ carries + targets
</div><div class="tooltip-section"><div class="tooltip-label">The Delta & Color (e.g., "+5%" = Green)</div><strong>Period vs Season comparison:</strong> Difference between recent RZ share and season average RZ share (in percentage points).
<br><br><strong>Example Calculation:</strong><br>
â€¢ Last 3 weeks: Player got 7 RZ targets, team had 18 total = 38.9% RZ share<br>
â€¢ Season average: Player got 22 RZ targets, team had 68 total = 32.4% RZ share<br>
â€¢ <strong>Delta: 38.9% - 32.4% = +6.5%</strong> (Extreme positive = dark green card)<br><br><strong>Color Thresholds:</strong><br>
â€¢ Dark Green: +6% or more<br>
â€¢ Light Green: +2.5% to +4%<br>
â€¢ Gray: Â±1.5% (stable)<br>
â€¢ Light Red: -2.5% to -4%<br>
â€¢ Dark Red: -6% or worse
</div><div class="tooltip-section"><div class="tooltip-label">What It Means</div>
â€¢ 30%+ with positive delta = Dominating team's RZ, high TD upside<br>
â€¢ Rising RZ share = Increasing TD opportunity, buy candidate<br>
â€¢ Falling RZ share = TD upside declining, potential concern
</div>
`,
'points-per-touch': `
<strong>Points per Touch Efficiency</strong><div class="tooltip-section"><div class="tooltip-label">The Number (e.g., "1.45")</div>
Average fantasy points per touch for the selected time period.
<br>
â€¢ <strong>WR/TE:</strong> Points per target
<br>
â€¢ <strong>RB:</strong> Points per opportunity (carry + target)
</div><div class="tooltip-section"><div class="tooltip-label">The Delta & Color (e.g., "+0.15" = Green)</div><strong>Period vs Season comparison:</strong> Difference in efficiency (recent vs season average).
<br><br><strong>Example Calculation:</strong><br>
â€¢ Last 3 weeks: Player scored 45 pts on 28 targets = 1.61 pts/target<br>
â€¢ Season average: Player scored 112 pts on 78 targets = 1.44 pts/target<br>
â€¢ <strong>Delta: 1.61 - 1.44 = +0.17</strong> (Moderate positive = green card)<br><br><strong>Color Thresholds:</strong><br>
â€¢ Dark Green: +0.40 or more<br>
â€¢ Light Green: +0.15 to +0.25<br>
â€¢ Gray: Â±0.08 (stable)<br>
â€¢ Light Red: -0.15 to -0.25<br>
â€¢ Dark Red: -0.40 or worse
</div><div class="tooltip-section"><div class="tooltip-label">What It Means</div>
â€¢ Higher efficiency + steady volume = Elite player<br>
â€¢ Rising efficiency = Buy candidate<br>
â€¢ Falling efficiency with high volume = Positive regression likely
</div>
`,
'consistency': `
<strong>Consistency Score</strong><div class="tooltip-section"><div class="tooltip-label">The Number (e.g., "75")</div>
Consistency score (0-100) for the selected time period. Higher = more consistent.
<br><br>
Formula: 100 - (Coefficient of Variation)
</div><div class="tooltip-section"><div class="tooltip-label">The Delta (e.g., "+8")</div><strong>Period vs Season comparison:</strong> Difference in consistency score.
<br><br>
â€¢ Positive (+) = MORE consistent recently<br>
â€¢ Negative (-) = LESS consistent recently (boom/bust)
</div><div class="tooltip-section"><div class="tooltip-label">What It Means</div>
â€¢ 75+ = Very consistent (safe floor)<br>
â€¢ 50-75 = Moderate consistency<br>
â€¢ <50 = Boom/bust player
</div>
`,
'ceiling': `
<strong>Ceiling (90th Percentile)</strong><div class="tooltip-section"><div class="tooltip-label">The Number (e.g., "24.5")</div>
90th percentile fantasy score for the selected time period. Represents weekly upside.
</div><div class="tooltip-section"><div class="tooltip-label">The Delta (e.g., "+3.2")</div><strong>Period vs Season comparison:</strong> Difference in ceiling.
<br><br>
â€¢ Positive (+) = Higher ceiling recently<br>
â€¢ Negative (-) = Lower ceiling recently
</div><div class="tooltip-section"><div class="tooltip-label">What It Means</div>
â€¢ 25+ ceiling = League-winning upside<br>
â€¢ Rising ceiling = Player breaking out<br>
â€¢ High ceiling + low floor = Boom/bust
</div>
`,
'floor': `
<strong>Floor (10th Percentile)</strong><div class="tooltip-section"><div class="tooltip-label">The Number (e.g., "8.5")</div>
10th percentile fantasy score for the selected time period. Represents weekly safety.
</div><div class="tooltip-section"><div class="tooltip-label">The Delta (e.g., "+2.1")</div><strong>Period vs Season comparison:</strong> Difference in floor.
<br><br>
â€¢ Positive (+) = Higher floor recently (safer)<br>
â€¢ Negative (-) = Lower floor recently (riskier)
</div><div class="tooltip-section"><div class="tooltip-label">What It Means</div>
â€¢ 10+ floor = Very safe weekly play<br>
â€¢ Rising floor = Role solidifying<br>
â€¢ Low floor = Risky start
</div>
`
};
content.innerHTML = tooltips[metric] || '<strong>Select a metric to see details</strong>';
}
function setHeatmapPeriod(period) {
heatmapState.period = period;
updateHeatmap();
}

// Updated functions for dropdown-based filters
function setHeatmapPosition(position) {
heatmapState.position = position;
updateHeatmap();
}

function setHeatmapMetric(metric) {
heatmapState.metric = metric;
updateHeatmapLegend(metric);
updateHeatmap();
}

function setHeatmapPeriodNew(period) {
heatmapState.period = period;
updateHeatmap();
}

function setHeatmapDisplayNew(display) {
heatmapState.display = display;
updateHeatmap();
}

function setHeatmapDisplay(display) {
heatmapState.display = display;
updateHeatmap();
}
function updateHeatmap() {
const position = heatmapState.position;
const metric = heatmapState.metric;
console.log(`===== HEATMAP UPDATE =====`);
console.log(`Position: ${position}, Metric: ${metric}, Period: ${heatmapState.period}`);
console.log(`Current scoring format: ${currentScoringFormat}`);
updateHeatmapLegend(metric);
let players = getPlayersForPosition(position);
console.log(`Players loaded for ${position}: ${players.length}`);
if (players.length > 0 && metric === 'actual-vs-expected') {
const sample = players[0];
console.log(`Sample ${position}: ${sample.name}`);
console.log(` - avgPoints: ${sample.avgPoints.toFixed(2)}`);
console.log(` - pctOverExpected: ${sample.pctOverExpected.toFixed(2)}%`);
if (sample.weeks && sample.weeks.length > 0) {
const recentWeek = sample.weeks[sample.weeks.length - 1];
console.log(` - Recent week fpts: ${recentWeek.fpts.toFixed(2)}`);
console.log(` - Recent week expectedFpts: ${recentWeek.expectedFpts.toFixed(2)}`);
}
}
players = players.map(player => {
const metricData = calculatePlayerMetric(player, metric, heatmapState.period);
return {
...player,
metricValue: metricData.value,
metricDelta: metricData.delta,
metricDisplay: metricData.display
};
}).filter(p => p.metricValue !== null);
console.log(`Players after metric calculation: ${players.length}`);
// First, sort by actual metric value to get the TOP players
players.sort((a, b) => b.metricValue - a.metricValue);

// Slice to get top N players based on their actual performance
if (heatmapState.display !== 'all') {
const displayLimit = parseInt(heatmapState.display);
if (displayLimit > 0) {
players = players.slice(0, displayLimit);
}
}

// Now re-sort those top players by their CHANGE (metricDelta)
// This puts the greenest (biggest improvement) in top-left, 
// and reddest (biggest decline) in bottom-right
players.sort((a, b) => b.metricDelta - a.metricDelta);
console.log(`Players to display: ${players.length}`);
updatePositionStats(players, position);
renderHeatmapCards(players, position);
updateHeatmapTicker();
renderPlayerInsightsFromHeatmap();
}
function getPlayersForPosition(position) {
if (position === 'WR') {
if (!aggregatedWRs) return [];
return Object.values(window.aggregatedWRs).filter(p => p.gamesPlayed >= 3);
} else if (position === 'RB') {
if (!aggregatedRBs) return [];
return Object.values(window.aggregatedRBs).filter(p => p.gamesPlayed >= 3);
} else if (position === 'TE') {
if (!aggregatedTEs) return [];
return Object.values(window.aggregatedTEs).filter(p => p.gamesPlayed >= 3);
}
return [];
}
function calculatePlayerMetric(player, metric, period) {
const periodData = getPlayerDataForPeriod(player, period);
if (!periodData) return { value: null, delta: 0, display: 'N/A' };
const seasonData = getPlayerDataForPeriod(player, 'season');
if (!seasonData) return { value: null, delta: 0, display: 'N/A' };
const avgPoints = periodData.avgPoints;
const avgExpected = periodData.avgExpected;
const weeks = periodData.weeks;
const seasonWeeks = seasonData.weeks;
switch (metric) {
case 'actual-vs-expected': {
if (avgExpected === 0 || weeks.length === 0) return { value: null, delta: 0, display: '0.0' };
const periodOverExpected = avgExpected > 0 ? ((avgPoints - avgExpected) / avgExpected) * 100 : 0;
const seasonOverExpected = player.pctOverExpected || 0;
const delta = periodOverExpected - seasonOverExpected;
return {
value: avgPoints,
delta: delta,
display: avgPoints.toFixed(1)
};
}
case 'target-share': {
if (weeks.length === 0) return { value: null, delta: 0, display: '0.0%' };
const periodUsageShare = weeks.reduce((sum, w) => sum + (w.usageShare || 0), 0) / weeks.length;
const seasonUsageShare = seasonWeeks.reduce((sum, w) => sum + (w.usageShare || 0), 0) / seasonWeeks.length;
const usageDelta = periodUsageShare - seasonUsageShare;
return {
value: periodUsageShare,
delta: usageDelta,
display: periodUsageShare.toFixed(1) + '%'
};
}
case 'rz-opp-share': {
if (weeks.length === 0) return { value: null, delta: 0, display: '0.0%' };
const rzField = player.position === 'RB' ? 'rzOpportunities' : 'rzTargets';
const team = teamStats[player.team];
if (!team || !team.weeklyRzOpps) return { value: null, delta: 0, display: '0.0%' };
let periodPlayerRzOpps = 0;
let periodTeamRzOpps = 0;
weeks.forEach(w => {
periodPlayerRzOpps += (w[rzField] || 0);
periodTeamRzOpps += (team.weeklyRzOpps[w.week] || 0);
});
const periodRzShare = periodTeamRzOpps > 0 ? (periodPlayerRzOpps / periodTeamRzOpps) * 100 : 0;
let seasonPlayerRzOpps = 0;
let seasonTeamRzOpps = 0;
seasonWeeks.forEach(w => {
seasonPlayerRzOpps += (w[rzField] || 0);
seasonTeamRzOpps += (team.weeklyRzOpps[w.week] || 0);
});
const seasonRzShare = seasonTeamRzOpps > 0 ? (seasonPlayerRzOpps / seasonTeamRzOpps) * 100 : 0;
const rzDelta = periodRzShare - seasonRzShare;
return {
value: periodRzShare,
delta: rzDelta,
display: periodRzShare.toFixed(1) + '%'
};
}
case 'points-per-touch': {
if (weeks.length === 0) return { value: null, delta: 0, display: '0.00' };
let periodTotalTouches = 0;
weeks.forEach(w => {
if (player.position === 'RB') {
periodTotalTouches += (w.rushAttempts || 0) + (w.targets || 0);
} else {
periodTotalTouches += (w.targets || 0);
}
});
const periodPpTouch = periodTotalTouches > 0 ? (avgPoints * weeks.length) / periodTotalTouches : 0;
let seasonTotalTouches = 0;
seasonWeeks.forEach(w => {
if (player.position === 'RB') {
seasonTotalTouches += (w.rushAttempts || 0) + (w.targets || 0);
} else {
seasonTotalTouches += (w.targets || 0);
}
});
const seasonPpTouch = seasonTotalTouches > 0 ? (seasonData.avgPoints * seasonWeeks.length) / seasonTotalTouches : 0;
const touchDelta = periodPpTouch - seasonPpTouch;
return {
value: periodPpTouch,
delta: touchDelta,
display: periodPpTouch.toFixed(2)
};
}
case 'usage-trend': {
if (weeks.length === 0) return { value: null, delta: 0, display: '0.0%' };
const periodUsageShare = weeks.reduce((sum, w) => sum + (w.usageShare || w.teamShare || 0), 0) / weeks.length;
const seasonUsageShare = seasonWeeks.reduce((sum, w) => sum + (w.usageShare || w.teamShare || 0), 0) / seasonWeeks.length;
const trendDelta = periodUsageShare - seasonUsageShare;
return {
value: periodUsageShare,
delta: trendDelta,
display: periodUsageShare.toFixed(1) + '%'
};
}
case 'consistency': {
if (weeks.length < 2) return { value: null, delta: 0, display: '0' };
const periodPoints = weeks.map(w => w.fpts);
const periodMean = periodPoints.reduce((sum, p) => sum + p, 0) / periodPoints.length;
const periodVariance = periodPoints.reduce((sum, p) => sum + Math.pow(p - periodMean, 2), 0) / periodPoints.length;
const periodStdDev = Math.sqrt(periodVariance);
const periodCv = periodMean > 0 ? (periodStdDev / periodMean) * 100 : 0;
const periodConsistency = Math.max(0, 100 - periodCv);
const seasonPoints = seasonWeeks.map(w => w.fpts);
const seasonMean = seasonPoints.reduce((sum, p) => sum + p, 0) / seasonPoints.length;
const seasonVariance = seasonPoints.reduce((sum, p) => sum + Math.pow(p - seasonMean, 2), 0) / seasonPoints.length;
const seasonStdDev = Math.sqrt(seasonVariance);
const seasonCv = seasonMean > 0 ? (seasonStdDev / seasonMean) * 100 : 0;
const seasonConsistency = Math.max(0, 100 - seasonCv);
const consistencyDelta = periodConsistency - seasonConsistency;
return {
value: periodConsistency,
delta: consistencyDelta,
display: periodConsistency.toFixed(0)
};
}
case 'ceiling': {
if (weeks.length < 3) return { value: null, delta: 0, display: '0.0' };
const periodSortedPoints = weeks.map(w => w.fpts).sort((a, b) => b - a);
const periodCeilingIndex = Math.floor(periodSortedPoints.length * 0.1);
const periodCeiling = periodSortedPoints[periodCeilingIndex] || periodSortedPoints[0];
const seasonSortedPoints = seasonWeeks.map(w => w.fpts).sort((a, b) => b - a);
const seasonCeilingIndex = Math.floor(seasonSortedPoints.length * 0.1);
const seasonCeiling = seasonSortedPoints[seasonCeilingIndex] || seasonSortedPoints[0];
const ceilingDelta = periodCeiling - seasonCeiling;
return {
value: periodCeiling,
delta: ceilingDelta,
display: periodCeiling.toFixed(1)
};
}
case 'floor': {
if (weeks.length < 3) return { value: null, delta: 0, display: '0.0' };
const periodFloorPoints = weeks.map(w => w.fpts).sort((a, b) => a - b);
const periodFloorIndex = Math.floor(periodFloorPoints.length * 0.1);
const periodFloor = periodFloorPoints[periodFloorIndex] || periodFloorPoints[0];
const seasonFloorPoints = seasonWeeks.map(w => w.fpts).sort((a, b) => a - b);
const seasonFloorIndex = Math.floor(seasonFloorPoints.length * 0.1);
const seasonFloor = seasonFloorPoints[seasonFloorIndex] || seasonFloorPoints[0];
const floorDelta = periodFloor - seasonFloor;
return {
value: periodFloor,
delta: floorDelta,
display: periodFloor.toFixed(1)
};
}
default: {
return { value: avgPoints, delta: player.pctOverExpected || 0, display: avgPoints.toFixed(1) };
}
}
}
function getPlayerDataForPeriod(player, period) {
const weeks = player.weeks || [];
if (weeks.length === 0) return null;
let relevantWeeks;
switch(period) {
case 'week':
relevantWeeks = weeks.slice(-1);
break;
case 'last3':
relevantWeeks = weeks.slice(-3);
break;
case 'last5':
relevantWeeks = weeks.slice(-5);
break;
case 'season':
default:
relevantWeeks = weeks;
break;
}
if (relevantWeeks.length === 0) return null;
const totalPoints = relevantWeeks.reduce((sum, w) => sum + (parseFloat(w.fpts) || 0), 0);

// Use the correct expectedFpts based on current scoring format
const totalExpected = relevantWeeks.reduce((sum, w) => {
let expected = 0;
if (currentScoringFormat === 'std') {
expected = parseFloat(w.expectedFptsSTD || w.expectedFpts) || 0;
} else if (currentScoringFormat === 'half') {
expected = parseFloat(w.expectedFptsHALF || w.expectedFpts) || 0;
} else {
expected = parseFloat(w.expectedFptsPPR || w.expectedFpts) || 0;
}
return sum + expected;
}, 0);

const avgPoints = totalPoints / relevantWeeks.length;
const avgExpected = totalExpected / relevantWeeks.length;
return {
avgPoints,
avgExpected,
weeks: relevantWeeks,
weeksAvailable: relevantWeeks.length
};
}
function updatePositionStats(players, position) {
if (players.length === 0) {
console.log('No players to display stats for');
return;
}
const displayFilter = heatmapState.display;
let topN = 24; // default
if (displayFilter === '36') topN = 36;
else if (displayFilter === '50') topN = 50;
else if (displayFilter === 'all') topN = players.length;
const metric = heatmapState.metric;
let allPlayers = getPlayersForPosition(position);
allPlayers = allPlayers.map(player => {
const metricData = calculatePlayerMetric(player, metric, heatmapState.period);
return {
...player,
metricValue: metricData.value,
metricDisplay: metricData.display
};
}).filter(p => p.metricValue !== null);
allPlayers.sort((a, b) => b.metricValue - a.metricValue);
const topPlayers = allPlayers.slice(0, Math.min(topN, allPlayers.length));
let avgValue = 0;
let unit = '';
let label = '';
if (metric === 'actual-vs-expected') {
const totalPoints = topPlayers.reduce((sum, p) => sum + p.metricValue, 0);
avgValue = topPlayers.length > 0 ? totalPoints / topPlayers.length : 0;
unit = ' PPG';
label = 'Top ' + topN + ' Avg';
} else if (metric === 'target-share') {
const totalShare = topPlayers.reduce((sum, p) => sum + p.metricValue, 0);
avgValue = topPlayers.length > 0 ? totalShare / topPlayers.length : 0;
unit = '%';
label = 'Top ' + topN + ' Avg';
} else if (metric === 'rz-opportunity') {
const totalRZ = topPlayers.reduce((sum, p) => sum + p.metricValue, 0);
avgValue = topPlayers.length > 0 ? totalRZ / topPlayers.length : 0;
unit = ' RZ Opp';
label = 'Top ' + topN + ' Avg';
} else if (metric === 'floor-consistency') {
const totalFloor = topPlayers.reduce((sum, p) => sum + p.metricValue, 0);
avgValue = topPlayers.length > 0 ? totalFloor / topPlayers.length : 0;
unit = '';
label = 'Top ' + topN + ' Avg';
}
const positionBadgeClass = position === 'WR' ? 'wr-badge' : position === 'RB' ? 'rb-badge' : 'te-badge';
const positionName = position === 'WR' ? 'Wide Receivers' : position === 'RB' ? 'Running Backs' : 'Tight Ends';
document.getElementById('heatmap-position-stats').textContent = `${label} ${avgValue.toFixed(1)}${unit}`;
}
function getHeatmapColorClass(delta, metric) {
if (metric === 'actual-vs-expected') {
if (delta >= 20) return 'extreme-positive';
if (delta >= 15) return 'strong-positive';
if (delta >= 10) return 'moderate-positive';
if (delta >= 5) return 'slight-positive';
if (delta >= -5) return 'neutral';
if (delta >= -10) return 'slight-negative';
if (delta >= -15) return 'moderate-negative';
if (delta >= -20) return 'strong-negative';
return 'extreme-negative';
} else if (metric === 'target-share' || metric === 'usage-trend') {
if (delta >= 8) return 'extreme-positive';
if (delta >= 5) return 'strong-positive';
if (delta >= 3) return 'moderate-positive';
if (delta >= 1.5) return 'slight-positive';
if (delta >= -1.5) return 'neutral';
if (delta >= -3) return 'slight-negative';
if (delta >= -5) return 'moderate-negative';
if (delta >= -8) return 'strong-negative';
return 'extreme-negative';
} else if (metric === 'rz-opp-share') {
if (delta >= 6) return 'extreme-positive';
if (delta >= 4) return 'strong-positive';
if (delta >= 2.5) return 'moderate-positive';
if (delta >= 1.5) return 'slight-positive';
if (delta >= -1.5) return 'neutral';
if (delta >= -2.5) return 'slight-negative';
if (delta >= -4) return 'moderate-negative';
if (delta >= -6) return 'strong-negative';
return 'extreme-negative';
} else if (metric === 'points-per-touch') {
if (delta >= 0.4) return 'extreme-positive';
if (delta >= 0.25) return 'strong-positive';
if (delta >= 0.15) return 'moderate-positive';
if (delta >= 0.08) return 'slight-positive';
if (delta >= -0.08) return 'neutral';
if (delta >= -0.15) return 'slight-negative';
if (delta >= -0.25) return 'moderate-negative';
if (delta >= -0.4) return 'strong-negative';
return 'extreme-negative';
} else if (metric === 'consistency') {
if (delta >= 15) return 'extreme-positive';
if (delta >= 10) return 'strong-positive';
if (delta >= 6) return 'moderate-positive';
if (delta >= 3) return 'slight-positive';
if (delta >= -3) return 'neutral';
if (delta >= -6) return 'slight-negative';
if (delta >= -10) return 'moderate-negative';
if (delta >= -15) return 'strong-negative';
return 'extreme-negative';
} else if (metric === 'ceiling' || metric === 'floor') {
if (delta >= 6) return 'extreme-positive';
if (delta >= 4) return 'strong-positive';
if (delta >= 2.5) return 'moderate-positive';
if (delta >= 1.5) return 'slight-positive';
if (delta >= -1.5) return 'neutral';
if (delta >= -2.5) return 'slight-negative';
if (delta >= -4) return 'moderate-negative';
if (delta >= -6) return 'strong-negative';
return 'extreme-negative';
} else {
if (delta >= 20) return 'extreme-positive';
if (delta >= 15) return 'strong-positive';
if (delta >= 10) return 'moderate-positive';
if (delta >= 5) return 'slight-positive';
if (delta >= -5) return 'neutral';
if (delta >= -10) return 'slight-negative';
if (delta >= -15) return 'moderate-negative';
if (delta >= -20) return 'strong-negative';
return 'extreme-negative';
}
}
function updateHeatmapLegend(metric) {
const titleEl = document.getElementById('heatmap-legend-title');
const labels = [
document.getElementById('legend-label-0'),
document.getElementById('legend-label-1'),
document.getElementById('legend-label-2'),
document.getElementById('legend-label-3'),
document.getElementById('legend-label-4'),
document.getElementById('legend-label-5'),
document.getElementById('legend-label-6'),
document.getElementById('legend-label-7'),
document.getElementById('legend-label-8')
];
const legendConfigs = {
'actual-vs-expected': {
title: 'Performance vs Expected',
labels: [
'-20%+<br>Extreme Under',
'-15 to -20%<br>Strong Under',
'-10 to -15%<br>Moderate Under',
'-5 to -10%<br>Slight Under',
'Â±5%<br>On Target',
'+5 to +10%<br>Slight Over',
'+10 to +15%<br>Moderate Over',
'+15 to +20%<br>Strong Over',
'+20%+<br>Extreme Over'
]
},
'target-share': {
title: 'Target/Opportunity Share',
labels: [
'-8%+<br>Extreme Low',
'-5 to -8%<br>Strong Low',
'-3 to -5%<br>Moderate Low',
'-1.5 to -3%<br>Slight Low',
'Â±1.5%<br>Average',
'+1.5 to +3%<br>Slight High',
'+3 to +5%<br>Moderate High',
'+5 to +8%<br>Strong High',
'+8%+<br>Extreme High'
]
},
'rz-opp-share': {
title: 'RZ Opportunity Share',
labels: [
'-6%+<br>Extreme Low',
'-4 to -6%<br>Strong Low',
'-2.5 to -4%<br>Moderate Low',
'-1.5 to -2.5%<br>Slight Low',
'Â±1.5%<br>Average',
'+1.5 to +2.5%<br>Slight High',
'+2.5 to +4%<br>Moderate High',
'+4 to +6%<br>Strong High',
'+6%+<br>Extreme High'
]
}
};
const config = legendConfigs[metric] || legendConfigs['actual-vs-expected'];
titleEl.textContent = config.title;
labels.forEach((label, idx) => {
if (label) label.innerHTML = config.labels[idx];
});
}
function getHeatmapArrow(delta) {
if (delta >= 10) return 'â†‘';
if (delta >= 5) return 'â†—';
if (delta >= -5) return 'â†’';
if (delta >= -10) return 'â†˜';
return 'â†“';
}
function getArrowColorClass(delta) {
if (delta >= 5) return 'positive-delta';
if (delta <= -5) return 'negative-delta';
return '';
}
function renderHeatmapCards(players, position) {
const grid = document.getElementById('heatmap-player-grid');
const metric = heatmapState.metric; // Get current metric
grid.innerHTML = players.map(player => {
const colorClass = getHeatmapColorClass(player.metricDelta, metric);
const arrow = getHeatmapArrow(player.metricDelta);
const arrowColorClass = getArrowColorClass(player.metricDelta);
const deltaSign = player.metricDelta >= 0 ? '+' : '';
return `
<div class="heatmap-player-card ${colorClass}" onclick="openPlayerModal('${player.id}')"><div class="heatmap-player-name">${player.name}</div><div class="heatmap-player-team">${player.team}</div><div class="heatmap-bottom-row"><div class="heatmap-value">${player.metricDisplay}</div><div class="heatmap-delta-group ${arrowColorClass}"><div class="heatmap-arrow">${arrow}</div><div class="heatmap-delta-value">${deltaSign}${player.metricDelta.toFixed(0)}%</div></div></div></div>
`;
}).join('');
}
function updateMarketOpportunities() {
if (!aggregatedWRs || !aggregatedRBs || !aggregatedTEs) {
console.log('Market Opportunities: Data not yet loaded');
return;
}
if (!injuryData || Object.keys(injuryData).length === 0) {
console.log('Market Opportunities: Waiting for injury data...');
const cachedData = localStorage.getItem('injuryData');
if (cachedData) {
try {
const parsedCache = JSON.parse(cachedData);
const cacheAge = Date.now() - (parsedCache.timestamp || 0);
if (cacheAge < 3600000) {
injuryData = parsedCache.data;
console.log('Market Opportunities: Loaded injury data from cache');
}
} catch (e) {
console.error('Failed to parse cached injury data:', e);
}
}
if (!injuryData || Object.keys(injuryData).length === 0) {
console.log('Market Opportunities: Proceeding without injury data (will retry in 2s)');
setTimeout(updateMarketOpportunities, 2000);
}
}
const allPlayers = [
...Object.values(window.aggregatedWRs).filter(p => p.gamesPlayed >= 3),
...Object.values(window.aggregatedRBs).filter(p => p.gamesPlayed >= 3),
...Object.values(window.aggregatedTEs).filter(p => p.gamesPlayed >= 3)
];
console.log('Market Opportunities: Analyzing', allPlayers.length, 'players');
const buyLow = identifyBuyLowCandidates(allPlayers);
const sellHigh = identifySellHighCandidates(allPlayers);
console.log('Market Opportunities:', { buyLow: buyLow.length, sellHigh: sellHigh.length });
renderMarketOpportunities(buyLow, sellHigh);
}
function identifyBuyLowCandidates(players) {
console.log('Market Opportunities: Analyzing', players.length, 'players for Buy Low');

// CALCULATE MOST RECENT WEEK ONCE - same logic as spotlight cards
const weekCounts = {};
players.forEach(p => {
    if (p.weeks && p.weeks.length > 0) {
        const playerLatestWeek = Math.max(...p.weeks.map(w => w.week));
        weekCounts[playerLatestWeek] = (weekCounts[playerLatestWeek] || 0) + 1;
    }
});

let mostRecentWeek = 0;
for (const [week, count] of Object.entries(weekCounts)) {
    if (count >= 10 && parseInt(week) > mostRecentWeek) {
        mostRecentWeek = parseInt(week);
    }
}

const last5Weeks = [
    mostRecentWeek,
    mostRecentWeek - 1,
    mostRecentWeek - 2,
    mostRecentWeek - 3,
    mostRecentWeek - 4
];

console.log('Buy Low - Most recent week:', mostRecentWeek, 'Last 5 weeks:', last5Weeks);

const usedNarratives = {}; // Track narrative usage
const candidates = players
.filter(player => {
    // Filter out players who missed 3+ of last 5 games
    const weeks = player.weeks || [];
    const playerWeeksPlayed = weeks.filter(w => last5Weeks.includes(w.week)).length;
    const available = playerWeeksPlayed >= 3;
    
    if (!available && player.name.includes('Evans')) {
        console.log(`âœ“ Filtered out ${player.name} from Buy Low - only played ${playerWeeksPlayed} of last 5 weeks`);
    }
    
    return available;
})
.map(player => {
const avgPoints = player.avgPoints || 0;
const weeks = player.weeks || [];
if (weeks.length < 3) return null;
const lastGame = weeks[weeks.length - 1];
const lastGamePoints = lastGame ? parseFloat(lastGame.fpts) || 0 : 0;
if (lastGamePoints >= 20) return null;
const recentWeeks = weeks.slice(-4); // Last 4 weeks
const solidWeeks = recentWeeks.filter(w => parseFloat(w.fpts) >= 10).length;
const hasEstablishedRole = solidWeeks >= 3;
const oppShare = player.latestWeekOppShare || 0;
const teamPts = player.latestWeekTeamPoints || 0;
let avgUsageShare = 0;
let avgTargets = 0;
let avgOpportunities = 0;
if (weeks.length > 0) {
avgUsageShare = weeks.reduce((sum, w) => sum + (w.usageShare || 0), 0) / weeks.length;
avgTargets = weeks.reduce((sum, w) => sum + (parseFloat(w.Tgt || w.targets) || 0), 0) / weeks.length;
if (player.position === 'RB') {
avgOpportunities = weeks.reduce((sum, w) => sum + ((parseFloat(w.Att || 0) || 0) + (parseFloat(w.Tgt || w.targets) || 0)), 0) / weeks.length;
} else {
avgOpportunities = avgTargets;
}
}
const underPerforming = player.pctOverExpected || 0;
const hasNegMomentum = player.momentum && player.momentum.isValid && player.momentum.score < -5;
const goodOffense = teamPts > 24;
const highVolume = avgUsageShare > 18 || oppShare > 15;
const isUnderperforming = underPerforming < -8;
const hasGoodSituation = (goodOffense && (avgUsageShare > 12 || oppShare > 10));
const meetsMinimum = avgPoints > 8;
if ((isUnderperforming && hasGoodSituation && meetsMinimum) || (hasEstablishedRole && underPerforming < -5 && meetsMinimum)) {
const narrativeOptions = [];
if (hasEstablishedRole && goodOffense) {
narrativeOptions.push('Established role on elite offense - buy the consistency');
}
if (hasEstablishedRole) {
narrativeOptions.push('Consistent 10+ point weeks - emerging reliable option');
}
if (oppShare > 20 && teamPts > 24) {
narrativeOptions.push('Elite offense role + volume - production should rebound');
}
if (hasNegMomentum && avgUsageShare > 15) {
narrativeOptions.push('Strong usage despite slump - buy the dip');
}
if (goodOffense && avgUsageShare > 18) {
narrativeOptions.push('High-powered offense role - volume should translate');
}
if (goodOffense && avgUsageShare > 12) {
narrativeOptions.push('Good situation + volume, recent production should improve');
}
if (avgUsageShare > 20) {
narrativeOptions.push(`High usage (${avgUsageShare.toFixed(0)}% share) but TD-luck drought`);
} else if (avgOpportunities >= 12) {
const oppText = player.position === 'RB' ? 'opportunities' : 'targets';
narrativeOptions.push(`Strong volume (${avgOpportunities.toFixed(1)} ${oppText}/game) with room to improve`);
}
if (oppShare > 15) {
narrativeOptions.push('Strong opportunity share - usage should convert to points');
}
// Fallback narrative - use opportunities/targets instead of usage share when available
if (avgUsageShare > 0) {
narrativeOptions.push(`Solid usage (${avgUsageShare.toFixed(0)}% share) but underperforming expected`);
} else if (avgOpportunities >= 8) {
const oppText = player.position === 'RB' ? 'opportunities' : 'targets';
narrativeOptions.push(`Decent volume (${avgOpportunities.toFixed(1)} ${oppText}/game) but underperforming`);
} else {
narrativeOptions.push('Underperforming expected points - buy the dip');
}
let selectedNarrative = narrativeOptions[0];
for (const narrative of narrativeOptions) {
const normalizedNarrative = narrative.replace(/\d+%/g, 'X%'); // Normalize percentages for tracking
if (!usedNarratives[normalizedNarrative] || usedNarratives[normalizedNarrative] < 2) {
selectedNarrative = narrative;
usedNarratives[normalizedNarrative] = (usedNarratives[normalizedNarrative] || 0) + 1;
break;
}
}
console.log('Buy Low candidate:', player.name, {
reason: selectedNarrative,
narrativeOptions: narrativeOptions.length
});
let upsideScore = Math.abs(underPerforming);
if (hasEstablishedRole) upsideScore += 10;
if (goodOffense && highVolume) upsideScore += 5;
return {
player: player,
upside: upsideScore,
usageShare: avgUsageShare,
reason: selectedNarrative
};
}
return null;
})
.filter(x => x !== null)
.sort((a, b) => b.upside - a.upside)
.slice(0, 5);
return candidates;
}
function identifySellHighCandidates(players) {
console.log('Market Opportunities: Analyzing', players.length, 'players for Sell High');
console.log('Injury Data Check:', {
injuryDataExists: !!injuryData,
injuryDataKeys: injuryData ? Object.keys(injuryData).length : 0,
sampleKeys: injuryData ? Object.keys(injuryData).slice(0, 5) : []
});

// CALCULATE MOST RECENT WEEK - same as buy low
const weekCounts = {};
players.forEach(p => {
    if (p.weeks && p.weeks.length > 0) {
        const playerLatestWeek = Math.max(...p.weeks.map(w => w.week));
        weekCounts[playerLatestWeek] = (weekCounts[playerLatestWeek] || 0) + 1;
    }
});

let mostRecentWeek = 0;
for (const [week, count] of Object.entries(weekCounts)) {
    if (count >= 10 && parseInt(week) > mostRecentWeek) {
        mostRecentWeek = parseInt(week);
    }
}

const last5Weeks = [
    mostRecentWeek,
    mostRecentWeek - 1,
    mostRecentWeek - 2,
    mostRecentWeek - 3,
    mostRecentWeek - 4
];

console.log('Sell High - Most recent week:', mostRecentWeek, 'Last 5 weeks:', last5Weeks);

const positionRanks = {};
['WR', 'RB', 'TE'].forEach(pos => {
const posPlayers = players.filter(p => p.position === pos);
const sorted = [...posPlayers].sort((a, b) => b.avgPoints - a.avgPoints);
sorted.forEach((p, idx) => {
positionRanks[p.id] = idx + 1;
});
});

// Debug counters
let irFilteredCount = 0;
let availabilityFilteredCount = 0;
let top10FilteredCount = 0;
let avgPointsFilteredCount = 0;
let lastWeekFilteredCount = 0;
let momentumFilteredCount = 0;
let roleExpansionFilteredCount = 0;
let noTDSpikeCount = 0;
let noLimitedVolumeCount = 0;
let notTDDependentCount = 0;
let notRecentlyGoodCount = 0;
let passedAllFiltersCount = 0;

const usedNarratives = {}; // Track narrative usage
const candidates = players
.filter(player => {
    // Filter out players who missed 3+ of last 5 games
    const weeks = player.weeks || [];
    const playerWeeksPlayed = weeks.filter(w => last5Weeks.includes(w.week)).length;
    const available = playerWeeksPlayed >= 3;
    
    if (!available) {
        availabilityFilteredCount++;
    }
    
    return available;
})
.map(player => {
const avgPoints = player.avgPoints || 0;
const weeks = player.weeks || [];
if (weeks.length < 3) return null;
const posRank = positionRanks[player.id] || 999;
if (posRank <= 10) {
top10FilteredCount++;
return null;
}
if (avgPoints < 6 || avgPoints > 22) { // Relaxed from 7-20 to 6-22
avgPointsFilteredCount++;
return null;
}
const injury = getPlayerInjuryStatus(player.name);
if (injury && (injury.status === 'IR' || injury.status === 'PUP')) {
irFilteredCount++;
console.log(`âœ“ Filtered out ${player.name} - ${injury.status}`);
return null;
}
const last3Weeks = weeks.slice(-3);
const last3Points = last3Weeks.map(w => parseFloat(w.fpts) || 0);
const last3Avg = last3Points.reduce((sum, pts) => sum + pts, 0) / last3Points.length;

// Get most recent week's performance
const lastWeekPoints = last3Points[last3Points.length - 1];

// Expected points analysis - check for role expansion
const last3ExpectedPoints = last3Weeks.map(w => parseFloat(w.expectedFpts) || 0);
const last3ExpectedAvg = last3ExpectedPoints.reduce((sum, pts) => sum + pts, 0) / 3;
const prevWeeksExpected = weeks.slice(-6, -3).map(w => parseFloat(w.expectedFpts) || 0);
const prevExpectedAvg = prevWeeksExpected.length > 0 
? prevWeeksExpected.reduce((sum, pts) => sum + pts, 0) / prevWeeksExpected.length 
: 0;

// Role expansion check - if expected points increased significantly, role has grown
const expectedPointsGrowth = prevExpectedAvg > 0 ? ((last3ExpectedAvg - prevExpectedAvg) / prevExpectedAvg) * 100 : 0;
const hasRoleExpansion = expectedPointsGrowth > 25; // Relaxed from 15% to 25%

if (hasRoleExpansion) {
roleExpansionFilteredCount++;
return null;
}

// TD analysis - the core of sell high
const last3TDs = last3Weeks.reduce((sum, w) => {
return sum + (parseFloat(w.rec_td) || 0) + (parseFloat(w.rush_td) || 0);
}, 0);
const lastWeekTDs = (parseFloat(last3Weeks[2].rec_td) || 0) + (parseFloat(last3Weeks[2].rush_td) || 0);

// Debug: Log first few players with TDs
if (last3TDs > 0 && passedAllFiltersCount < 3) {
console.log(`Player with TDs: ${player.name}`, {
last3TDs,
lastWeekTDs,
last3Weeks: last3Weeks.map(w => ({
week: w.week,
fpts: w.fpts,
rec_td: w.rec_td,
rush_td: w.rush_td
}))
});
}

const tdPoints = last3TDs * 6;
const tdDependency = last3Avg > 0 ? (tdPoints / (last3Avg * 3)) * 100 : 0;

// Volume/Usage analysis
const totalUsageShare = weeks.reduce((sum, w) => sum + (w.usageShare || 0), 0);
const avgUsageShare = totalUsageShare / weeks.length;
const last3UsageShare = last3Weeks.reduce((sum, w) => sum + (w.usageShare || 0), 0) / 3;

// Points without TDs - what would they score without the TDs?
const last3PointsNoTDs = last3Avg - (tdPoints / 3);

// Don't suggest sell high if coming off a terrible week - very relaxed now
if (lastWeekPoints < 6) {
lastWeekFilteredCount++;
return null;
}

const hasSolidMomentum = player.momentum && player.momentum.isValid && player.momentum.score > 10;
if (hasSolidMomentum) {
momentumFilteredCount++;
return null;
}

// SELL HIGH CRITERIA (RELAXED):
// 1. Recent TD spike(s) - at least 1 TD in last 3 weeks
// 2. Limited volume - usage share under 22%
// 3. TD-dependent scoring - remove TDs and they're mediocre
// 4. Currently valued reasonably - last 3 week average over 9

const hasTDSpike = last3TDs >= 1; // Relaxed from 2+ to 1+
const hasLimitedVolume = last3UsageShare < 22; // Relaxed from 20 to 22
const isTDDependent = tdDependency > 30; // Relaxed from 35 to 30
const wouldBeMediocreWithoutTDs = last3PointsNoTDs < 11; // Relaxed from 10 to 11
const recentlyGoodEnough = last3Avg > 9; // New: just need decent 3-week average

// Calculate sell high score based on TD spike severity + volume limits
const tdSpikeScore = (last3TDs * 2) + (lastWeekTDs * 3); // Weight recent TDs heavily
const volumePenalty = last3UsageShare < 12 ? 2.0 : last3UsageShare < 16 ? 1.5 : 1.2;
const sellHighScore = tdSpikeScore * volumePenalty * (tdDependency / 40);

if (hasTDSpike && hasLimitedVolume && recentlyGoodEnough && (isTDDependent || wouldBeMediocreWithoutTDs)) {
passedAllFiltersCount++;
const narrativeOptions = [];
if (lastWeekTDs >= 2) {
narrativeOptions.push(`${lastWeekTDs} TDs last week on ${last3UsageShare.toFixed(0)}% usage - peak value`);
}
if (last3TDs >= 3 && last3UsageShare < 15) {
narrativeOptions.push(`${last3TDs} TDs on minimal volume - sell before regression`);
}
if (tdDependency > 55) {
narrativeOptions.push(`${tdDependency.toFixed(0)}% TD-dependent - value inflated, trade now`);
}
if (wouldBeMediocreWithoutTDs && last3TDs >= 2) {
narrativeOptions.push(`Would avg ${last3PointsNoTDs.toFixed(1)} PPG without TDs - sell spike`);
}
if (last3UsageShare < 12 && last3TDs >= 2) {
narrativeOptions.push(`TD spike on <12% usage - unsustainable value`);
}
if (lastWeekTDs >= 1 && lastWeekPoints > 15) {
narrativeOptions.push(`Recent TD lifted value (${lastWeekPoints.toFixed(1)} pts) - cash out`);
}
if (tdDependency > 45 && last3UsageShare < 18) {
narrativeOptions.push(`Limited role papered over by TDs - sell while hot`);
}
narrativeOptions.push(`${last3TDs} TDs masking limited role - trade at peak`);
let selectedNarrative = narrativeOptions[0];
for (const narrative of narrativeOptions) {
const normalizedNarrative = narrative.replace(/\d+%?/g, 'X').replace(/\d+\.\d+/g, 'X'); // Normalize numbers
if (!usedNarratives[normalizedNarrative] || usedNarratives[normalizedNarrative] < 2) {
selectedNarrative = narrative;
usedNarratives[normalizedNarrative] = (usedNarratives[normalizedNarrative] || 0) + 1;
break;
}
}
console.log('Sell High candidate:', player.name, {
reason: selectedNarrative,
last3TDs: last3TDs,
lastWeekTDs: lastWeekTDs,
usageShare: last3UsageShare.toFixed(1),
tdDependency: tdDependency.toFixed(0),
wouldBeWithoutTDs: last3PointsNoTDs.toFixed(1)
});
return {
player: player,
downside: sellHighScore,
tdRate: last3TDs / 3,
tdDependency: tdDependency,
usage: last3UsageShare,
lastWeekTDs: lastWeekTDs,
reason: selectedNarrative
};
} else {
// Track why they failed final criteria
if (!hasTDSpike) noTDSpikeCount++;
if (!hasLimitedVolume) noLimitedVolumeCount++;
if (!isTDDependent && !wouldBeMediocreWithoutTDs) notTDDependentCount++;
if (!recentlyGoodEnough) notRecentlyGoodCount++;
}
return null;
})
.filter(x => x !== null)
.sort((a, b) => b.downside - a.downside)
.slice(0, 5);

// Comprehensive debug summary
console.log('\n=== SELL HIGH FILTER SUMMARY ===');
console.log(`Total players analyzed: ${players.length}`);
console.log(`Filtered by Top 10: ${top10FilteredCount}`);
console.log(`Filtered by Avg Points (not 6-22): ${avgPointsFilteredCount}`);
console.log(`Filtered by IR/PUP: ${irFilteredCount}`);
console.log(`Filtered by Last Week < 6: ${lastWeekFilteredCount}`);
console.log(`Filtered by Solid Momentum: ${momentumFilteredCount}`);
console.log(`Filtered by Role Expansion (>25%): ${roleExpansionFilteredCount}`);
console.log(`Failed TD Spike check (need 1+): ${noTDSpikeCount}`);
console.log(`Failed Limited Volume check (<22%): ${noLimitedVolumeCount}`);
console.log(`Failed TD Dependent check (>30%): ${notTDDependentCount}`);
console.log(`Failed 3-week avg check (>9 PPG): ${notRecentlyGoodCount}`);
console.log(`Passed ALL filters: ${passedAllFiltersCount}`);
console.log(`Final candidates: ${candidates.length}`);
console.log('================================\n');

return candidates;
}
function generateBuyLowReason(player, underPerforming, usageShare) {
const reasons = [];
if (usageShare > 20) reasons.push(`High usage (${usageShare.toFixed(0)}% share)`);
else if (usageShare > 15) reasons.push(`Solid usage (${usageShare.toFixed(0)}% share)`);
else reasons.push(`Decent usage (${usageShare.toFixed(0)}% share)`);
if (underPerforming < -15) reasons.push('TD-luck drought');
else reasons.push('underperforming expected');
return reasons.join(' but ');
}
function generateSellHighReason(player, overPerforming, tdDependent, tdRate) {
const reasons = [];
if (tdDependent) reasons.push(`TD rate unsustainable (${tdRate.toFixed(1)}/game)`);
if (overPerforming > 20) reasons.push('extreme outperformance');
else if (overPerforming > 12) reasons.push('significant overperformance');
if (reasons.length === 0) reasons.push('regression likely');
return reasons.join(', ');
}
function renderMarketOpportunities(buyLow, sellHigh) {
// Check if we're rendering for home page or heatmap page
const homeContainer = document.getElementById('home-market-opportunities');
const heatmapGrid = document.getElementById('market-opportunities-grid');

if (homeContainer) {
// Home page rendering with buy-sell-container structure
const buyLowHTML = `
<div class="buy-section">
    <div class="section-header">
        <span class="section-label buy">BUY LOW <span class="info-icon">â“˜<span class="info-icon-tooltip">Upside % = Underperformance vs expected + bonuses for established role (+10) and good offense/volume (+5). Higher % = more buy-low opportunity.</span></span></span>
    </div>
    ${buyLow.map(opp => {
        const escapedId = opp.player.id.replace(/'/g, "\\'");
        return `
    <div class="player-item" onclick="openPlayerModal('${escapedId}');" style="cursor: pointer;">
        <div class="action-badge buy">BUY</div>
        <div class="player-info">
            <div class="player-name">${opp.player.name}</div>
            <div class="player-reason">${opp.reason}</div>
        </div>
        <div class="player-change positive">+${opp.upside.toFixed(0)}%</div>
    </div>
        `;
    }).join('')}
</div>
`;
const sellHighHTML = `
<div class="sell-section">
    <div class="section-header">
        <span class="section-label sell">SELL HIGH <span class="info-icon">â“˜<span class="info-icon-tooltip">Downside % = TD spike score Ã— volume penalty Ã— TD dependency. Based on recent TDs on limited volume. Higher % = more sell-high risk.</span></span></span>
    </div>
    ${sellHigh.map(opp => {
        const escapedId = opp.player.id.replace(/'/g, "\\'");
        return `
    <div class="player-item" onclick="openPlayerModal('${escapedId}');" style="cursor: pointer;">
        <div class="action-badge sell">SELL</div>
        <div class="player-info">
            <div class="player-name">${opp.player.name}</div>
            <div class="player-reason">${opp.reason}</div>
        </div>
        <div class="player-change negative">-${opp.downside.toFixed(0)}%</div>
    </div>
        `;
    }).join('')}
</div>
`;
homeContainer.innerHTML = buyLowHTML + sellHighHTML;
}

if (heatmapGrid) {
// Heatmap page rendering with market-column structure
const buyLowHTML = `
<div class="market-column"><div class="market-column-header"><div class="market-column-title buy-low">Buy Low <span class="info-icon">â“˜<span class="info-icon-tooltip">Upside % = Underperformance vs expected + bonuses for established role (+10) and good offense/volume (+5). Higher % = more buy-low opportunity.</span></span></div><div class="market-column-count">(${buyLow.length} players)</div></div>
${buyLow.map(opp => {
const escapedId = opp.player.id.replace(/'/g, "\\'");
return `
<div class="opportunity-card" onclick="openPlayerModal('${escapedId}');"><div class="opportunity-badge buy">BUY</div><div class="opportunity-info"><div class="opportunity-name">${opp.player.name}</div><div class="opportunity-reason">${opp.reason}</div></div><div class="opportunity-percentage positive">+${opp.upside.toFixed(0)}%</div></div>
`;
}).join('')}
</div>
`;
const sellHighHTML = `
<div class="market-column"><div class="market-column-header"><div class="market-column-title sell-high">Sell High <span class="info-icon">â“˜<span class="info-icon-tooltip">Downside % = TD spike score Ã— volume penalty Ã— TD dependency. Based on recent TDs on limited volume. Higher % = more sell-high risk.</span></span></div><div class="market-column-count">(${sellHigh.length} players)</div></div>
${sellHigh.map(opp => {
const escapedId = opp.player.id.replace(/'/g, "\\'");
return `
<div class="opportunity-card" onclick="openPlayerModal('${escapedId}');"><div class="opportunity-badge sell">SELL</div><div class="opportunity-info"><div class="opportunity-name">${opp.player.name}</div><div class="opportunity-reason">${opp.reason}</div></div><div class="opportunity-percentage negative">-${opp.downside.toFixed(0)}%</div></div>
`;
}).join('')}
</div>
`;
heatmapGrid.innerHTML = buyLowHTML + sellHighHTML;
}
}
function getLast3GamesAvg(player) {
if (!player.weeks || player.weeks.length === 0) return null;
let globalMaxWeek = 0;
Object.values(window.aggregatedWRs).forEach(p => {
if (p.weeks && p.weeks.length > 0) {
const maxWeek = Math.max(...p.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
Object.values(window.aggregatedRBs).forEach(p => {
if (p.weeks && p.weeks.length > 0) {
const maxWeek = Math.max(...p.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
Object.values(window.aggregatedTEs).forEach(p => {
if (p.weeks && p.weeks.length > 0) {
const maxWeek = Math.max(...p.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
if (globalMaxWeek === 0) return null;
const last3ActualWeeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
const prior3ActualWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];
let last3WeeksGames = player.weeks.filter(w =>
last3ActualWeeks.includes(w.week) && w.fpts > 0
);
let usedAlternateWeeks = false;
if (last3WeeksGames.length === 1) {
const weeks2and3 = player.weeks.filter(w =>
[globalMaxWeek - 1, globalMaxWeek - 2].includes(w.week) && w.fpts > 0
);
if (weeks2and3.length >= 2) {
last3WeeksGames = weeks2and3;
usedAlternateWeeks = true;
}
}
if (last3WeeksGames.length < 2) {
const allGamesWithPoints = player.weeks
.filter(w => w.fpts > 0)
.sort((a, b) => b.week - a.week);
if (allGamesWithPoints.length >= 2) {
last3WeeksGames = allGamesWithPoints.slice(0, Math.min(3, allGamesWithPoints.length));
usedAlternateWeeks = true;
}
}
let prior3WeeksGames = player.weeks.filter(w =>
prior3ActualWeeks.includes(w.week) && w.fpts > 0
);
if (usedAlternateWeeks && last3WeeksGames.length > 0) {
const oldestRecentWeek = Math.min(...last3WeeksGames.map(w => w.week));
prior3WeeksGames = player.weeks
.filter(w => w.week < oldestRecentWeek && w.fpts > 0)
.sort((a, b) => b.week - a.week)
.slice(0, 3);
}
const gamesPlayed = last3WeeksGames.length;
if (gamesPlayed < 2) return null;
const totalPoints = last3WeeksGames.reduce((sum, w) => sum + w.fpts, 0);
const avgPoints = totalPoints / gamesPlayed;
let avgVolume = 0;
if (player.position === 'WR' || player.position === 'TE') {
avgVolume = last3WeeksGames.reduce((sum, w) => sum + (w.targets || 0), 0) / gamesPlayed;
} else {
avgVolume = last3WeeksGames.reduce((sum, w) => sum + (w.opportunities || 0), 0) / gamesPlayed;
}
const efficiency = avgVolume > 0 ? avgPoints / avgVolume : 0;
let priorAvgVolume = 0;
let priorEfficiency = 0;
let priorRzOppsPerGame = 0;
if (prior3WeeksGames.length >= 2) {
if (player.position === 'WR' || player.position === 'TE') {
priorAvgVolume = prior3WeeksGames.reduce((sum, w) => sum + (w.targets || 0), 0) / prior3WeeksGames.length;
} else {
priorAvgVolume = prior3WeeksGames.reduce((sum, w) => sum + (w.opportunities || 0), 0) / prior3WeeksGames.length;
}
priorEfficiency = priorAvgVolume > 0 ? prior3WeeksGames.reduce((sum, w) => sum + w.fpts, 0) / prior3WeeksGames.length / priorAvgVolume : 0;
const rawData = player.position === 'WR' ? wrData : (player.position === 'TE' ? teData : rbData);
if (rawData) {
let priorTotalRzOpps = 0;
prior3WeeksGames.forEach(weekData => {
const weekNum = weekData.week;
const weekRow = rawData.find(row =>
row.Team === player.team &&
row.Player === player.name &&
parseInt(row.Week) === weekNum
);
if (weekRow) {
if (player.position === 'WR' || player.position === 'TE') {
priorTotalRzOpps += parseFloat(weekRow.RZ_TGT) ||
parseFloat(weekRow['RZ TGT']) ||
parseFloat(weekRow.RZTGT) ||
parseFloat(weekRow['Red Zone Targets']) ||
0;
} else {
const rzAtt = parseFloat(weekRow.RZ_RUSH_ATT) ||
parseFloat(weekRow['RZ RUSH ATT']) ||
parseFloat(weekRow.RZATT) ||
parseFloat(weekRow['RZ ATT']) ||
parseFloat(weekRow.RZ_ATT) ||
parseFloat(weekRow['RZ_RUSH_ATT']) ||
0;
const rzTgt = parseFloat(weekRow.RZ_TGT) ||
parseFloat(weekRow['RZ TGT']) ||
parseFloat(weekRow.RZTGT) ||
0;
priorTotalRzOpps += rzAtt + rzTgt;
}
}
});
priorRzOppsPerGame = priorTotalRzOpps / prior3WeeksGames.length;
}
}
let totalRzOpps = 0;
// Use aggregated week data instead of raw CSV for consistency with team page
last3WeeksGames.forEach(weekData => {
if (player.position === 'WR' || player.position === 'TE') {
totalRzOpps += weekData.rzTargets || 0;
} else {
totalRzOpps += weekData.rzOpportunities || 0;
}
});
return {
avgPoints,
avgVolume,
efficiency,
gamesPlayed,
rzOppsPerGame: totalRzOpps / gamesPlayed,
globalMaxWeek, // Include for debugging if needed
priorAvgVolume,
priorEfficiency,
priorRzOppsPerGame
};
}
function calculateDashboardCategories() {
const allEligiblePlayers = [
...Object.values(window.aggregatedWRs).filter(p => p.gamesPlayed >= 3),
...Object.values(window.aggregatedRBs).filter(p => p.gamesPlayed >= 3),
...Object.values(window.aggregatedTEs).filter(p => p.gamesPlayed >= 3)
];
if (allEligiblePlayers.length === 0) return null;
function shouldExcludePlayerForInactivity(player) {
if (!player.weeks || player.weeks.length === 0) return true;
let globalMaxWeek = 0;
[...Object.values(window.aggregatedWRs), ...Object.values(window.aggregatedRBs), ...Object.values(window.aggregatedTEs)].forEach(p => {
if (p.weeks && p.weeks.length > 0) {
const maxWeek = Math.max(...p.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
const gamesWithPoints = player.weeks.filter(w => w.fpts > 0).sort((a, b) => b.week - a.week);
if (gamesWithPoints.length === 0) return true;
const mostRecentGame = gamesWithPoints[0];
const weeksAgo = globalMaxWeek - mostRecentGame.week;
if (weeksAgo >= 3) {
const recentGames = player.weeks.filter(w =>
w.week >= (globalMaxWeek - 2) && w.fpts > 0
);
if (recentGames.length < 2) {
return true; // EXCLUDE
}
}
return false; // INCLUDE
}
const playersWithLast3 = allEligiblePlayers
.filter(p => !shouldExcludePlayerForInactivity(p)) // NEW: Filter out inactive players
.map(p => {
const last3 = getLast3GamesAvg(p);
return { ...p, last3 };
})
.filter(p => {
if (!p.last3) return false;
return p.last3.avgPoints >= 7.0;
});
const categories = {
volumeMonsters: calculateVolumeMonsters(playersWithLast3),
efficiencyElites: calculateEfficiencyElites(playersWithLast3),
redZoneKingsWR: calculateRedZoneKingsWR(playersWithLast3),
redZoneBacks: calculateRedZoneBacks(playersWithLast3),
rbEfficiency: calculateRBEfficiency(playersWithLast3),
consistentFloor: calculateConsistentFloor(playersWithLast3),
airYardsLeaders: calculateAirYardsLeaders(playersWithLast3),
passCatchingBacks: calculatePassCatchingBacks(playersWithLast3),
targetLeadersTE: calculateTargetLeadersTE(playersWithLast3),
redZoneDominanceTE: calculateRedZoneDominanceTE(playersWithLast3),
totalTouchdownLeadersWR: calculateTotalTouchdownLeadersWR(playersWithLast3)
};
return categories;
}
function calculateVolumeMonsters(players) {
const rbPlayers = players.filter(p => p.position === 'RB');
const volumeData = rbPlayers.map(p => {
const volume = p.last3.avgVolume; // Use last 3 games average
const priorVolume = p.last3.priorAvgVolume || 0;
const change = priorVolume > 0 ? volume - priorVolume : 0;
return { player: p, value: volume, change: change };
}).sort((a, b) => b.value - a.value);
const threshold = volumeData[Math.floor(volumeData.length * 0.25)]?.value || 0;
return volumeData
.filter(d => d.value >= threshold)
.slice(0, 8)
.map((d, idx) => ({
player: d.player,
rank: idx + 1,
metric: d.value.toFixed(1),
metricLabel: 'Opps/Game (L3)',
change: d.change.toFixed(1),
explanation: 'High touch volume (last 3 games) - workhouse usage',
scatterKey: 'volume-efficiency'
}));
}
function calculateEfficiencyElites(players) {
const efficiencyData = players
.filter(p => p.avgPoints >= 7) // Only players with 7+ PPG
.map(p => {
const efficiency = p.last3.efficiency; // Use last 3 games efficiency
const priorEfficiency = p.last3.priorEfficiency || 0;
const change = priorEfficiency > 0 ? efficiency - priorEfficiency : 0;
return { player: p, value: efficiency, change: change };
}).sort((a, b) => b.value - a.value);
return efficiencyData
.slice(0, Math.ceil(efficiencyData.length * 0.2))
.slice(0, 8)
.map((d, idx) => ({
player: d.player,
rank: idx + 1,
metric: d.value.toFixed(2),
metricLabel: d.player.position === 'WR' ? 'Pts/Tgt (L3)' : 'Pts/Opp (L3)',
change: d.change.toFixed(2),
explanation: 'Elite production per touch (last 3 games) - league winner upside if volume increases',
scatterKey: 'volume-efficiency'
}));
}
function calculateRedZoneKingsWR(players) {
const wrPlayers = players.filter(p => p.position === 'WR');
const redZoneData = wrPlayers.map(p => {
const rzPerGame = p.last3.rzOppsPerGame; // Use last 3 games RZ opps
const priorRzPerGame = p.last3.priorRzOppsPerGame || 0;
const change = priorRzPerGame > 0 ? rzPerGame - priorRzPerGame : 0;
return { player: p, value: rzPerGame, change: change };
})
.filter(d => d.value > 0) // Only players with RZ opportunities
.sort((a, b) => b.value - a.value);
return redZoneData
.slice(0, 8)
.map((d, idx) => ({
player: d.player,
rank: idx + 1,
metric: d.value.toFixed(1),
metricLabel: 'RZ Tgt/G (L3)',
change: d.change.toFixed(1),
explanation: 'WRs with highest red zone target rate (last 3 games) - weekly TD upside',
scatterKey: 'redzone'
}));
}
function calculateRedZoneBacks(players) {
const rbPlayers = players.filter(p => p.position === 'RB');
const redZoneData = rbPlayers.map(p => {
const rzPerGame = p.last3.rzOppsPerGame; // Use last 3 games RZ opps (rush + targets)
const priorRzPerGame = p.last3.priorRzOppsPerGame || 0;
const change = priorRzPerGame > 0 ? rzPerGame - priorRzPerGame : 0;
return { player: p, value: rzPerGame, change: change };
})
.filter(d => d.value > 0) // Only players with RZ opportunities
.sort((a, b) => b.value - a.value);
return redZoneData
.slice(0, 8)
.map((d, idx) => ({
player: d.player,
rank: idx + 1,
metric: d.value.toFixed(1),
metricLabel: 'RZ Opps/G (L3)',
change: d.change.toFixed(1),
explanation: 'RBs with highest red zone usage (last 3 games) - carries + targets in scoring position',
scatterKey: 'redzone'
}));
}
function calculateRBEfficiency(players) {
const rbPlayers = players.filter(p => p.position === 'RB');
const efficiencyData = rbPlayers.map(p => {
let totalYards = 0;
let totalAttempts = 0;
let priorTotalYards = 0;
let priorTotalAttempts = 0;
if (p.weeks && p.weeks.length > 0) {
let globalMaxWeek = 0;
Object.values(window.aggregatedRBs).forEach(rb => {
if (rb.weeks && rb.weeks.length > 0) {
const maxWeek = Math.max(...rb.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
const last3Weeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
const prior3Weeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];
p.weeks.forEach(w => {
if (last3Weeks.includes(w.week)) {
const weekRow = rbData.find(row =>
row.Player === p.name &&
row.Team === p.team &&
parseInt(row.Week) === w.week
);
if (weekRow) {
totalYards += parseFloat(weekRow.YDS) || 0;
totalAttempts += parseFloat(weekRow.ATT) || 0;
}
}
if (prior3Weeks.includes(w.week)) {
const weekRow = rbData.find(row =>
row.Player === p.name &&
row.Team === p.team &&
parseInt(row.Week) === w.week
);
if (weekRow) {
priorTotalYards += parseFloat(weekRow.YDS) || 0;
priorTotalAttempts += parseFloat(weekRow.ATT) || 0;
}
}
});
}
const yardsPerAttempt = totalAttempts > 0 ? totalYards / totalAttempts : 0;
const priorYardsPerAttempt = priorTotalAttempts > 0 ? priorTotalYards / priorTotalAttempts : 0;
const change = priorYardsPerAttempt > 0 ? yardsPerAttempt - priorYardsPerAttempt : 0;
return {
player: p,
value: yardsPerAttempt,
totalAttempts: totalAttempts,
change: change
};
})
.filter(d => d.totalAttempts >= 20) // Minimum 20 attempts over last 3 games
.sort((a, b) => b.value - a.value);
return efficiencyData
.slice(0, 8)
.map((d, idx) => ({
player: d.player,
rank: idx + 1,
metric: d.value.toFixed(2),
metricLabel: 'Yds/Att (L3)',
change: d.change,
explanation: 'RBs with highest yards per carry (last 3 games) - explosive rushing efficiency',
scatterKey: 'volume-efficiency'
}));
}
function calculateBuyLowGems(players) {
const buyLowData = players.map(p => {
const oppShare = p.latestWeekOppShare || 0;
const teamPts = p.latestWeekTeamPoints || 0;
const situationScore = oppShare * (teamPts / 30); // Normalize team points
const actualPPG = p.last3.avgPoints; // Use last 3 games average
const expectedPPG = situationScore * 2; // Rough expected
const underperformance = expectedPPG - actualPPG;
const hasNegMomentum = p.momentum && p.momentum.isValid && p.momentum.score < -5;
return {
player: p,
value: underperformance,
situationScore: situationScore,
actualPPG: actualPPG,
oppShare: oppShare,
teamPts: teamPts,
hasNegMomentum: hasNegMomentum
};
})
.filter(d => d.underperformance > 0 && d.situationScore > 15)
.sort((a, b) => b.value - a.value);
return buyLowData
.slice(0, 8)
.map((d, idx) => {
let explanation;
if (d.oppShare > 25 && d.teamPts > 25) {
explanation = 'Elite offense role + volume - production should rebound';
} else if (d.hasNegMomentum && d.oppShare > 20) {
explanation = 'Strong usage despite slump - buy the dip';
} else if (d.situationScore > 25) {
explanation = 'Premium situation, underperforming - positive regression due';
} else if (d.teamPts > 27) {
explanation = 'High-powered offense role - volume should translate';
} else {
explanation = 'Good situation + volume, recent production should improve';
}
return {
player: d.player,
rank: idx + 1,
metric: d.actualPPG.toFixed(1),
metricLabel: 'PPG (L3)',
score: d.situationScore.toFixed(0),
explanation: explanation,
scatterKey: 'opportunity-share'
};
});
}
function calculateSellHighAlerts(players) {
const sellHighData = players.map(p => {
const last3Weeks = [...p.weeks].sort((a, b) => b.week - a.week).slice(0, 3);
const last3Points = last3Weeks.map(w => parseFloat(w.fpts) || 0);
const ppg = last3Points.reduce((sum, pts) => sum + pts, 0) / last3Points.length;

// Get most recent week's performance
const lastWeekPoints = last3Points[0]; // Already sorted newest first

// Expected points analysis - check for role expansion
const last3ExpectedPoints = last3Weeks.map(w => parseFloat(w.expectedFpts) || 0);
const last3ExpectedAvg = last3ExpectedPoints.reduce((sum, pts) => sum + pts, 0) / 3;
const prevWeeks = [...p.weeks].sort((a, b) => b.week - a.week).slice(3, 6);
const prevExpectedPoints = prevWeeks.map(w => parseFloat(w.expectedFpts) || 0);
const prevExpectedAvg = prevExpectedPoints.length > 0 
? prevExpectedPoints.reduce((sum, pts) => sum + pts, 0) / prevExpectedPoints.length 
: 0;

// Role expansion check
const expectedPointsGrowth = prevExpectedAvg > 0 ? ((last3ExpectedAvg - prevExpectedAvg) / prevExpectedAvg) * 100 : 0;
const hasRoleExpansion = expectedPointsGrowth > 25; // Relaxed from 15% to 25%

// TD analysis - the core of sell high
const last3TDs = last3Weeks.reduce((sum, w) => sum + (parseFloat(w.rec_td) || 0) + (parseFloat(w.rush_td) || 0), 0);
const lastWeekTDs = (parseFloat(last3Weeks[0].rec_td) || 0) + (parseFloat(last3Weeks[0].rush_td) || 0);
const tdPoints = last3TDs * 6; // 6 points per TD
const tdDependency = ppg > 0 ? (tdPoints / (ppg * 3)) * 100 : 0; // % of points from TDs

// Volume analysis
const avgOpportunities = p.last3.avgOpportunities || p.latestWeekOppShare || 0;
const last3UsageShare = last3Weeks.reduce((sum, w) => sum + (w.usageShare || 0), 0) / 3;

// Points without TDs - what would they score without the TDs?
const ppgNoTDs = ppg - (tdPoints / 3);

// SELL HIGH CRITERIA (RELAXED):
const hasTDSpike = last3TDs >= 1; // Relaxed from 2+ to 1+
const hasLimitedVolume = last3UsageShare < 22 || avgOpportunities < 18; // Relaxed from 20/15 to 22/18
const isTDDependent = tdDependency > 30; // Relaxed from 35 to 30
const wouldBeMediocreWithoutTDs = ppgNoTDs < 11; // Relaxed from 10 to 11
const hadGoodLastWeek = lastWeekPoints >= 6; // Relaxed from 10 to 6
const recentlyGoodEnough = ppg > 9; // Need decent 3-week average

const hasSolidMomentum = p.momentum && p.momentum.isValid && p.momentum.score > 10;

// Calculate sell high score based on TD spike severity
const tdSpikeScore = (last3TDs * 2) + (lastWeekTDs * 3);
const volumePenalty = last3UsageShare < 12 ? 2.0 : last3UsageShare < 16 ? 1.5 : 1.2;
const sellHighScore = tdSpikeScore * volumePenalty * (tdDependency / 40);

return {
player: p,
value: ppg,
last3TDs: last3TDs,
lastWeekTDs: lastWeekTDs,
lastWeekPoints: lastWeekPoints,
tdDependency: tdDependency,
last3UsageShare: last3UsageShare,
ppgNoTDs: ppgNoTDs,
hasTDSpike: hasTDSpike,
hasLimitedVolume: hasLimitedVolume,
isTDDependent: isTDDependent,
wouldBeMediocreWithoutTDs: wouldBeMediocreWithoutTDs,
hadGoodLastWeek: hadGoodLastWeek,
recentlyGoodEnough: recentlyGoodEnough,
hasRoleExpansion: hasRoleExpansion,
expectedPointsGrowth: expectedPointsGrowth,
sellHighScore: sellHighScore,
hasSolidMomentum: hasSolidMomentum
};
})
.filter(d => {
return d.value > 8 && // Relaxed from 10 to 8
d.recentlyGoodEnough && // Need decent 3-week average
d.hasTDSpike &&
d.hasLimitedVolume &&
(d.isTDDependent || d.wouldBeMediocreWithoutTDs) &&
!d.hasRoleExpansion &&
!d.hasSolidMomentum;
})
.sort((a, b) => b.sellHighScore - a.sellHighScore); // Sort by sell high score
return sellHighData
.slice(0, 8)
.map((d, idx) => {
let explanation;
if (d.lastWeekTDs >= 2) {
explanation = `${d.lastWeekTDs} TDs last week on ${d.last3UsageShare.toFixed(0)}% usage - peak value`;
} else if (d.last3TDs >= 3 && d.last3UsageShare < 15) {
explanation = `${d.last3TDs} TDs on minimal volume - sell before regression`;
} else if (d.tdDependency > 55) {
explanation = `${d.tdDependency.toFixed(0)}% TD-dependent - value inflated, trade now`;
} else if (d.wouldBeMediocreWithoutTDs && d.last3TDs >= 2) {
explanation = `Would avg ${d.ppgNoTDs.toFixed(1)} PPG without TDs - sell spike`;
} else if (d.last3UsageShare < 12 && d.last3TDs >= 2) {
explanation = `TD spike on <12% usage - unsustainable value`;
} else if (d.lastWeekTDs >= 1 && d.lastWeekPoints > 15) {
explanation = `Recent TD lifted value (${d.lastWeekPoints.toFixed(1)} pts) - cash out`;
} else {
explanation = `${d.last3TDs} TDs masking limited role - trade at peak`;
}
return {
player: d.player,
rank: idx + 1,
metric: d.value.toFixed(1),
metricLabel: 'PPG (L3)',
score: d.consistency.toFixed(1),
explanation: explanation,
scatterKey: 'floor-ceiling'
};
});
}
function calculateBellcowsTargetHogs(players) {
const bellcowData = players.map(p => {
const last3Weeks = [...p.weeks].sort((a, b) => b.week - a.week).slice(0, 3);
let totalShare = 0;
let weekCount = 0;
last3Weeks.forEach(weekData => {
const rawData = p.position === 'WR' ? wrData : rbData;
if (rawData) {
const weekRow = rawData.find(row =>
row.Team === p.team &&
row.Player === p.name &&
parseInt(row.Week) === weekData.week
);
if (weekRow && weekRow['Opp Share']) {
totalShare += parseFloat(weekRow['Opp Share']) || 0;
weekCount++;
}
}
});
const avgShare = weekCount > 0 ? totalShare / weekCount : 0;
const threshold = p.position === 'WR' ? 28 : 70; // WR: 28% target share, RB: 70% opp share
return { player: p, value: avgShare, threshold: threshold };
})
.filter(d => d.value >= d.threshold)
.sort((a, b) => b.value - a.value);
return bellcowData
.slice(0, 8)
.map((d, idx) => ({
player: d.player,
rank: idx + 1,
metric: d.value.toFixed(1) + '%',
metricLabel: d.player.position === 'WR' ? 'Tgt Share (L3)' : 'Opp Share (L3)',
score: d.player.last3.avgPoints.toFixed(1),
explanation: d.player.position === 'WR' ?
'Target hog over last 3 games - will get volume in any game script' :
'Bellcow back over last 3 games - elite workload share',
scatterKey: 'opportunity-share'
}));
}
function calculateConsistentFloor(players) {
const wrPlayers = players.filter(p => p.position === 'WR');
const consistentData = wrPlayers.map(p => {
const targetsPerGame = p.last3.avgVolume; // For WRs, avgVolume is targets
const ppg = p.last3.avgPoints;
const priorTargetsPerGame = p.last3.priorAvgVolume || 0;
const change = priorTargetsPerGame > 0 ? targetsPerGame - priorTargetsPerGame : 0;
return {
player: p,
value: targetsPerGame,
ppg: ppg,
change: change
};
})
.filter(d => d.ppg > 8 && d.value >= 6) // Decent production and minimum target volume
.sort((a, b) => b.value - a.value); // Sort by targets per game
return consistentData
.slice(0, 8)
.map((d, idx) => ({
player: d.player,
rank: idx + 1,
metric: d.value.toFixed(1),
metricLabel: 'Tgt/Game (L3)',
change: d.change.toFixed(1),
explanation: 'Consistent target volume recently - reliable PPR floor',
scatterKey: 'volume-efficiency'
}));
}
function calculateAirYardsLeaders(players) {
const wrPlayers = players.filter(p => p.position === 'WR');
const airYardsData = wrPlayers.map(p => {
let totalAirYards = 0;
let gameCount = 0;
if (p.weeks && p.weeks.length > 0) {
let globalMaxWeek = 0;
Object.values(window.aggregatedWRs).forEach(wr => {
if (wr.weeks && wr.weeks.length > 0) {
const maxWeek = Math.max(...wr.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
const last3Weeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
p.weeks.forEach(w => {
if (last3Weeks.includes(w.week)) {
const weekRow = wrData.find(row =>
row.Team === p.team &&
row.Player === p.name &&
parseInt(row.Week) === w.week
);
if (weekRow && weekRow['Air Yards']) {
totalAirYards += parseFloat(weekRow['Air Yards']) || 0;
gameCount++;
}
}
});
}
const airYardsPerGame = gameCount > 0 ? totalAirYards / gameCount : 0;
let priorAirYards = 0;
let priorGameCount = 0;
if (p.weeks && p.weeks.length > 0) {
let globalMaxWeek = 0;
Object.values(window.aggregatedWRs).forEach(wr => {
if (wr.weeks && wr.weeks.length > 0) {
const maxWeek = Math.max(...wr.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
const priorWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];
p.weeks.forEach(w => {
if (priorWeeks.includes(w.week)) {
const weekRow = wrData.find(row =>
row.Team === p.team &&
row.Player === p.name &&
parseInt(row.Week) === w.week
);
if (weekRow && weekRow['Air Yards']) {
priorAirYards += parseFloat(weekRow['Air Yards']) || 0;
priorGameCount++;
}
}
});
}
const priorAirYardsPerGame = priorGameCount > 0 ? priorAirYards / priorGameCount : 0;
const change = priorAirYardsPerGame > 0 ? airYardsPerGame - priorAirYardsPerGame : 0;
return { player: p, value: airYardsPerGame, change: change };
})
.filter(d => d.value > 0)
.sort((a, b) => b.value - a.value);
return airYardsData
.slice(0, 8)
.map((d, idx) => ({
player: d.player,
rank: idx + 1,
metric: d.value.toFixed(1),
metricLabel: 'Air Yds/G (L3)',
change: d.change.toFixed(1),
explanation: 'Deep threat potential - high air yards signal downfield usage',
scatterKey: 'volume-efficiency'
}));
}
function calculatePassCatchingBacks(players) {
const rbPlayers = players.filter(p => p.position === 'RB');
const receivingData = rbPlayers.map(p => {
let totalTargets = 0;
let gameCount = 0;
if (p.weeks && p.weeks.length > 0) {
let globalMaxWeek = 0;
Object.values(window.aggregatedRBs).forEach(rb => {
if (rb.weeks && rb.weeks.length > 0) {
const maxWeek = Math.max(...rb.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
const last3Weeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
p.weeks.forEach(w => {
if (last3Weeks.includes(w.week)) {
const weekRow = rbData.find(row =>
row.Team === p.team &&
row.Player === p.name &&
parseInt(row.Week) === w.week
);
if (weekRow && weekRow.TGT) {
totalTargets += parseFloat(weekRow.TGT) || 0;
gameCount++;
}
}
});
}
const targetsPerGame = gameCount > 0 ? totalTargets / gameCount : 0;
let priorTargets = 0;
let priorGameCount = 0;
if (p.weeks && p.weeks.length > 0) {
let globalMaxWeek = 0;
Object.values(window.aggregatedRBs).forEach(rb => {
if (rb.weeks && rb.weeks.length > 0) {
const maxWeek = Math.max(...rb.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
const priorWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];
p.weeks.forEach(w => {
if (priorWeeks.includes(w.week)) {
const weekRow = rbData.find(row =>
row.Team === p.team &&
row.Player === p.name &&
parseInt(row.Week) === w.week
);
if (weekRow && weekRow.TGT) {
priorTargets += parseFloat(weekRow.TGT) || 0;
priorGameCount++;
}
}
});
}
const priorTargetsPerGame = priorGameCount > 0 ? priorTargets / priorGameCount : 0;
const change = priorTargetsPerGame > 0 ? targetsPerGame - priorTargetsPerGame : 0;
return { player: p, value: targetsPerGame, change: change };
})
.filter(d => d.value >= 2.0) // Minimum 2 targets per game
.sort((a, b) => b.value - a.value);
return receivingData
.slice(0, 8)
.map((d, idx) => ({
player: d.player,
rank: idx + 1,
metric: d.value.toFixed(1),
metricLabel: 'Tgt/Game (L3)',
change: d.change.toFixed(1),
explanation: 'Pass-catching backs - PPR gold with receiving volume',
scatterKey: 'volume-efficiency'
}));
}
function calculateTargetLeadersTE(players) {
const tePlayers = players.filter(p => p.position === 'TE');
const targetData = tePlayers.map(p => {
const targetsPerGame = p.last3.avgVolume; // For TEs, avgVolume is targets per game
const priorTargetsPerGame = p.last3.priorAvgVolume || 0;
const change = priorTargetsPerGame > 0 ? targetsPerGame - priorTargetsPerGame : 0;
return { player: p, value: targetsPerGame, change: change };
})
.filter(d => d.value > 0) // Only TEs with targets
.sort((a, b) => b.value - a.value);
return targetData
.slice(0, 8)
.map((d, idx) => ({
player: d.player,
rank: idx + 1,
metric: d.value.toFixed(1),
metricLabel: 'Tgt/Game (L3)',
change: d.change.toFixed(1),
explanation: 'TEs with highest target volume (last 3 games) - consistent fantasy floor',
scatterKey: 'volume-efficiency'
}));
}
function calculateRedZoneDominanceTE(players) {
const tePlayers = players.filter(p => p.position === 'TE');
const redZoneData = tePlayers.map(p => {
let rzTargets = 0;
let rzTDs = 0;
let gameCount = 0;
if (p.weeks && p.weeks.length > 0) {
let globalMaxWeek = 0;
Object.values(window.aggregatedTEs).forEach(te => {
if (te.weeks && te.weeks.length > 0) {
const maxWeek = Math.max(...te.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
const last3Weeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
p.weeks.forEach(w => {
if (last3Weeks.includes(w.week)) {
const weekRow = teData.find(row =>
row.Player === p.name &&
row.Team === p.team &&
parseInt(row.Week) === w.week
);
if (weekRow) {
rzTargets += parseFloat(weekRow.RZ_TGT) || 0;
rzTDs += parseFloat(weekRow.RZ_TD) || 0;
gameCount++;
}
}
});
}
const rzScore = gameCount > 0 ? (rzTargets + (rzTDs * 3)) / gameCount : 0;
let priorRzTargets = 0;
let priorRzTDs = 0;
let priorGameCount = 0;
if (p.weeks && p.weeks.length > 0) {
let globalMaxWeek = 0;
Object.values(window.aggregatedTEs).forEach(te => {
if (te.weeks && te.weeks.length > 0) {
const maxWeek = Math.max(...te.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
const priorWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];
p.weeks.forEach(w => {
if (priorWeeks.includes(w.week)) {
const weekRow = teData.find(row =>
row.Player === p.name &&
row.Team === p.team &&
parseInt(row.Week) === w.week
);
if (weekRow) {
priorRzTargets += parseFloat(weekRow.RZ_TGT) || 0;
priorRzTDs += parseFloat(weekRow.RZ_TD) || 0;
priorGameCount++;
}
}
});
}
const priorRzScore = priorGameCount > 0 ? (priorRzTargets + (priorRzTDs * 3)) / priorGameCount : 0;
const change = priorRzScore > 0 ? rzScore - priorRzScore : 0;
return { player: p, value: rzScore, change: change, rzTargets: rzTargets, rzTDs: rzTDs, gameCount: gameCount };
})
.filter(d => d.value > 0) // Only TEs with RZ involvement
.sort((a, b) => b.value - a.value);
return redZoneData
.slice(0, 8)
.map((d, idx) => ({
player: d.player,
rank: idx + 1,
metric: d.value.toFixed(1),
metricLabel: 'RZ Score (L3)',
change: d.change.toFixed(1),
explanation: 'TEs with most RZ targets + TDs (last 3 games) - weekly TD upside',
scatterKey: 'redzone'
}));
}
function calculateTotalTouchdownLeadersWR(players) {
const wrPlayers = players.filter(p => p.position === 'WR');
const tdData = wrPlayers.map(p => {
let recTDs = 0;
let rushTDs = 0;
let gameCount = 0;
if (p.weeks && p.weeks.length > 0) {
let globalMaxWeek = 0;
Object.values(window.aggregatedWRs).forEach(wr => {
if (wr.weeks && wr.weeks.length > 0) {
const maxWeek = Math.max(...wr.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
const last3Weeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
p.weeks.forEach(w => {
if (last3Weeks.includes(w.week)) {
const weekRow = wrData.find(row =>
row.Player === p.name &&
row.Team === p.team &&
parseInt(row.Week) === w.week
);
if (weekRow) {
recTDs += parseFloat(weekRow.REC_TD) || 0;
rushTDs += parseFloat(weekRow.RUSH_TD) || 0;
gameCount++;
}
}
});
}
const totalTDs = recTDs + rushTDs;
const tdsPerGame = gameCount > 0 ? totalTDs / gameCount : 0;
let priorRecTDs = 0;
let priorRushTDs = 0;
let priorGameCount = 0;
if (p.weeks && p.weeks.length > 0) {
let globalMaxWeek = 0;
Object.values(window.aggregatedWRs).forEach(wr => {
if (wr.weeks && wr.weeks.length > 0) {
const maxWeek = Math.max(...wr.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
const priorWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];
p.weeks.forEach(w => {
if (priorWeeks.includes(w.week)) {
const weekRow = wrData.find(row =>
row.Player === p.name &&
row.Team === p.team &&
parseInt(row.Week) === w.week
);
if (weekRow) {
priorRecTDs += parseFloat(weekRow.REC_TD) || 0;
priorRushTDs += parseFloat(weekRow.RUSH_TD) || 0;
priorGameCount++;
}
}
});
}
const priorTotalTDs = priorRecTDs + priorRushTDs;
const priorTdsPerGame = priorGameCount > 0 ? priorTotalTDs / priorGameCount : 0;
const change = priorTdsPerGame > 0 ? tdsPerGame - priorTdsPerGame : 0;
return { player: p, value: tdsPerGame, change: change, recTDs: recTDs, rushTDs: rushTDs, totalTDs: totalTDs };
})
.filter(d => d.totalTDs > 0) // Only WRs who scored TDs
.sort((a, b) => b.value - a.value);
return tdData
.slice(0, 8)
.map((d, idx) => ({
player: d.player,
rank: idx + 1,
metric: d.value.toFixed(2),
metricLabel: 'TDs/Game (L3)',
change: d.change.toFixed(2),
explanation: 'WRs scoring the most TDs (receiving + rushing) in last 3 games',
scatterKey: 'redzone'
}));
}
function calculateBoomBustDFS(players) {
const boomBustData = players.map(p => {
const last3Weeks = [...p.weeks].sort((a, b) => b.week - a.week).slice(0, 3);
const variances = last3Weeks.map(w => {
const weekAvg = w.fpts;
return Math.pow(weekAvg - p.last3.avgPoints, 2);
});
const variance = variances.reduce((sum, v) => sum + v, 0) / variances.length;
const stdDev = Math.sqrt(variance);
const consistency = 10 / (stdDev + 1);
const ppg = p.last3.avgPoints; // Use last 3 games average
const ceiling = ppg; // Simplified ceiling
return {
player: p,
value: ceiling,
consistency: consistency,
stdDev: stdDev
};
})
.filter(d => d.value > 10) // Decent recent ceiling
.sort((a, b) => a.consistency - b.consistency) // Low consistency (high variance)
.slice(0, 8);
return boomBustData
.map((d, idx) => ({
player: d.player,
rank: idx + 1,
metric: d.value.toFixed(1),
metricLabel: 'PPG (L3)',
score: d.stdDev.toFixed(1),
explanation: 'High recent variance - tournament play, avoid cash games',
scatterKey: 'floor-ceiling'
}));
}
let keyInsightsState = {
currentIndex: 0,
insights: [],
autoRotateInterval: null
};
function renderStatOfTheWeek() {
const statContainer = document.getElementById('stat-of-week');
const simpleInsightsContainer = document.getElementById('heatmap-simple-insights');
if (!statContainer && !simpleInsightsContainer) return;
const allWRs = Object.values(window.aggregatedWRs).filter(p => p.gamesPlayed >= 3);
const allRBs = Object.values(window.aggregatedRBs).filter(p => p.gamesPlayed >= 3);
if (allWRs.length === 0 && allRBs.length === 0) return;
const stats = [];
const highTargetWRs = allWRs
.map(p => ({
player: p,
targetsPerGame: p.totalTargets / p.gamesPlayed
}))
.filter(d => d.targetsPerGame >= 8)
.sort((a, b) => b.targetsPerGame - a.targetsPerGame);
if (highTargetWRs.length > 0) {
const avgHighTarget = highTargetWRs.reduce((sum, p) => sum + p.player.avgPoints, 0) / highTargetWRs.length;
const avgAllWRs = allWRs.reduce((sum, p) => sum + p.avgPoints, 0) / allWRs.length;
const difference = avgHighTarget - avgAllWRs;
stats.push({
value: '8+',
label: `High-Volume Alphas (${highTargetWRs.length} WRs)`,
text: `WRs commanding <strong>8+ targets/game</strong> are averaging <strong>+${difference.toFixed(1)} PPG</strong> over the field. Target these alpha receivers dominating their team's passing offense.`,
category: 'High-Volume Alphas'
});
}
const volumeRBs = allRBs
.map(p => ({
player: p,
oppsPerGame: p.totalOpportunities / p.gamesPlayed
}))
.filter(d => d.oppsPerGame >= 18)
.sort((a, b) => b.oppsPerGame - a.oppsPerGame);
if (volumeRBs.length > 0) {
const avgVolRBPts = volumeRBs.reduce((sum, p) => sum + p.player.avgPoints, 0) / volumeRBs.length;
const avgAllRBs = allRBs.reduce((sum, p) => sum + p.avgPoints, 0) / allRBs.length;
const rbDiff = avgVolRBPts - avgAllRBs;
stats.push({
value: '18+',
label: `Volume Monsters (${volumeRBs.length} RBs)`,
text: `RBs seeing <strong>18+ opportunities/game</strong> average <strong>+${rbDiff.toFixed(1)} PPG</strong> vs the field. Bell-cow backs deliver consistent RB1 productionâ€”prioritize workload.`,
category: 'Volume Monsters'
});
}
const allPlayers = [...allWRs, ...allRBs];
const efficiencyThreshold = 2.76;
const efficiencyPlayers = allPlayers
.map(p => {
const touches = p.position === 'WR'
? p.totalTargets
: (p.totalRushAttempts || 0) + (p.totalTargets || 0);
const ppt = touches > 0 ? p.totalPoints / touches : 0;
return { player: p, ppt: ppt, touches: touches };
})
.filter(d => d.ppt >= efficiencyThreshold && d.touches >= 30)
.sort((a, b) => b.ppt - a.ppt);
if (efficiencyPlayers.length > 0) {
const avgEfficientPPG = efficiencyPlayers.reduce((sum, p) => sum + p.player.avgPoints, 0) / efficiencyPlayers.length;
const count = efficiencyPlayers.length;
stats.push({
value: efficiencyThreshold.toFixed(2),
label: `Efficiency Elites (${count} players)`,
text: `Players with <strong>${efficiencyThreshold.toFixed(2)}+ points per touch</strong> average <strong>${avgEfficientPPG.toFixed(1)} PPG</strong>. Elite efficiency often signals quality over quantityâ€”target these players in trades.`,
category: 'Efficiency Elites'
});
}
const rzThresholdPerGame = 2.0;
const rzPlayers = allPlayers
.map(p => ({
player: p,
rzOppsPerGame: p.rzOpportunities / p.gamesPlayed
}))
.filter(d => d.rzOppsPerGame >= rzThresholdPerGame)
.sort((a, b) => b.rzOppsPerGame - a.rzOppsPerGame);
if (rzPlayers.length > 0) {
const avgRZPlayerPPG = rzPlayers.reduce((sum, p) => sum + p.player.avgPoints, 0) / rzPlayers.length;
const avgAllPlayersPPG = allPlayers.reduce((sum, p) => sum + p.avgPoints, 0) / allPlayers.length;
const rzAdvantage = avgRZPlayerPPG - avgAllPlayersPPG;
const count = rzPlayers.length;
stats.push({
value: `${rzThresholdPerGame.toFixed(1)}+`,
label: `Red Zone Kings (${count} players)`,
text: `Players averaging <strong>${rzThresholdPerGame.toFixed(1)}+ red zone opportunities/game</strong> score <strong>+${rzAdvantage.toFixed(1)} PPG</strong> more than the field. RZ usage = TD equityâ€”target these scoring threats.`,
category: 'Red Zone Kings'
});
}
keyInsightsState.insights = stats;
keyInsightsState.currentIndex = 0;
displayInsight(0);
startInsightRotation();
renderPlayerInsightsFromHeatmap();
}

function renderPlayerInsightsFromHeatmap() {
const container = document.getElementById('heatmap-simple-insights');
if (!container) return;

const position = heatmapState.position;
const metric = heatmapState.metric;
const period = heatmapState.period;

let players = getPlayersForPosition(position);
if (players.length === 0) {
container.innerHTML = '<div class="insights-empty">Loading player insights...</div>';
return;
}

// Calculate metrics for all players
players = players.map(player => {
const metricData = calculatePlayerMetric(player, metric, period);
const avgPPG = player.avgPoints || 0;
const snapPct = player.avgSnapPct || 0;
const targetShare = player.position !== 'RB' ? (player.avgTargetShare || 0) : (player.avgOppShare || 0);

return {
...player,
metricValue: metricData.value,
metricDelta: metricData.delta,
metricDisplay: metricData.display,
avgPPG: avgPPG,
snapPct: snapPct,
volumeShare: targetShare
};
}).filter(p => p.metricValue !== null);

// Filter for relevant fantasy players only
const relevantPlayers = players.filter(p => {
// Must have decent PPG (7+) OR high volume share (15%+) OR high snap % (50%+)
return p.avgPPG >= 7 || p.volumeShare >= 15 || p.snapPct >= 50;
});

if (relevantPlayers.length === 0) {
container.innerHTML = '<div class="insights-empty">No significant movements detected among fantasy-relevant players.</div>';
return;
}

// Sort by combination of delta and current value (prioritize high-volume movers)
relevantPlayers.sort((a, b) => {
const aScore = Math.abs(a.metricDelta) * (1 + (a.avgPPG / 20));
const bScore = Math.abs(b.metricDelta) * (1 + (b.avgPPG / 20));
return bScore - aScore;
});

// Adjust PPG thresholds based on scoring format
const scoringMultiplier = currentScoringFormat === 'ppr' ? 1.0 : 
                          currentScoringFormat === 'half' ? 0.85 : 
                          0.75; // standard

const thresholds = {
breakout: 8 * scoringMultiplier,
buyLow: 9 * scoringMultiplier,
rising: 7 * scoringMultiplier,
steady: 12 * scoringMultiplier,
highFloor: 8 * scoringMultiplier,
highFloorMax: 12 * scoringMultiplier,
watch: 7 * scoringMultiplier,
watchMax: 10 * scoringMultiplier,
cooling: 10 * scoringMultiplier,
negMomentum: 9 * scoringMultiplier,
underperform: 7 * scoringMultiplier,
underperformMax: 11 * scoringMultiplier,
fade: 9 * scoringMultiplier
};

const insights = [];

// POSITIVE INSIGHTS

// 1. BREAKOUT - Big positive movers with strong volume
const breakouts = relevantPlayers
.filter(p => p.metricDelta > 20 && p.avgPPG >= thresholds.breakout)
.slice(0, 1);

breakouts.forEach(player => {
const tier = getTierLabel(player.avgPPG, position);
const metricName = getMetricName(metric);
insights.push({
type: 'breakout',
text: `<strong>BREAKOUT:</strong> <span class="highlight-positive">${player.name}</span> <span class="tier-badge">${tier}</span> has surged <span class="highlight-positive bold-metric">+${player.metricDelta.toFixed(0)}%</span> in ${metricName}. Strong buy candidate with upward trajectory.`
});
});

// 2. BUY LOW - Solid players with recent positive trends
const buyLows = relevantPlayers
.filter(p => p.metricDelta > 10 && p.metricDelta <= 20 && p.avgPPG >= thresholds.buyLow && !breakouts.includes(p))
.slice(0, 1);

buyLows.forEach(player => {
const tier = getTierLabel(player.avgPPG, position);
const metricName = getMetricName(metric);
insights.push({
type: 'buy-low',
text: `<strong>BUY LOW:</strong> <span class="highlight-positive">${player.name}</span> <span class="tier-badge">${tier}</span> showing <span class="highlight-positive bold-metric">+${player.metricDelta.toFixed(0)}%</span> improvement in ${metricName}. Acquiring momentum before the market catches up.`
});
});

// 3. VOLUME SPIKE - Big usage increases
if (metric !== 'actual-vs-expected') {
const volumeSpikes = relevantPlayers
.filter(p => p.metricDelta > 25 && p.volumeShare >= 15 && !breakouts.includes(p) && !buyLows.includes(p))
.slice(0, 1);

volumeSpikes.forEach(player => {
const metricName = getMetricName(metric);
insights.push({
type: 'volume-spike',
text: `<strong>VOLUME SPIKE:</strong> <span class="highlight-positive">${player.name}</span> seeing massive <span class="highlight-positive bold-metric">+${player.metricDelta.toFixed(0)}%</span> increase in ${metricName}. Now commanding <span class="bold-metric">${player.volumeShare.toFixed(1)}%</span> share â€” elite usage trend emerging.`
});
});
}

// 4. RISING STAR - Moderate improvers with good upside
const risingStars = relevantPlayers
.filter(p => p.metricDelta > 5 && p.metricDelta <= 15 && p.avgPPG >= thresholds.rising && p.avgPPG < thresholds.watchMax && !buyLows.includes(p) && !breakouts.includes(p))
.slice(0, 1);

risingStars.forEach(player => {
const metricName = getMetricName(metric);
insights.push({
type: 'rising',
text: `<strong>RISING STAR:</strong> <span class="highlight-positive">${player.name}</span> trending up with <span class="highlight-positive bold-metric">+${player.metricDelta.toFixed(0)}%</span> in ${metricName}. Potential league-winner on the wire.`
});
});

// NEUTRAL/WATCHLIST INSIGHTS

// 5. STEADY PRODUCER - Consistent performers
const steadyProducers = relevantPlayers
.filter(p => Math.abs(p.metricDelta) <= 10 && p.avgPPG >= thresholds.steady && p.snapPct >= 60)
.slice(0, 1);

steadyProducers.forEach(player => {
const tier = getTierLabel(player.avgPPG, position);
insights.push({
type: 'steady',
text: `<strong>STEADY:</strong> <span style="color: var(--text-primary)">${player.name}</span> <span class="tier-badge">${tier}</span> maintaining stable production. Consistent <span class="bold-metric">${player.snapPct.toFixed(0)}%</span> snap share â€” reliable floor play.`
});
});

// 6. HIGH FLOOR - Players with consistent volume but moderate production
const highFloor = relevantPlayers
.filter(p => p.volumeShare >= 20 && p.avgPPG >= thresholds.highFloor && p.avgPPG < thresholds.highFloorMax && !steadyProducers.includes(p))
.slice(0, 1);

highFloor.forEach(player => {
insights.push({
type: 'high-floor',
text: `<strong>HIGH FLOOR:</strong> <span style="color: var(--text-primary)">${player.name}</span> commanding <span class="bold-metric">${player.volumeShare.toFixed(0)}%</span> share. Volume-driven safety â€” lacks ceiling but offers stability.`
});
});

// 7. WATCH LIST - Players with potential but need monitoring
const watchList = relevantPlayers
.filter(p => Math.abs(p.metricDelta) <= 8 && p.avgPPG >= thresholds.watch && p.avgPPG < thresholds.watchMax && p.snapPct >= 50 && !steadyProducers.includes(p) && !highFloor.includes(p))
.slice(0, 1);

watchList.forEach(player => {
insights.push({
type: 'watch',
text: `<strong>WATCH LIST:</strong> <span style="color: var(--text-primary)">${player.name}</span> holding steady with <span class="bold-metric">${player.snapPct.toFixed(0)}%</span> snaps. Keep an eye â€” one injury away from relevance.`
});
});

// NEGATIVE INSIGHTS

// 8. COOLING OFF - Small declines worth noting
const coolingOff = relevantPlayers
.filter(p => p.metricDelta < -5 && p.metricDelta >= -15 && p.avgPPG >= thresholds.cooling)
.slice(0, 1);

coolingOff.forEach(player => {
const metricName = getMetricName(metric);
insights.push({
type: 'cooling',
text: `<strong>COOLING OFF:</strong> <span class="highlight-negative">${player.name}</span> slipping <span class="highlight-negative bold-metric">${player.metricDelta.toFixed(0)}%</span> in ${metricName}. Early warning signs â€” monitor next few weeks.`
});
});

// 9. NEGATIVE MOMENTUM - Declining but still fantasy relevant
const negMomentum = relevantPlayers
.filter(p => p.metricDelta < -15 && p.metricDelta >= -25 && p.avgPPG >= thresholds.negMomentum && !coolingOff.includes(p))
.slice(0, 1);

negMomentum.forEach(player => {
const tier = getTierLabel(player.avgPPG, position);
const metricName = getMetricName(metric);
insights.push({
type: 'neg-momentum',
text: `<strong>NEGATIVE MOMENTUM:</strong> <span class="highlight-negative">${player.name}</span> <span class="tier-badge">${tier}</span> declining <span class="highlight-negative bold-metric">${player.metricDelta.toFixed(0)}%</span> in ${metricName}. Trend is concerning â€” sell window closing.`
});
});

// 10. VOLUME DRAIN - Losing opportunity share
if (metric !== 'actual-vs-expected') {
const volumeDrain = relevantPlayers
.filter(p => p.metricDelta < -20 && p.volumeShare >= 10 && !negMomentum.includes(p) && !coolingOff.includes(p))
.slice(0, 1);

volumeDrain.forEach(player => {
const metricName = getMetricName(metric);
insights.push({
type: 'volume-drain',
text: `<strong>VOLUME DRAIN:</strong> <span class="highlight-negative">${player.name}</span> losing ground with <span class="highlight-negative bold-metric">${player.metricDelta.toFixed(0)}%</span> drop in ${metricName}. Share down to <span class="bold-metric">${player.volumeShare.toFixed(1)}%</span> â€” role diminishing fast.`
});
});
}

// 11. UNDERPERFORMING - Missing expected points
const underperform = relevantPlayers
.filter(p => p.metricDelta < -15 && p.avgPPG >= thresholds.underperform && p.avgPPG < thresholds.underperformMax && !negMomentum.includes(p) && !coolingOff.includes(p))
.slice(0, 1);

underperform.forEach(player => {
const metricName = getMetricName(metric);
insights.push({
type: 'underperform',
text: `<strong>UNDERPERFORMING:</strong> <span class="highlight-negative">${player.name}</span> falling short with <span class="highlight-negative bold-metric">${player.metricDelta.toFixed(0)}%</span> decline in ${metricName}. Expected more based on usage.`
});
});

// 12. FADING - Players declining significantly
const fading = relevantPlayers
.filter(p => p.metricDelta < -25 && p.avgPPG < thresholds.fade && !underperform.includes(p) && !negMomentum.includes(p) && !coolingOff.includes(p))
.slice(0, 1);

fading.forEach(player => {
const metricName = getMetricName(metric);
insights.push({
type: 'fade',
text: `<strong>FADING:</strong> <span class="highlight-negative">${player.name}</span> cratering with <span class="highlight-negative bold-metric">${player.metricDelta.toFixed(0)}%</span> decline in ${metricName}. Immediate drop candidate.`
});
});

if (insights.length === 0) {
container.innerHTML = '<div class="insights-empty">No significant movements detected among fantasy-relevant players in this time range.</div>';
return;
}

// Show all insights (up to 12)
const finalInsights = insights;

// Map insight types to their badge icons
const badgeMap = {
'breakout': 'â¬†',
'buy-low': '+',
'volume-spike': 'â—†',
'rising': 'â†—',
'steady': 'â—',
'high-floor': 'â– ',
'watch': 'â—',
'cooling': 'â†™',
'neg-momentum': 'â–¼',
'volume-drain': 'â—‡',
'underperform': 'â–½',
'fade': 'â¬‡'
};

const insightsHTML = `<div class="insights-grid">${finalInsights.map(insight => {
// Get badge icon
const badge = badgeMap[insight.type] || 'â€¢';
// Add badge to the strong tag
const textWithBadge = insight.text.replace(
'<strong>',
`<strong><span class="insight-badge">${badge}</span>`
);
return `<div class="heatmap-simple-insight" data-type="${insight.type}">
<div class="insight-content">${textWithBadge}</div>
</div>`;
}).join('')}</div>`;

container.innerHTML = insightsHTML;
}

// Helper function to determine player tier based on PPG
// Helper function to determine player tier based on PPG and scoring format
function getTierLabel(ppg, position) {
// Adjust thresholds based on scoring format
const scoringMultiplier = currentScoringFormat === 'ppr' ? 1.0 : 
                          currentScoringFormat === 'half' ? 0.85 : 
                          0.75; // standard

if (position === 'RB') {
const rb1 = 15 * scoringMultiplier;
const rb2High = 12 * scoringMultiplier;
const rb2Low = 9 * scoringMultiplier;

if (ppg >= rb1) return 'RB1 territory';
if (ppg >= rb2High) return 'High-end RB2';
if (ppg >= rb2Low) return 'Low-end RB2/Flex';
return 'Bench/streamer';
} else if (position === 'WR') {
const wr1 = 15 * scoringMultiplier;
const wr2High = 12 * scoringMultiplier;
const wr2Low = 9 * scoringMultiplier;

if (ppg >= wr1) return 'WR1 territory';
if (ppg >= wr2High) return 'High-end WR2';
if (ppg >= wr2Low) return 'Low-end WR2/Flex';
return 'Bench depth';
} else { // TE
const te1Elite = 12 * scoringMultiplier;
const te1Mid = 9 * scoringMultiplier;
const teStreamer = 7 * scoringMultiplier;

if (ppg >= te1Elite) return 'Elite TE1';
if (ppg >= te1Mid) return 'Mid-range TE1';
if (ppg >= teStreamer) return 'Streamer TE';
return 'Bench depth';
}
}

// Helper function to get readable metric name
function getMetricName(metric) {
if (metric === 'actual-vs-expected') return 'performance vs expected';
if (metric === 'target-share') return 'target/opportunity share';
if (metric === 'rz-opp-share') return 'red zone opportunities';
return 'performance';
}

function renderSimpleInsights(insights) {
const container = document.getElementById('heatmap-simple-insights');
if (!container) return;

if (insights.length === 0) {
container.innerHTML = '<div class="heatmap-simple-insight">Loading insights...</div>';
return;
}

const insightsHTML = insights.map(insight => {
// Remove HTML tags and create clean text
let text = insight.text.replace(/<strong>/g, '').replace(/<\/strong>/g, '');
return `<div class="heatmap-simple-insight">${insight.label}: ${text}</div>`;
}).join('');

container.innerHTML = insightsHTML;
}

function displayInsight(index) {
const valueEl = document.getElementById('heatmap-rotating-value');
const labelEl = document.getElementById('heatmap-rotating-label');
const textEl = document.getElementById('heatmap-rotating-text');

if (!valueEl || !labelEl || !textEl) return;
if (keyInsightsState.insights.length === 0) {
valueEl.textContent = '...';
labelEl.textContent = 'Loading';
textEl.textContent = 'Analyzing player data...';
return;
}

index = ((index % keyInsightsState.insights.length) + keyInsightsState.insights.length) % keyInsightsState.insights.length;
keyInsightsState.currentIndex = index;
const insight = keyInsightsState.insights[index];

// Fade out
valueEl.style.opacity = '0';
labelEl.style.opacity = '0';
textEl.style.opacity = '0';

setTimeout(() => {
// Update content
valueEl.textContent = insight.value;
labelEl.textContent = insight.label;
// Remove HTML tags from text
textEl.innerHTML = insight.text.replace(/<strong>/g, '').replace(/<\/strong>/g, '');

// Fade in
valueEl.style.opacity = '1';
labelEl.style.opacity = '1';
textEl.style.opacity = '1';
}, 300);
}
function nextInsight() {
stopInsightRotation();
displayInsight(keyInsightsState.currentIndex + 1);
startInsightRotation();
}
function previousInsight() {
stopInsightRotation();
displayInsight(keyInsightsState.currentIndex - 1);
startInsightRotation();
}
function startInsightRotation() {
stopInsightRotation(); // Clear any existing interval
keyInsightsState.autoRotateInterval = setInterval(() => {
displayInsight(keyInsightsState.currentIndex + 1);
}, 15000); // 15 seconds
}
function stopInsightRotation() {
if (keyInsightsState.autoRotateInterval) {
clearInterval(keyInsightsState.autoRotateInterval);
keyInsightsState.autoRotateInterval = null;
}
}
let dashboardTrendState = {
wr: {
isPlaying: false,
currentTranche: 3, // Start at final position
chart: null,
trails: {},
fixedAxes: null,
medianX: null,
medianY: null,
filter: 'all' // 'all', 'positive', 'negative'
},
rb: {
isPlaying: false,
currentTranche: 3, // Start at final position
chart: null,
trails: {},
fixedAxes: null,
medianX: null,
medianY: null,
filter: 'all' // 'all', 'positive', 'negative'
}
};
function toggleChartExpand(position) {
const wrWidget = document.getElementById('wr-trend-widget');
const rbWidget = document.getElementById('rb-trend-widget');
const wrBtn = document.getElementById('wr-expand-btn');
const rbBtn = document.getElementById('rb-expand-btn');
if (position === 'wr') {
if (wrWidget.classList.contains('expanded')) {
wrWidget.classList.remove('expanded');
rbWidget.classList.remove('collapsed');
wrBtn.textContent = 'â›¶';
wrBtn.title = 'Expand';
} else {
wrWidget.classList.add('expanded');
rbWidget.classList.add('collapsed');
wrBtn.textContent = 'â›¶';
wrBtn.title = 'Collapse';
}
} else {
if (rbWidget.classList.contains('expanded')) {
rbWidget.classList.remove('expanded');
wrWidget.classList.remove('collapsed');
rbBtn.textContent = 'â›¶';
rbBtn.title = 'Expand';
} else {
rbWidget.classList.add('expanded');
wrWidget.classList.add('collapsed');
rbBtn.textContent = 'â›¶';
rbBtn.title = 'Collapse';
}
}
setTimeout(() => {
if (position === 'wr' || !wrWidget.classList.contains('collapsed')) {
renderDashboardWRTrend();
}
if (position === 'rb' || !rbWidget.classList.contains('collapsed')) {
renderDashboardRBTrend();
}
}, 100);
}
function setDashboardFilter(position, filter) {
dashboardTrendState[position].filter = filter;
['all', 'positive', 'negative'].forEach(f => {
const btn = document.getElementById(`${position}-filter-${f}`);
if (btn) {
if (f === filter) {
btn.classList.add('active');
} else {
btn.classList.remove('active');
}
}
});
if (position === 'wr') {
renderDashboardWRTrend();
} else {
renderDashboardRBTrend();
}
}
function calculateTrancheData(players, position) {
let globalMaxWeek = 0;
players.forEach(player => {
if (player.weeks && player.weeks.length > 0) {
const maxWeek = Math.max(...player.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
const tranche3Start = 7;
const tranche3Weeks = [];
for (let w = tranche3Start; w <= globalMaxWeek; w++) {
tranche3Weeks.push(w);
}
const tranches = [
{ name: 'Weeks 1-3', weeks: [1, 2, 3] },
{ name: 'Weeks 4-6', weeks: [4, 5, 6] },
{ name: `Weeks ${tranche3Start}-${globalMaxWeek}`, weeks: tranche3Weeks }
];
return players.map(player => {
const trancheData = tranches.map((tranche, idx) => {
const weeksInTranche = player.weeks.filter(w => tranche.weeks.includes(w.week));
if (weeksInTranche.length === 0) return null;
let volume, efficiency;
if (position === 'WR') {
volume = weeksInTranche.reduce((sum, w) => sum + (w.targets || 0), 0) / weeksInTranche.length;
const totalTargets = weeksInTranche.reduce((sum, w) => sum + (w.targets || 0), 0);
const totalPoints = weeksInTranche.reduce((sum, w) => sum + w.fpts, 0);
efficiency = totalTargets > 0 ? totalPoints / totalTargets : 0;
} else {
volume = weeksInTranche.reduce((sum, w) => sum + ((w.rushAttempts || 0) + (w.targets || 0)), 0) / weeksInTranche.length;
const totalOpps = weeksInTranche.reduce((sum, w) => sum + ((w.rushAttempts || 0) + (w.targets || 0)), 0);
const totalPoints = weeksInTranche.reduce((sum, w) => sum + w.fpts, 0);
efficiency = totalOpps > 0 ? totalPoints / totalOpps : 0;
}
return {
tranche: idx + 1,
trancheName: tranche.name,
volume: volume,
efficiency: efficiency,
gamesPlayed: weeksInTranche.length
};
}).filter(t => t !== null);
let totalDistance = 0;
if (trancheData.length >= 2) {
for (let i = 1; i < trancheData.length; i++) {
const dx = trancheData[i].volume - trancheData[i-1].volume;
const dy = trancheData[i].efficiency - trancheData[i-1].efficiency;
totalDistance += Math.sqrt(dx*dx + dy*dy);
}
}
return {
player: player,
tranches: trancheData,
totalDistance: totalDistance
};
}).filter(p => p.tranches.length > 0);
}
function calculateFixedAxesAndMedian(trancheData) {
let minX = Infinity, maxX = -Infinity;
let minY = Infinity, maxY = -Infinity;
let allX = [], allY = [];
let currentWeekX = [], currentWeekY = [];
trancheData.forEach(playerData => {
playerData.tranches.forEach(t => {
minX = Math.min(minX, t.volume);
maxX = Math.max(maxX, t.volume);
minY = Math.min(minY, t.efficiency);
maxY = Math.max(maxY, t.efficiency);
allX.push(t.volume);
allY.push(t.efficiency);
if (t.tranche === 3) {
currentWeekX.push(t.volume);
currentWeekY.push(t.efficiency);
}
});
});
currentWeekX.sort((a, b) => a - b);
currentWeekY.sort((a, b) => a - b);
const currentMedianX = currentWeekX.length > 0 ? currentWeekX[Math.floor(currentWeekX.length / 2)] : 0;
const currentMedianY = currentWeekY.length > 0 ? currentWeekY[Math.floor(currentWeekY.length / 2)] : 0;
allX.sort((a, b) => a - b);
allY.sort((a, b) => a - b);
const medianX = allX[Math.floor(allX.length / 2)];
const medianY = allY[Math.floor(allY.length / 2)];
const rangeX = maxX - minX;
const rangeY = maxY - minY;
const zoomedMinX = medianX - (rangeX * 0.6);
const zoomedMaxX = medianX + (rangeX * 0.6);
const zoomedMinY = medianY - (rangeY * 0.6);
const zoomedMaxY = medianY + (rangeY * 0.6);
return {
axes: {
x: { min: zoomedMinX, max: zoomedMaxX },
y: { min: zoomedMinY, max: zoomedMaxY }
},
median: { x: currentMedianX, y: currentMedianY } // Return CURRENT week median
};
}
function renderDashboardCombinedTrend() {
renderDashboardWRTrend();
renderDashboardRBTrend();
}
function renderDashboardWRTrend() {
const canvas = document.getElementById('wr-trend-chart');
if (!canvas) { return;
}
if (!aggregatedWRs || Object.keys(aggregatedWRs).length === 0) { return;
}
const wrs = Object.values(window.aggregatedWRs)
.filter(p => p.gamesPlayed >= 3)
.sort((a, b) => b.avgPoints - a.avgPoints)
.slice(0, 36);
const trancheData = calculateTrancheData(wrs, 'WR');
updateTrancheLabel('wr', dashboardTrendState.wr.currentTranche);
if (!dashboardTrendState.wr.fixedAxes) {
const result = calculateFixedAxesAndMedian(trancheData);
dashboardTrendState.wr.fixedAxes = result.axes;
dashboardTrendState.wr.medianX = result.median.x;
dashboardTrendState.wr.medianY = result.median.y;
}
const sortedByDistance = [...trancheData].sort((a, b) => b.totalDistance - a.totalDistance);
const topMovers = new Set(sortedByDistance.slice(0, 5).map(d => d.player.id));
const movementData = trancheData.map(pd => {
const effT2 = pd.tranches.find(t => t.tranche === 2)?.efficiency || 0;
const effT3 = pd.tranches.find(t => t.tranche === 3)?.efficiency || 0;
const volT2 = pd.tranches.find(t => t.tranche === 2)?.volume || 0;
const volT3 = pd.tranches.find(t => t.tranche === 3)?.volume || 0;
const effChange = effT3 - effT2;
const volChange = (volT3 - volT2) / 10; // Normalize volume change
const movement = effChange + volChange;
return { playerId: pd.player.id, movement };
});
const filter = dashboardTrendState.wr.filter;
let filteredPlayerIds = new Set(trancheData.map(d => d.player.id));
if (filter === 'positive') {
const topPositive = movementData
.filter(m => m.movement > 0)
.sort((a, b) => b.movement - a.movement)
.slice(0, 10)
.map(m => m.playerId);
filteredPlayerIds = new Set(topPositive);
} else if (filter === 'negative') {
const topNegative = movementData
.filter(m => m.movement < 0)
.sort((a, b) => a.movement - b.movement)
.slice(0, 10)
.map(m => m.playerId);
filteredPlayerIds = new Set(topNegative);
}
if (dashboardTrendState.wr.chart) {
dashboardTrendState.wr.chart.destroy();
}
const currentTranche = dashboardTrendState.wr.currentTranche;
let currentData = interpolateTranchePlayers(trancheData, currentTranche, 'wr');
currentData = currentData.filter(d => filteredPlayerIds.has(d.player.id));
const trailDatasets = [];
if (currentTranche > 0) {
const currentPhase = Math.floor(currentTranche);
if (!dashboardTrendState.wr.lastPhase) {
dashboardTrendState.wr.lastPhase = 0;
}
if (currentPhase > dashboardTrendState.wr.lastPhase) {
dashboardTrendState.wr.trails = {};
dashboardTrendState.wr.lastPhase = currentPhase;
}
currentData.forEach(point => {
const playerId = point.player.id;
if (!dashboardTrendState.wr.trails[playerId]) {
dashboardTrendState.wr.trails[playerId] = [];
}
dashboardTrendState.wr.trails[playerId].push({ x: point.x, y: point.y });
if (dashboardTrendState.wr.trails[playerId].length > 30) {
dashboardTrendState.wr.trails[playerId].shift();
}
const trail = dashboardTrendState.wr.trails[playerId];
if (trail.length > 2) {
const teamColor = teamColors[point.player.team] || '#666';
const r = parseInt(teamColor.slice(1, 3), 16);
const g = parseInt(teamColor.slice(3, 5), 16);
const b = parseInt(teamColor.slice(5, 7), 16);
trailDatasets.push({
type: 'line',
data: trail,
borderColor: `rgba(${r}, ${g}, ${b}, 0.3)`,
borderWidth: 2.5, // Thicker trail for better visibility
fill: false,
pointRadius: 0,
pointHoverRadius: 0,
tension: 0.4, // Smooth curve
segment: {
borderColor: ctx => {
const progress = ctx.p0DataIndex / (trail.length - 1);
const opacity = 0.1 + (progress * 0.3);
return `rgba(${r}, ${g}, ${b}, ${opacity})`;
}
}
});
}
});
}
const ctx = canvas.getContext('2d');
dashboardTrendState.wr.chart = new Chart(ctx, {
type: 'scatter',
data: {
datasets: [
...trailDatasets,
{
data: currentData,
backgroundColor: currentData.map(d => {
const isTopMover = topMovers.has(d.player.id);
const color = teamColors[d.player.team] || '#666';
const r = parseInt(color.slice(1, 3), 16);
const g = parseInt(color.slice(3, 5), 16);
const b = parseInt(color.slice(5, 7), 16);
return isTopMover ? `rgba(${r}, ${g}, ${b}, 0.9)` : `rgba(${r}, ${g}, ${b}, 0.6)`;
}),
borderColor: currentData.map(d => {
const isTopMover = topMovers.has(d.player.id);
const color = teamColors[d.player.team] || '#666';
return isTopMover ? color : color;
}),
borderWidth: 2,
pointRadius: 6,
pointHoverRadius: 8
}
]
},
options: {
responsive: true,
maintainAspectRatio: false,
onClick: (event, elements) => {
if (elements.length > 0) {
const lastDataset = dashboardTrendState.wr.chart.data.datasets.length - 1;
if (elements[0].datasetIndex === lastDataset) {
const index = elements[0].index;
const player = currentData[index].player;
handleChartClick(event, player, openPlayerModal);
}
}
},
plugins: {
legend: { display: false },
tooltip: {
...getMobileChartTooltipConfig(),
filter: (tooltipItem) => {
return tooltipItem.datasetIndex === dashboardTrendState.wr.chart.data.datasets.length - 1;
},
callbacks: {
label: (context) => {
const p = context.raw.player;
return [
p.name,
`Targets/G: ${context.parsed.x.toFixed(1)}`,
`Pts/Target: ${context.parsed.y.toFixed(2)}`
];
}
}
}
},
scales: {
x: {
min: dashboardTrendState.wr.fixedAxes.x.min,
max: dashboardTrendState.wr.fixedAxes.x.max,
title: { display: true, text: 'Targets per Game', color: getThemeColors().textSecondary, font: { size: 11 } },
grid: {
color: getThemeColors().grid,
drawTicks: true
},
ticks: {
color: getThemeColors().textSecondary,
font: { size: 10 },
stepSize: 2
}
},
y: {
min: dashboardTrendState.wr.fixedAxes.y.min,
max: dashboardTrendState.wr.fixedAxes.y.max,
title: { display: true, text: 'Points per Target', color: getThemeColors().textSecondary, font: { size: 11 } },
grid: {
color: getThemeColors().grid,
drawTicks: true
},
ticks: {
color: getThemeColors().textSecondary,
font: { size: 10 },
stepSize: 0.5
}
}
}
},
plugins: [{
id: 'quadrantLines',
afterDatasetsDraw: (chart) => {
const ctx = chart.ctx;
const chartArea = chart.chartArea;
const xAxis = chart.scales.x;
const yAxis = chart.scales.y;
const xMid = dashboardTrendState.wr.medianX;
const yMid = dashboardTrendState.wr.medianY;
const isDark = !document.documentElement.getAttribute('data-theme') || document.documentElement.getAttribute('data-theme') === 'dark';
ctx.strokeStyle = isDark ? 'rgba(142, 142, 147, 0.5)' : 'rgba(90, 90, 90, 0.3)';
ctx.setLineDash([3, 3]);
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(xAxis.getPixelForValue(xMid), chartArea.top);
ctx.lineTo(xAxis.getPixelForValue(xMid), chartArea.bottom);
ctx.stroke();
ctx.beginPath();
ctx.moveTo(chartArea.left, yAxis.getPixelForValue(yMid));
ctx.lineTo(chartArea.right, yAxis.getPixelForValue(yMid));
ctx.stroke();
ctx.setLineDash([]);
ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
ctx.textAlign = 'center';
const xMidPixel = xAxis.getPixelForValue(xMid);
const yMidPixel = yAxis.getPixelForValue(yMid);
ctx.fillStyle = '#30d158';
ctx.fillText('ELITE', (xMidPixel + chartArea.right) / 2, (chartArea.top + yMidPixel) / 2 - 4);
ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
ctx.fillStyle = isDark ? '#8e8e93' : '#5a5a5a';
ctx.fillText('High Vol + Efficiency', (xMidPixel + chartArea.right) / 2, (chartArea.top + yMidPixel) / 2 + 8);
ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
ctx.fillStyle = '#0a84ff';
ctx.fillText('SLEEPER', (chartArea.left + xMidPixel) / 2, (chartArea.top + yMidPixel) / 2 - 4);
ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
ctx.fillStyle = isDark ? '#8e8e93' : '#5a5a5a';
ctx.fillText('Efficient, Low Vol', (chartArea.left + xMidPixel) / 2, (chartArea.top + yMidPixel) / 2 + 8);
ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
ctx.fillStyle = '#FFD60A';
ctx.fillText('HOLD', (xMidPixel + chartArea.right) / 2, (yMidPixel + chartArea.bottom) / 2 - 4);
ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
ctx.fillStyle = isDark ? '#8e8e93' : '#5a5a5a';
ctx.fillText('Volume, Poor Efficiency', (xMidPixel + chartArea.right) / 2, (yMidPixel + chartArea.bottom) / 2 + 8);
ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
ctx.fillStyle = '#ff453a';
ctx.fillText('FADE', (chartArea.left + xMidPixel) / 2, (yMidPixel + chartArea.bottom) / 2 - 4);
ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
ctx.fillStyle = isDark ? '#8e8e93' : '#5a5a5a';
ctx.fillText('Low Vol + Efficiency', (chartArea.left + xMidPixel) / 2, (yMidPixel + chartArea.bottom) / 2 + 8);
}
}]
});
}
function renderDashboardRBTrend() {
const canvas = document.getElementById('rb-trend-chart');
if (!canvas) { return;
}
if (!aggregatedRBs || Object.keys(aggregatedRBs).length === 0) { return;
}
const rbs = Object.values(window.aggregatedRBs)
.filter(p => p.gamesPlayed >= 3)
.sort((a, b) => b.avgPoints - a.avgPoints)
.slice(0, 36);
const trancheData = calculateTrancheData(rbs, 'RB');
updateTrancheLabel('rb', dashboardTrendState.rb.currentTranche);
if (!dashboardTrendState.rb.fixedAxes) {
const result = calculateFixedAxesAndMedian(trancheData);
dashboardTrendState.rb.fixedAxes = result.axes;
dashboardTrendState.rb.medianX = result.median.x;
dashboardTrendState.rb.medianY = result.median.y;
}
const sortedByDistance = [...trancheData].sort((a, b) => b.totalDistance - a.totalDistance);
const topMovers = new Set(sortedByDistance.slice(0, 5).map(d => d.player.id));
const movementData = trancheData.map(pd => {
const effT2 = pd.tranches.find(t => t.tranche === 2)?.efficiency || 0;
const effT3 = pd.tranches.find(t => t.tranche === 3)?.efficiency || 0;
const volT2 = pd.tranches.find(t => t.tranche === 2)?.volume || 0;
const volT3 = pd.tranches.find(t => t.tranche === 3)?.volume || 0;
const effChange = effT3 - effT2;
const volChange = (volT3 - volT2) / 10; // Normalize volume change
const movement = effChange + volChange;
return { playerId: pd.player.id, movement };
});
const filter = dashboardTrendState.rb.filter;
let filteredPlayerIds = new Set(trancheData.map(d => d.player.id));
if (filter === 'positive') {
const topPositive = movementData
.filter(m => m.movement > 0)
.sort((a, b) => b.movement - a.movement)
.slice(0, 10)
.map(m => m.playerId);
filteredPlayerIds = new Set(topPositive);
} else if (filter === 'negative') {
const topNegative = movementData
.filter(m => m.movement < 0)
.sort((a, b) => a.movement - b.movement)
.slice(0, 10)
.map(m => m.playerId);
filteredPlayerIds = new Set(topNegative);
}
if (dashboardTrendState.rb.chart) {
dashboardTrendState.rb.chart.destroy();
}
const currentTranche = dashboardTrendState.rb.currentTranche;
let currentData = interpolateTranchePlayers(trancheData, currentTranche, 'rb');
currentData = currentData.filter(d => filteredPlayerIds.has(d.player.id));
const trailDatasets = [];
if (currentTranche > 0) {
const currentPhase = Math.floor(currentTranche);
if (!dashboardTrendState.rb.lastPhase) {
dashboardTrendState.rb.lastPhase = 0;
}
if (currentPhase > dashboardTrendState.rb.lastPhase) {
dashboardTrendState.rb.trails = {};
dashboardTrendState.rb.lastPhase = currentPhase;
}
currentData.forEach(point => {
const playerId = point.player.id;
if (!dashboardTrendState.rb.trails[playerId]) {
dashboardTrendState.rb.trails[playerId] = [];
}
dashboardTrendState.rb.trails[playerId].push({ x: point.x, y: point.y });
if (dashboardTrendState.rb.trails[playerId].length > 30) {
dashboardTrendState.rb.trails[playerId].shift();
}
const trail = dashboardTrendState.rb.trails[playerId];
if (trail.length > 2) {
const teamColor = teamColors[point.player.team] || '#666';
const r = parseInt(teamColor.slice(1, 3), 16);
const g = parseInt(teamColor.slice(3, 5), 16);
const b = parseInt(teamColor.slice(5, 7), 16);
trailDatasets.push({
type: 'line',
data: trail,
borderColor: `rgba(${r}, ${g}, ${b}, 0.3)`,
borderWidth: 2.5, // Thicker trail for better visibility
fill: false,
pointRadius: 0,
pointHoverRadius: 0,
tension: 0.4, // Smooth curve
segment: {
borderColor: ctx => {
const progress = ctx.p0DataIndex / (trail.length - 1);
const opacity = 0.1 + (progress * 0.3);
return `rgba(${r}, ${g}, ${b}, ${opacity})`;
}
}
});
}
});
}
const ctx = canvas.getContext('2d');
dashboardTrendState.rb.chart = new Chart(ctx, {
type: 'scatter',
data: {
datasets: [
...trailDatasets,
{
data: currentData,
backgroundColor: currentData.map(d => {
const isTopMover = topMovers.has(d.player.id);
const color = teamColors[d.player.team] || '#666';
const r = parseInt(color.slice(1, 3), 16);
const g = parseInt(color.slice(3, 5), 16);
const b = parseInt(color.slice(5, 7), 16);
return isTopMover ? `rgba(${r}, ${g}, ${b}, 0.9)` : `rgba(${r}, ${g}, ${b}, 0.6)`;
}),
borderColor: currentData.map(d => {
const color = teamColors[d.player.team] || '#666';
return color;
}),
borderWidth: 2,
pointRadius: 6,
pointHoverRadius: 8
}
]
},
options: {
responsive: true,
maintainAspectRatio: false,
onClick: (event, elements) => {
if (elements.length > 0) {
const lastDataset = dashboardTrendState.rb.chart.data.datasets.length - 1;
if (elements[0].datasetIndex === lastDataset) {
const index = elements[0].index;
const player = currentData[index].player;
handleChartClick(event, player, openPlayerModal);
}
}
},
plugins: {
legend: { display: false },
tooltip: {
...getMobileChartTooltipConfig(),
filter: (tooltipItem) => {
return tooltipItem.datasetIndex === dashboardTrendState.rb.chart.data.datasets.length - 1;
},
callbacks: {
label: (context) => {
const p = context.raw.player;
return [
p.name,
`Opps/G: ${context.parsed.x.toFixed(1)}`,
`Pts/Opp: ${context.parsed.y.toFixed(2)}`
];
}
}
}
},
scales: {
x: {
min: dashboardTrendState.rb.fixedAxes.x.min,
max: dashboardTrendState.rb.fixedAxes.x.max,
title: { display: true, text: 'RB Opportunities per Game', color: getThemeColors().textSecondary, font: { size: 11 } },
grid: {
color: getThemeColors().grid,
drawTicks: true
},
ticks: {
color: getThemeColors().textSecondary,
font: { size: 10 },
stepSize: 2
}
},
y: {
min: dashboardTrendState.rb.fixedAxes.y.min,
max: dashboardTrendState.rb.fixedAxes.y.max,
title: { display: true, text: 'Points per Opportunity', color: getThemeColors().textSecondary, font: { size: 11 } },
grid: {
color: getThemeColors().grid,
drawTicks: true
},
ticks: {
color: getThemeColors().textSecondary,
font: { size: 10 },
stepSize: 0.2
}
}
}
},
plugins: [{
id: 'quadrantLines',
afterDatasetsDraw: (chart) => {
const ctx = chart.ctx;
const chartArea = chart.chartArea;
const xAxis = chart.scales.x;
const yAxis = chart.scales.y;
const xMid = dashboardTrendState.rb.medianX;
const yMid = dashboardTrendState.rb.medianY;
const isDark = !document.documentElement.getAttribute('data-theme') || document.documentElement.getAttribute('data-theme') === 'dark';
ctx.strokeStyle = isDark ? 'rgba(142, 142, 147, 0.5)' : 'rgba(90, 90, 90, 0.3)';
ctx.setLineDash([3, 3]);
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(xAxis.getPixelForValue(xMid), chartArea.top);
ctx.lineTo(xAxis.getPixelForValue(xMid), chartArea.bottom);
ctx.stroke();
ctx.beginPath();
ctx.moveTo(chartArea.left, yAxis.getPixelForValue(yMid));
ctx.lineTo(chartArea.right, yAxis.getPixelForValue(yMid));
ctx.stroke();
ctx.setLineDash([]);
ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
ctx.textAlign = 'center';
const xMidPixel = xAxis.getPixelForValue(xMid);
const yMidPixel = yAxis.getPixelForValue(yMid);
ctx.fillStyle = '#30d158';
ctx.fillText('ELITE', (xMidPixel + chartArea.right) / 2, (chartArea.top + yMidPixel) / 2 - 4);
ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
ctx.fillStyle = isDark ? '#8e8e93' : '#5a5a5a';
ctx.fillText('High Vol + Efficiency', (xMidPixel + chartArea.right) / 2, (chartArea.top + yMidPixel) / 2 + 8);
ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
ctx.fillStyle = '#0a84ff';
ctx.fillText('SLEEPER', (chartArea.left + xMidPixel) / 2, (chartArea.top + yMidPixel) / 2 - 4);
ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
ctx.fillStyle = isDark ? '#8e8e93' : '#5a5a5a';
ctx.fillText('Efficient, Low Vol', (chartArea.left + xMidPixel) / 2, (chartArea.top + yMidPixel) / 2 + 8);
ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
ctx.fillStyle = '#FFD60A';
ctx.fillText('HOLD', (xMidPixel + chartArea.right) / 2, (yMidPixel + chartArea.bottom) / 2 - 4);
ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
ctx.fillStyle = isDark ? '#8e8e93' : '#5a5a5a';
ctx.fillText('Volume, Poor Efficiency', (xMidPixel + chartArea.right) / 2, (yMidPixel + chartArea.bottom) / 2 + 8);
ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
ctx.fillStyle = '#ff453a';
ctx.fillText('FADE', (chartArea.left + xMidPixel) / 2, (yMidPixel + chartArea.bottom) / 2 - 4);
ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
ctx.fillStyle = isDark ? '#8e8e93' : '#5a5a5a';
ctx.fillText('Low Vol + Efficiency', (chartArea.left + xMidPixel) / 2, (yMidPixel + chartArea.bottom) / 2 + 8);
}
}]
});
}
function easeInOutCubic(t) {
return t < 0.5
? 4 * t * t * t
: 1 - Math.pow(-2 * t + 2, 3) / 2;
}
function interpolateTranchePlayers(trancheData, currentTranche, position) {
const medianX = dashboardTrendState[position].medianX;
const medianY = dashboardTrendState[position].medianY;
return trancheData.map(playerData => {
if (currentTranche === 0) {
return {
x: medianX,
y: medianY,
player: playerData.player
};
}
if (currentTranche < 1) {
const data1 = playerData.tranches.find(t => t.tranche === 1);
if (!data1) return null;
const t = easeInOutCubic(currentTranche); // Apply easing
return {
x: medianX + (data1.volume - medianX) * t,
y: medianY + (data1.efficiency - medianY) * t,
player: playerData.player
};
}
const tranche1 = Math.floor(currentTranche);
const tranche2 = Math.ceil(currentTranche);
const rawT = currentTranche - tranche1; // interpolation factor (0 to 1)
const t = easeInOutCubic(rawT); // Apply easing for smooth transitions
const data1 = playerData.tranches.find(t => t.tranche === tranche1);
const data2 = playerData.tranches.find(t => t.tranche === tranche2);
if (!data1 && !data2) return null;
if (!data2 || tranche1 === tranche2) {
return data1 ? {
x: data1.volume,
y: data1.efficiency,
player: playerData.player
} : null;
}
if (!data1) {
return {
x: data2.volume,
y: data2.efficiency,
player: playerData.player
};
}
return {
x: data1.volume + (data2.volume - data1.volume) * t,
y: data1.efficiency + (data2.efficiency - data1.efficiency) * t,
player: playerData.player
};
}).filter(d => d !== null);
}
function toggleDashboardTrend(positionParam) {
const position = positionParam === 'combined' ? dashboardTrendState.currentPosition : positionParam;
const state = dashboardTrendState[position];
if (state.isPlaying) {
state.isPlaying = false;
const btn = document.getElementById(`${position}-play-btn`);
btn.textContent = 'â–¶';
btn.classList.remove('playing');
return;
}
state.currentTranche = 0;
state.trails = {}; // Clear trails
state.lastPhase = 0; // Reset phase tracker
state.isPlaying = true;
const btn = document.getElementById(`${position}-play-btn`);
btn.textContent = 'â¸';
btn.classList.add('playing');
const scrubber = document.getElementById(`${position}-tranche-scrubber`);
scrubber.value = 0;
updateTrancheLabel(position, 0);
animateDashboardTrend(position);
}
function animateDashboardTrend(position) {
const state = dashboardTrendState[position];
if (!state.isPlaying) return;
state.currentTranche += 0.0325; // Slowed down by 35% for better visual clarity
if (state.currentTranche >= 3) {
state.currentTranche = 3;
state.isPlaying = false;
const btn = document.getElementById(`${position}-play-btn`);
btn.textContent = 'â–¶';
btn.classList.remove('playing');
}
const scrubber = document.getElementById(`${position}-tranche-scrubber`);
scrubber.value = state.currentTranche;
updateTrancheLabel(position, state.currentTranche);
if (position === 'wr') {
renderDashboardWRTrend();
} else {
renderDashboardRBTrend();
}
if (state.isPlaying) {
requestAnimationFrame(() => animateDashboardTrend(position));
}
}
function updateTrancheLabel(position, tranche) {
const label = document.getElementById(`${position}-tranche-label`);
if (!label) return;
let globalMaxWeek = 0;
const players = position === 'wr' ? aggregatedWRs : aggregatedRBs;
Object.values(players).forEach(player => {
if (player.weeks && player.weeks.length > 0) {
const maxWeek = Math.max(...player.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
if (tranche === 0) {
label.textContent = 'Start';
return;
}
if (tranche < 1) {
label.textContent = 'Start â†’ Weeks 1-3';
return;
}
const trancheNames = [
'Start', // 0
'Weeks 1-3', // 1
'Weeks 4-6', // 2
`Weeks 7-${globalMaxWeek}` // 3
];
if (tranche % 1 !== 0) {
const idx1 = Math.floor(tranche);
const idx2 = Math.ceil(tranche);
label.textContent = `${trancheNames[idx1]} â†’ ${trancheNames[idx2]}`;
} else {
const idx = Math.round(tranche);
label.textContent = trancheNames[idx] || trancheNames[3];
}
}
function setupDashboardTrendScrubbers() {
const wrScrubber = document.getElementById('wr-tranche-scrubber');
if (wrScrubber) {
wrScrubber.addEventListener('input', (e) => {
const tranche = parseFloat(e.target.value);
dashboardTrendState.wr.currentTranche = tranche;
dashboardTrendState.wr.isPlaying = false;
dashboardTrendState.wr.lastPhase = Math.floor(tranche); // Update phase tracker
const btn = document.getElementById('wr-play-btn');
btn.textContent = 'â–¶';
btn.classList.remove('playing');
updateTrancheLabel('wr', tranche);
renderDashboardWRTrend();
});
}
const rbScrubber = document.getElementById('rb-tranche-scrubber');
if (rbScrubber) {
rbScrubber.addEventListener('input', (e) => {
const tranche = parseFloat(e.target.value);
dashboardTrendState.rb.currentTranche = tranche;
dashboardTrendState.rb.isPlaying = false;
dashboardTrendState.rb.lastPhase = Math.floor(tranche); // Update phase tracker
const btn = document.getElementById('rb-play-btn');
btn.textContent = 'â–¶';
btn.classList.remove('playing');
updateTrancheLabel('rb', tranche);
renderDashboardRBTrend();
});
}
}
function renderDashboardCategories() {
const container = document.getElementById('dashboard-categories');
if (!container) { return;
}
const categories = calculateDashboardCategories();
if (!categories) { container.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 40px;">Loading categories...</p>';
return;
}
renderStatOfTheWeek();
renderDashboardCombinedTrend();
const categoryConfigs = [
{ key: 'volumeMonsters', title: 'Volume Monsters (RB)', color: '#ff453a', tooltip: 'RBs with the highest opportunities (carries + targets) per game in last 3 weeks. High volume = reliable fantasy production.' },
{ key: 'efficiencyElites', title: 'Efficiency Elites', color: '#FFD60A', tooltip: 'Players scoring the most fantasy points per touch in last 3 weeks. High efficiency = doing more with less. League-winner upside if volume increases.' },
{ key: 'redZoneKingsWR', title: 'Red Zone Kings (WR)', color: '#bf5af2', tooltip: 'WRs with the most red zone targets per game in last 3 weeks. More RZ targets = higher TD upside.' },
{ key: 'redZoneBacks', title: 'Red Zone Backs (RB)', color: '#ff453a', tooltip: 'RBs with the most red zone opportunities (carries + targets) per game in last 3 weeks. Dominant in scoring position.' },
{ key: 'rbEfficiency', title: 'RB Efficiency (Yds/Att)', color: '#30d158', tooltip: 'RBs with highest yards per carry in last 3 weeks. Explosive runners who maximize every touch.' },
{ key: 'consistentFloor', title: 'High-Volume Alphas (WR)', color: '#64d2ff', tooltip: 'WRs with the most targets per game in last 3 weeks. Commanding volume = alpha status in their offense.' },
{ key: 'airYardsLeaders', title: 'Air Yards Leaders (WR)', color: '#0a84ff', tooltip: 'WRs with highest air yards per game in last 3 weeks. Deep threats with explosive upside potential.' },
{ key: 'passCatchingBacks', title: 'Pass-Catching Backs (RB)', color: '#5e5ce6', tooltip: 'RBs with highest target share in last 3 weeks. PPR gold with receiving work in the passing game.' },
{ key: 'targetLeadersTE', title: 'Target Leaders (TE)', color: '#30d158', tooltip: 'TEs with the most targets per game in last 3 weeks. High volume = consistent TE production.' },
{ key: 'redZoneDominanceTE', title: 'Red Zone Dominance (TE)', color: '#bf5af2', tooltip: 'TEs with most red zone production in last 3 weeks. RZ Score = (RZ Targets + RZ TDs Ã— 3) per game. TDs weighted 3x because they\'re more valuable than targets.' },
{ key: 'totalTouchdownLeadersWR', title: 'Total TD Leaders (WR)', color: '#ff453a', tooltip: 'WRs scoring the most total touchdowns (receiving + rushing) in last 3 weeks. Elite scorers.' }
];
let html = '';
html += '<div class="categories-carousel-container">';
html += '<div class="categories-carousel-scroll" id="categories-carousel">';
let hasAnyData = false;
let categoriesHTML = ''; // Build categories first
categoryConfigs.forEach(config => {
const categoryData = categories[config.key];
if (!categoryData || categoryData.length === 0) { return;
}
hasAnyData = true;
categoriesHTML += `
<div class="category-carousel-item"><div class="category-header"><div class="category-title" style="position: relative;">
${config.title}
<div class="leaderboard-info-icon" onclick="toggleLeaderboardTooltip(event)">
i
<div class="leaderboard-tooltip">
${config.tooltip}
</div></div></div></div><div class="category-cards-container" id="category-${config.key}">
`;
categoryData.forEach((item, idx) => {
categoriesHTML += renderCategoryCard(item, config.color, config.key, config.title);
});
categoriesHTML += `
</div></div>
`;
});
html += categoriesHTML + categoriesHTML;
html += '</div>';
html += '</div>';
const categoryCount = categoryConfigs.filter(config => categories[config.key] && categories[config.key].length > 0).length;
html += '<div class="carousel-dots" id="carousel-dots">';
for (let i = 0; i < categoryCount; i++) {
html += `<div class="carousel-dot ${i === 0 ? 'active' : ''}" data-index="${i}"></div>`;
}
html += '</div>';
if (!hasAnyData) { container.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 40px;">No category data available. Please upload player data.</p>';
} else {
container.innerHTML = html;
initializeCarouselDots();
}
}
function initializeCarouselDots() {
const carouselContainer = document.querySelector('.categories-carousel-container');
const carousel = document.getElementById('categories-carousel');
const dots = document.querySelectorAll('.carousel-dot');
if (!carouselContainer || !carousel || dots.length === 0) return;
dots.forEach((dot, dotIndex) => {
dot.addEventListener('click', () => {
const itemWidth = carousel.querySelector('.category-carousel-item')?.offsetWidth || 0;
const gap = 20;
const scrollPosition = dotIndex * (itemWidth + gap);
carouselContainer.scrollTo({
left: scrollPosition,
behavior: 'smooth'
});
});
});
let scrollTimeout;
carouselContainer.addEventListener('scroll', () => {
clearTimeout(scrollTimeout);
scrollTimeout = setTimeout(() => {
const scrollLeft = carouselContainer.scrollLeft;
const itemWidth = carousel.querySelector('.category-carousel-item')?.offsetWidth || 0;
const gap = 20;
const currentIndex = Math.round(scrollLeft / (itemWidth + gap));
dots.forEach((dot, index) => {
if (index === currentIndex) {
dot.classList.add('active');
} else {
dot.classList.remove('active');
}
});
}, 50);
});
}
function renderAllLeaderboards() {
const container = document.getElementById('all-leaderboards-grid');
if (!container) { return;
}
const categories = calculateDashboardCategories();
if (!categories) { container.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 40px;">Loading categories...</p>';
return;
}
const categoryConfigs = [
{ key: 'volumeMonsters', title: 'Volume Monsters (RB)', color: '#ff453a', tooltip: 'RBs with the highest opportunities (carries + targets) per game in last 3 weeks.' },
{ key: 'consistentFloor', title: 'High-Volume Alphas (WR)', color: '#64d2ff', tooltip: 'WRs with the most targets per game in last 3 weeks.' },
{ key: 'redZoneKingsWR', title: 'Red Zone Kings (WR)', color: '#bf5af2', tooltip: 'WRs with the most red zone targets per game in last 3 weeks.' },
{ key: 'redZoneBacks', title: 'Red Zone Backs (RB)', color: '#ff453a', tooltip: 'RBs with the most red zone opportunities per game in last 3 weeks.' },
{ key: 'efficiencyElites', title: 'Efficiency Elites', color: '#FFD60A', tooltip: 'Players scoring the most fantasy points per touch in last 3 weeks.' },
{ key: 'rbEfficiency', title: 'RB Efficiency (Yds/Att)', color: '#30d158', tooltip: 'RBs with highest yards per carry in last 3 weeks.' },
{ key: 'airYardsLeaders', title: 'Air Yards Leaders (WR)', color: '#0a84ff', tooltip: 'WRs with highest air yards per game in last 3 weeks.' },
{ key: 'passCatchingBacks', title: 'Pass-Catching Backs (RB)', color: '#5e5ce6', tooltip: 'RBs with highest target share in last 3 weeks.' },
{ key: 'targetLeadersTE', title: 'Target Leaders (TE)', color: '#30d158', tooltip: 'TEs with the most targets per game in last 3 weeks.' },
{ key: 'redZoneDominanceTE', title: 'Red Zone Dominance (TE)', color: '#bf5af2', tooltip: 'TEs with most red zone production in last 3 weeks. RZ Score = (RZ Targets + RZ TDs Ã— 3) per game. TDs weighted 3x.' },
{ key: 'totalTouchdownLeadersWR', title: 'Total TD Leaders (WR)', color: '#ff453a', tooltip: 'WRs with the most total touchdowns (receiving + rushing) in last 3 weeks.' }
];
let html = '';
categoryConfigs.forEach(config => {
const categoryData = categories[config.key];
if (!categoryData || categoryData.length === 0) {
return;
}
html += `
<div style="background: var(--bg-secondary); border-radius: 12px; padding: 20px; border: 1px solid var(--border-color);"><div class="category-header" style="margin-bottom: 16px;"><div class="category-title" style="position: relative; font-size: 16px; font-weight: 700; color: var(--text-primary);">
${config.title}
<div class="leaderboard-info-icon" onclick="toggleLeaderboardTooltip(event)">
i
<div class="leaderboard-tooltip">
${config.tooltip}
</div></div></div></div><div style="display: grid; grid-template-columns: 1fr; gap: 8px;">
`;
const maxMetricValue = Math.max(...categoryData.map(item => parseFloat(item.metric) || 0));
categoryData.forEach((item, idx) => {
html += renderCompactCategoryCard(item, config.color, config.key, config.title, maxMetricValue);
});
html += `
</div></div>
`;
});
if (html === '') {
container.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 40px; grid-column: 1 / -1;">No leaderboard data available. Please upload player data.</p>';
} else {
container.innerHTML = `<div style="display: grid; grid-template-columns: repeat(auto-fit, minwidth(350px, 1fr)); gap: 24px; width: 100%;">${html}</div>`;
}
renderPPGLeaderboard('WR');
}
function renderPPGLeaderboard(position) {
const container = document.getElementById('ppg-leaderboard-content');
if (!container) return;
let players = [];
if (position === 'WR') {
players = Object.values(window.aggregatedWRs);
} else if (position === 'RB') {
players = Object.values(window.aggregatedRBs);
} else if (position === 'TE') {
players = Object.values(window.aggregatedTEs);
}
const topPlayers = players
.filter(p => p.gamesPlayed >= 3)
.sort((a, b) => b.avgPoints - a.avgPoints)
.slice(0, 20);
let html = '';
topPlayers.forEach((player, idx) => {
const teamColor = teamColors[player.team] || '#666';
const escapedId = player.id.replace(/'/g, "\\'");
const rank = idx + 1;
html += `
<div onclick="openPlayerModal('${escapedId}')" style="
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
border-radius: 8px;
padding: 12px;
display: flex;
align-items: center;
gap: 12px;
cursor: pointer;
transition: all 0.2s ease;
" onmouseover="this.style.borderColor='var(--positive)'" onmouseout="this.style.borderColor='var(--border-color)'"><div style="
font-size: 18px;
font-weight: 700;
color: var(--text-tertiary);
min-width: 32px;
text-align: center;
">#${rank}</div><div style="
background: ${teamColor};
color: white;
font-size: 10px;
font-weight: 700;
padding: 4px 6px;
border-radius: 4px;
min-width: 36px;
text-align: center;
">${player.team}</div><div style="flex: 1;"><div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${player.name}</div><div style="font-size: 11px; color: var(--text-tertiary);">${player.position} Â· ${player.gamesPlayed} GP</div></div><div style="text-align: right;"><div style="font-size: 18px; font-weight: 700; color: var(--positive);">${player.avgPoints.toFixed(1)}</div><div style="font-size: 10px; color: var(--text-tertiary);">PPG</div></div></div>
`;
});
container.innerHTML = html;
}
function filterPPGLeaderboard(position) {
document.querySelectorAll('.ppg-position-btn').forEach(btn => {
if (btn.dataset.position === position) {
btn.classList.add('active');
btn.style.background = 'var(--positive)';
btn.style.borderColor = 'var(--positive)';
btn.style.color = 'white';
} else {
btn.classList.remove('active');
btn.style.background = 'var(--bg-tertiary)';
btn.style.borderColor = 'var(--border-color)';
btn.style.color = 'var(--text-secondary)';
}
});
renderPPGLeaderboard(position);
}
function togglePRSFootnote() {
const content = document.getElementById('prs-footnote-content');
const icon = document.getElementById('prs-footnote-icon');
if (content.style.display === 'none') {
content.style.display = 'block';
icon.textContent = 'âœ•';
} else {
content.style.display = 'none';
icon.textContent = 'â“˜';
}
}
function calculatePRS(player, allPlayers) {
const usageShare = player.weeks.reduce((sum, w) => sum + (w.usageShare || 0), 0) / player.weeks.length;
const rzShare = player.weeks.reduce((sum, w) => sum + (w.rzShare || 0), 0) / player.weeks.length;
const maxGames = Math.max(...allPlayers.map(p => p.gamesPlayed));
const gamesPlayedPct = player.gamesPlayed / maxGames;
const usageValues = allPlayers.map(p => {
const avgUsage = p.weeks.reduce((sum, w) => sum + (w.usageShare || 0), 0) / p.weeks.length;
return avgUsage * p.avgPoints;
});
const minUsage = Math.min(...usageValues);
const maxUsage = Math.max(...usageValues);
const playerUsageScore = usageShare * player.avgPoints;
const usageNorm = maxUsage > minUsage ? (playerUsageScore - minUsage) / (maxUsage - minUsage) : 0;
const rzValues = allPlayers.map(p => {
const avgRZ = p.weeks.reduce((sum, w) => sum + (w.rzShare || 0), 0) / p.weeks.length;
return avgRZ * p.avgPoints;
});
const minRZ = Math.min(...rzValues);
const maxRZ = Math.max(...rzValues);
const playerRZScore = rzShare * player.avgPoints;
const rzNorm = maxRZ > minRZ ? (playerRZScore - minRZ) / (maxRZ - minRZ) : 0;
const floorReliabilityValues = allPlayers.map(p => {
let hitCount = 0;
let totalDiff = 0;
let validWeeks = 0;
p.weeks.forEach(w => {
if (w.expectedFpts > 0 && w.fpts !== undefined) {
const diff = w.fpts - w.expectedFpts;
const diffPct = diff / w.expectedFpts;
const threshold = p.avgPoints >= 14 ? -0.15 : -0.10;
if (diffPct >= threshold) hitCount++;
totalDiff += diffPct;
validWeeks++;
}
});
if (validWeeks === 0) return 0;
const hitRate = hitCount / validWeeks;
const avgDiffPct = totalDiff / validWeeks;
const expectedBonus = p.avgPoints >= 14 ? 0.15 : 0;
const diffComponent = Math.min(0.50, Math.max(0, avgDiffPct + 0.25));
return (0.60 * hitRate) + (0.40 * diffComponent) + expectedBonus;
});
const minFloor = Math.min(...floorReliabilityValues);
const maxFloor = Math.max(...floorReliabilityValues);
let consistencyNorm = 0;
let playerHitCount = 0;
let playerTotalDiff = 0;
let playerValidWeeks = 0;
player.weeks.forEach(w => {
if (w.expectedFpts > 0 && w.fpts !== undefined) {
const diff = w.fpts - w.expectedFpts;
const diffPct = diff / w.expectedFpts;
const threshold = player.avgPoints >= 14 ? -0.15 : -0.10;
if (diffPct >= threshold) playerHitCount++;
playerTotalDiff += diffPct;
playerValidWeeks++;
}
});
if (playerValidWeeks > 0) {
const playerHitRate = playerHitCount / playerValidWeeks;
const playerAvgDiffPct = playerTotalDiff / playerValidWeeks;
const playerExpectedBonus = player.avgPoints >= 14 ? 0.15 : 0;
const playerDiffComponent = Math.min(0.50, Math.max(0, playerAvgDiffPct + 0.25));
const playerFloorScore = (0.60 * playerHitRate) + (0.40 * playerDiffComponent) + playerExpectedBonus;
consistencyNorm = maxFloor > minFloor ? (playerFloorScore - minFloor) / (maxFloor - minFloor) : 0;
}
let prsRaw;
if (player.position === 'WR') {
prsRaw = (0.40 * usageNorm) + (0.20 * rzNorm) + (0.30 * consistencyNorm) + (0.10 * gamesPlayedPct);
} else {
prsRaw = (0.40 * usageNorm) + (0.30 * rzNorm) + (0.20 * consistencyNorm) + (0.10 * gamesPlayedPct);
}
return Math.round(prsRaw * 100);
}
function renderPRSLeaderboard(position) {
const container = document.getElementById('prs-leaderboard-content');
if (!container) return;
let players = [];
if (position === 'WR') {
players = Object.values(window.aggregatedWRs);
} else if (position === 'RB') {
players = Object.values(window.aggregatedRBs);
} else if (position === 'TE') {
players = Object.values(window.aggregatedTEs);
}
const eligiblePlayers = players.filter(p => p.gamesPlayed >= 3);
const playersWithPRS = eligiblePlayers.map(player => ({
...player,
prs: calculatePRS(player, eligiblePlayers)
}));
const topPlayers = playersWithPRS
.sort((a, b) => b.prs - a.prs)
.slice(0, 20);
let html = '';
topPlayers.forEach((player, idx) => {
const teamColor = teamColors[player.team] || '#666';
const escapedId = player.id.replace(/'/g, "\\'");
const rank = idx + 1;
const prs = player.prs;
let prsColor = '#30d158'; // Green
if (prs < 60) prsColor = '#ff453a'; // Red
else if (prs < 75) prsColor = '#FFD60A'; // Yellow
html += `
<div onclick="openPlayerModal('${escapedId}')" style="
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
border-radius: 8px;
padding: 12px;
display: flex;
align-items: center;
gap: 12px;
cursor: pointer;
transition: all 0.2s ease;
" onmouseover="this.style.borderColor='var(--positive)'" onmouseout="this.style.borderColor='var(--border-color)'"><div style="
font-size: 16px;
font-weight: 700;
color: var(--text-tertiary);
min-width: 28px;
text-align: center;
">#${rank}</div><div style="
background: ${teamColor};
color: white;
font-size: 10px;
font-weight: 700;
padding: 4px 6px;
border-radius: 4px;
min-width: 36px;
text-align: center;
">${player.team}</div><div style="flex: 1; min-width: 0;"><div style="font-size: 13px; font-weight: 600; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${player.name}</div><div style="font-size: 10px; color: var(--text-tertiary);">${player.avgPoints.toFixed(1)} PPG Â· ${player.gamesPlayed} GP</div></div><div style="text-align: right;"><div style="font-size: 18px; font-weight: 700; color: ${prsColor};">${prs.toFixed(1)}</div><div style="font-size: 9px; color: var(--text-tertiary);">PRS</div></div></div>
`;
});
container.innerHTML = html;
}
function filterPRSLeaderboard(position) {
document.querySelectorAll('.prs-position-btn').forEach(btn => {
if (btn.dataset.position === position) {
btn.classList.add('active');
btn.style.background = 'var(--positive)';
btn.style.borderColor = 'var(--positive)';
btn.style.color = 'white';
} else {
btn.classList.remove('active');
btn.style.background = 'var(--bg-tertiary)';
btn.style.borderColor = 'var(--border-color)';
btn.style.color = 'var(--text-secondary)';
}
});
renderPRSLeaderboard(position);
}
async function loadPlayerSchedule(team, position) {
const container = document.getElementById('modal-schedule-chart-content');
if (!container) return;
let scheduleHTML = `
<div class="schedule-list">
`;
for (let week = 11; week <= 18; week++) {
const scheduleData = NFL_SCHEDULE_2025[team]?.[week];
if (!scheduleData) continue;
const opponent = scheduleData.opponent;
const isHome = scheduleData.home;
if (opponent === 'BYE') {
scheduleHTML += `
<div class="schedule-row bye-week"><div class="week-info"><div class="week-label">Week</div><div class="week-number">${week}</div></div><div class="matchup-info"><div class="opponent-line"><span class="opponent-team">BYE WEEK</span></div></div><div class="defense-rank"><div class="rank-label">â€”</div><div class="rank-value" style="background: transparent; border: none; color: #8e8e93;">â€”</div></div><div class="defense-rank"><div class="rank-label">â€”</div><div class="rank-value" style="background: transparent; border: none; color: #8e8e93;">â€”</div></div></div>
`;
continue;
}
const vsPositionRank = getVsPositionRank(opponent, position);
const passOrRushRank = (position === 'RB') ? getRushDefenseRank(opponent) : getPassDefenseRank(opponent);
const vsPositionClass = getDefenseRankClass(vsPositionRank, 'position');
const passOrRushClass = getDefenseRankClass(passOrRushRank, position === 'RB' ? 'rush' : 'pass');
const vsPositionTooltip = getRankTooltip(vsPositionRank, 'position', position);
const passOrRushTooltip = getRankTooltip(passOrRushRank, position === 'RB' ? 'rush' : 'pass');
scheduleHTML += `
<div class="schedule-row"><div style="display: flex; align-items: center; justify-content: space-between; width: 100%;"><div class="week-info"><div class="week-label">Week</div><div class="week-number">${week}</div></div><div class="matchup-info"><div class="opponent-line"><span class="vs-label">${isHome ? 'vs' : '@'}</span><span class="opponent-team">${opponent}</span></div></div></div><div class="mobile-defense-ranks"><span class="mobile-rank ${vsPositionClass}">vs ${position}: ${vsPositionRank}${getOrdinal(vsPositionRank)}</span><span class="mobile-rank-separator">â€¢</span><span class="mobile-rank ${passOrRushClass}">${position === 'RB' ? 'Rush' : 'Pass'} D: ${passOrRushRank}${getOrdinal(passOrRushRank)}</span></div><div class="defense-rank desktop-only"><div class="rank-label">
vs ${position}
<span class="info-icon">i</span></div><div class="rank-value ${vsPositionClass}">${vsPositionRank}${getOrdinal(vsPositionRank)}</div><div class="rank-tooltip"><div class="tooltip-title">Defense vs ${position}</div><div class="tooltip-text">${vsPositionTooltip}</div></div></div><div class="defense-rank desktop-only"><div class="rank-label">
${position === 'RB' ? 'Rush D' : 'Pass D'}
<span class="info-icon">i</span></div><div class="rank-value ${passOrRushClass}">${passOrRushRank}${getOrdinal(passOrRushRank)}</div><div class="rank-tooltip"><div class="tooltip-title">${position === 'RB' ? 'Rush Defense Rank' : 'Pass Defense Rank'}</div><div class="tooltip-text">${passOrRushTooltip}</div></div></div></div>
`;
}
scheduleHTML += `
</div>
`;
container.innerHTML = scheduleHTML;
}
function renderCompactCategoryCard(item, color, categoryKey, categoryTitle, maxMetricValue) {
const player = item.player;
const teamColor = teamColors[player.team] || '#666';
const escapedId = player.id.replace(/'/g, "\\'");
const escapedCategory = (categoryTitle || '').replace(/'/g, "\\'");
const escapedExplanation = (item.explanation || '').replace(/'/g, "\\'");
const metricValue = parseFloat(item.metric) || 0;
const barWidthPercent = maxMetricValue > 0 ? (metricValue / maxMetricValue) * 100 : 0;
const change = parseFloat(item.change || 0);
const changeClass = change > 0 ? 'comparison-up' : change < 0 ? 'comparison-down' : '';
const changeIcon = change > 0 ? 'â–²' : change < 0 ? 'â–¼' : '';
const showChange = Math.abs(change) >= 0.1; // Only show if change is meaningful
return `
<div class="compact-player-card" onclick="openPlayerModalWithCategory('${escapedId}', '${escapedCategory}', '${escapedExplanation}', '${item.rank}', '${item.metricLabel}', '${item.metric}')" style="
background: var(--bg-tertiary);
border: 1px solid var(--border-color);
border-radius: 8px;
padding: 10px 14px;
display: flex;
align-items: center;
gap: 12px;
cursor: pointer;
transition: all 0.2s ease;
"><div style="
background: ${teamColor};
color: white;
font-size: 10px;
font-weight: 700;
padding: 4px 6px;
border-radius: 4px;
min-width: 32px;
text-align: center;
">${player.team}</div><div style="
flex: 1;
display: flex;
flex-direction: column;
gap: 4px;
"><div style="
font-size: 13px;
font-weight: 600;
color: var(--text-primary);
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
">${player.name}</div><div class="metric-bar-container" style="width: 150px;"><div class="metric-bar" style="width: ${barWidthPercent}%; background: ${teamColor};"></div></div></div><div style="
font-size: 11px;
color: var(--text-tertiary);
min-width: 24px;
">${player.position}</div><div style="
font-size: 13px;
color: var(--text-secondary);
min-width: 28px;
text-align: center;
">#${item.rank}</div><div style="
display: flex;
align-items: center;
gap: 6px;
position: relative;
"><span class="compact-metric-value"
style="
font-size: 14px;
font-weight: 700;
color: var(--text-primary);
position: relative;
">
${item.metric}
</span>
${showChange ? `
<span class="player-comparison ${changeClass}" style="
display: flex;
align-items: center;
gap: 2px;
font-size: 11px;
white-space: nowrap;
position: relative;
"><span class="comparison-icon">${changeIcon}</span>
${Math.abs(change).toFixed(item.metric.includes('.') && item.metric.split('.')[1].length > 1 ? 2 : 1)}
<span class="change-tooltip" style="
position: absolute;
bottom: 100%;
right: 0;
transform: translateY(0);
margin-bottom: 8px;
background: var(--bg-elevated);
border: 1px solid var(--border-color-light);
border-radius: 8px;
padding: 8px 12px;
font-size: 10px;
white-space: nowrap;
opacity: 0;
pointer-events: none;
transition: opacity 0.2s ease;
z-index: 2001;
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
">vs prior 3 weeks</span></span>
` : `
<span style="
display: flex;
align-items: center;
gap: 2px;
font-size: 11px;
color: var(--text-tertiary);
min-width: 40px;
justify-content: center;
">â€”</span>
`}
</div></div>
`;
}
function scrollCategories(direction) {
const carousel = document.getElementById('categories-carousel');
if (!carousel) return;
carousel.style.animation = 'none';
const scrollAmount = carousel.offsetWidth / 2; // Scroll by width of 2 items
if (direction === 1) {
carousel.scrollLeft += scrollAmount;
} else {
carousel.scrollLeft -= scrollAmount;
}
setTimeout(() => {
carousel.style.animation = '';
}, 500);
}
function renderCategoryCard(item, color, categoryKey, categoryTitle) {
const player = item.player;
const teamColor = teamColors[player.team] || '#666';
const escapedId = player.id.replace(/'/g, "\\'");
const escapedCategory = (categoryTitle || '').replace(/'/g, "\\'");
const escapedExplanation = (item.explanation || '').replace(/'/g, "\\'");
const change = parseFloat(item.change || 0);
const changeClass = change > 0 ? 'comparison-up' : change < 0 ? 'comparison-down' : '';
const changeIcon = change > 0 ? 'â–²' : change < 0 ? 'â–¼' : '';
const showChange = Math.abs(change) >= 0.1; // Only show if change is meaningful
let tooltipText = '';
if (item.metricLabel.includes('Opps/Game')) {
tooltipText = `Average opportunities (rush attempts + targets) per game in last 3 weeks. Change vs weeks 4-6 back.`;
} else if (item.metricLabel.includes('Pts/Tgt')) {
tooltipText = `Fantasy points per target in last 3 weeks. Higher = more efficient. Change vs weeks 4-6 back.`;
} else if (item.metricLabel.includes('Pts/Opp')) {
tooltipText = `Fantasy points per opportunity in last 3 weeks. Higher = more efficient. Change vs weeks 4-6 back.`;
} else if (item.metricLabel.includes('RZ')) {
tooltipText = `Red zone opportunities per game in last 3 weeks. More = higher TD potential. Change vs weeks 4-6 back.`;
} else if (item.metricLabel.includes('Tgt/Game') || item.metricLabel.includes('Tgt/G')) {
tooltipText = `Average targets per game in last 3 weeks. Higher = more consistent volume. Change vs weeks 4-6 back.`;
} else if (item.metricLabel.includes('Yds/Att')) {
tooltipText = `Yards per carry in last 3 weeks. Higher = more explosive running. Change vs weeks 4-6 back.`;
} else if (item.metricLabel.includes('Air Yds')) {
tooltipText = `Air yards (depth of target) per game in last 3 weeks. Higher = deep threat. Change vs weeks 4-6 back.`;
} else if (item.metricLabel.includes('Tgt Share')) {
tooltipText = `Target share percentage in last 3 weeks. Higher = more passing game involvement. Change vs weeks 4-6 back.`;
} else {
tooltipText = `${item.metricLabel} in last 3 weeks. Change vs weeks 4-6 back.`;
}
let mainStatTooltip = '';
if (item.metricLabel.includes('Opps/Game')) {
mainStatTooltip = 'Opportunities per game (Rush Att + Targets)';
} else if (item.metricLabel.includes('Pts/Tgt')) {
mainStatTooltip = 'Fantasy points per target';
} else if (item.metricLabel.includes('Pts/Opp')) {
mainStatTooltip = 'Fantasy points per opportunity';
} else if (item.metricLabel.includes('RZ')) {
mainStatTooltip = 'Red zone opportunities per game';
} else if (item.metricLabel.includes('Tgt/Game') || item.metricLabel.includes('Tgt/G')) {
mainStatTooltip = 'Targets per game';
} else if (item.metricLabel.includes('Yds/Att')) {
mainStatTooltip = 'Yards per carry';
} else if (item.metricLabel.includes('Air Yds')) {
mainStatTooltip = 'Air yards per game';
} else if (item.metricLabel.includes('Tgt Share')) {
mainStatTooltip = 'Target share %';
} else {
mainStatTooltip = `${item.metricLabel} (Avg Last 3 games)`;
}
return `
<div class="player-card" onclick="openPlayerModalWithCategory('${escapedId}', '${escapedCategory}', '${escapedExplanation}', '${item.rank}', '${item.metricLabel}', '${item.metric}')"><div class="player-card-header" style="margin-bottom: 0;"><div class="category-rank-simple" style="margin-right: 12px;">#${item.rank}</div><div class="player-card-badge" style="background: ${teamColor};">
${player.team}
</div><div style="flex: 1; display: flex; flex-direction: column; gap: 2px;"><div class="player-card-name">${player.name}</div><div class="player-card-team">${player.position}</div></div><div style="display: flex; align-items: center; gap: 4px; position: relative;"><span class="player-stat-value" style="white-space: nowrap; font-size: 12px; font-weight: 700;">
${item.metric}
</span>
${showChange ? `
<span class="player-comparison ${changeClass}" style="white-space: nowrap; font-size: 12px;"><span class="comparison-icon">${changeIcon}</span>
${Math.abs(change).toFixed(item.metric.includes('.') && item.metric.split('.')[1].length > 1 ? 2 : 1)}
</span>
` : ''}
</div></div></div>
`;
}
function toggleFootnote() {
const content = document.getElementById('footnote-content');
const icon = document.getElementById('footnote-icon');
if (content.style.display === 'none') {
content.style.display = 'block';
icon.textContent = 'âœ•';
} else {
content.style.display = 'none';
icon.textContent = 'â“˜';
}
}
function renderMiniScatterPlots() {
document.querySelectorAll('.category-card-chart canvas').forEach(canvas => {
if (!canvas.id) return;
const ctx = canvas.getContext('2d');
if (!ctx) return;
canvas.width = canvas.offsetWidth;
canvas.height = 100;
const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
gradient.addColorStop(0, 'rgba(48, 209, 88, 0.1)');
gradient.addColorStop(1, 'rgba(10, 132, 255, 0.1)');
ctx.fillStyle = gradient;
ctx.fillRect(0, 0, canvas.width, canvas.height);
ctx.strokeStyle = 'rgba(48, 209, 88, 0.5)';
ctx.lineWidth = 2;
ctx.beginPath();
ctx.moveTo(0, canvas.height * 0.7);
ctx.lineTo(canvas.width * 0.5, canvas.height * 0.4);
ctx.lineTo(canvas.width, canvas.height * 0.3);
ctx.stroke();
});
}
let advancedScatterChart = null;
let highlightedPlayerIds = []; // Now supports up to 2 players
let selectedWeekRange = 'all';
let advancedCurrentPosition = 'RB';
let isChangingPosition = false; // Prevent recursive position changes
let currentQuadrantExplanation = '';
let advancedPlayerCount = 50; // Default: show top 50 players
let scatterUpdateTimeout = null; // Debounce timer for chart updates to prevent freezing
const scatterPresets = {
WR: [
{
name: 'Volume vs Efficiency',
xAxis: 'targets',
yAxis: 'catch_rate',
description: 'High-volume receivers with strong catch rates',
quadrantExplanation: 'Top-right = High volume + reliable hands. Bottom-right = Volume without efficiency. Top-left = Efficient but limited opportunities.'
},
{
name: 'Volume vs Production',
xAxis: 'targets',
yAxis: 'fantasy_points',
description: 'Target share translating to fantasy points',
quadrantExplanation: 'Top-right = Elite fantasy assets (volume + production). Bottom-right = High volume underperformers. Top-left = Efficient scorers with limited volume.'
},
{
name: 'Target Share vs Production',
xAxis: 'target_share',
yAxis: 'fantasy_points',
description: 'Team involvement vs fantasy output',
quadrantExplanation: 'Top-right = Offensive centerpieces. Bottom-right = High target share not converting. Top-left = Boom/bust players or red zone specialists.'
},
{
name: 'Red Zone Usage',
xAxis: 'rz_targets',
yAxis: 'fantasy_points',
description: 'Red zone opportunities vs scoring',
quadrantExplanation: 'Top-right = TD-dependent scorers. Bottom-right = Red zone targets not converting. Top-left = Yardage-based scorers with limited red zone work.'
},
{
name: 'More with Less',
xAxis: 'targets',
yAxis: 'receiving_yards',
description: 'Target efficiency and big-play ability',
quadrantExplanation: 'Top-right = High volume + yards. Top-left = Explosive playmakers doing more with fewer touches. Bottom-right = Volume without yards.'
},
{
name: 'Team Dominance',
xAxis: 'target_share',
yAxis: 'team_points',
description: 'Target share in high/low-scoring offenses',
quadrantExplanation: 'Top-right = Alpha WRs on elite offenses. Bottom-right = Dominant share on bad offenses. Top-left = Supporting cast on great offenses.'
}
],
RB: [
{
name: 'Talent Indicator',
xAxis: 'ybc_per_att',
yAxis: 'yac_per_att',
description: 'Vision vs power/elusiveness',
quadrantExplanation: 'Top-right = Elite talent (vision + contact balance). Bottom-right = Great vision, poor after contact. Top-left = Contact breakers relying on line.'
},
{
name: 'Volume vs Production',
xAxis: 'opportunities',
yAxis: 'fantasy_points',
description: 'Opportunity share vs fantasy output',
quadrantExplanation: 'Top-right = Workhorse RBs producing. Bottom-right = High volume underperformers. Top-left = Efficient, limited-touch backs.'
},
{
name: 'Red Zone Usage',
xAxis: 'rz_opportunities',
yAxis: 'fantasy_points',
description: 'Red zone touches vs scoring',
quadrantExplanation: 'Top-right = Goal-line backs. Bottom-right = Red zone work not converting. Top-left = Yardage scorers with limited red zone role.'
},
{
name: 'Carries vs Opportunities',
xAxis: 'carries',
yAxis: 'opportunities',
description: 'Rushing role vs total touches',
quadrantExplanation: 'Top-right = Three-down backs (high carries + targets). Bottom-right = Pure rushers with minimal pass work. Top-left = Pass-catching specialists.'
},
{
name: 'Rushing Efficiency',
xAxis: 'carries',
yAxis: 'rushing_yards',
description: 'Rushing volume vs yards produced',
quadrantExplanation: 'Top-right = Bell-cow rushers. Bottom-right = High volume, low efficiency. Top-left = Explosive runners with limited carries.'
},
{
name: 'Team Context',
xAxis: 'opportunities',
yAxis: 'team_points',
description: 'Workload in high/low-scoring offenses',
quadrantExplanation: 'Top-right = Lead backs on elite offenses. Bottom-right = Workhorse on bad offenses. Top-left = Committee backs on great offenses.'
}
],
TE: [
{
name: 'Volume vs Efficiency',
xAxis: 'targets',
yAxis: 'catch_rate',
description: 'High-volume tight ends with strong catch rates',
quadrantExplanation: 'Top-right = High volume + reliable hands. Bottom-right = Volume without efficiency. Top-left = Efficient but limited opportunities.'
},
{
name: 'Volume vs Production',
xAxis: 'targets',
yAxis: 'fantasy_points',
description: 'Target share translating to fantasy points',
quadrantExplanation: 'Top-right = Elite fantasy assets (volume + production). Bottom-right = High volume underperformers. Top-left = Efficient scorers with limited volume.'
},
{
name: 'Target Share vs Production',
xAxis: 'target_share',
yAxis: 'fantasy_points',
description: 'Team involvement vs fantasy output',
quadrantExplanation: 'Top-right = Offensive centerpieces. Bottom-right = High target share not converting. Top-left = Boom/bust players or red zone specialists.'
},
{
name: 'Red Zone Usage',
xAxis: 'rz_targets',
yAxis: 'fantasy_points',
description: 'Red zone opportunities vs scoring',
quadrantExplanation: 'Top-right = TD-dependent scorers. Bottom-right = Red zone targets not converting. Top-left = Yardage-based scorers with limited red zone work.'
},
{
name: 'More with Less',
xAxis: 'targets',
yAxis: 'receiving_yards',
description: 'Target efficiency and big-play ability',
quadrantExplanation: 'Top-right = High volume + yards. Top-left = Explosive playmakers doing more with fewer touches. Bottom-right = Volume without yards.'
},
{
name: 'Team Dominance',
xAxis: 'target_share',
yAxis: 'team_points',
description: 'Target share in high/low-scoring offenses',
quadrantExplanation: 'Top-right = Alpha TEs on elite offenses. Bottom-right = Dominant share on bad offenses. Top-left = Supporting cast on great offenses.'
}
]
};
function filterPlayerSearch() {
const input = document.getElementById('player-search-input');
const searchTerm = input.value.toLowerCase().trim();
const dropdown = document.getElementById('player-search-dropdown');
if (searchTerm.length === 0) {
dropdown.style.display = 'none';
return;
}
const players = Object.values(allPlayers).filter(p =>
p.position === advancedCurrentPosition && p.gamesPlayed >= 3
);
const matches = players.filter(p =>
p.name.toLowerCase().includes(searchTerm)
).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 10);
if (matches.length === 0) {
dropdown.innerHTML = '<div style="padding: 12px; color: var(--text-secondary); font-size: 13px;">No players found</div>';
dropdown.style.display = 'block';
return;
}
let html = '';
matches.forEach(player => {
html += `
<div onclick="selectPlayerHighlight('${player.id.replace(/'/g, "\\'")}', '${player.name.replace(/'/g, "\\'")}', '${player.team}')"
style="padding: 10px 12px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-color); transition: background 0.2s;"
onmouseover="this.style.background='var(--bg-tertiary)'"
onmouseout="this.style.background='transparent'"><div><div style="font-weight: 600; color: var(--text-primary); font-size: 13px;">${player.name}</div><div style="font-size: 11px; color: var(--text-secondary);">${player.team} Â· ${player.avgPoints.toFixed(1)} PPG</div></div><div style="width: 24px; height: 24px; border-radius: 4px; background: ${teamColors[player.team] || '#666'}; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: 700; color: white;">
${player.team}
</div></div>
`;
});
dropdown.innerHTML = html;
dropdown.style.display = 'block';
}
function showPlayerSearchDropdown() {
const input = document.getElementById('player-search-input');
const dropdown = document.getElementById('player-search-dropdown');

// Position dropdown below the input
const rect = input.getBoundingClientRect();
dropdown.style.position = 'fixed';
dropdown.style.left = rect.left + 'px';
dropdown.style.top = (rect.bottom + 4) + 'px';
dropdown.style.width = rect.width + 'px';

if (input.value.length > 0) {
filterPlayerSearch();
}
}
function selectPlayerHighlight(playerId, playerName, team) {
if (highlightedPlayerIds.includes(playerId)) {
return; // Don't add duplicates
}
if (highlightedPlayerIds.length < 4) {
highlightedPlayerIds.push(playerId);
} else {
highlightedPlayerIds.shift();
highlightedPlayerIds.push(playerId);
}
updateSelectedPlayersDisplay();
const input = document.getElementById('player-search-input');
input.value = '';
const dropdown = document.getElementById('player-search-dropdown');
dropdown.style.display = 'none';
const clearBtn = document.getElementById('clear-player-btn');
clearBtn.style.display = highlightedPlayerIds.length > 0 ? 'block' : 'none';
updateAdvancedScatter();
}
function updateSelectedPlayersDisplay() {
const container = document.getElementById('selected-players-container');
if (highlightedPlayerIds.length === 0) {
container.style.display = 'none';
return;
}
container.style.display = 'flex';
let html = '';
highlightedPlayerIds.forEach((playerId, index) => {
const player = allPlayers[playerId];
if (player) {
html += `
<div style="
display: flex;
align-items: center;
gap: 6px;
padding: 4px 8px;
background: var(--bg-elevated);
border: 2px solid #fff;
border-radius: 6px;
font-size: 12px;
font-weight: 600;
"><span>${player.name} (${player.team})</span><button onclick="removePlayerHighlight('${playerId}')" style="
background: transparent;
border: none;
color: var(--text-secondary);
cursor: pointer;
font-size: 16px;
padding: 0;
width: 16px;
height: 16px;
line-height: 1;
display: flex;
align-items: center;
justify-content: center;
">Ã—</button></div>
`;
}
});
container.innerHTML = html;
}
function removePlayerHighlight(playerId) {
highlightedPlayerIds = highlightedPlayerIds.filter(id => id !== playerId);
updateSelectedPlayersDisplay();
const clearBtn = document.getElementById('clear-player-btn');
clearBtn.style.display = highlightedPlayerIds.length > 0 ? 'block' : 'none';
updateAdvancedScatter();
}
function clearPlayerHighlight() {
highlightedPlayerIds = [];
const input = document.getElementById('player-search-input');
input.value = '';
updateSelectedPlayersDisplay();
const clearBtn = document.getElementById('clear-player-btn');
clearBtn.style.display = 'none';
const dropdown = document.getElementById('player-search-dropdown');
dropdown.style.display = 'none';
updateAdvancedScatter();
}
document.addEventListener('click', function(e) {
const input = document.getElementById('player-search-input');
const dropdown = document.getElementById('player-search-dropdown');
if (input && dropdown && !input.contains(e.target) && !dropdown.contains(e.target)) {
dropdown.style.display = 'none';
}
});
function getWeekFilteredData(player, weekRange) {
if (weekRange === 'all') {
return player.weeks;
}
let globalMaxWeek = 0;
Object.values(allPlayers).forEach(p => {
if (p.weeks && p.weeks.length > 0) {
const maxWeek = Math.max(...p.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
if (weekRange === 'last3') {
const targetWeeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
return player.weeks.filter(w => targetWeeks.includes(w.week));
} else if (weekRange === 'last5') {
const targetWeeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2, globalMaxWeek - 3, globalMaxWeek - 4];
return player.weeks.filter(w => targetWeeks.includes(w.week));
} else if (weekRange.includes('-')) {
const [start, end] = weekRange.split('-').map(Number);
return player.weeks.filter(w => w.week >= start && w.week <= end);
} else if (!isNaN(weekRange)) {
return player.weeks.filter(w => w.week == weekRange);
}
return player.weeks;
}
function populatePresetButtons() {
const container = document.getElementById('preset-buttons-container');
if (!container) return;
const presets = scatterPresets[advancedCurrentPosition];
const xSelect = document.getElementById('x-axis-select');
const ySelect = document.getElementById('y-axis-select');
const currentX = xSelect ? xSelect.value : '';
const currentY = ySelect ? ySelect.value : '';

container.innerHTML = presets.map(preset => {
    const isActive = preset.xAxis === currentX && preset.yAxis === currentY;
    return `
    <button class="preset-btn ${isActive ? 'active' : ''}" 
            onclick="applyPreset('${preset.xAxis}', '${preset.yAxis}')" 
            data-x="${preset.xAxis}" 
            data-y="${preset.yAxis}"
            title="${preset.description}">
    ${preset.name}
    </button>
    `;
}).join('');
}
function applyPreset(xAxis, yAxis) {
const xSelect = document.getElementById('x-axis-select');
const ySelect = document.getElementById('y-axis-select');
if (xSelect && ySelect) {
xSelect.value = xAxis;
ySelect.value = yAxis;
const presets = scatterPresets[advancedCurrentPosition];
const preset = presets.find(p => p.xAxis === xAxis && p.yAxis === yAxis);
currentQuadrantExplanation = preset ? preset.quadrantExplanation : '';

// Update active state on preset buttons
document.querySelectorAll('.preset-btn').forEach(btn => {
    const btnX = btn.getAttribute('data-x');
    const btnY = btn.getAttribute('data-y');
    if (btnX === xAxis && btnY === yAxis) {
        btn.classList.add('active');
    } else {
        btn.classList.remove('active');
    }
});

updateAdvancedScatter();
}
}
const advancedStatDefinitions = {
WR: [
{
id: 'fantasy_points',
label: 'Fantasy Points per Game',
calculate: (player) => player.avgPoints || 0
},
{
id: 'points_per_target',
label: 'Points per Target',
calculate: (player) => {
const targetsPerGame = player.totalTargets / player.gamesPlayed;
return targetsPerGame > 0 ? player.avgPoints / targetsPerGame : 0;
}
},
{
id: 'targets',
label: 'Targets per Game',
calculate: (player) => player.totalTargets / player.gamesPlayed
},
{
id: 'receptions',
label: 'Receptions per Game',
calculate: (player) => player.totalRec / player.gamesPlayed
},
{
id: 'receiving_yards',
label: 'Receiving Yards per Game',
calculate: (player) => player.totalYDS / player.gamesPlayed
},
{
id: 'catch_rate',
label: 'Catch Rate (%)',
calculate: (player) => player.catchRate || 0
},
{
id: 'target_share',
label: 'Target Share (%)',
calculate: (player) => {
if (!player.weeks || player.weeks.length === 0) return 0;
const totalShare = player.weeks.reduce((sum, w) => sum + (w.teamShare || 0), 0);
return totalShare / player.weeks.length;
}
},
{
id: 'rz_targets',
label: 'Red Zone Targets per Game',
calculate: (player) => (player.rzOpportunities || 0) / player.gamesPlayed
},
{
id: 'air_yards',
label: 'Air Yards per Game',
calculate: (player) => player.airYardsPerGame || 0
},
{
id: 'yac_per_rec',
label: 'Yards After Catch per Reception',
calculate: (player) => player.yacPerRec || 0
},
{
id: 'team_points',
label: 'Team Points per Game',
calculate: (player) => {
if (!teamStats || !teamStats[player.team]) return 0;
return teamStats[player.team].avgPoints || 0;
}
},
{
id: 'receiving_tds',
label: 'Receiving TDs per Game',
calculate: (player) => (player.totalRecTDs || 0) / player.gamesPlayed
},
{
id: 'rushing_tds',
label: 'Rushing TDs per Game',
calculate: (player) => (player.totalRushTDs || 0) / player.gamesPlayed
},
{
id: 'total_tds',
label: 'Total TDs per Game',
calculate: (player) => ((player.totalRecTDs || 0) + (player.totalRushTDs || 0)) / player.gamesPlayed
},
{
id: 'rz_tds',
label: 'Red Zone TDs per Game',
calculate: (player) => (player.rzTDs || 0) / player.gamesPlayed
},
{
id: 'yards_per_touch',
label: 'Yards per Touch',
calculate: (player) => {
const totalYards = (player.totalYDS || 0) + (player.totalRushYards || 0);
const totalTouches = (player.totalRec || 0) + (player.totalCarries || 0);
return totalTouches > 0 ? totalYards / totalTouches : 0;
}
},
{
id: 'td_rate',
label: 'TD Rate (per Touch)',
calculate: (player) => {
const totalTDs = (player.totalRecTDs || 0) + (player.totalRushTDs || 0);
const totalTouches = (player.totalRec || 0) + (player.totalCarries || 0);
return totalTouches > 0 ? (totalTDs / totalTouches) * 100 : 0;
}
},
{
id: 'total_yards',
label: 'Total Yards per Game',
calculate: (player) => {
const totalYards = (player.totalYDS || 0) + (player.totalRushYards || 0);
return totalYards / player.gamesPlayed;
}
},
{
id: 'rushing_yards',
label: 'Rushing Yards per Game',
calculate: (player) => (player.totalRushYards || 0) / player.gamesPlayed
}
],
RB: [
{
id: 'fantasy_points',
label: 'Fantasy Points per Game',
calculate: (player) => player.avgPoints || 0
},
{
id: 'points_per_opportunity',
label: 'Points per Opportunity',
calculate: (player) => {
const oppsPerGame = player.totalOpportunities / player.gamesPlayed;
return oppsPerGame > 0 ? player.avgPoints / oppsPerGame : 0;
}
},
{
id: 'opportunities',
label: 'Opportunities per Game',
calculate: (player) => player.totalOpportunities / player.gamesPlayed
},
{
id: 'rushing_yards',
label: 'Rushing Yards per Game',
calculate: (player) => (player.totalRushYards || 0) / player.gamesPlayed
},
{
id: 'ybc_per_att',
label: 'Yards Before Contact per Att',
calculate: (player) => {
const carries = player.totalCarries || 0;
return carries > 0 ? (player.totalYBCON || 0) / carries : 0;
}
},
{
id: 'yac_per_att',
label: 'Yards After Contact per Att',
calculate: (player) => {
const carries = player.totalCarries || 0;
return carries > 0 ? (player.totalYACON || 0) / carries : 0;
}
},
{
id: 'rz_opportunities',
label: 'Red Zone Opportunities per Game',
calculate: (player) => (player.rzOpportunities || 0) / player.gamesPlayed
},
{
id: 'carries',
label: 'Carries per Game',
calculate: (player) => (player.totalCarries || 0) / player.gamesPlayed
},
{
id: 'targets',
label: 'Targets per Game',
calculate: (player) => (player.totalTargets || 0) / player.gamesPlayed
},
{
id: 'receptions',
label: 'Receptions per Game',
calculate: (player) => (player.totalRec || 0) / player.gamesPlayed
},
{
id: 'catch_rate',
label: 'Catch Rate (%)',
calculate: (player) => {
const totalTargets = player.totalTargets || 0;
const totalRec = player.totalRec || 0;
return totalTargets > 0 ? (totalRec / totalTargets) * 100 : 0;
}
},
{
id: 'target_share',
label: 'Target Share (%)',
calculate: (player) => {
if (!player.weeks || player.weeks.length === 0) return 0;
const totalShare = player.weeks.reduce((sum, w) => sum + (w.teamShare || 0), 0);
return totalShare / player.weeks.length;
}
},
{
id: 'team_points',
label: 'Team Points per Game',
calculate: (player) => {
if (!teamStats || !teamStats[player.team]) return 0;
return teamStats[player.team].avgPoints || 0;
}
},
{
id: 'receiving_tds',
label: 'Receiving TDs per Game',
calculate: (player) => (player.totalRecTDs || 0) / player.gamesPlayed
},
{
id: 'rushing_tds',
label: 'Rushing TDs per Game',
calculate: (player) => (player.totalRushTDs || 0) / player.gamesPlayed
},
{
id: 'total_tds',
label: 'Total TDs per Game',
calculate: (player) => ((player.totalRecTDs || 0) + (player.totalRushTDs || 0)) / player.gamesPlayed
},
{
id: 'rz_tds',
label: 'Red Zone TDs per Game',
calculate: (player) => (player.rzTDs || 0) / player.gamesPlayed
},
{
id: 'yards_per_touch',
label: 'Yards per Touch',
calculate: (player) => {
const totalYards = (player.totalRushYards || 0) + (player.totalRecYards || 0);
const totalTouches = (player.totalCarries || 0) + (player.totalRec || 0);
return totalTouches > 0 ? totalYards / totalTouches : 0;
}
},
{
id: 'td_rate',
label: 'TD Rate (per Touch)',
calculate: (player) => {
const totalTDs = (player.totalRecTDs || 0) + (player.totalRushTDs || 0);
const totalTouches = (player.totalCarries || 0) + (player.totalRec || 0);
return totalTouches > 0 ? (totalTDs / totalTouches) * 100 : 0;
}
},
{
id: 'total_yards',
label: 'Total Yards per Game',
calculate: (player) => {
const totalYards = (player.totalRushYards || 0) + (player.totalRecYards || 0);
return totalYards / player.gamesPlayed;
}
},
{
id: 'receiving_yards',
label: 'Receiving Yards per Game',
calculate: (player) => (player.totalRecYards || 0) / player.gamesPlayed
},
{
id: 'yards_per_reception',
label: 'Yards per Reception',
calculate: (player) => {
const totalRec = player.totalRec || 0;
return totalRec > 0 ? (player.totalRecYards || 0) / totalRec : 0;
}
}
],
TE: [
{
id: 'fantasy_points',
label: 'Fantasy Points per Game',
calculate: (player) => player.avgPoints || 0
},
{
id: 'points_per_target',
label: 'Points per Target',
calculate: (player) => {
const targetsPerGame = player.totalTargets / player.gamesPlayed;
return targetsPerGame > 0 ? player.avgPoints / targetsPerGame : 0;
}
},
{
id: 'targets',
label: 'Targets per Game',
calculate: (player) => player.totalTargets / player.gamesPlayed
},
{
id: 'receptions',
label: 'Receptions per Game',
calculate: (player) => player.totalRec / player.gamesPlayed
},
{
id: 'receiving_yards',
label: 'Receiving Yards per Game',
calculate: (player) => player.totalYDS / player.gamesPlayed
},
{
id: 'catch_rate',
label: 'Catch Rate (%)',
calculate: (player) => player.catchRate || 0
},
{
id: 'target_share',
label: 'Target Share (%)',
calculate: (player) => {
if (!player.weeks || player.weeks.length === 0) return 0;
const totalShare = player.weeks.reduce((sum, w) => sum + (w.teamShare || 0), 0);
return totalShare / player.weeks.length;
}
},
{
id: 'rz_targets',
label: 'Red Zone Targets per Game',
calculate: (player) => (player.rzOpportunities || 0) / player.gamesPlayed
},
{
id: 'air_yards',
label: 'Air Yards per Game',
calculate: (player) => player.airYardsPerGame || 0
},
{
id: 'yac_per_rec',
label: 'Yards After Catch per Reception',
calculate: (player) => player.yacPerRec || 0
},
{
id: 'team_points',
label: 'Team Points per Game',
calculate: (player) => {
if (!teamStats || !teamStats[player.team]) return 0;
return teamStats[player.team].avgPoints || 0;
}
},
{
id: 'receiving_tds',
label: 'Receiving TDs per Game',
calculate: (player) => (player.totalRecTDs || 0) / player.gamesPlayed
},
{
id: 'rushing_tds',
label: 'Rushing TDs per Game',
calculate: (player) => (player.rzRushTDs || 0) / player.gamesPlayed
},
{
id: 'total_tds',
label: 'Total TDs per Game',
calculate: (player) => ((player.totalRecTDs || 0) + (player.rzRushTDs || 0)) / player.gamesPlayed
},
{
id: 'rz_tds',
label: 'Red Zone TDs per Game',
calculate: (player) => (player.rzTDs || 0) / player.gamesPlayed
},
{
id: 'total_yards',
label: 'Total Yards per Game',
calculate: (player) => {
const totalYards = (player.totalYDS || 0) + (player.totalRushYards || 0);
return totalYards / player.gamesPlayed;
}
},
{
id: 'yards_per_touch',
label: 'Yards per Reception',
calculate: (player) => {
return player.totalRec > 0 ? (player.totalYDS || 0) / player.totalRec : 0;
}
},
{
id: 'td_rate',
label: 'TD Rate (per Target)',
calculate: (player) => {
const totalTDs = player.totalRecTDs || 0;
return player.totalTargets > 0 ? (totalTDs / player.totalTargets) * 100 : 0;
}
}
]
};

// ðŸ”§ VERSION CHECK v3.0 - This should appear in console immediately
console.log('%cðŸ”§ FFSE STATS VERSION 3.0 LOADED', 'background: #00ff00; color: #000; font-size: 20px; font-weight: bold; padding: 10px;');
console.log('RB stats count:', advancedStatDefinitions.RB.length);
console.log('TE stats count:', advancedStatDefinitions.TE.length);
console.log('WR stats count:', advancedStatDefinitions.WR.length);

// Check for problematic stats that shouldn't exist
const rbHasAirYards = advancedStatDefinitions.RB.some(s => s.id === 'air_yards');
const rbHasPointsPerTarget = advancedStatDefinitions.RB.some(s => s.id === 'points_per_target');
const teHasRushingYards = advancedStatDefinitions.TE.some(s => s.id === 'rushing_yards');

if (rbHasAirYards) console.error('âŒ ERROR: RB has air_yards!');
if (rbHasPointsPerTarget) console.error('âŒ ERROR: RB has points_per_target!');
if (teHasRushingYards) console.error('âŒ ERROR: TE has rushing_yards!');

if (!rbHasAirYards && !rbHasPointsPerTarget && !teHasRushingYards) {
console.log('%câœ… ALL STAT DEFINITIONS CORRECT!', 'background: #00ff00; color: #000; font-size: 16px; padding: 5px;');
}

function toggleAxisControl(axisId) {
const content = document.getElementById(`${axisId}-content`);
const icon = document.getElementById(`${axisId}-icon`);
if (content && icon) {
if (content.classList.contains('collapsed')) {
content.classList.remove('collapsed');
icon.classList.remove('collapsed');
} else {
content.classList.add('collapsed');
icon.classList.add('collapsed');
}
}
}
function switchAdvancedPosition(position) {
if (isChangingPosition) {
console.warn('âš ï¸ Blocked recursive call to switchAdvancedPosition');
return;
}

isChangingPosition = true;
console.log(`\nðŸ”„ switchAdvancedPosition called with: ${position}`);
console.log('Previous position was:', advancedCurrentPosition);

advancedCurrentPosition = position;
console.log('advancedCurrentPosition now set to:', advancedCurrentPosition);

currentQuadrantExplanation = '';
clearPlayerHighlight();

document.getElementById('advanced-wr-btn')?.classList.toggle('active', position === 'WR');
document.getElementById('advanced-rb-btn')?.classList.toggle('active', position === 'RB');
document.getElementById('advanced-te-btn')?.classList.toggle('active', position === 'TE');

// Update dropdown WITHOUT triggering onchange
const positionSelect = document.getElementById('advanced-position-select');
if (positionSelect && positionSelect.value !== position) {
console.log(`Updating dropdown from ${positionSelect.value} to ${position}`);
// Temporarily remove event listener
const oldOnChange = positionSelect.onchange;
positionSelect.onchange = null;
positionSelect.value = position;
positionSelect.onchange = oldOnChange;
}

console.log('About to call populatePresetButtons()');
populatePresetButtons();

console.log('About to call populateAdvancedDropdowns() - THIS SHOULD REBUILD DROPDOWNS');
populateAdvancedDropdowns();

console.log('About to call updateAdvancedScatter()');
updateAdvancedScatter();

isChangingPosition = false;
console.log('âœ… switchAdvancedPosition complete\n');
}
function setPlayerCount(count) {
advancedPlayerCount = count;
document.getElementById('count-12').classList.toggle('active', count === 12);
document.getElementById('count-24').classList.toggle('active', count === 24);
document.getElementById('count-36').classList.toggle('active', count === 36);
document.getElementById('count-50').classList.toggle('active', count === 50);
document.getElementById('count-all').classList.toggle('active', count === null);
updateAdvancedScatter();
}
function resetAdvancedZoom() {
if (advancedScatterChart) {
advancedScatterChart.resetZoom();
}
}
function populateAdvancedDropdowns() {
// Version: 2.0 - Fixed RB/TE dropdown filtering
console.log('=== populateAdvancedDropdowns v2.0 called ===');
console.log('Current position:', advancedCurrentPosition);

const stats = advancedStatDefinitions[advancedCurrentPosition];
console.log('Total stats for position:', stats ? stats.length : 'UNDEFINED!');

const xSelect = document.getElementById('x-axis-select');
const ySelect = document.getElementById('y-axis-select');

if (!xSelect || !ySelect) {
console.error('âŒ Dropdown selects not found!');
return;
}

console.log('Found dropdowns - X has', xSelect.options.length, 'options, Y has', ySelect.options.length, 'options');

const currentX = xSelect.value;
const currentY = ySelect.value;

// FORCE complete clear of dropdowns
while (xSelect.firstChild) {
xSelect.removeChild(xSelect.firstChild);
}
while (ySelect.firstChild) {
ySelect.removeChild(ySelect.firstChild);
}
console.log('âœ“ Dropdowns forcefully cleared');

// NO FILTERING - Just use the stats as-is since they're already correct per position
console.log('âœ“ Using stats directly (no filter needed - arrays are position-specific)');
console.log('Stats to add:', stats.map(s => `${s.id} (${s.label})`).join(', '));

stats.forEach((stat, index) => {
console.log(`Adding stat ${index + 1}/${stats.length}: ${stat.id} - ${stat.label}`);
const xOption = document.createElement('option');
xOption.value = stat.id;
xOption.textContent = stat.label;
xSelect.appendChild(xOption);

const yOption = document.createElement('option');
yOption.value = stat.id;
yOption.textContent = stat.label;
ySelect.appendChild(yOption);
});

console.log('âœ“ X-axis final options count:', xSelect.options.length);
console.log('âœ“ Y-axis final options count:', ySelect.options.length);

// CRITICAL: Log what's ACTUALLY in the dropdowns right now
const xOptions = Array.from(xSelect.options).map(o => o.value);
const yOptions = Array.from(ySelect.options).map(o => o.value);
console.log('ðŸ“‹ X-axis actual options:', xOptions);
console.log('ðŸ“‹ Y-axis actual options:', yOptions);

// Check for the problematic ones
if (advancedCurrentPosition === 'RB') {
if (xOptions.includes('air_yards')) console.error('ðŸš¨ RB X-axis HAS air_yards!');
if (xOptions.includes('points_per_target')) console.error('ðŸš¨ RB X-axis HAS points_per_target!');
if (!xOptions.includes('air_yards') && !xOptions.includes('points_per_target')) {
console.log('âœ… RB dropdowns look correct!');
}
}
if (advancedCurrentPosition === 'TE') {
if (xOptions.includes('rushing_yards')) console.error('ðŸš¨ TE X-axis HAS rushing_yards!');
if (!xOptions.includes('rushing_yards')) {
console.log('âœ… TE dropdowns look correct!');
}
}

// Log what's actually in the dropdowns now
console.log('X-axis options:', Array.from(xSelect.options).map(o => o.text).join(', '));

if (currentX && stats.find(s => s.id === currentX)) {
xSelect.value = currentX;
} else {
// Default to Red Zone Usage for RB, Volume vs Efficiency for WR/TE
if (advancedCurrentPosition === 'RB') {
    xSelect.value = 'rz_opportunities';
} else {
    xSelect.value = 'targets';
}
}
if (currentY && stats.find(s => s.id === currentY)) {
ySelect.value = currentY;
} else {
// Default to fantasy_points for RB Red Zone, catch_rate for WR/TE
if (advancedCurrentPosition === 'RB') {
    ySelect.value = 'fantasy_points';
} else {
    ySelect.value = 'catch_rate';
}
}

console.log('âœ“ Final X-axis value:', xSelect.value, '(' + xSelect.options[xSelect.selectedIndex].text + ')');
console.log('âœ“ Final Y-axis value:', ySelect.value, '(' + ySelect.options[ySelect.selectedIndex].text + ')');
console.log('=== populateAdvancedDropdowns v2.0 complete ===\n');
}
function calculateAdvancedStat(player, statId, weekFilteredWeeks = null) {
const stats = advancedStatDefinitions[advancedCurrentPosition];
const stat = stats.find(s => s.id === statId);
if (!stat) return 0;
const playerForCalc = weekFilteredWeeks ? {
...player,
weeks: weekFilteredWeeks,
gamesPlayed: weekFilteredWeeks.length,
totalTargets: weekFilteredWeeks.reduce((sum, w) => sum + (w.targets || 0), 0),
totalOpportunities: weekFilteredWeeks.reduce((sum, w) => sum + ((w.rushAttempts || 0) + (w.targets || 0)), 0),
totalPoints: weekFilteredWeeks.reduce((sum, w) => sum + w.fpts, 0),
avgPoints: weekFilteredWeeks.length > 0 ? weekFilteredWeeks.reduce((sum, w) => sum + w.fpts, 0) / weekFilteredWeeks.length : 0
} : player;
const value = stat.calculate(playerForCalc);
return isFinite(value) ? value : 0;
}
function getAdvancedStatLabel(statId) {
const stats = advancedStatDefinitions[advancedCurrentPosition];
const stat = stats.find(s => s.id === statId);
return stat ? stat.label : '';
}
function generateQuadrantExplanation(xStatId, yStatId, xLabel, yLabel) {
const volumeStats = ['targets_per_game', 'opportunities_per_game', 'team_share', 'air_yards_per_game'];
const efficiencyStats = ['yards_per_target', 'yards_per_reception', 'yards_per_touch', 'catch_rate', 'points_per_target', 'points_per_opportunity'];
const productionStats = ['fantasy_ppg', 'yards_per_game', 'receiving_yards_per_game', 'rushing_yards_per_game'];
const scoringStats = ['rz_targets_per_game', 'rz_opportunities_per_game', 'td_rate'];
const xIsVolume = volumeStats.includes(xStatId);
const xIsEfficiency = efficiencyStats.includes(xStatId);
const xIsProduction = productionStats.includes(xStatId);
const xIsScoring = scoringStats.includes(xStatId);
const yIsVolume = volumeStats.includes(yStatId);
const yIsEfficiency = efficiencyStats.includes(yStatId);
const yIsProduction = productionStats.includes(yStatId);
const yIsScoring = scoringStats.includes(yStatId);
let explanation = '';
if ((xIsVolume && yIsEfficiency) || (xIsEfficiency && yIsVolume)) {
explanation = `<strong>What to look for:</strong> Top-right = elite players with high volume AND efficiency (studs). Bottom-right = volume without efficiency (sell high). Top-left = efficient with low volume (buy low candidates).`;
}
else if ((xIsVolume && yIsProduction) || (xIsProduction && yIsVolume)) {
explanation = `<strong>What to look for:</strong> Top-right = workhorses producing (league winners). Bottom-right = volume hogs underperforming (regression candidates). Top-left = efficient producers lacking volume (breakout potential if usage increases).`;
}
else if ((xIsVolume && yIsScoring) || (xIsScoring && yIsVolume)) {
explanation = `<strong>What to look for:</strong> Top-right = high-volume goal-line threats (must-starts with TD upside). Bottom-right = volume without scoring opportunities (TD-dependent floor). Top-left = goal-line specialists (boom/bust).`;
}
else if ((xIsEfficiency && yIsProduction) || (xIsProduction && yIsEfficiency)) {
explanation = `<strong>What to look for:</strong> Top-right = efficient producers (sustainable performers). Bottom-right = producing despite inefficiency (volume-driven, regression risk). Top-left = efficient low producers (need more volume).`;
}
else if ((xIsEfficiency && yIsScoring) || (xIsScoring && yIsEfficiency)) {
explanation = `<strong>What to look for:</strong> Top-right = efficient players with TD equity (high ceiling). Bottom-right = TD-dependent without efficiency (volatility). Top-left = efficient players without scoring (steady floor, limited ceiling).`;
}
else if ((xIsProduction && yIsScoring) || (xIsScoring && yIsProduction)) {
explanation = `<strong>What to look for:</strong> Top-right = elite producers with scoring equity (championship upside). Bottom-right = big producers without TDs (high floor). Top-left = TD-dependent scorers (boom/bust weekly).`;
}
else if ((xIsVolume && yIsVolume) || (xIsEfficiency && yIsEfficiency) || (xIsProduction && yIsProduction) || (xIsScoring && yIsScoring)) {
explanation = `<strong>What to look for:</strong> Top-right = elite in both ${xLabel.includes('Opp') || yLabel.includes('Opp') ? 'opportunity metrics' : 'metrics'} (target these players). Bottom-left = struggling in both areas (avoid). Diagonal = trade-offs between the two stats.`;
}
else {
explanation = `<strong>What to look for:</strong> Top-right = above median in both ${xLabel} and ${yLabel} (target these players). Bottom-left = below median in both (avoid). <span style="color: var(--text-tertiary);">Grey dotted lines show median values.</span>`;
}
return explanation;
}
function updateAdvancedScatter() {
// CRITICAL FIX: Debounce rapid updates to prevent chart conflicts
if (scatterUpdateTimeout) {
clearTimeout(scatterUpdateTimeout);
}

scatterUpdateTimeout = setTimeout(() => {
updateAdvancedScatterImmediate();
}, 50); // 50ms debounce
}

function updateAdvancedScatterImmediate() {
hideStickyChartTooltip();
if (!allPlayers || Object.keys(allPlayers).length === 0) { return;
}
const xStatId = document.getElementById('x-axis-select').value;
const yStatId = document.getElementById('y-axis-select').value;
const weekRange = document.getElementById('week-range-select').value;

// Update preset button active states
document.querySelectorAll('.preset-btn').forEach(btn => {
    const btnX = btn.getAttribute('data-x');
    const btnY = btn.getAttribute('data-y');
    if (btnX === xStatId && btnY === yStatId) {
        btn.classList.add('active');
    } else {
        btn.classList.remove('active');
    }
});

const xLabel = getAdvancedStatLabel(xStatId);
const yLabel = getAdvancedStatLabel(yStatId);
const weekRangeText = weekRange === 'all' ? '' : ` (${document.getElementById('week-range-select').selectedOptions[0].text})`;
document.getElementById('scatter-title').textContent = `${yLabel} vs ${xLabel}${weekRangeText}`;
const descriptionEl = document.getElementById('scatter-description');
if (currentQuadrantExplanation) {
descriptionEl.innerHTML =
`<strong>What to look for:</strong> ${currentQuadrantExplanation}`;
} else {
let explanation = generateQuadrantExplanation(xStatId, yStatId, xLabel, yLabel);
descriptionEl.innerHTML = explanation;
}
const players = Object.values(allPlayers).filter(p =>
p.position === advancedCurrentPosition &&
p.gamesPlayed >= 3
);
const scatterData = players.map(player => {
const weekFilteredWeeks = getWeekFilteredData(player, weekRange);
if (weekFilteredWeeks.length === 0) return null;
const x = calculateAdvancedStat(player, xStatId, weekFilteredWeeks);
const y = calculateAdvancedStat(player, yStatId, weekFilteredWeeks);
return {
x: x,
y: y,
player: player,
avgPoints: player.avgPoints || 0 // For sorting
};
}).filter(d => d && isFinite(d.x) && isFinite(d.y));
let filteredData = scatterData.sort((a, b) => b.avgPoints - a.avgPoints);
if (advancedPlayerCount) {
const highlightedData = filteredData.filter(d => highlightedPlayerIds.includes(d.player.id));
const nonHighlightedData = filteredData.filter(d => !highlightedPlayerIds.includes(d.player.id));
const topNonHighlighted = nonHighlightedData.slice(0, advancedPlayerCount);
filteredData = [...highlightedData, ...topNonHighlighted];
}
renderAdvancedScatter(filteredData, xLabel, yLabel);

// Generate insights for the current scatter plot
if (filteredData.length > 0) {
generateScatterInsights(filteredData, advancedCurrentPosition, xStatId, yStatId);
}
}
function renderAdvancedScatter(data, xLabel, yLabel) {
const canvas = document.getElementById('advanced-scatter-chart');
if (!canvas) return;

// CRITICAL FIX: Properly destroy existing chart and clear canvas
if (advancedScatterChart) {
try {
    advancedScatterChart.destroy();
    advancedScatterChart = null;
} catch (e) {
    console.warn('Error destroying chart:', e);
}
}

// Clear the canvas manually to ensure clean state
const ctx = canvas.getContext('2d');
ctx.clearRect(0, 0, canvas.width, canvas.height);

const xValues = data.map(d => d.x).sort((a, b) => a - b);
const yValues = data.map(d => d.y).sort((a, b) => a - b);
const xMedian = xValues.length > 0 ? xValues[Math.floor(xValues.length / 2)] : 0;
const yMedian = yValues.length > 0 ? yValues[Math.floor(yValues.length / 2)] : 0;
const xMin = Math.min(...xValues);
const xMax = Math.max(...xValues);
const yMin = Math.min(...yValues);
const yMax = Math.max(...yValues);
const xRange = xMax - xMin;
const yRange = yMax - yMin;
const minRange = 0.1;
const xPadding = Math.max(xRange * 0.1, minRange); // 10% padding or minimum
const yPadding = Math.max(yRange * 0.1, minRange);
const xAxisMin = xRange > 0 ? xMin - xPadding : xMin - 1;
const xAxisMax = xRange > 0 ? xMax + xPadding : xMax + 1;
const yAxisMin = yRange > 0 ? yMin - yPadding : yMin - 1;
const yAxisMax = yRange > 0 ? yMax + yPadding : yMax + 1;
let datasets = [];
const regularData = highlightedPlayerIds.length > 0
? data.filter(d => !highlightedPlayerIds.includes(d.player.id))
: data;
datasets.push({
label: advancedCurrentPosition,
data: regularData,
backgroundColor: regularData.map(d => {
const color = teamColors[d.player.team] || '#666';
return color + '99'; // Add transparency
}),
borderColor: regularData.map(d => teamColors[d.player.team] || '#666'),
borderWidth: 2,
pointRadius: 8,
pointHoverRadius: 12,
pointHoverBorderWidth: 3
});
if (highlightedPlayerIds.length > 0) {
highlightedPlayerIds.forEach((playerId, index) => {
const highlightedData = data.filter(d => d.player.id === playerId);
if (highlightedData.length > 0) {
const player = highlightedData[0].player;
const color = teamColors[player.team] || '#666';
datasets.push({
label: `Highlighted ${index + 1}`,
data: highlightedData,
backgroundColor: color,
borderColor: '#fff',
borderWidth: 4,
pointRadius: 16,
pointHoverRadius: 20,
pointHoverBorderWidth: 5,
pointStyle: 'circle'
});
}
});
}
const dynamicLabelsPlugin = {
id: 'dynamicLabels',
afterDatasetsDraw(chart) {
const ctx = chart.ctx;
const meta = chart.getDatasetMeta(0); // Get first dataset (regular players)
if (!meta || !meta.data) return;

// PERFORMANCE FIX: Limit max labels based on dataset size
const totalDataPoints = data.length;
let baseMaxLabels = 15;
if (totalDataPoints > 80) {
    baseMaxLabels = 8; // Severely limit labels for "All" view
} else if (totalDataPoints > 50) {
    baseMaxLabels = 10;
}

const allPoints = [];
chart.data.datasets.forEach((dataset, datasetIndex) => {
const datasetMeta = chart.getDatasetMeta(datasetIndex);
if (!datasetMeta || !datasetMeta.data) return;
datasetMeta.data.forEach((point, index) => {
const dataPoint = dataset.data[index];
if (!dataPoint || !dataPoint.player) return;
allPoints.push({
x: point.x,
y: point.y,
dataX: dataPoint.x,
dataY: dataPoint.y,
player: dataPoint.player,
isHighlighted: highlightedPlayerIds.includes(dataPoint.player.id),
teamColor: teamColors[dataPoint.player.team] || '#666'
});
});
});
const centerX = (chart.scales.x.min + chart.scales.x.max) / 2;
const centerY = (chart.scales.y.min + chart.scales.y.max) / 2;
const pointsWithDistance = allPoints.map(p => ({
...p,
distanceFromCenter: Math.sqrt(
Math.pow(p.dataX - centerX, 2) +
Math.pow(p.dataY - centerY, 2)
)
})).sort((a, b) => b.distanceFromCenter - a.distanceFromCenter);
const xRange = chart.scales.x.max - chart.scales.x.min;
const yRange = chart.scales.y.max - chart.scales.y.min;
const initialXRange = xAxisMax - xAxisMin;
const initialYRange = yAxisMax - yAxisMin;
const zoomFactor = Math.min(initialXRange / xRange, initialYRange / yRange);
let maxLabels = Math.min(baseMaxLabels, Math.floor(10 + zoomFactor * 5));
const minSpacing = 50; // Minimum pixels between labels
const labelPadding = 6;
const lineLength = 16; // Length of connecting line

// PERFORMANCE FIX: Use a spatial grid for faster collision detection
const gridSize = 100; // pixels per grid cell
const grid = new Map();
const getGridKey = (x, y) => {
    const gx = Math.floor(x / gridSize);
    const gy = Math.floor(y / gridSize);
    return `${gx},${gy}`;
};
const getNearbyGridKeys = (x, y) => {
    const gx = Math.floor(x / gridSize);
    const gy = Math.floor(y / gridSize);
    const keys = [];
    for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
            keys.push(`${gx + dx},${gy + dy}`);
        }
    }
    return keys;
};

const wouldCollide = (x, y, width, height) => {
    const nearbyKeys = getNearbyGridKeys(x + width/2, y + height/2);
    for (const key of nearbyKeys) {
        const cellLabels = grid.get(key) || [];
        for (const bounds of cellLabels) {
            if (!(x + width + minSpacing < bounds.x ||
            x - minSpacing > bounds.x + bounds.width ||
            y + height + minSpacing < bounds.y ||
            y - minSpacing > bounds.y + bounds.height)) {
                return true;
            }
        }
    }
    return false;
};

ctx.save();
let labelsDrawn = 0;
for (const point of pointsWithDistance) {
if (labelsDrawn >= maxLabels) break;
const nameParts = point.player.name.split(' ');
let lastName = nameParts[nameParts.length - 1];
const suffixes = ['Jr.', 'Sr.', 'II', 'III', 'IV', 'V', 'Jr', 'Sr'];
if (nameParts.length >= 2 && suffixes.includes(lastName)) {
lastName = nameParts[nameParts.length - 2] + ' ' + lastName;
}
ctx.font = '11px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
const textWidth = ctx.measureText(lastName).width;
const textHeight = 16;
const labelX = point.x + lineLength + 2;
const labelY = point.y;
if (!wouldCollide(labelX - labelPadding, labelY - textHeight/2 - labelPadding,
textWidth + labelPadding * 2, textHeight + labelPadding * 2)) {
ctx.strokeStyle = 'rgba(200, 200, 200, 0.25)';
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(point.x + 8, point.y); // Start from edge of point
ctx.lineTo(point.x + lineLength, point.y);
ctx.stroke();
// SAFE COLOR PARSING with NaN protection
let r = 10, g = 132, b = 255; // Default blue
if (point.teamColor && point.teamColor.startsWith('#') && point.teamColor.length >= 7) {
const rParsed = parseInt(point.teamColor.slice(1, 3), 16);
const gParsed = parseInt(point.teamColor.slice(3, 5), 16);
const bParsed = parseInt(point.teamColor.slice(5, 7), 16);
// Only use parsed values if they're valid numbers
if (!isNaN(rParsed) && !isNaN(gParsed) && !isNaN(bParsed)) {
    r = rParsed;
    g = gParsed;
    b = bParsed;
}
}
ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.3)`;
ctx.shadowBlur = 12;
const gradient = ctx.createLinearGradient(
labelX - labelPadding,
labelY - textHeight/2 - labelPadding,
labelX + textWidth + labelPadding,
labelY + textHeight/2 + labelPadding
);
gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.15)`);
gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0.10)`);
ctx.fillStyle = gradient;
ctx.fillRect(
labelX - labelPadding,
labelY - textHeight/2 - labelPadding,
textWidth + labelPadding * 2,
textHeight + labelPadding * 2
);
ctx.shadowBlur = 0;
ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
ctx.lineWidth = 1;
ctx.strokeRect(
labelX - labelPadding,
labelY - textHeight/2 - labelPadding,
textWidth + labelPadding * 2,
textHeight + labelPadding * 2
);
ctx.fillStyle = point.isHighlighted ? '#fff' : '#fff';
ctx.font = '500 11px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
ctx.textAlign = 'left';
ctx.textBaseline = 'middle';
ctx.fillText(lastName, labelX, labelY);

// Add bounds to spatial grid
const bounds = {
x: labelX - labelPadding,
y: labelY - textHeight/2 - labelPadding,
width: textWidth + labelPadding * 2,
height: textHeight + labelPadding * 2
};
const gridKey = getGridKey(bounds.x + bounds.width/2, bounds.y + bounds.height/2);
if (!grid.has(gridKey)) {
    grid.set(gridKey, []);
}
grid.get(gridKey).push(bounds);

labelsDrawn++;
}
}
ctx.restore();
}
};
advancedScatterChart = new Chart(ctx, {
type: 'scatter',
data: { datasets },
plugins: [dynamicLabelsPlugin],
options: {
responsive: true,
maintainAspectRatio: false,
plugins: {
legend: {
display: false
},
tooltip: {
enabled: false, // Disable default tooltip
external: function(context) {
if (isMobileDevice()) {
return;
}
const tooltipModel = context.tooltip;
if (tooltipModel.opacity === 0) {
const existingTooltip = document.getElementById('advanced-chart-tooltip');
if (existingTooltip) {
existingTooltip.style.opacity = '0';
setTimeout(() => existingTooltip.remove(), 200);
}
return;
}
let tooltipEl = document.getElementById('advanced-chart-tooltip');
if (!tooltipEl) {
tooltipEl = document.createElement('div');
tooltipEl.id = 'advanced-chart-tooltip';
tooltipEl.style.position = 'absolute';
tooltipEl.style.pointerEvents = 'none';
tooltipEl.style.transition = 'opacity 0.2s';
document.body.appendChild(tooltipEl);
}
if (tooltipModel.dataPoints && tooltipModel.dataPoints.length > 0) {
const hoveredPoint = tooltipModel.dataPoints[0].raw;
// Calculate adaptive threshold based on data range
const xRange = xAxisMax - xAxisMin;
const yRange = yAxisMax - yAxisMin;
const threshold = Math.min(xRange, yRange) * 0.02; // 2% of smaller axis range
const uniquePlayers = new Map();
advancedScatterChart.data.datasets.forEach(dataset => {
if (!dataset.data) return;
dataset.data.forEach(point => {
if (!point || !point.player) return;
const distance = Math.sqrt(
Math.pow(point.x - hoveredPoint.x, 2) +
Math.pow(point.y - hoveredPoint.y, 2)
);
if (distance < threshold) {
if (!uniquePlayers.has(point.player.id)) {
uniquePlayers.set(point.player.id, {
player: point.player,
x: point.x,
y: point.y,
color: teamColors[point.player.team] || '#666'
});
}
}
});
});
let innerHTML = '';
let index = 0;
uniquePlayers.forEach((p) => {
if (index > 0) {
innerHTML += '<div style="height: 8px;"></div>'; // Spacing
}
innerHTML += `
<div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;"><div style="width: 10px; height: 10px; background-color: ${p.color}; border-radius: 2px; flex-shrink: 0;"></div><span style="font-weight: 600;">${p.player.name}</span></div><div style="margin-left: 18px; font-size: 12px; color: #ddd;">
${xLabel}: ${p.x.toFixed(1)}
</div><div style="margin-left: 18px; font-size: 12px; color: #ddd; margin-bottom: 4px;">
${yLabel}: ${p.y.toFixed(1)}
</div>
`;
index++;
});
tooltipEl.innerHTML = innerHTML;
}
tooltipEl.style.opacity = '1';
tooltipEl.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
tooltipEl.style.color = 'white';
tooltipEl.style.border = '1px solid #2c2c2e';
tooltipEl.style.borderRadius = '8px';
tooltipEl.style.padding = '12px';
tooltipEl.style.fontSize = '13px';
tooltipEl.style.zIndex = '10000';
const position = context.chart.canvas.getBoundingClientRect();
tooltipEl.style.left = position.left + window.pageXOffset + tooltipModel.caretX + 'px';
tooltipEl.style.top = position.top + window.pageYOffset + tooltipModel.caretY + 'px';
}
},
annotation: {
annotations: {
xMedianLine: {
type: 'line',
xMin: xMedian,
xMax: xMedian,
borderColor: 'rgba(142, 142, 147, 0.4)',
borderWidth: 2,
borderDash: [8, 4],
label: {
display: false
}
},
yMedianLine: {
type: 'line',
yMin: yMedian,
yMax: yMedian,
borderColor: 'rgba(142, 142, 147, 0.4)',
borderWidth: 2,
borderDash: [8, 4],
label: {
display: false
}
}
}
},
zoom: {
pan: {
enabled: true,
mode: 'xy',
modifierKey: null, // No modifier key needed - just drag to pan
threshold: 5, // Minimum drag distance to start panning
onPanStart: function({chart}) {
// Prevent tooltip from showing during pan
chart.options.plugins.tooltip.enabled = false;
},
onPanComplete: function({chart}) {
chart.update('none');
// Re-enable tooltip after pan
setTimeout(() => {
chart.options.plugins.tooltip.enabled = false; // Keep disabled since we use external
}, 100);
}
},
zoom: {
wheel: {
enabled: true,
speed: 0.1
},
pinch: {
enabled: true
},
mode: 'xy',
speed: 0.1,
onZoomComplete: function({chart}) {
chart.update('none');
}
},
limits: {
x: {min: xAxisMin, max: xAxisMax},
y: {min: yAxisMin, max: yAxisMax}
}
}
},
scales: {
x: {
title: {
display: true,
text: xLabel,
color: '#8e8e93',
font: {
size: 14,
weight: '600'
}
},
min: xAxisMin,
max: xAxisMax,
grid: {
color: 'rgba(255, 255, 255, 0.05)'
},
ticks: {
color: '#8e8e93',
font: {
size: 12
}
}
},
y: {
title: {
display: true,
text: yLabel,
color: '#8e8e93',
font: {
size: 14,
weight: '600'
}
},
min: yAxisMin,
max: yAxisMax,
grid: {
color: 'rgba(255, 255, 255, 0.05)'
},
ticks: {
color: '#8e8e93',
font: {
size: 12
}
}
}
},
onClick: (event, elements) => {
if (elements.length > 0) {
const datasetIndex = elements[0].datasetIndex;
const dataIndex = elements[0].index;
const dataset = advancedScatterChart.data.datasets[datasetIndex];
const clickedPoint = dataset.data[dataIndex];
const player = clickedPoint.player;
const additionalData = {
findOverlapping: true,
point: { x: clickedPoint.x, y: clickedPoint.y },
threshold: 0.5, // Adjust based on your data scale
stats: (p) => {
return `${xLabel}: ${p.x.toFixed(1)}\n${yLabel}: ${p.y.toFixed(1)}`;
}
};
handleChartClick(event, player, openPlayerModal, additionalData);
}
}
}
});
}
function initializeAdvancedAnalytics() {
populatePresetButtons();
populateAdvancedDropdowns();
populateWeekSelector();
updateAdvancedScatter();
}
function populateWeekSelector() {
const select = document.getElementById('week-range-select');
if (!select) return;
let globalMaxWeek = 0;
Object.values(allPlayers).forEach(p => {
if (p.weeks && p.weeks.length > 0) {
const maxWeek = Math.max(...p.weeks.map(w => w.week));
if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
}
});
let html = `
<option value="all">All Weeks</option><option value="last3">Last 3 Weeks</option><option value="last5">Last 5 Weeks</option><option value="1-4">Weeks 1-4</option><option value="5-8">Weeks 5-8</option>
`;
if (globalMaxWeek > 0) {
html += `<option disabled>â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</option>`;
for (let week = 1; week <= globalMaxWeek; week++) {
html += `<option value="${week}">Week ${week} Only</option>`;
}
}
select.innerHTML = html;
}
const GOOGLE_SHEETS_URL = 'https://script.google.com/macros/s/AKfycbxgIp_XJLI1rc8g3cH4V6mQhXOQRE80vNyIQU18JiFRSInJwjjPfI5Qjj2i_3XgqRbSUg/exec';
function submitWaitlist(event) { event.preventDefault();
event.stopPropagation();
const emailInput = document.getElementById('waitlist-email');
const successMsg = document.getElementById('waitlist-success');
if (!emailInput || !successMsg) { showWaitlistModal(false, 'Error: Form not properly initialized');
return false;
}
const email = emailInput.value.trim();
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
if (!email || !emailRegex.test(email)) { alert('âš ï¸ Please enter a valid email address');
emailInput.focus();
return false;
}
const submitBtn = event.target.querySelector('button[type="submit"]');
if (submitBtn) {
const originalBtnText = submitBtn.textContent;
submitBtn.disabled = true;
submitBtn.textContent = 'Submitting...';
const payload = {
email: email,
timestamp: new Date().toISOString()
};
fetch(GOOGLE_SHEETS_URL, {
method: 'POST',
mode: 'no-cors',
headers: {
'Content-Type': 'application/json',
},
body: JSON.stringify(payload)
}).then(() => {
showWaitlistModal(true);
emailInput.value = '';
submitBtn.disabled = false;
submitBtn.textContent = originalBtnText;
}).catch(err => {
showWaitlistModal(true);
emailInput.value = '';
submitBtn.disabled = false;
submitBtn.textContent = originalBtnText;
});
}
return false;
}
window.submitWaitlist = submitWaitlist;
function showWaitlistModal(success, customMessage) {
const modal = document.getElementById('waitlist-modal');
if (modal) {
if (!success && customMessage) {
alert(customMessage);
return;
}
modal.classList.add('show');
}
}
function closeWaitlistModal() {
const modal = document.getElementById('waitlist-modal');
if (modal) {
modal.classList.remove('show');
}
}
function showLoginModal() {
document.getElementById('login-modal').style.display = 'flex';
document.getElementById('login-error').classList.remove('show');
}
function closeLoginModal() {
document.getElementById('login-modal').style.display = 'none';
document.getElementById('login-email').value = '';
document.getElementById('login-password').value = '';
document.getElementById('login-error').classList.remove('show');
}
function showPrivacyModal() {
document.getElementById('privacy-modal').style.display = 'flex';
}
function closePrivacyModal() {
document.getElementById('privacy-modal').style.display = 'none';
}
window.handleLogin = function(event) {
if (event) {
event.preventDefault();
event.stopPropagation();
}
const emailEl = document.getElementById('login-email');
const passwordEl = document.getElementById('login-password');
if (!emailEl || !passwordEl) { alert('Error: Login form not properly initialized');
return false;
}
const email = emailEl.value.trim();
const password = passwordEl.value;
const ADMIN_EMAIL = 'aryi3025@gmail.com';
const ADMIN_PASSWORD = 'admin051213!';
if (email === ADMIN_EMAIL && password === ADMIN_PASSWORD) {
closeLoginModal();
updateUIForAdmin(true);
setTimeout(() => {
navigateToPage('admin-panel');
}, 100);
alert('Login successful! Welcome back.');
} else {
const errorMsg = document.getElementById('login-error');
if (errorMsg) {
errorMsg.classList.add('show');
setTimeout(() => {
errorMsg.classList.remove('show');
}, 3000);
} else {
alert('Invalid credentials. Please try again.');
}
}
return false;
};
function checkAdminStatus() {
const isLoggedIn = localStorage.getItem('ffse_admin_logged_in') === 'true';
if (isLoggedIn) { updateUIForAdmin(true);
} else {
updateUIForAdmin(false);
}
updateLastUpdatedDisplay();
}
function toggleMobileMenu() {
const menuButton = document.querySelector('.mobile-menu-button');
const menuOverlay = document.getElementById('mobile-menu-overlay');
const menu = document.getElementById('mobile-menu');
menuButton.classList.toggle('active');
menuOverlay.classList.toggle('active');
menu.classList.toggle('active');
if (menu.classList.contains('active')) {
document.body.style.overflow = 'hidden';
} else {
document.body.style.overflow = '';
}
}
function closeMobileMenu() {
const menuButton = document.querySelector('.mobile-menu-button');
const menuOverlay = document.getElementById('mobile-menu-overlay');
const menu = document.getElementById('mobile-menu');
menuButton.classList.remove('active');
menuOverlay.classList.remove('active');
menu.classList.remove('active');
document.body.style.overflow = '';
}
function navigateFromMobileMenu(pageName) {
document.querySelectorAll('.mobile-menu-item').forEach(item => {
item.classList.remove('active');
});
const activeMenuItem = document.querySelector(`.mobile-menu-item[data-page="${pageName}"]`);
if (activeMenuItem) activeMenuItem.classList.add('active');
closeMobileMenu();
navigateToPage(pageName);
window.scrollTo({ top: 0, behavior: 'smooth' });
}
function navigateToPage(pageName) {
hideStickyChartTooltip();

// Stop team insights rotation when leaving teams page
if (pageName !== 'teams') {
    stopTeamInsightRotation();
}

// Stop scatter insights rotation when leaving advanced-analytics page
if (pageName !== 'advanced-analytics') {
    stopScatterInsightRotation();
}

document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
const activeTab = document.querySelector(`.nav-tab[data-page="${pageName}"]`);
if (activeTab) activeTab.classList.add('active');
document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
const targetPage = document.getElementById(pageName);
if (targetPage) targetPage.classList.add('active');
if (['wide-receivers', 'running-backs', 'tight-ends'].includes(pageName)) {
expandAllTiers();
setTimeout(() => {
expandAllTiers();
}, 100);
}
if (pageName === 'top-movers') {
setTimeout(() => {
renderDashboardCategories();
setTimeout(renderMiniScatterPlots, 100);
}, 100);
}
if (pageName === 'teams') {
setTimeout(() => {
updateTeamAnalysis();
// Restart team insights rotation when entering teams page
if (teamInsightsState.insights.length > 0) {
    startTeamInsightRotation();
}
}, 100);
}
if (pageName === 'advanced-analytics') {
setTimeout(() => {
// Update scatter chart which will generate insights
updateAdvancedScatter();
}, 100);
}
if (pageName === 'all-leaderboards') {
setTimeout(() => {
renderAllLeaderboards();
}, 100);
}
if (pageName === 'analytics-dashboard') {
setTimeout(() => {
initializeMetricTooltip();
}, 100);
}
if (pageName === 'home') {
setTimeout(() => {
updateHomepageInsights();
}, 100);
}
window.scrollTo({ top: 0, behavior: 'smooth' });
}
function setScoringFormat(format) {
console.log(`===== SCORING FORMAT CHANGE =====`);
console.log(`Old format: ${currentScoringFormat}, New format: ${format}`);
if (format === 'std') { } else if (format === 'half') { } else { }
currentScoringFormat = format;
localStorage.setItem('ffse_scoring_format', format);
document.querySelectorAll('.scoring-option').forEach(btn => {
btn.classList.remove('active');
if (btn.dataset.format === format) {
btn.classList.add('active');
}
});
const mainContent = document.querySelector('.main-content');
if (mainContent) {
mainContent.classList.add('updating-values');
setTimeout(() => {
mainContent.classList.remove('updating-values');
}, 600);
}
const activePage = document.querySelector('.page.active');
if (activePage && activePage.id === 'analytics-page') {
const heatmapGrid = document.getElementById('heatmap-cards-grid');
if (heatmapGrid) {
heatmapGrid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: var(--text-secondary); font-size: 14px;">âŸ³ Recalculating for ' + (format === 'ppr' ? 'PPR' : format === 'half' ? 'Half-PPR' : 'Standard') + ' scoring...</div>';
}
}
if (wrData && rbData) {
console.log(`Data available - WR: ${wrData ? wrData.length : 0}, RB: ${rbData ? rbData.length : 0}, TE: ${teData ? teData.length : 0}`);
console.log('Starting data reprocessing...');
setTimeout(() => {
console.log('ðŸ“Š Reprocessing data for new scoring format:', currentScoringFormat);
if (wrData) {
console.log('ðŸ”„ Recalculating WR data...');
aggregatedWRs = aggregatePlayerData(wrData, 'WR');
evaluationDataWR = calculateWREvaluationMetrics(wrData);
console.log('âœ… WR recalculation complete:', Object.keys(aggregatedWRs).length, 'players');
}
if (rbData) {
console.log('ðŸ”„ Recalculating RB data...');
aggregatedRBs = aggregatePlayerData(rbData, 'RB');
evaluationDataRB = calculateRBEvaluationMetrics(rbData);
console.log('âœ… RB recalculation complete:', Object.keys(aggregatedRBs).length, 'players');
}
if (teData) {
console.log('ðŸ”„ Recalculating TE data...');
aggregatedTEs = aggregatePlayerData(teData, 'TE');
console.log('âœ… TE recalculation complete:', Object.keys(aggregatedTEs).length, 'players');
}
allPlayers = { ...window.aggregatedWRs, ...window.aggregatedRBs, ...window.aggregatedTEs };
calculateROSRanks();
calculateAllMomentum();
console.log('ðŸŽ¨ Re-rendering all position pages...');
renderWRPlayerCards();
renderRBPlayerCards();
renderTEPlayerCards();
renderTicker();
renderMarketTicker();
// renderHomeInsights(); // Old homepage - disabled
renderTeamsTicker();
renderScatterPlots();
renderPPGLeaderboard(document.querySelector('.ppg-position-btn.active')?.dataset.position || 'WR');
updateMarketOpportunities(); // Update market opportunities with new scoring
updateHomepageInsights(); // Update homepage insights with new scoring
// Ticker removed from leaderboards page
/*
const analyticsInsightsTrack = document.getElementById('analytics-insights-track');
if (analyticsInsightsTrack) {
const topWRs = Object.values(window.aggregatedWRs)
.filter(p => p.gamesPlayed >= 3)
.sort((a, b) => b.avgPoints - a.avgPoints)
.slice(0, 10)
.map((p, idx) => ({ ...p, rank: idx + 1 }));
const topRBs = Object.values(window.aggregatedRBs)
.filter(p => p.gamesPlayed >= 3)
.sort((a, b) => b.avgPoints - a.avgPoints)
.slice(0, 10)
.map((p, idx) => ({ ...p, rank: idx + 1 }));
const topTEs = Object.values(window.aggregatedTEs)
.filter(p => p.gamesPlayed >= 3)
.sort((a, b) => b.avgPoints - a.avgPoints)
.slice(0, 10)
.map((p, idx) => ({ ...p, rank: idx + 1 }));
const allTopPlayers = [...topWRs, ...topRBs, ...topTEs];
const analyticsTickerHTML = allTopPlayers.map((player) => {
return `
<div class="ticker-item"><span style="font-weight: 700; color: var(--text-tertiary); font-size: 12px; min-width: 24px;">#${player.rank}</span><span class="player-name">${player.name}</span><span style="color: var(--text-secondary); font-size: 11px;">${player.position} Â· ${player.team}</span><span class="avg-pts">${player.avgPoints.toFixed(1)} PPG</span></div>
`;
}).join('');
analyticsInsightsTrack.innerHTML = analyticsTickerHTML + analyticsTickerHTML;
}
*/
if (aggregatedWRs && aggregatedRBs && aggregatedTEs) {
initializeAnalyticsDashboard();
}
console.log('âœ… Scoring format change complete!');
console.log('Data reprocessing complete');
console.log(`WR aggregated players: ${Object.keys(aggregatedWRs).length}`);
console.log(`RB aggregated players: ${Object.keys(aggregatedRBs).length}`);
console.log(`TE aggregated players: ${Object.keys(aggregatedTEs).length}`);
const sampleWR = Object.values(window.aggregatedWRs)[0];
if (sampleWR) {
console.log(`Sample WR: ${sampleWR.name}`);
console.log(` - Avg Points: ${sampleWR.avgPoints.toFixed(2)}`);
console.log(` - pctOverExpected: ${sampleWR.pctOverExpected.toFixed(2)}%`);
if (sampleWR.weeks && sampleWR.weeks.length > 0) {
const lastWeek = sampleWR.weeks[sampleWR.weeks.length - 1];
console.log(` - Last week fpts: ${lastWeek.fpts.toFixed(2)}`);
console.log(` - Last week expectedFpts: ${lastWeek.expectedFpts.toFixed(2)}`);
}
}
}, 100);
} else {
console.log('Data not ready for reprocessing');
}
}
function initializeScoringFormat() {
const savedFormat = localStorage.getItem('ffse_scoring_format') || 'ppr';
currentScoringFormat = savedFormat;
document.querySelectorAll('.scoring-option').forEach(btn => {
btn.classList.remove('active');
if (btn.dataset.format === savedFormat) {
btn.classList.add('active');
}
});
updateHeaderScoringDropdown(savedFormat); if (savedFormat === 'std') { } else if (savedFormat === 'half') { } else { }
}
function toggleHeaderScoringDropdown() {
const dropdown = document.getElementById('header-scoring-dropdown');
dropdown.classList.toggle('open');
if (dropdown.classList.contains('open')) {
setTimeout(() => {
document.addEventListener('click', closeHeaderDropdownOutside);
}, 0);
} else {
document.removeEventListener('click', closeHeaderDropdownOutside);
}
}
function closeHeaderDropdownOutside(e) {
const dropdown = document.getElementById('header-scoring-dropdown');
if (!dropdown.contains(e.target)) {
dropdown.classList.remove('open');
document.removeEventListener('click', closeHeaderDropdownOutside);
}
}
function setHeaderScoringFormat(format) {
document.getElementById('header-scoring-dropdown').classList.remove('open');
document.removeEventListener('click', closeHeaderDropdownOutside);
updateHeaderScoringDropdown(format);
setScoringFormat(format);
}

// Navigation Dropdown Functions
function initializeNavigationDropdowns() {
const dropdowns = ['decisionsDropdown', 'positionsDropdown', 'analyticsDropdown'];

dropdowns.forEach(id => {
const dropdown = document.getElementById(id);
if (!dropdown) return;

// Open on hover (desktop)
dropdown.addEventListener('mouseenter', () => {
// Close all other dropdowns
dropdowns.forEach(otherId => {
if (otherId !== id) {
const otherDropdown = document.getElementById(otherId);
if (otherDropdown) otherDropdown.classList.remove('open');
}
});
dropdown.classList.add('open');
});

// Close when mouse leaves
dropdown.addEventListener('mouseleave', () => {
setTimeout(() => {
if (!dropdown.matches(':hover')) {
dropdown.classList.remove('open');
}
}, 100);
});

// Handle dropdown item clicks
const dropdownItems = dropdown.querySelectorAll('.dropdown-item');
dropdownItems.forEach(item => {
item.addEventListener('click', (e) => {
const page = item.getAttribute('data-page');
if (page) {
dropdown.classList.remove('open');
navigateToPage(page);
}
});
});
});
}

// Initialize dropdowns when DOM is ready
if (document.readyState === 'loading') {
document.addEventListener('DOMContentLoaded', initializeNavigationDropdowns);
} else {
initializeNavigationDropdowns();
}

function updateHeaderScoringDropdown(format) {
const label = document.getElementById('header-scoring-label');
const buttons = document.querySelectorAll('.header-scoring-menu button');
if (format === 'ppr') {
label.textContent = 'PPR';
} else if (format === 'half') {
label.textContent = 'Half-PPR';
} else {
label.textContent = 'Standard';
}
buttons.forEach(btn => {
btn.classList.remove('active');
if ((format === 'ppr' && btn.textContent === 'PPR') ||
(format === 'half' && btn.textContent === 'Half-PPR') ||
(format === 'std' && btn.textContent === 'Standard')) {
btn.classList.add('active');
}
});
}
function scrollToWaitlist() {
const footer = document.querySelector('.footer');
if (footer) {
footer.scrollIntoView({ behavior: 'smooth', block: 'start' });
setTimeout(() => {
const emailInput = document.getElementById('waitlist-email');
if (emailInput) emailInput.focus();
}, 500);
}
}
function updateLastUpdatedDisplay() {
const lastUpdated = localStorage.getItem('ffse_last_updated');
const displayEl = document.getElementById('last-updated-date');
if (displayEl) {
if (lastUpdated) {
const date = new Date(lastUpdated);
const options = { month: 'short', day: 'numeric', year: 'numeric' };
displayEl.textContent = date.toLocaleDateString('en-US', options);
} else {
displayEl.textContent = 'No data uploaded';
}
}
}
function setLastUpdatedDate() {
const now = new Date().toISOString();
localStorage.setItem('ffse_last_updated', now);
updateLastUpdatedDisplay();
}
function updateUIForAdmin(isAdmin) {
const adminLoginLink = document.getElementById('admin-login-link');
const adminTab = document.getElementById('admin-tab');
const mobileAdminTab = document.getElementById('mobile-admin-tab');
if (isAdmin) {
if (adminTab) adminTab.style.display = 'block';
if (mobileAdminTab) mobileAdminTab.style.display = 'block';
if (adminLoginLink) {
adminLoginLink.textContent = 'Admin Panel';
adminLoginLink.onclick = (e) => {
e.preventDefault();
navigateToPage('admin-panel');
return false;
};
}
} else {
if (adminTab) adminTab.style.display = 'none';
if (mobileAdminTab) mobileAdminTab.style.display = 'none';
if (adminLoginLink) {
adminLoginLink.textContent = 'Admin Login';
adminLoginLink.onclick = (e) => {
e.preventDefault();
showLoginModal();
return false;
};
}
}
updateAdminPanelDisplay();
}
function logoutAdmin() {
localStorage.removeItem('ffse_admin_logged_in');
updateUIForAdmin(false);
if (document.getElementById('admin-panel').classList.contains('active')) {
navigateToPage('top-movers');
}
alert('Logged out successfully');
}
function updateAdminPanelDisplay() {
const lastUpdatedEl = document.getElementById('admin-last-updated');
if (lastUpdatedEl) {
const lastUpdated = localStorage.getItem('ffse_last_updated');
if (lastUpdated) {
const date = new Date(lastUpdated);
const options = { month: 'short', day: 'numeric', year: 'numeric', hour: 'numeric', minute: '2-digit' };
lastUpdatedEl.textContent = date.toLocaleDateString('en-US', options);
} else {
lastUpdatedEl.textContent = 'No data uploaded';
}
}
}
function handleAdminWRUpload(event) {
const file = event.target.files[0];
if (file) {
const statusEl = document.getElementById('admin-wr-status');
if (statusEl) statusEl.textContent = 'Processing...';
if (statusEl) statusEl.style.color = 'var(--text-secondary)';
Papa.parse(file, {
header: true,
skipEmptyLines: true,
complete: function(results) {
wrData = results.data.filter(row => row.Player && row.Week);
localStorage.setItem('wrData', JSON.stringify(wrData));
if (statusEl) statusEl.textContent = 'âœ“ WR data uploaded successfully';
if (statusEl) statusEl.style.color = 'var(--positive)';
if (rbData && teData) {
processAllData();
updateAdminPanelDisplay();
}
},
error: function(error) {
if (statusEl) statusEl.textContent = 'âœ— Error uploading WR data';
if (statusEl) statusEl.style.color = 'var(--negative)'; }
});
}
}
function handleAdminRBUpload(event) {
const file = event.target.files[0];
if (file) {
const statusEl = document.getElementById('admin-rb-status');
if (statusEl) statusEl.textContent = 'Processing...';
if (statusEl) statusEl.style.color = 'var(--text-secondary)';
Papa.parse(file, {
header: true,
skipEmptyLines: true,
complete: function(results) {
rbData = results.data.filter(row => row.Player && row.Week);
localStorage.setItem('rbData', JSON.stringify(rbData));
if (statusEl) statusEl.textContent = 'âœ“ RB data uploaded successfully';
if (statusEl) statusEl.style.color = 'var(--positive)';
if (wrData && teData) {
processAllData();
updateAdminPanelDisplay();
}
},
error: function(error) {
if (statusEl) statusEl.textContent = 'âœ— Error uploading RB data';
if (statusEl) statusEl.style.color = 'var(--negative)'; }
});
}
}
function handleAdminTEUpload(event) {
const file = event.target.files[0];
if (file) {
const statusEl = document.getElementById('admin-te-status');
if (statusEl) statusEl.textContent = 'Processing...';
if (statusEl) statusEl.style.color = 'var(--text-secondary)';
Papa.parse(file, {
header: true,
skipEmptyLines: true,
complete: function(results) {
teData = results.data.filter(row => row.Player && row.Week);
window.teData = teData;
localStorage.setItem('teData', JSON.stringify(teData));
if (statusEl) statusEl.textContent = 'âœ“ TE data uploaded successfully';
if (statusEl) statusEl.style.color = 'var(--positive)';
if (wrData && rbData) {
processAllData();
updateAdminPanelDisplay();
}
},
error: function(error) {
if (statusEl) statusEl.textContent = 'âœ— Error uploading TE data';
if (statusEl) statusEl.style.color = 'var(--negative)'; }
});
}
}
function toggleTickerTooltip(event) {
event.stopPropagation();
const icon = event.currentTarget;
const tooltip = icon.querySelector('.ticker-tooltip');
document.querySelectorAll('.ticker-tooltip.active').forEach(otherTooltip => {
if (otherTooltip !== tooltip) {
otherTooltip.classList.remove('active');
}
});
tooltip.classList.toggle('active');
}
document.addEventListener('click', function(event) {
if (!event.target.closest('.ticker-info-icon')) {
document.querySelectorAll('.ticker-tooltip.active').forEach(tooltip => {
tooltip.classList.remove('active');
});
}
});
function toggleLeaderboardTooltip(event) {
event.stopPropagation();
const icon = event.currentTarget;
const tooltip = icon.querySelector('.leaderboard-tooltip');
document.querySelectorAll('.leaderboard-tooltip.active').forEach(otherTooltip => {
if (otherTooltip !== tooltip) {
otherTooltip.classList.remove('active');
}
});
tooltip.classList.toggle('active');
}
document.addEventListener('click', function(event) {
if (!event.target.closest('.leaderboard-info-icon')) {
document.querySelectorAll('.leaderboard-tooltip.active').forEach(tooltip => {
tooltip.classList.remove('active');
});
}
});
function toggleDashboardScatterTooltip(event) {
event.stopPropagation();
const icon = event.currentTarget;
const tooltip = icon.querySelector('.dashboard-scatter-tooltip');
document.querySelectorAll('.dashboard-scatter-tooltip.active').forEach(otherTooltip => {
if (otherTooltip !== tooltip) {
otherTooltip.classList.remove('active');
}
});
tooltip.classList.toggle('active');
}
document.addEventListener('click', function(event) {
if (!event.target.closest('.dashboard-scatter-info')) {
document.querySelectorAll('.dashboard-scatter-tooltip.active').forEach(tooltip => {
tooltip.classList.remove('active');
});
}
});
function initializePortalTooltip() {
let tooltip = document.getElementById('portal-tooltip');
if (!tooltip) {
tooltip = document.createElement('div');
tooltip.id = 'portal-tooltip';
document.body.appendChild(tooltip);
}
document.addEventListener('mouseover', function(e) {
const target = e.target.closest('.compact-metric-value');
if (target && target.hasAttribute('data-tooltip-text')) {
const tooltipText = target.getAttribute('data-tooltip-text');
const rect = target.getBoundingClientRect();
tooltip.innerHTML = tooltipText + '<span class="tooltip-secondary">Bar shows relative performance vs. #1</span>';
tooltip.style.opacity = '0';
tooltip.style.display = 'block';
const tooltipWidth = tooltip.offsetWidth;
const tooltipHeight = tooltip.offsetHeight;
let left = rect.left - tooltipWidth - 12;
let top = rect.top + (rect.height / 2) - (tooltipHeight / 2);
if (left < 10) {
left = rect.right + 12;
}
if (top < 10) {
top = 10;
} else if (top + tooltipHeight > window.innerHeight - 10) {
top = window.innerHeight - tooltipHeight - 10;
}
tooltip.style.left = left + 'px';
tooltip.style.top = top + 'px';
tooltip.style.opacity = '';
tooltip.style.display = '';
tooltip.classList.add('visible');
}
});
document.addEventListener('mouseout', function(e) {
const target = e.target.closest('.compact-metric-value');
if (target && target.hasAttribute('data-tooltip-text')) {
tooltip.classList.remove('visible');
}
});
}
window.addEventListener('DOMContentLoaded', () => {
initializeScoringFormat();
checkAdminStatus();
initializePortalTooltip();
fetchInjuryData().then(() => {
console.log('Injury data loaded from API:', Object.keys(injuryData).length, 'players');
const activePage = document.querySelector('.page.active');
if (activePage && activePage.id === 'wr-page' && wrData) {
renderWRPlayerCards();
} else if (activePage && activePage.id === 'rb-page' && rbData) {
renderRBPlayerCards();
} else if (activePage && activePage.id === 'te-page' && teData) {
renderTEPlayerCards();
} else if (activePage && activePage.id === 'analytics-page') {
console.log('Refreshing market opportunities with updated injury data');
updateMarketOpportunities();
}
});
setTimeout(() => {
expandAllTiers();
if (window.innerWidth <= 768) {
const legendItems = document.getElementById('heatmap-legend-items');
if (legendItems) {
legendItems.scrollLeft = (legendItems.scrollWidth - legendItems.clientWidth) / 2;
}
}
}, 100);
});
if ('ontouchstart' in window) {
document.addEventListener('DOMContentLoaded', () => {
document.addEventListener('click', (e) => {
const tooltipParent = e.target.closest('.radial-with-tooltip');
if (tooltipParent) {
e.preventDefault();
const wasActive = tooltipParent.classList.contains('active');
document.querySelectorAll('.radial-with-tooltip').forEach(el => {
el.classList.remove('active');
});
if (!wasActive) {
tooltipParent.classList.add('active');
}
}
});
});
}


/* ========================================
   DYNAMIC HOMEPAGE INSIGHTS SYSTEM
   ======================================== */

// Insight rotation indices (persisted in sessionStorage for page reloads)
function getNextInsightIndex(boxType, maxIndex) {
    const key = `insight_${boxType}_index`;
    let current = parseInt(sessionStorage.getItem(key) || '0');
    current = (current + 1) % maxIndex;
    sessionStorage.setItem(key, current.toString());
    return current;
}

// Calculate latest week from all players
function getLatestWeek() {
    let maxWeek = 0;
    [...Object.values(window.aggregatedWRs || {}), ...Object.values(window.aggregatedRBs || {}), ...Object.values(window.aggregatedTEs || {})].forEach(p => {
        if (p.weeks && p.weeks.length > 0) {
            const playerMax = Math.max(...p.weeks.map(w => w.week));
            if (playerMax > maxWeek) maxWeek = playerMax;
        }
    });
    return maxWeek;
}

// Helper function to navigate to scatter plot with player highlighted
function navigateToScatterPlotWithPlayer(player, chartType) {
    navigateToPage('advanced-analytics');
    setTimeout(() => {
        // Switch to correct position tab
        const positionTab = player.position === 'RB' ? 'rb' : (player.position === 'TE' ? 'wr' : 'wr');
        switchMatrix(positionTab);
        
        setTimeout(() => {
            // Switch to specific chart within that position
            if (positionTab === 'wr') {
                switchWRMatrix(chartType);
            } else {
                switchRBMatrix(chartType);
            }
            
            // Highlight the player
            setTimeout(() => {
                const playerId = `${player.name}_${player.team}`;
                window.highlightedPlayerIds = [playerId];
                
                // Trigger scatter plot redraw with highlight
                if (positionTab === 'rb') {
                    updateRBScatter();
                } else {
                    updateWRScatter();
                }
            }, 200);
        }, 100);
    }, 200);
}

// Small Box #1 Insights - Always show specific player
const smallBox1Insights = [
    {
        label: 'OPPORTUNITY SURGE',
        title: 'Volume Breakout',
        calculate: () => {
            const latestWeek = getLatestWeek();
            const last3Weeks = [latestWeek, latestWeek - 1, latestWeek - 2];
            const prior3Weeks = [latestWeek - 3, latestWeek - 4, latestWeek - 5];
            
            const movers = [];
            [...Object.values(window.aggregatedWRs || {}), ...Object.values(window.aggregatedRBs || {})].forEach(player => {
                if (!player.weeks || player.weeks.length < 5) return;
                
                const isWR = player.position === 'WR';
                const last3 = player.weeks.filter(w => last3Weeks.includes(w.week));
                const prior3 = player.weeks.filter(w => prior3Weeks.includes(w.week));
                
                if (last3.length < 2 || prior3.length < 2) return;
                
                let last3Avg = 0, prior3Avg = 0;
                if (isWR) {
                    last3Avg = last3.reduce((sum, w) => sum + (w.teamShare || 0), 0) / last3.length;
                    prior3Avg = prior3.reduce((sum, w) => sum + (w.teamShare || 0), 0) / prior3.length;
                } else {
                    last3.forEach(w => {
                        const teamTotal = (rbData || []).filter(r => r.Team === player.team && parseInt(r.Week) === w.week)
                            .reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);
                        if (teamTotal > 0) last3Avg += (w.opportunities / teamTotal) * 100;
                    });
                    last3Avg /= last3.length;
                    
                    prior3.forEach(w => {
                        const teamTotal = (rbData || []).filter(r => r.Team === player.team && parseInt(r.Week) === w.week)
                            .reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);
                        if (teamTotal > 0) prior3Avg += (w.opportunities / teamTotal) * 100;
                    });
                    prior3Avg /= prior3.length;
                }
                
                const change = last3Avg - prior3Avg;
                if (change > 5 && player.avgPoints >= 8) {
                    movers.push({ player, change, last3Avg });
                }
            });
            
            movers.sort((a, b) => b.change - a.change);
            const topPlayer = movers[0]?.player;
            const change = movers[0]?.change || 0;
            const share = movers[0]?.last3Avg || 0;
            
            return {
                playerName: topPlayer ? topPlayer.name : 'No Data',
                stat: `+${change.toFixed(1)}%`,
                description: `${topPlayer?.position || ''} Â· ${topPlayer?.team || ''} Â· ${share.toFixed(0)}% share`,
                link: () => {
                    if (topPlayer) {
                        const chartType = topPlayer.position === 'RB' ? 'share' : 'target-share';
                        navigateToScatterPlotWithPlayer(topPlayer, chartType);
                    }
                },
                detail: 'Target share surge (3W vs prior 3W)'
            };
        }
    },
    {
        label: 'RED ZONE UPSIDE',
        title: 'TD Regression Candidate',
        calculate: () => {
            const latestWeek = getLatestWeek();
            const last3Weeks = [latestWeek, latestWeek - 1, latestWeek - 2];
            
            const candidates = [];
            [...Object.values(window.aggregatedWRs || {}), ...Object.values(window.aggregatedRBs || {}), ...Object.values(window.aggregatedTEs || {})].forEach(player => {
                if (!player.weeks || player.weeks.length < 3) return;
                
                const last3 = player.weeks.filter(w => last3Weeks.includes(w.week));
                if (last3.length < 2) return;
                
                const rzField = player.position === 'RB' ? 'rzOpportunities' : 'rzTargets';
                const totalRZ = last3.reduce((sum, w) => sum + (w[rzField] || 0), 0);
                const totalTD = last3.reduce((sum, w) => sum + (w.touchdowns || 0), 0);
                const avgRZ = totalRZ / last3.length;
                
                if (avgRZ >= 2.5 && totalTD <= 1 && player.avgPoints >= 10) {
                    candidates.push({ player, avgRZ, totalTD, totalRZ });
                }
            });
            
            candidates.sort((a, b) => b.avgRZ - a.avgRZ);
            const topPlayer = candidates[0]?.player;
            const avgRZ = candidates[0]?.avgRZ || 0;
            const totalRZ = candidates[0]?.totalRZ || 0;
            
            return {
                playerName: topPlayer ? topPlayer.name : 'No Data',
                stat: `${totalRZ} RZ Opps`,
                description: `${topPlayer?.position || ''} Â· ${topPlayer?.team || ''} Â· ${avgRZ.toFixed(1)}/game`,
                link: () => {
                    if (topPlayer) {
                        navigateToScatterPlotWithPlayer(topPlayer, 'redzone');
                    }
                },
                detail: 'High RZ usage, low TD conversion'
            };
        }
    },
    {
        label: 'ELITE USAGE',
        title: 'Snap Rate Breakout',
        calculate: () => {
            const latestWeek = getLatestWeek();
            const last2Weeks = [latestWeek, latestWeek - 1];
            
            const eliteSnaps = [];
            [...Object.values(window.aggregatedWRs || {}), ...Object.values(window.aggregatedRBs || {}), ...Object.values(window.aggregatedTEs || {})].forEach(player => {
                if (!player.weeks || player.weeks.length < 2) return;
                
                const last2 = player.weeks.filter(w => last2Weeks.includes(w.week) && w.snapPct);
                if (last2.length < 2) return;
                
                const avgSnap = last2.reduce((sum, w) => sum + w.snapPct, 0) / last2.length;
                const prior2Weeks = [latestWeek - 3, latestWeek - 4];
                const prior2 = player.weeks.filter(w => prior2Weeks.includes(w.week) && w.snapPct);
                
                let priorAvg = 0;
                if (prior2.length >= 1) {
                    priorAvg = prior2.reduce((sum, w) => sum + w.snapPct, 0) / prior2.length;
                }
                
                const increase = avgSnap - priorAvg;
                
                if (avgSnap >= 85 && increase >= 10 && player.avgPoints >= 8) {
                    eliteSnaps.push({ player, avgSnap, increase });
                }
            });
            
            eliteSnaps.sort((a, b) => b.increase - a.increase);
            const topPlayer = eliteSnaps[0]?.player;
            const snap = eliteSnaps[0]?.avgSnap || 0;
            const increase = eliteSnaps[0]?.increase || 0;
            
            return {
                playerName: topPlayer ? topPlayer.name : 'No Data',
                stat: `${snap.toFixed(0)}%`,
                description: `${topPlayer?.position || ''} Â· ${topPlayer?.team || ''} Â· +${increase.toFixed(0)}% vs prior`,
                link: () => topPlayer ? openPlayerModal(topPlayer) : null,
                detail: 'Elite snap rate surge'
            };
        }
    },
    {
        label: 'TEAM TAKEOVER',
        title: 'Commanding Volume',
        calculate: () => {
            const latestWeek = getLatestWeek();
            const last3Weeks = [latestWeek, latestWeek - 1, latestWeek - 2];
            
            const volumeLeaders = [];
            [...Object.values(window.aggregatedWRs || {}), ...Object.values(window.aggregatedRBs || {})].forEach(player => {
                if (!player.weeks || player.weeks.length < 3) return;
                
                const last3 = player.weeks.filter(w => last3Weeks.includes(w.week));
                if (last3.length < 2) return;
                
                const isWR = player.position === 'WR';
                let avgShare = 0;
                
                if (isWR) {
                    avgShare = last3.reduce((sum, w) => sum + (w.teamShare || 0), 0) / last3.length;
                } else {
                    last3.forEach(w => {
                        const teamTotal = (rbData || []).filter(r => r.Team === player.team && parseInt(r.Week) === w.week)
                            .reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);
                        if (teamTotal > 0) avgShare += (w.opportunities / teamTotal) * 100;
                    });
                    avgShare /= last3.length;
                }
                
                if (avgShare >= 30 && player.avgPoints >= 12) {
                    volumeLeaders.push({ player, avgShare });
                }
            });
            
            volumeLeaders.sort((a, b) => b.avgShare - a.avgShare);
            const topPlayer = volumeLeaders[0]?.player;
            const share = volumeLeaders[0]?.avgShare || 0;
            
            return {
                playerName: topPlayer ? topPlayer.name : 'No Data',
                stat: `${share.toFixed(0)}%`,
                description: `${topPlayer?.position || ''} Â· ${topPlayer?.team || ''} Â· Team share`,
                link: () => {
                    if (topPlayer) {
                        navigateToPage('teams');
                        setTimeout(() => {
                            openTeamModal(topPlayer.team);
                        }, 200);
                    }
                },
                detail: 'Dominating team opportunity share'
            };
        }
    }
];

// Small Box #2 Insights - Always show specific player
const smallBox2Insights = [
    {
        label: 'EFFICIENCY KING',
        title: 'Points Per Touch',
        calculate: () => {
            const latestWeek = getLatestWeek();
            const last3Weeks = [latestWeek, latestWeek - 1, latestWeek - 2];
            
            const efficient = [];
            [...Object.values(window.aggregatedWRs || {}), ...Object.values(window.aggregatedRBs || {}), ...Object.values(window.aggregatedTEs || {})].forEach(player => {
                if (!player.weeks || player.weeks.length < 3) return;
                
                const last3 = player.weeks.filter(w => last3Weeks.includes(w.week) && w.fpts > 0);
                if (last3.length < 2) return;
                
                const isWR = player.position === 'WR' || player.position === 'TE';
                const avgOpps = last3.reduce((sum, w) => sum + (isWR ? (w.targets || 0) : (w.opportunities || 0)), 0) / last3.length;
                const avgPts = last3.reduce((sum, w) => sum + w.fpts, 0) / last3.length;
                
                if (avgOpps >= 10 && avgPts >= 12) {
                    const efficiency = avgPts / avgOpps;
                    efficient.push({ player, efficiency, avgPts, avgOpps });
                }
            });
            
            efficient.sort((a, b) => b.efficiency - a.efficiency);
            const topPlayer = efficient[0]?.player;
            const eff = efficient[0]?.efficiency || 0;
            const avgOpps = efficient[0]?.avgOpps || 0;
            
            return {
                playerName: topPlayer ? topPlayer.name : 'No Data',
                stat: `${eff.toFixed(2)}`,
                description: `${topPlayer?.position || ''} Â· ${topPlayer?.team || ''} Â· ${avgOpps.toFixed(1)} opps/g`,
                link: () => {
                    if (topPlayer) {
                        navigateToScatterPlotWithPlayer(topPlayer, 'efficiency');
                    }
                },
                detail: 'Pts per opportunity (last 3 weeks)'
            };
        }
    },
    {
        label: 'CONSISTENT FLOOR',
        title: 'Weekly Reliability',
        calculate: () => {
            const reliable = [];
            [...Object.values(window.aggregatedWRs || {}), ...Object.values(window.aggregatedRBs || {}), ...Object.values(window.aggregatedTEs || {})].forEach(player => {
                if (!player.weeks || player.weeks.length < 5 || !player.avgPoints || player.avgPoints < 12) return;
                
                const scores = player.weeks.map(w => w.fpts);
                const mean = scores.reduce((sum, s) => sum + s, 0) / scores.length;
                const variance = scores.reduce((sum, s) => sum + Math.pow(s - mean, 2), 0) / scores.length;
                const stdDev = Math.sqrt(variance);
                const cv = stdDev / mean;
                
                if (cv < 0.45 && player.avgPoints >= 14) {
                    reliable.push({ player, cv, avgPoints: player.avgPoints, stdDev });
                }
            });
            
            reliable.sort((a, b) => a.cv - b.cv);
            const topPlayer = reliable[0]?.player;
            const ppg = reliable[0]?.avgPoints || 0;
            const stdDev = reliable[0]?.stdDev || 0;
            
            return {
                playerName: topPlayer ? topPlayer.name : 'No Data',
                stat: `${ppg.toFixed(1)} PPG`,
                description: `${topPlayer?.position || ''} Â· ${topPlayer?.team || ''} Â· Â±${stdDev.toFixed(1)} SD`,
                link: () => topPlayer ? openPlayerModal(topPlayer) : null,
                detail: 'Low variance, high floor'
            };
        }
    },
    {
        label: 'BREAKOUT ALERT',
        title: 'Usage Momentum',
        calculate: () => {
            const latestWeek = getLatestWeek();
            const recentWeeks = [latestWeek, latestWeek - 1];
            
            const breakouts = [];
            [...Object.values(window.aggregatedWRs || {}), ...Object.values(window.aggregatedRBs || {}), ...Object.values(window.aggregatedTEs || {})].forEach(player => {
                if (!player.weeks || player.weeks.length < 4) return;
                
                const recent = player.weeks.filter(w => recentWeeks.includes(w.week));
                if (recent.length < 2) return;
                
                const isWR = player.position === 'WR' || player.position === 'TE';
                const latestOpp = recent[recent.length - 1][isWR ? 'targets' : 'opportunities'] || 0;
                const prevOpp = recent[recent.length - 2][isWR ? 'targets' : 'opportunities'] || 0;
                
                const seasonAvg = player.weeks.reduce((sum, w) => sum + (w[isWR ? 'targets' : 'opportunities'] || 0), 0) / player.weeks.length;
                
                const increase = latestOpp - seasonAvg;
                
                if (latestOpp >= 12 && increase >= 4 && player.avgPoints >= 8) {
                    breakouts.push({ player, latestOpp, increase, seasonAvg });
                }
            });
            
            breakouts.sort((a, b) => b.increase - a.increase);
            const topPlayer = breakouts[0]?.player;
            const latest = breakouts[0]?.latestOpp || 0;
            const increase = breakouts[0]?.increase || 0;
            
            return {
                playerName: topPlayer ? topPlayer.name : 'No Data',
                stat: `${latest}`,
                description: `${topPlayer?.position || ''} Â· ${topPlayer?.team || ''} Â· +${increase.toFixed(0)} vs avg`,
                link: () => {
                    if (topPlayer) {
                        const chartType = topPlayer.position === 'RB' ? 'opportunity-efficiency' : 'volume-production';
                        navigateToScatterPlotWithPlayer(topPlayer, chartType);
                    }
                },
                detail: `${topPlayer?.position === 'RB' ? 'Opportunities' : 'Targets'} spike (W${getLatestWeek()})`
            };
        }
    },
    {
        label: 'EFFICIENCY EDGE',
        title: 'Yards Per Touch',
        calculate: () => {
            const latestWeek = getLatestWeek();
            const last3Weeks = [latestWeek, latestWeek - 1, latestWeek - 2];
            
            const yardLeaders = [];
            Object.values(window.aggregatedRBs || {}).forEach(player => {
                if (!player.weeks || player.weeks.length < 3) return;
                
                const last3 = player.weeks.filter(w => last3Weeks.includes(w.week));
                if (last3.length < 2) return;
                
                const totalYards = last3.reduce((sum, w) => sum + (w.rushYards || 0) + (w.recYards || 0), 0);
                const totalTouches = last3.reduce((sum, w) => sum + (w.rushAttempts || 0) + (w.receptions || 0), 0);
                
                if (totalTouches >= 25) {
                    const ypt = totalYards / totalTouches;
                    yardLeaders.push({ player, ypt, totalYards, totalTouches });
                }
            });
            
            yardLeaders.sort((a, b) => b.ypt - a.ypt);
            const topPlayer = yardLeaders[0]?.player;
            const ypt = yardLeaders[0]?.ypt || 0;
            const touches = yardLeaders[0]?.totalTouches || 0;
            
            return {
                playerName: topPlayer ? topPlayer.name : 'No Data',
                stat: `${ypt.toFixed(1)} YPT`,
                description: `RB Â· ${topPlayer?.team || ''} Â· ${touches} touches (3W)`,
                link: () => topPlayer ? openPlayerModal(topPlayer) : null,
                detail: 'Elite yards per touch efficiency'
            };
        }
    }
];

// Update homepage insights
function updateHomepageInsights() {
    if (!window.aggregatedWRs || !window.aggregatedRBs) return;
    
    try {
        // Get rotation indices
        const box1Index = getNextInsightIndex('small1', smallBox1Insights.length);
        const box2Index = getNextInsightIndex('small2', smallBox2Insights.length);
        
        // Calculate insights
        const box1Insight = smallBox1Insights[box1Index];
        const box2Insight = smallBox2Insights[box2Index];
        
        const box1Data = box1Insight.calculate();
        const box2Data = box2Insight.calculate();
        
        // Update Small Box 1
        const smallBox1 = document.querySelector('.hero-story-small:nth-child(1)');
        if (smallBox1 && box1Data.playerName !== 'No Data') {
            smallBox1.innerHTML = `
                <div class="story-label">${box1Insight.label}</div>
                <h3 class="story-headline-small">${box1Data.playerName}</h3>
                <p class="story-subhead-small">${box1Data.description}</p>
                <div class="data-point">
                    <div class="data-value-small">${box1Data.stat}</div>
                    <div class="data-label">${box1Data.detail}</div>
                </div>
            `;
            smallBox1.style.cursor = 'pointer';
            smallBox1.onclick = box1Data.link;
        }
        
        // Update Small Box 2
        const smallBox2 = document.querySelector('.hero-story-small:nth-child(2)');
        if (smallBox2 && box2Data.playerName !== 'No Data') {
            smallBox2.innerHTML = `
                <div class="story-label">${box2Insight.label}</div>
                <h3 class="story-headline-small">${box2Data.playerName}</h3>
                <p class="story-subhead-small">${box2Data.description}</p>
                <div class="data-point">
                    <div class="data-value-small">${box2Data.stat}</div>
                    <div class="data-label">${box2Data.detail}</div>
                </div>
            `;
            smallBox2.style.cursor = 'pointer';
            smallBox2.onclick = box2Data.link;
        }
        
        // Update large box with link to leaderboards
        updateLargeBoxInsight();
        
    } catch (error) {
        console.error('Error updating homepage insights:', error);
    }
}

// Large box insight - rotate between 3 team-focused insights
function updateLargeBoxInsight() {
    const largeBox = document.querySelector('.hero-story-main');
    if (!largeBox || !window.aggregatedWRs || !window.aggregatedRBs) return;
    
    // Rotate based on day of week (0-6), cycling through 3 insights
    const dayOfWeek = new Date().getDay();
    const insightIndex = dayOfWeek % 3;
    
    const latestWeek = getLatestWeek();
    const last3Weeks = [latestWeek, latestWeek - 1, latestWeek - 2];
    
    let insight = null;
    
    if (insightIndex === 0) {
        // Option 1: Offensive Powerhouses
        insight = calculateOffensivePowerhouses(last3Weeks);
    } else if (insightIndex === 1) {
        // Option 2: Target-Heavy Offenses
        insight = calculateTargetHeavyOffenses(last3Weeks);
    } else {
        // Option 5: Fantasy-Friendly Offenses
        insight = calculateFantasyFriendlyOffenses(last3Weeks);
    }
    
    if (insight) {
        largeBox.innerHTML = `
            <div class="story-label">${insight.label}</div>
            <h1 class="story-headline">${insight.headline}</h1>
            <p class="story-subhead">${insight.subhead}</p>
            
            <div class="story-data-points">
                <div class="data-point">
                    <div class="data-value-split">
                        <span class="data-value-number">${insight.teams[0].number}</span>
                        <span class="data-value-unit">${insight.teams[0].unit}</span>
                    </div>
                    <div class="data-label">${insight.teams[0].name}</div>
                </div>
                <div class="data-point">
                    <div class="data-value-split">
                        <span class="data-value-number">${insight.teams[1].number}</span>
                        <span class="data-value-unit">${insight.teams[1].unit}</span>
                    </div>
                    <div class="data-label">${insight.teams[1].name}</div>
                </div>
                <div class="data-point">
                    <div class="data-value-split">
                        <span class="data-value-number">${insight.teams[2].number}</span>
                        <span class="data-value-unit">${insight.teams[2].unit}</span>
                    </div>
                    <div class="data-label">${insight.teams[2].name}</div>
                </div>
            </div>
            
            <button class="story-cta">${insight.cta}</button>
        `;
        largeBox.style.cursor = 'pointer';
        largeBox.onclick = () => {
            navigateToPage('teams');
        };
    }
}

// Calculate Option 1: Offensive Powerhouses
function calculateOffensivePowerhouses(last3Weeks) {
    const teamPoints = {};
    
    [...Object.values(window.aggregatedWRs || {}), ...Object.values(window.aggregatedRBs || {}), ...Object.values(window.aggregatedTEs || {})].forEach(player => {
        if (!player.weeks || player.weeks.length < 2) return;
        
        const last3 = player.weeks.filter(w => last3Weeks.includes(w.week));
        if (last3.length === 0) return;
        
        const totalPoints = last3.reduce((sum, w) => sum + (w.fpts || 0), 0);
        
        if (!teamPoints[player.team]) {
            teamPoints[player.team] = 0;
        }
        teamPoints[player.team] += totalPoints;
    });
    
    const topTeams = Object.entries(teamPoints)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3)
        .map(([team, points]) => ({
            name: team,
            number: points.toFixed(0),
            unit: 'pts'
        }));
    
    return {
        label: 'TRENDING NOW',
        headline: 'Offensive Powerhouses',
        subhead: 'Teams dominating fantasy production across all skill positions over the last 3 weeks.',
        teams: topTeams,
        cta: 'View Team Breakdowns â†’'
    };
}

// Calculate Option 2: Target-Heavy Offenses
function calculateTargetHeavyOffenses(last3Weeks) {
    const teamTargets = {};
    const teamGames = {};
    
    [...Object.values(window.aggregatedWRs || {}), ...Object.values(window.aggregatedTEs || {})].forEach(player => {
        if (!player.weeks || player.weeks.length < 2) return;
        
        const last3 = player.weeks.filter(w => last3Weeks.includes(w.week));
        if (last3.length === 0) return;
        
        const totalTargets = last3.reduce((sum, w) => sum + (w.targets || 0), 0);
        
        if (!teamTargets[player.team]) {
            teamTargets[player.team] = 0;
            teamGames[player.team] = 0;
        }
        teamTargets[player.team] += totalTargets;
        
        // Count unique weeks for this team
        const uniqueWeeks = new Set(last3.map(w => w.week));
        teamGames[player.team] = Math.max(teamGames[player.team], uniqueWeeks.size);
    });
    
    const topTeams = Object.entries(teamTargets)
        .map(([team, targets]) => ({
            team,
            avgTargets: teamGames[team] > 0 ? targets / teamGames[team] : 0
        }))
        .sort((a, b) => b.avgTargets - a.avgTargets)
        .slice(0, 3)
        .map(({ team, avgTargets }) => ({
            name: team,
            number: avgTargets.toFixed(1),
            unit: 'tgt/g'
        }));
    
    return {
        label: 'TRENDING NOW',
        headline: 'High-Volume Passing Attacks',
        subhead: 'Teams generating the most target opportunities for pass catchers in recent weeks.',
        teams: topTeams,
        cta: 'Explore Team Outlooks â†’'
    };
}

// Calculate Option 5: Fantasy-Friendly Offenses
function calculateFantasyFriendlyOffenses(last3Weeks) {
    const teamData = {};
    
    [...Object.values(window.aggregatedWRs || {}), ...Object.values(window.aggregatedRBs || {}), ...Object.values(window.aggregatedTEs || {})].forEach(player => {
        if (!player.weeks || player.weeks.length < 2) return;
        
        const last3 = player.weeks.filter(w => last3Weeks.includes(w.week));
        if (last3.length === 0) return;
        
        const avgPoints = last3.reduce((sum, w) => sum + (w.fpts || 0), 0) / last3.length;
        
        if (avgPoints >= 10) {
            if (!teamData[player.team]) {
                teamData[player.team] = {
                    relevantPlayers: 0,
                    totalPoints: 0,
                    playerCount: 0
                };
            }
            teamData[player.team].relevantPlayers++;
            teamData[player.team].totalPoints += last3.reduce((sum, w) => sum + (w.fpts || 0), 0);
            teamData[player.team].playerCount++;
        }
    });
    
    const topTeams = Object.entries(teamData)
        .sort((a, b) => b[1].relevantPlayers - a[1].relevantPlayers)
        .slice(0, 3)
        .map(([team, data]) => ({
            name: team,
            number: data.relevantPlayers.toString(),
            unit: 'players'
        }));
    
    return {
        label: 'TRENDING NOW',
        headline: 'Fantasy-Friendly Offenses',
        subhead: 'Best environments for player breakouts with multiple 10+ PPG options.',
        teams: topTeams,
        cta: 'Explore All Teams â†’'
    };
}


/* ========================================
   HOMEPAGE JAVASCRIPT
   ======================================== */

// Player data
        const playerData = {
            'nicoCollins': {
                name: 'Nico Collins', position: 'WR', team: 'HOU',
                weeks: [7, 9, 10], targets: [10, 11, 15],
                snapPct: [51, 79, 89], fpts: [6.7, 14.5, 22.6],
                insight: 'Snap share jumped 38% over 3 weeks with target surge',
                vizType: 'scatter'
            },
            'drakeLondon': {
                name: 'Drake London', position: 'WR', team: 'ATL',
                weeks: [6, 7, 9, 10], targetShare: [51.6, 27.8, 41.2, 0],
                fpts: [31.8, 8.2, 38.8, 24.4],
                insight: 'Elite 98% snap rate with volatile target distribution',
                vizType: 'bar'
            },
            'jonathanTaylor': {
                name: 'Jonathan Taylor', position: 'RB', team: 'IND',
                weeks: [6, 7, 8, 9, 10], touches: [25, 19, 14, 16, 35],
                fpts: [23.7, 34.2, 37.4, 7.7, 49.6], rec: [4, 3, 2, 2, 3], att: [21, 16, 12, 14, 32],
                insight: 'Massive Week 10 workload - 35 touches, 49.6 fantasy points',
                vizType: 'pie'
            },
            'devonAchane': {
                name: "De'Von Achane", position: 'RB', team: 'MIA',
                weeks: [6, 7, 8, 9, 10], touches: [22, 18, 25, 24, 28],
                fpts: [31.0, 12.8, 20.1, 16.6, 40.5],
                insight: 'Consistent 20+ touch floor with elite efficiency',
                vizType: 'scatter'
            },
            'jamesonWilliams': {
                name: 'Jameson Williams', position: 'WR', team: 'DET',
                weeks: [6, 7, 9, 10], snapPct: [85, 85, 91, 87],
                fpts: [18.6, 0, 16.6, 23.9], targets: [7, 2, 6, 7],
                insight: 'High snap rate stability with boom/bust scoring pattern',
                vizType: 'bar'
            }
        };
        
        const players = Object.values(playerData);
        let currentSlide = 0;
        let charts = {};
        let autoRotateTimer;
        
        function initializeViz() {
            const container = document.getElementById('vizContainer');
            const nav = document.getElementById('rotationNav');
            
            players.forEach((player, index) => {
                const slide = document.createElement('div');
                slide.className = 'viz-slide' + (index === 0 ? ' active' : '');
                slide.id = `slide-${index}`;
                
                const wrapper = document.createElement('div');
                wrapper.className = 'chart-wrapper';
                const canvas = document.createElement('canvas');
                canvas.id = `chart-${index}`;
                wrapper.appendChild(canvas);
                slide.appendChild(wrapper);
                container.appendChild(slide);
                
                const dot = document.createElement('div');
                dot.className = 'nav-dot' + (index === 0 ? ' active' : '');
                dot.onclick = () => goToSlide(index);
                nav.appendChild(dot);
            });
            
            players.forEach((player, index) => createChart(player, index));
            updatePlayerInfo(0);
            startAutoRotate();
        }
        
        function createChart(player, index) {
            const ctx = document.getElementById(`chart-${index}`).getContext('2d');
            if (player.vizType === 'scatter') createScatterChart(ctx, player, index);
            else if (player.vizType === 'bar') createBarChart(ctx, player, index);
            else if (player.vizType === 'pie') createPieChart(ctx, player, index);
        }
        
        function createScatterChart(ctx, player, index) {
            const data = player.weeks.map((week, i) => ({
                x: player.snapPct ? player.snapPct[i] : player.touches[i],
                y: player.fpts[i], week: week
            }));
            
            charts[index] = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Performance', data: data,
                        backgroundColor: '#30d158', borderColor: '#30d158',
                        borderWidth: 2, pointRadius: 6, pointHoverRadius: 8
                    }, {
                        label: 'Trend', data: data, type: 'line',
                        borderColor: 'rgba(48, 209, 88, 0.3)', borderWidth: 3,
                        pointRadius: 0, fill: false, tension: 0.4
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: {
                            title: { display: true, text: player.snapPct ? 'Snap %' : 'Touches', color: '#8e8e93' },
                            grid: { color: '#1c1c1e' }, ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: { display: true, text: 'Fantasy Points', color: '#8e8e93' },
                            grid: { color: '#1c1c1e' }, ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }
        
        function createBarChart(ctx, player, index) {
            const labels = player.weeks.map(w => `Week ${w}`);
            const data = player.targetShare || player.snapPct || player.fpts;
            
            charts[index] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(v => v > 0 ? 'rgba(48, 209, 88, 0.8)' : 'rgba(255, 69, 58, 0.8)'),
                        borderColor: data.map(v => v > 0 ? '#30d158' : '#ff453a'),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: {
                            beginAtZero: true, grid: { color: '#1c1c1e' },
                            ticks: { color: '#8e8e93', callback: (v) => v + '%' }
                        },
                        x: { grid: { display: false }, ticks: { color: '#8e8e93' } }
                    }
                }
            });
        }
        
        function createPieChart(ctx, player, index) {
            const rec = player.rec[player.rec.length - 1];
            const att = player.att[player.att.length - 1];
            
            charts[index] = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Receptions', 'Rush Attempts'],
                    datasets: [{ data: [rec, att], backgroundColor: ['#30d158', '#0a84ff'], borderWidth: 0 }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    plugins: { legend: { position: 'bottom', labels: { color: '#8e8e93', padding: 16 } } }
                }
            });
        }
        
        function goToSlide(index) {
            if (index === currentSlide) return;
            
            const slides = document.querySelectorAll('.viz-slide');
            const dots = document.querySelectorAll('.nav-dot');
            
            slides[currentSlide].classList.remove('active');
            slides[currentSlide].classList.add('prev');
            dots[currentSlide].classList.remove('active');
            
            setTimeout(() => slides[currentSlide].classList.remove('prev'), 600);
            
            currentSlide = index;
            slides[currentSlide].classList.add('active');
            dots[currentSlide].classList.add('active');
            
            updatePlayerInfo(index);
            resetAutoRotate();
        }
        
        function updatePlayerInfo(index) {
            const player = players[index];
            document.getElementById('vizPlayerName').textContent = player.name;
            document.getElementById('vizPlayerInfo').textContent = 
                `${player.position} â€¢ ${player.team} â€¢ ${player.insight}`;
        }
        
        function startAutoRotate() {
            autoRotateTimer = setInterval(() => {
                goToSlide((currentSlide + 1) % players.length);
            }, 8000);
        }
        
        function resetAutoRotate() {
            clearInterval(autoRotateTimer);
            startAutoRotate();
        }
        
        let headlineIndex = 0;
        
        // Sleeper API News Functions
        async function fetchSleeperNews() {
            try {
                const now = Date.now();
                if (now - lastNewsFetch < NEWS_FETCH_INTERVAL && sleeperNewsItems.length > 0) {
                    return sleeperNewsItems; // Use cached news
                }
                
                console.log('Fetching Sleeper player news...');
                const response = await fetch('https://api.sleeper.app/v1/players/nfl');
                const allPlayers = await response.json();
                
                // Get all player names from our datasets
                const ourPlayerNames = new Set();
                if (window.wrData) window.wrData.forEach(p => ourPlayerNames.add(p.Player));
                if (window.rbData) window.rbData.forEach(p => ourPlayerNames.add(p.Player));
                if (window.teData) window.teData.forEach(p => ourPlayerNames.add(p.Player));
                
                // Filter to relevant players with recent news
                const newsItems = [];
                const cutoffTime = Date.now() - (48 * 60 * 60 * 1000); // 48 hours ago
                
                for (const [playerId, player] of Object.entries(allPlayers)) {
                    if (!player || !player.position) continue;
                    
                    // Only WR, RB, TE
                    if (!['WR', 'RB', 'TE'].includes(player.position)) continue;
                    
                    // Check if this is one of our tracked players
                    const fullName = `${player.first_name} ${player.last_name}`;
                    if (!ourPlayerNames.has(fullName)) continue;
                    
                    // Check for injury status or recent news
                    const hasInjury = player.injury_status && player.injury_status !== 'Healthy';
                    const hasRecentNews = player.news_updated && player.news_updated > cutoffTime;
                    
                    if (hasInjury || hasRecentNews) {
                        let headline = '';
                        
                        if (hasInjury) {
                            const statusMap = {
                                'Questionable': 'Questionable',
                                'Doubtful': 'Doubtful', 
                                'Out': 'Out',
                                'IR': 'On Injured Reserve',
                                'PUP': 'On PUP List',
                                'COV': 'COVID List'
                            };
                            headline = statusMap[player.injury_status] || player.injury_status;
                            if (player.injury_body_part) {
                                headline += ` - ${player.injury_body_part}`;
                            }
                        } else if (player.status === 'Active' && player.injury_status === null) {
                            headline = 'Cleared to play - No injury designation';
                        }
                        
                        if (headline) {
                            newsItems.push({
                                header: `${fullName} - ${player.position}`,
                                subheader: headline,
                                timestamp: player.news_updated || Date.now(),
                                priority: hasInjury ? 1 : 2
                            });
                        }
                    }
                }
                
                // Sort by priority then timestamp
                newsItems.sort((a, b) => {
                    if (a.priority !== b.priority) return a.priority - b.priority;
                    return b.timestamp - a.timestamp;
                });
                
                // Limit to top 7 news items
                sleeperNewsItems = newsItems.slice(0, 7);
                lastNewsFetch = now;
                
                console.log(`âœ“ Loaded ${sleeperNewsItems.length} news items from Sleeper`);
                return sleeperNewsItems;
                
            } catch (error) {
                console.error('Error fetching Sleeper news:', error);
                return [];
            }
        }
        
        // Build rotation messages (branded + news)
        function buildRotationMessages() {
            const brandedMessages = [
                { header: 'Find value before your league does.', subheader: 'See the trends before your league mates do.' },
                { header: 'Signal > Hype.', subheader: 'The edge you need, without the noise.' }
            ];
            
            // Get top 24 players per position for priority news
            const top24Players = getTop24PlayersByPosition();
            
            // Separate priority news (top 24) from other news
            const priorityNews = [];
            const regularNews = [];
            
            sleeperNewsItems.forEach(news => {
                if (top24Players.has(news.header.split(' - ')[0])) {
                    priorityNews.push(news);
                } else {
                    regularNews.push(news);
                }
            });
            
            // Build rotation: priority news first, then interleave branded + regular news
            const rotationPool = [];
            
            // Add all priority news first
            priorityNews.forEach(news => {
                rotationPool.push({
                    header: news.header,
                    subheader: news.subheader
                });
            });
            
            // Interleave branded messages with regular news (every 3-4 items)
            let newsIndex = 0;
            let brandedIndex = 0;
            
            while (newsIndex < regularNews.length || brandedIndex < brandedMessages.length) {
                // Add 3 news items
                for (let i = 0; i < 3 && newsIndex < regularNews.length; i++) {
                    rotationPool.push({
                        header: regularNews[newsIndex].header,
                        subheader: regularNews[newsIndex].subheader
                    });
                    newsIndex++;
                }
                
                // Add 1 branded message
                if (brandedIndex < brandedMessages.length) {
                    rotationPool.push(brandedMessages[brandedIndex]);
                    brandedIndex++;
                }
            }
            
            // If no news at all, ensure branded messages are there
            if (rotationPool.length === 0) {
                return brandedMessages;
            }
            
            return rotationPool;
        }
        
        // Get top 24 players by position based on fantasy points
        function getTop24PlayersByPosition() {
            const top24Set = new Set();
            
            // Helper to get top 24 from a position dataset
            const addTop24 = (data, position) => {
                if (!data || data.length === 0) return;
                
                // Calculate average fantasy points per game for each player
                const playerAvgs = {};
                data.forEach(row => {
                    const player = row.Player;
                    if (!playerAvgs[player]) {
                        playerAvgs[player] = { total: 0, games: 0 };
                    }
                    
                    const points = parseFloat(row.Ft_Points || row['Ft Points'] || 0);
                    if (points > 0) {
                        playerAvgs[player].total += points;
                        playerAvgs[player].games += 1;
                    }
                });
                
                // Calculate averages and sort
                const sortedPlayers = Object.entries(playerAvgs)
                    .map(([name, stats]) => ({
                        name,
                        avg: stats.games > 0 ? stats.total / stats.games : 0
                    }))
                    .filter(p => p.avg > 0)
                    .sort((a, b) => b.avg - a.avg)
                    .slice(0, 24);
                
                sortedPlayers.forEach(p => top24Set.add(p.name));
            };
            
            // Add top 24 from each position
            addTop24(window.wrData, 'WR');
            addTop24(window.rbData, 'RB');
            addTop24(window.teData, 'TE');
            
            return top24Set;
        }
        
        
// Render Market Ticker with Real Data
// Removed duplicate renderMarketTicker


function rotateStatusText() {
            const headlineEl = document.getElementById('statusHeadline');
            const subheadlineEl = document.getElementById('statusSubheadline');
            
            if (!headlineEl || !subheadlineEl) return;
            
            headlineEl.style.opacity = '0';
            subheadlineEl.style.opacity = '0';
            
            setTimeout(() => {
                const messages = buildRotationMessages();
                headlineIndex = (headlineIndex + 1) % messages.length;
                
                const currentMessage = messages[headlineIndex];
                headlineEl.textContent = currentMessage.header;
                subheadlineEl.textContent = currentMessage.subheader;
                
                headlineEl.style.opacity = '1';
                subheadlineEl.style.opacity = '1';
            }, 500);
        }
        
        // Fetch news on page load and refresh periodically
        async function initializeNewsRotation() {
            await fetchSleeperNews();
            rotateStatusText(); // Trigger first rotation with news
        }
        
        setInterval(rotateStatusText, 7500); // 50% slower (was 5000ms, now 7500ms)
        setInterval(fetchSleeperNews, NEWS_FETCH_INTERVAL); // Refresh news every 5 minutes
        
        window.addEventListener('DOMContentLoaded', initializeViz);
        
        // Initialize news on page load (after data is loaded)
        window.addEventListener('DOMContentLoaded', () => {
            setTimeout(initializeNewsRotation, 2000); // Wait for data to load first
        });

// ========================================
// START/SIT COMPARISON TOOL JAVASCRIPT
// ========================================

let comparisonPlayersData = [];
let isExpandedMetrics = false;
let selectedPlayer1 = null;
let selectedPlayer2 = null;

// Initialize comparison tool when page loads
function initializeComparisonTool() {
    if (!window.wrData && !window.rbData && !window.teData) {
        console.log('Data not loaded yet, waiting...');
        setTimeout(initializeComparisonTool, 500);
        return;
    }
    
    console.log('Initializing comparison tool...');
    loadComparisonPlayersData();
    
    // Update scoring format display
    const scoringDisplay = document.getElementById('scoring-format-display');
    if (scoringDisplay) {
        const formatMap = { 'ppr': 'PPR', 'half': 'Half-PPR', 'std': 'Standard' };
        scoringDisplay.textContent = formatMap[currentScoringFormat] || 'PPR';
    }
    
    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.comparison-player-search')) {
            hideAllDropdowns();
        }
    });
}

// Load and aggregate player data
function loadComparisonPlayersData() {
    comparisonPlayersData = [];
    
    // Aggregate all players with their stats
    const positions = [
        { data: window.wrData, pos: 'WR' },
        { data: window.rbData, pos: 'RB' },
        { data: window.teData, pos: 'TE' }
    ];
    
    positions.forEach(({ data, pos }) => {
        if (!data) {
            console.warn(`${pos} data not loaded yet`);
            return;
        }
        
        console.log(`Loading ${pos} players from ${data.length} rows`);
        
        const playerStats = {};
        
        data.forEach(row => {
            const name = row.Player;
            const week = parseInt(row.Week);
            
            if (!playerStats[name]) {
                playerStats[name] = {
                    name: name,
                    position: pos,
                    team: row.Team,
                    weeks: [],
                    totalPoints: 0,
                    games: 0
                };
            }
            
            const fpts = parseFloat(row.FPTS) || 0;
            
            // Parse snap % - try all possible field name variations (case-sensitive and variations)
            let snapPct = 0;
            const snapFields = [
                'SNAP_PCT', 'Snap_Pct', 'snap_pct', 
                'Snap %', 'Snap%', 'snap%', 'SNAP%',
                'Snap', 'SNAP',
                'Snap_Count', 'SNAP_COUNT', 'snap_count',
                'Team_Total_Snaps', 'Total_Snaps'
            ];
            
            for (let field of snapFields) {
                if (row[field] !== undefined && row[field] !== null && row[field] !== '') {
                    snapPct = parseFloat(row[field]);
                    if (!isNaN(snapPct)) {
                        // Handle different snap % formats:
                        // - Decimal (0.855) â†’ multiply by 100 to get 85.5%
                        // - Whole number (85) â†’ already a percentage, keep as-is
                        // - Large decimal (85.5) â†’ already a percentage, keep as-is
                        if (snapPct > 0 && snapPct < 1) {
                            snapPct = snapPct * 100;
                        }
                        // snapPct is now in percentage form (0-100 range)
                        
                        // Debug: Log for first RB row to see what field and value we're getting
                        if (pos === 'RB' && !playerStats[name].debugLogged) {
                            console.log(`[${pos}] ${name} Week ${week} - Found snap in field "${field}": ${row[field]} â†’ ${snapPct}%`);
                            playerStats[name].debugLogged = true;
                        }
                        break;
                    }
                }
            }
            
            // If we still have 0, try case-insensitive search for any field containing "snap" and "pct" or just "snap"
            if (snapPct === 0) {
                const allFields = Object.keys(row);
                const snapField = allFields.find(f => 
                    f.toLowerCase().includes('snap') && f.toLowerCase().includes('pct')
                ) || allFields.find(f => f.toLowerCase() === 'snap');
                
                if (snapField && row[snapField] !== undefined && row[snapField] !== null && row[snapField] !== '') {
                    snapPct = parseFloat(row[snapField]);
                    if (!isNaN(snapPct) && snapPct > 0) {
                        if (snapPct > 0 && snapPct < 1) {
                            snapPct = snapPct * 100;
                        }
                        if (pos === 'RB' && !playerStats[name].debugLogged) {
                            console.log(`[${pos}] ${name} Week ${week} - Found snap via search in field "${snapField}": ${row[snapField]} â†’ ${snapPct}%`);
                            playerStats[name].debugLogged = true;
                        }
                    }
                }
            }
            
            // If we still have 0, log all available fields for debugging
            if (snapPct === 0 && pos === 'RB' && !playerStats[name].fieldsLogged) {
                console.log(`[${pos}] ${name} available snap-related fields:`, Object.keys(row).filter(k => k.toLowerCase().includes('snap')));
                console.log(`[${pos}] ${name} sample data for Snap_Pct:`, row['Snap_Pct']);
                playerStats[name].fieldsLogged = true;
            }
            
            // Parse target share - try all variations for ALL positions (RBs catch passes too!)
            let targetShare = 0;
            const targetFields = ['% TM', '%TM', 'Target Share', 'Target%', 'TGT%', '%_TM', 'PCT_TM'];
            for (let field of targetFields) {
                if (row[field] !== undefined && row[field] !== null && row[field] !== '') {
                    targetShare = parseFloat(row[field]);
                    if (!isNaN(targetShare)) {
                        // If target share is stored as decimal (0.275 instead of 27.5), convert it
                        if (targetShare > 0 && targetShare < 1) {
                            targetShare = targetShare * 100;
                        }
                        break;
                    }
                }
            }
            
            // Parse targets for ALL positions
            const targets = parseInt(row.TGT) || 0;
            
            // Parse rush attempts for RBs - try all variations
            let rushAttempts = 0;
            if (pos === 'RB') {
                const rushFields = ['Rush Att', 'RUSH_ATT', 'rush_att', 'RushAtt', 'ATT', 'Att'];
                for (let field of rushFields) {
                    if (row[field] !== undefined && row[field] !== null && row[field] !== '') {
                        rushAttempts = parseInt(row[field]);
                        if (!isNaN(rushAttempts)) break;
                    }
                }
            }
            
            playerStats[name].weeks.push({
                week: week,
                fpts: fpts,
                snapPct: snapPct,
                targetShare: targetShare,
                targets: targets,
                rushAttempts: pos === 'RB' ? rushAttempts : null
            });
            
            playerStats[name].totalPoints += fpts;
            playerStats[name].games += 1;
        });
        
        // Debug: Log first player's data to see what fields we have
        if (Object.keys(playerStats).length > 0) {
            const firstPlayer = Object.keys(playerStats)[0];
            console.log(`Sample ${pos} data for ${firstPlayer}:`, playerStats[firstPlayer].weeks[0]);
        }
        
        // Calculate aggregated stats
        Object.keys(playerStats).forEach(name => {
            const player = playerStats[name];
            player.ppg = player.games > 0 ? player.totalPoints / player.games : 0;
            
            // Calculate floor and ceiling (15th and 85th percentile for realistic ranges)
            const sortedPoints = player.weeks.map(w => w.fpts).sort((a, b) => a - b);
            player.floor = sortedPoints[Math.floor(sortedPoints.length * 0.15)] || 0;
            player.ceiling = sortedPoints[Math.floor(sortedPoints.length * 0.85)] || 0;
            
            // Store all game scores for distribution curve
            player.gameScores = sortedPoints;
            
            // Calculate consistency (standard deviation)
            const mean = player.ppg;
            const variance = player.weeks.reduce((sum, w) => sum + Math.pow(w.fpts - mean, 2), 0) / player.weeks.length;
            player.stdDev = Math.sqrt(variance);
            
            // Average snap percentage - be more lenient with filtering
            // Count weeks where snapPct exists and is not exactly 0 (could be very small decimals)
            const weeksWithSnaps = player.weeks.filter(w => w.snapPct !== undefined && w.snapPct !== null && w.snapPct > 0);
            player.avgSnapPct = weeksWithSnaps.length > 0 
                ? weeksWithSnaps.reduce((sum, w) => sum + w.snapPct, 0) / weeksWithSnaps.length 
                : 0;
            
            // If still 0 but we have weeks data, log it for debugging
            if (player.avgSnapPct === 0 && player.weeks.length > 0 && pos === 'RB') {
                console.log(`[${pos}] ${name} - avgSnapPct is 0. Sample week snapPct values:`, 
                    player.weeks.slice(0, 3).map(w => w.snapPct));
            }
            
            // Average targets for all positions
            player.avgTargets = player.weeks.reduce((sum, w) => sum + (w.targets || 0), 0) / player.weeks.length;
            
            // Calculate target share differently for RBs vs WR/TE
            if (pos === 'RB') {
                // For RBs: Calculate target share as (RB targets / ALL team targets including WR/TE/RB) per week
                let validWeeksTargetShare = 0;
                let totalTargetSharePct = 0;
                
                player.weeks.forEach(week => {
                    if (week.targets > 0) {
                        // Find ALL players (WR/TE/RB) on the same team in the same week to calculate team total targets
                        const allPositions = [
                            ...(window.wrData || []),
                            ...(window.rbData || []),
                            ...(window.teData || [])
                        ];
                        
                        const teamPlayersThisWeek = allPositions.filter(row => 
                            row.Team === player.team && 
                            parseInt(row.Week) === week.week
                        );
                        
                        const teamTotalTargets = teamPlayersThisWeek.reduce((sum, row) => sum + (parseInt(row.TGT) || 0), 0);
                        
                        if (teamTotalTargets > 0) {
                            const weekTargetShare = (week.targets / teamTotalTargets) * 100;
                            totalTargetSharePct += weekTargetShare;
                            validWeeksTargetShare++;
                        }
                    }
                });
                
                player.avgTargetShare = validWeeksTargetShare > 0 ? totalTargetSharePct / validWeeksTargetShare : 0;
                
                // Average rush attempts
                const weeksWithRushes = player.weeks.filter(w => w.rushAttempts > 0);
                player.avgRushAttempts = weeksWithRushes.length > 0
                    ? weeksWithRushes.reduce((sum, w) => sum + w.rushAttempts, 0) / weeksWithRushes.length
                    : 0;
            } else {
                // For WR/TE: Use the % TM field from the data
                const weeksWithTargets = player.weeks.filter(w => w.targetShare > 0);
                player.avgTargetShare = weeksWithTargets.length > 0 
                    ? weeksWithTargets.reduce((sum, w) => sum + w.targetShare, 0) / weeksWithTargets.length 
                    : 0;
            }
            
            // Debug logging for first player of each position
            if (name === Object.keys(playerStats)[0]) {
                console.log(`${pos} ${name}:`);
                console.log(`  Snap%: ${player.avgSnapPct.toFixed(1)}% (${weeksWithSnaps.length}/${player.weeks.length} weeks with snaps)`);
                console.log(`  Sample week snap data:`, player.weeks[0]?.snapPct);
                if (pos !== 'RB') {
                    console.log(`  Target Share: ${player.avgTargetShare.toFixed(1)}%`);
                } else {
                    console.log(`  Target Share: ${player.avgTargetShare.toFixed(1)}% (calculated from team totals)`);
                    console.log(`  Avg Rush Att: ${player.avgRushAttempts.toFixed(1)}`);
                }
            }
            
            // Calculate momentum (last 3 weeks vs previous 3 weeks)
            if (player.weeks.length >= 6) {
                const recent3 = player.weeks.slice(-3).reduce((sum, w) => sum + w.fpts, 0) / 3;
                const prev3 = player.weeks.slice(-6, -3).reduce((sum, w) => sum + w.fpts, 0) / 3;
                player.momentum = recent3 - prev3;
            } else {
                player.momentum = 0;
            }
            
            // Only include players with at least 3 games played
            if (player.games >= 3) {
                comparisonPlayersData.push(player);
            }
        });
    });
    
    // Sort by PPG descending
    comparisonPlayersData.sort((a, b) => b.ppg - a.ppg);
    
    // Log position breakdown
    const positionCounts = {
        'WR': comparisonPlayersData.filter(p => p.position === 'WR').length,
        'RB': comparisonPlayersData.filter(p => p.position === 'RB').length,
        'TE': comparisonPlayersData.filter(p => p.position === 'TE').length
    };
    console.log(`Loaded ${comparisonPlayersData.length} players for comparison:`, positionCounts);
}

// Filter players based on search input
function filterPlayers(playerNum) {
    const searchInput = document.getElementById(`player${playerNum}-search`);
    const dropdown = document.getElementById(`player${playerNum}-dropdown`);
    const searchTerm = searchInput.value.toLowerCase().trim();
    
    if (searchTerm.length === 0) {
        // Show top 10 players when empty
        const topPlayers = comparisonPlayersData.slice(0, 10);
        populateDropdown(playerNum, topPlayers);
    } else {
        // Filter players by name
        const filtered = comparisonPlayersData.filter(player => 
            player.name.toLowerCase().includes(searchTerm)
        ).slice(0, 50); // Limit to 50 results
        
        populateDropdown(playerNum, filtered);
    }
    
    dropdown.classList.add('show');
}

// Show dropdown when input is focused
function showDropdown(playerNum) {
    const searchInput = document.getElementById(`player${playerNum}-search`);
    const searchTerm = searchInput.value.toLowerCase().trim();
    
    if (searchTerm.length === 0) {
        // Show top 10 players
        const topPlayers = comparisonPlayersData.slice(0, 10);
        populateDropdown(playerNum, topPlayers);
    } else {
        filterPlayers(playerNum);
    }
}

// Populate dropdown with players
function populateDropdown(playerNum, players) {
    const dropdown = document.getElementById(`player${playerNum}-dropdown`);
    const searchInput = document.getElementById(`player${playerNum}-search`);
    dropdown.innerHTML = '';
    
    // Move dropdown to body if it isn't already
    if (dropdown.parentElement !== document.body) {
        document.body.appendChild(dropdown);
    }
    
    if (players.length === 0) {
        dropdown.innerHTML = '<div class="search-dropdown-item" style="text-align: center; color: var(--text-tertiary);">No players found</div>';
        return;
    }
    
    players.forEach(player => {
        const item = document.createElement('div');
        item.className = 'search-dropdown-item';
        
        const teamColor = teamColors[player.team] || '#666';
        
        item.innerHTML = `
            <div class="comparison-team-logo" style="background: ${teamColor};">
                ${player.team}
            </div>
            <div class="search-dropdown-item-content">
                <div class="search-dropdown-item-name">${player.name}</div>
                <div class="search-dropdown-item-info">${player.position} â€¢ ${player.team} â€¢ ${player.ppg.toFixed(1)} PPG</div>
            </div>
        `;
        item.onclick = () => selectPlayer(playerNum, player);
        dropdown.appendChild(item);
    });
    
    // Position the dropdown using fixed positioning
    positionDropdown(playerNum);
    
    dropdown.classList.add('show');
}

// Position dropdown relative to input using fixed positioning
function positionDropdown(playerNum) {
    const searchInput = document.getElementById(`player${playerNum}-search`);
    const dropdown = document.getElementById(`player${playerNum}-dropdown`);
    
    if (!searchInput || !dropdown) return;
    
    const rect = searchInput.getBoundingClientRect();
    dropdown.style.top = `${rect.bottom + 4}px`;
    dropdown.style.left = `${rect.left}px`;
    dropdown.style.width = `${rect.width}px`;
}

// Reposition dropdown on window resize
window.addEventListener('resize', () => {
    // Reposition any open dropdowns
    [1, 2].forEach(playerNum => {
        const dropdown = document.getElementById(`player${playerNum}-dropdown`);
        if (dropdown && dropdown.classList.contains('show')) {
            positionDropdown(playerNum);
        }
    });
});

// Reposition dropdown on scroll
window.addEventListener('scroll', () => {
    // Reposition any open dropdowns
    [1, 2].forEach(playerNum => {
        const dropdown = document.getElementById(`player${playerNum}-dropdown`);
        if (dropdown && dropdown.classList.contains('show')) {
            positionDropdown(playerNum);
        }
    });
});

// Select a player from dropdown
function selectPlayer(playerNum, player) {
    const searchInput = document.getElementById(`player${playerNum}-search`);
    const dropdown = document.getElementById(`player${playerNum}-dropdown`);
    
    searchInput.value = player.name;
    dropdown.classList.remove('show');
    
    if (playerNum === 1) {
        selectedPlayer1 = player;
    } else {
        selectedPlayer2 = player;
    }
    
    // Update comparison if both players are selected
    if (selectedPlayer1 && selectedPlayer2) {
        updateComparison();
    }
}

// Hide all dropdowns
function hideAllDropdowns() {
    document.querySelectorAll('.search-dropdown').forEach(dropdown => {
        dropdown.classList.remove('show');
    });
}

// Update comparison when players are selected
function updateComparison() {
    if (!selectedPlayer1 || !selectedPlayer2) {
        document.getElementById('comparison-results').style.display = 'none';
        return;
    }
    
    const player1 = selectedPlayer1;
    const player2 = selectedPlayer2;
    
    // Show results
    document.getElementById('comparison-results').style.display = 'block';
    
    // Update player names with team logos
    const player1NameEl = document.getElementById('player1-name');
    const player2NameEl = document.getElementById('player2-name');
    
    const player1Color = teamColors[player1.team] || '#666';
    const player2Color = teamColors[player2.team] || '#666';
    
    player1NameEl.innerHTML = `
        <div class="comparison-player-name-container">
            <div class="comparison-player-logo" style="background: ${player1Color};">
                ${player1.team}
            </div>
            <div class="comparison-player-name-text">${player1.name}</div>
        </div>
    `;
    
    player2NameEl.innerHTML = `
        <div class="comparison-player-name-container">
            <div class="comparison-player-logo" style="background: ${player2Color};">
                ${player2.team}
            </div>
            <div class="comparison-player-name-text">${player2.name}</div>
        </div>
    `;
    
    // Generate metrics
    generateCoreMetrics(player1, player2);
    generateExpandedMetrics(player1, player2);
    
    // Generate recommendation
    generateRecommendation(player1, player2);
    
    // Generate visual comparisons
    generateMiniStats(player1, player2);
    
    // Reset expanded state
    isExpandedMetrics = false;
    document.getElementById('expanded-metrics').style.display = 'none';
    document.getElementById('expand-btn').textContent = 'Show More Stats â–¼';
}

// Generate core metrics (always visible)
function generateCoreMetrics(player1, player2) {
    const coreMetricsContainer = document.getElementById('core-metrics');
    coreMetricsContainer.innerHTML = '';
    
    // Reordered: Target Share and Avg Targets/Rush Att at top, then Floor/Ceiling/Momentum
    const metrics = [
        { label: 'Target Share', p1: player1.avgTargetShare, p2: player2.avgTargetShare, format: 'percent' },
    ];
    
    // Add position-specific metric (Avg Targets or Avg Rush Attempts)
    if (player1.position === 'RB' || player2.position === 'RB') {
        metrics.push({ label: 'Avg Rush Attempts', p1: player1.avgRushAttempts, p2: player2.avgRushAttempts, format: 'decimal' });
    } else {
        metrics.push({ label: 'Avg Targets', p1: player1.avgTargets, p2: player2.avgTargets, format: 'decimal' });
    }
    
    // Add Floor, Ceiling, Momentum
    metrics.push(
        { label: 'Floor', p1: player1.floor, p2: player2.floor, format: 'decimal' },
        { label: 'Ceiling', p1: player1.ceiling, p2: player2.ceiling, format: 'decimal' },
        { label: 'Momentum', p1: player1.momentum, p2: player2.momentum, format: 'momentum' }
    );
    
    metrics.forEach(metric => {
        const row = createMetricRow(metric, player1, player2);
        coreMetricsContainer.appendChild(row);
    });
}

// Generate expanded metrics (shown on click)
function generateExpandedMetrics(player1, player2) {
    const expandedMetricsContainer = document.getElementById('expanded-metrics');
    expandedMetricsContainer.innerHTML = '';
    
    const metrics = [
        { label: 'Consistency (Ïƒ)', p1: player1.stdDev, p2: player2.stdDev, format: 'decimal', lowerIsBetter: true },
        { label: 'Games Played', p1: player1.games, p2: player2.games, format: 'integer' }
    ];
    
    // Add rush attempts if either player is an RB
    if (player1.position === 'RB' || player2.position === 'RB') {
        metrics.push(
            { label: 'Avg Rush Att', p1: player1.avgRushAttempts || 0, p2: player2.avgRushAttempts || 0, format: 'decimal' }
        );
    }
    
    metrics.forEach(metric => {
        const row = createMetricRow(metric, player1, player2);
        expandedMetricsContainer.appendChild(row);
    });
}

// Create a metric row
function createMetricRow(metric, player1, player2) {
    const row = document.createElement('div');
    row.className = 'comparison-metric-row';
    
    const p1Value = formatMetricValue(metric.p1, metric.format);
    const p2Value = formatMetricValue(metric.p2, metric.format);
    
    // Determine winner (handle "lower is better" metrics)
    let p1Wins = metric.lowerIsBetter ? metric.p1 < metric.p2 : metric.p1 > metric.p2;
    let p2Wins = !p1Wins && metric.p1 !== metric.p2;
    
    row.innerHTML = `
        <div class="comparison-metric-value left ${p1Wins ? 'winner' : (p2Wins ? 'loser' : '')}">${p1Value}</div>
        <div class="comparison-metric-label">${metric.label}</div>
        <div class="comparison-metric-value right ${p2Wins ? 'winner' : (p1Wins ? 'loser' : '')}">${p2Value}</div>
    `;
    
    return row;
}

// Format metric values
function formatMetricValue(value, format) {
    if (value === null || value === undefined || isNaN(value)) return '--';
    
    switch(format) {
        case 'decimal':
            return value.toFixed(1);
        case 'percent':
            return value.toFixed(1) + '%';
        case 'integer':
            return Math.round(value).toString();
        case 'momentum':
            return (value >= 0 ? '+' : '') + value.toFixed(1);
        default:
            return value.toString();
    }
}

// Toggle expanded metrics
function toggleExpandedMetrics() {
    isExpandedMetrics = !isExpandedMetrics;
    const expandedDiv = document.getElementById('expanded-metrics');
    const expandBtn = document.getElementById('expand-btn');
    
    if (isExpandedMetrics) {
        expandedDiv.style.display = 'block';
        expandBtn.textContent = 'Show Less Stats â–²';
    } else {
        expandedDiv.style.display = 'none';
        expandBtn.textContent = 'Show More Stats â–¼';
    }
}

// Generate recommendation
function generateRecommendation(player1, player2) {
    // Calculate scores for each player
    const p1Score = calculatePlayerScore(player1);
    const p2Score = calculatePlayerScore(player2);
    
    // Determine winner
    const winner = p1Score > p2Score ? player1 : player2;
    const loser = p1Score > p2Score ? player2 : player1;
    const winnerScore = Math.max(p1Score, p2Score);
    const loserScore = Math.min(p1Score, p2Score);
    
    // Calculate confidence (percentage difference)
    const scoreDiff = winnerScore - loserScore;
    const confidence = Math.min(95, Math.round(50 + (scoreDiff / 2)));
    
    // Update player names highlighting
    const player1NameEl = document.getElementById('player1-name');
    const player2NameEl = document.getElementById('player2-name');
    
    player1NameEl.classList.remove('recommended');
    player2NameEl.classList.remove('recommended');
    
    if (winner.name === player1.name) {
        player1NameEl.classList.add('recommended');
    } else {
        player2NameEl.classList.add('recommended');
    }
    
    // Generate reason
    const reason = generateRecommendationReason(winner, loser);
    
    // Update UI
    document.getElementById('recommendation-text').textContent = `Start ${winner.name}`;
    document.getElementById('recommendation-reason').textContent = reason;
    document.getElementById('confidence-score').textContent = confidence + '%';
}

// Calculate player score for recommendation
function calculatePlayerScore(player) {
    let score = 0;
    
    // PPG (40% weight)
    score += player.ppg * 4;
    
    // Floor (20% weight)
    score += player.floor * 2;
    
    // Momentum (20% weight)
    score += player.momentum * 2;
    
    // Snap % (10% weight)
    score += player.avgSnapPct * 0.1;
    
    // Consistency bonus (10% weight) - lower std dev is better
    score += (20 - player.stdDev) * 0.5;
    
    return score;
}

// Generate recommendation reason
function generateRecommendationReason(winner, loser) {
    const reasons = [];
    
    if (winner.ppg > loser.ppg + 2) {
        reasons.push('higher scoring average');
    }
    
    if (winner.floor > loser.floor + 2) {
        reasons.push('safer floor');
    }
    
    if (winner.ceiling > loser.ceiling + 5) {
        reasons.push('elite upside');
    }
    
    if (winner.momentum > 2 && winner.momentum > loser.momentum) {
        reasons.push('positive momentum');
    }
    
    if (winner.stdDev < loser.stdDev - 2) {
        reasons.push('more consistent');
    }
    
    if (winner.avgSnapPct > loser.avgSnapPct + 10) {
        reasons.push('higher snap share');
    }
    
    if (reasons.length === 0) {
        return 'Overall metrics slightly favor this player';
    }
    
    if (reasons.length === 1) {
        return reasons[0].charAt(0).toUpperCase() + reasons[0].slice(1);
    }
    
    return reasons.slice(0, 2).join(' and ').charAt(0).toUpperCase() + 
           reasons.slice(0, 2).join(' and ').slice(1);
}

// Generate Mini Stat Bars - FPTS/G, Snap%, Target Share, Avg Targets/Rush Attempts
function generateMiniStats(player1, player2) {
    const miniStatsContainer = document.getElementById('mini-stats');
    
    // Get team colors for each player
    const p1Color = teamColors[player1.team] || '#0a84ff';
    const p2Color = teamColors[player2.team] || '#0a84ff';
    
    // Determine 4th stat based on position
    let fourthStat;
    if (player1.position === 'RB' || player2.position === 'RB') {
        // If either player is RB, show Avg Rush Attempts
        fourthStat = { 
            label: 'Avg Rush Att', 
            p1: player1.avgRushAttempts || 0, 
            p2: player2.avgRushAttempts || 0, 
            format: '' 
        };
    } else {
        // Otherwise show Avg Targets
        fourthStat = { 
            label: 'Avg Targets', 
            p1: player1.avgTargets || 0, 
            p2: player2.avgTargets || 0, 
            format: '' 
        };
    }
    
    const miniStats = [
        { label: 'FPTS/G', p1: player1.ppg, p2: player2.ppg, format: '' },
        { label: 'Snap %', p1: player1.avgSnapPct || 0, p2: player2.avgSnapPct || 0, format: '%' },
        { label: 'Target Share', p1: player1.avgTargetShare || 0, p2: player2.avgTargetShare || 0, format: '%' },
        fourthStat
    ];
    
    miniStatsContainer.innerHTML = miniStats.map(stat => {
        const maxValue = Math.max(stat.p1, stat.p2);
        const p1Height = maxValue > 0 ? (stat.p1 / maxValue) * 100 : 50;
        const p2Height = maxValue > 0 ? (stat.p2 / maxValue) * 100 : 50;
        
        const p1Winner = stat.p1 > stat.p2;
        const p2Winner = stat.p2 > stat.p1;
        
        // Add opacity for non-winners
        const p1Opacity = p1Winner ? '1' : '0.5';
        const p2Opacity = p2Winner ? '1' : '0.5';
        
        return `
            <div class="comparison-mini-stat">
                <div class="comparison-mini-stat-label">${stat.label}</div>
                <div class="comparison-mini-bars">
                    <div class="comparison-mini-bar-container">
                        <div class="comparison-mini-bar-value">${stat.p1.toFixed(1)}${stat.format}</div>
                        <div class="comparison-mini-bar">
                            <div class="comparison-mini-bar-fill ${p1Winner ? 'winner' : ''}" 
                                 style="height: ${p1Height}%; background: ${p1Color}; opacity: ${p1Opacity};"></div>
                        </div>
                        <div class="comparison-mini-player-label">P1</div>
                    </div>
                    <div class="comparison-mini-bar-container">
                        <div class="comparison-mini-bar-value">${stat.p2.toFixed(1)}${stat.format}</div>
                        <div class="comparison-mini-bar">
                            <div class="comparison-mini-bar-fill ${p2Winner ? 'winner' : ''}" 
                                 style="height: ${p2Height}%; background: ${p2Color}; opacity: ${p2Opacity};"></div>
                        </div>
                        <div class="comparison-mini-player-label">P2</div>
                    </div>
                </div>
            </div>
        `;
    }).join('');
}

// Initialize when navigating to Start/Sit page
document.addEventListener('DOMContentLoaded', () => {
    // Wait a bit for data to load
    setTimeout(initializeComparisonTool, 1000);
});

</script></body></html>

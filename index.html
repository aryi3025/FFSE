<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FFSE - Fantasy Football Stock Exchange</title>
    
    <!-- Open Graph Meta Tags for Link Previews -->
    <meta property="og:title" content="FFSE">
    <meta property="og:description" content="Advanced Fantasy Football Analytics">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://ffexchange.vercel.app/">
    <meta property="og:image" content="https://ffexchange.vercel.app/og-image.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="FFSE">
    <meta name="twitter:description" content="Advanced Fantasy Football Analytics">
    <meta name="twitter:image" content="https://ffexchange.vercel.app/og-image.png">
    
    <!-- Additional Meta Tags -->
    <meta name="description" content="FFSE - Advanced Fantasy Football Analytics">
    <meta name="theme-color" content="#000000">
    
    <!--
    FFSE - Fantasy Football Stock Exchange
    Version: v92

    LATEST UPDATES (v92):
    - ✅ NEW: Analytics Dashboard - comprehensive position performance heatmap
    - ✅ Position heatmap with dropdown selector (WR/RB/TE)
    - ✅ Diagonal arrow indicators showing performance nuance (5-level spectrum)
    - ✅ Color-coded cards with 9-level gradient (extreme under to extreme over)
    - ✅ Time period filters: Season Avg, This Week, Last 3, Last 5
    - ✅ Multiple metrics: Actual vs Expected, Target Share, RZ Opportunity, PPTouch, etc.
    - ✅ Market Opportunities section: Buy Low / Sell High recommendations
    - ✅ Renamed old "Dashboard" to "Leaderboards"
    - ✅ Analytics Dashboard is now the first tab
    - ✅ Clickable cards open player modals with full analytics

    PREVIOUS UPDATES (v90):
    - ✅ Added new "Floor Metrics" tab to player modal
    - ✅ Implemented Option B design: radial progress circles with hover tooltips
    - ✅ Moved Fragility Score and Ghost Rate from stats section to dedicated tab
    - ✅ Using negative framing (lower = better) for both metrics
    - ✅ Fragility Score breakdown: TD Dependency, Week Variance, Volume Penalty
    - ✅ Ghost Rate breakdown: Playable/Boom/Bust games
    - ✅ Color-coded radial charts: Green (<33), Yellow (33-67), Red (>67)
    - ✅ Mobile touch support for tooltips (tap to toggle)
    - ✅ Removed empty Reliability & Consistency stats page

    PREVIOUS UPDATES (v89):
    - ✅ Moved community sentiment to top right corner of player modal header
    - ✅ Redesigned sentiment bar to be more subtle (thin 8px bar)
    - ✅ Simplified sentiment display - removed dominant label, keeping just bar + vote count
    - ✅ Improved mobile responsiveness for header sentiment section
    - ✅ Moved vote buttons outside of sentiment section for cleaner layout
    - ✅ Added "Points per Target" metric for WR/TE in Advanced Analytics
    - ✅ Added "Points per Opportunity" metric for RB in Advanced Analytics
    - ✅ New efficiency metrics available in X/Y axis dropdowns
    - ✅ Moved X/Y axis controls inside chart container in Advanced Analytics
    - ✅ Removed collapsible behavior from axis controls - always visible now
    - ✅ Fixed team modal player names to white color (12px font)
    - ✅ Fixed player modal name to white (removed team color)
    - ✅ Added Player Reliability Score (PRS) tab with circular gauge
    - ✅ PRS combines usage (40%), RZ role (30%), consistency (20%), games (10%)
    - ✅ 4 component mini bars showing each factor's contribution
    - ✅ Color-coded gauge: green (70+), yellow (40-69), red (<40)

    PREVIOUS UPDATES (v87-v88):
    - ✅ Beautiful initial loading screen with progress tracking
    - ✅ Animated logo with pulsing effect
    - ✅ Real-time progress updates during data fetch
    - ✅ Smooth fade-out transition when loading complete
    - ✅ Progress stages: 10% Connect → 30% Download → 50-75% Parse → 80-90% Calculate → 95-100% Render

    FEATURES:
    - Auto-fetch data from GitHub repository
    - WR/RB/TE rankings with tier-based organization
    - Advanced analytics with interactive scatter plots
    - Team outlook with offensive identity analysis
    - Community sentiment voting system
    - Mobile-responsive design

    GitHub Data Repository: https://github.com/aryi3025/ffse-data

    Full changelog: See CHANGELOG.md
    
    ============================================
    QUICK NAVIGATION GUIDE (Use Ctrl+F / Cmd+F)
    ============================================
    
    CSS SECTIONS:
    - Search: "1. BASE & RESET" - Root variables & base styles
    - Search: "2. LAYOUT" - Page structure & grid
    - Search: "3. HEADER" - Top navigation bar
    - Search: "4. TICKER" - Top movers ticker
    - Search: "5. TABLES" - Player rankings tables
    - Search: "6. CARDS" - Player cards & team cards
    - Search: "7. CHARTS" - Scatter plots & visualizations
    - Search: "8. SENTIMENT" - Voting system styles
    - Search: "9. MODAL" - Popup overlays
    - Search: "10. UPLOAD" - Admin panel
    - Search: "11. RESPONSIVE" - Mobile breakpoints
    - Search: "12. UTILITIES" - Helper classes
    
    JAVASCRIPT SECTIONS:
    - Search: "// DATA LAYER" - Global variables
    - Search: "// LOADING SCREEN" - Initial load animation
    - Search: "// DATA FETCHING" - GitHub data fetch
    - Search: "// WR FUNCTIONS" - Wide receiver logic
    - Search: "// RB FUNCTIONS" - Running back logic  
    - Search: "// TE FUNCTIONS" - Tight end logic
    - Search: "// DASHBOARD" - Main dashboard page
    - Search: "// TEAM ANALYSIS" - Team breakdown page
    - Search: "// LEADERBOARDS" - All leaderboards page
    - Search: "// SENTIMENT" - Voting system
    - Search: "// UTILITIES" - Helper functions
    
    ============================================
    -->

    <!-- External Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <style>
        /* ============================================
           1. BASE & RESET
           ============================================ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Background Colors */
            --bg-primary: #000;
            --bg-secondary: #0a0a0a;
            --bg-tertiary: #1c1c1e;
            --bg-elevated: #2c2c2e;

            /* Text Colors */
            --text-primary: #fff;
            --text-secondary: #8e8e93;
            --text-tertiary: #636366;

            /* Accent Colors */
            --positive: #30d158;
            --positive-bg: rgba(48, 209, 88, 0.15);
            --negative: #ff453a;
            --negative-bg: rgba(255, 69, 58, 0.15);

            /* UI Elements */
            --border-color: #1c1c1e;
            --border-color-light: #2c2c2e;

            /* Spacing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', system-ui, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow-x: hidden;
        }

        /* ============================================
           2. LAYOUT
           ============================================ */
        .app-container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .main-content {
            flex: 1;
            padding: var(--spacing-lg);
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        .page {
            display: none;
            animation: fadeIn 0.3s ease-in;
        }

        .page.active {
            display: block;
        }

        @media (max-width: 768px) {
            .page {
                overflow-x: hidden;
                max-width: 100vw;
            }
        }

        /* All Leaderboards Grid */
        .all-leaderboards-wrapper {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 24px;
            padding: 24px 24px 48px;
            width: 100%;
            max-width: 100%;
            overflow: hidden;
        }

        @media (max-width: 768px) {
            .all-leaderboards-wrapper {
                grid-template-columns: 1fr !important;
                padding: 12px !important;
                gap: 16px;
                max-width: 100vw;
                overflow: hidden;
            }

            /* Ensure leaderboard cards fit on mobile */
            .all-leaderboards-wrapper > div {
                max-width: 100%;
                overflow: hidden;
                padding: 12px !important;
                box-sizing: border-box;
            }

            /* Compact player cards in leaderboards */
            .all-leaderboards-wrapper .compact-player-card,
            .all-leaderboards-wrapper .player-card {
                max-width: 100%;
                overflow: hidden;
                box-sizing: border-box;
                padding: 8px 10px !important;
                width: 100% !important;
            }

            /* Fix metric bar width on mobile */
            .compact-player-card .metric-bar-container {
                max-width: 60px !important;
                width: 60px !important;
                min-width: 60px !important;
                flex-shrink: 0;
            }
            
            .compact-player-card .compact-metric-value {
                flex-shrink: 0;
                min-width: 0;
            }

            /* PPG Leaderboard mobile */
            #ppg-leaderboard-content {
                grid-template-columns: 1fr !important;
            }
            
            /* All leaderboards grid mobile */
            #all-leaderboards-grid > div {
                grid-template-columns: 1fr !important;
            }

            .ppg-position-btn {
                flex: 1;
                padding: 8px 8px !important;
                font-size: 11px !important;
            }

            /* Page header mobile */
            #all-leaderboards .page-header {
                padding: 16px 12px !important;
            }

            #all-leaderboards .page-title {
                font-size: 20px !important;
            }

            #all-leaderboards .page-subtitle {
                font-size: 12px !important;
            }

            /* Ensure player names don't overflow */
            .compact-player-card > div {
                min-width: 0 !important;
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* ============================================
           3. HEADER
           ============================================ */
        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .ticker-section {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            overflow: hidden;
            position: sticky;
            top: 73px; /* Below header */
            z-index: 99;
            margin-bottom: 24px;
            border-radius: 0; /* Remove border radius when sticky */
        }

        .ticker-header {
            padding: 8px 24px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ticker-info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1.5px solid var(--text-tertiary);
            color: var(--text-tertiary);
            font-size: 10px;
            font-weight: 700;
            font-style: normal;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            z-index: 9999; /* High z-index for icon and its tooltip */
            flex-shrink: 0;
        }

        .ticker-info-icon:hover {
            border-color: var(--text-secondary);
            color: var(--text-secondary);
            background: rgba(255, 255, 255, 0.05);
        }

        .ticker-info-icon:active {
            transform: scale(0.95);
        }

        .ticker-tooltip {
            position: absolute;
            left: calc(100% + 8px);
            top: 50%;
            transform: translateY(-30%);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 11px;
            font-weight: 400;
            color: var(--text-primary);
            line-height: 1.4;
            white-space: normal;
            width: 300px;
            max-width: calc(100vw - 80px);
            text-transform: none;
            letter-spacing: normal;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10000; /* Very high z-index to appear above everything */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }

        .ticker-tooltip.active {
            opacity: 1;
            visibility: visible;
        }

        .ticker-tooltip::before {
            content: '';
            position: absolute;
            right: 100%;
            top: 20%;
            border: 6px solid transparent;
            border-right-color: var(--border-color);
        }

        .ticker-tooltip::after {
            content: '';
            position: absolute;
            right: 100%;
            top: 20%;
            border: 5px solid transparent;
            border-right-color: var(--bg-secondary);
            margin-right: -1px;
        }

        @media (max-width: 768px) {
            .ticker-tooltip {
                width: 260px;
                font-size: 10px;
                padding: 8px 12px;
                left: auto;
                right: -8px;
                transform: translateY(-30%) translateX(100%);
            }

            .ticker-tooltip::before {
                right: auto;
                left: 100%;
                top: 20%;
                border-right-color: transparent;
                border-left-color: var(--border-color);
            }

            .ticker-tooltip::after {
                right: auto;
                left: 100%;
                top: 20%;
                margin-right: 0;
                margin-left: -1px;
                border-right-color: transparent;
                border-left-color: var(--bg-secondary);
            }
        }

        /* Leaderboard Info Icon & Tooltip */
        .leaderboard-info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 1.5px solid var(--text-tertiary);
            color: var(--text-tertiary);
            font-size: 9px;
            font-weight: 700;
            font-style: normal;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            z-index: 9999; /* High z-index for icon and its tooltip */
            flex-shrink: 0;
            margin-left: 6px;
        }

        .leaderboard-info-icon:hover {
            border-color: var(--text-secondary);
            color: var(--text-secondary);
            background: rgba(255, 255, 255, 0.05);
        }

        .leaderboard-info-icon:active {
            transform: scale(0.95);
        }

        .leaderboard-tooltip {
            position: absolute;
            left: calc(100% + 8px);
            top: 50%;
            transform: translateY(-30%);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 11px;
            font-weight: 400;
            color: var(--text-primary);
            line-height: 1.4;
            white-space: normal;
            width: 280px;
            max-width: calc(100vw - 80px);
            text-transform: none;
            letter-spacing: normal;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10000; /* Very high z-index to appear above everything */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }

        .leaderboard-tooltip.active {
            opacity: 1;
            visibility: visible;
        }

        .leaderboard-tooltip::before {
            content: '';
            position: absolute;
            right: 100%;
            top: 20%;
            border: 6px solid transparent;
            border-right-color: var(--border-color);
        }

        .leaderboard-tooltip::after {
            content: '';
            position: absolute;
            right: 100%;
            top: 20%;
            border: 5px solid transparent;
            border-right-color: var(--bg-secondary);
            margin-right: -1px;
        }

        @media (max-width: 768px) {
            .leaderboard-tooltip {
                width: 240px;
                font-size: 10px;
                padding: 8px 12px;
            }
            
            /* Schedule tab mobile responsiveness */
            .schedule-row {
                display: flex !important;
                flex-direction: column !important;
                gap: 10px !important;
                padding: 14px 16px !important;
                grid-template-columns: unset !important;
            }
            
            .week-info {
                flex-direction: row !important;
                align-items: center;
                justify-content: flex-start;
                gap: 6px;
            }
            
            .week-label {
                font-size: 10px !important;
                text-transform: uppercase;
                color: var(--text-secondary) !important;
            }
            
            .week-number {
                font-size: 18px !important;
                font-weight: 700;
            }
            
            .matchup-info {
                justify-content: flex-end;
                margin: 0;
            }
            
            .opponent-line {
                margin-bottom: 0;
                display: flex;
                align-items: baseline;
                gap: 6px;
                justify-content: flex-end;
            }
            
            .vs-label {
                font-size: 12px !important;
                font-weight: 600 !important;
            }
            
            .opponent-team {
                font-size: 18px !important;
                font-weight: 700;
            }
            
            /* Show mobile defense ranks, hide desktop */
            .mobile-defense-ranks {
                display: flex !important;
                flex-wrap: wrap;
                gap: 8px;
                margin-top: 0;
            }
            
            .mobile-rank {
                font-size: 12px !important;
                padding: 4px 10px;
                border-radius: 6px;
                white-space: nowrap;
                font-weight: 600;
            }
            
            /* Apply defense rank colors to mobile badges - 5-tier system */
            .mobile-rank.elite {
                background: rgba(48, 209, 88, 0.2) !important;
                color: #30d158 !important;
                border: 1px solid rgba(48, 209, 88, 0.4);
            }
            
            .mobile-rank.good {
                background: rgba(100, 210, 120, 0.15) !important;
                color: #5ed573 !important;
                border: 1px solid rgba(100, 210, 120, 0.3);
            }
            
            .mobile-rank.average {
                background: rgba(255, 214, 10, 0.15) !important;
                color: #ffd60a !important;
                border: 1px solid rgba(255, 214, 10, 0.3);
            }
            
            .mobile-rank.tough {
                background: rgba(255, 159, 10, 0.15) !important;
                color: #ff9f0a !important;
                border: 1px solid rgba(255, 159, 10, 0.3);
            }
            
            .mobile-rank.bad {
                background: rgba(255, 69, 58, 0.15) !important;
                color: #ff453a !important;
                border: 1px solid rgba(255, 69, 58, 0.3);
            }
            
            .mobile-rank-separator {
                display: none;
            }
            
            .desktop-only {
                display: none !important;
            }
            
            /* Performance Candles mobile */
            #modal-candles-chart {
                max-height: 300px !important;
            }
            
            #modal-chart-candles > div {
                padding: 12px !important;
            }
            
            #modal-chart-candles h3 {
                font-size: 16px !important;
            }
            
            #modal-chart-candles > div > div:first-child {
                margin-bottom: 16px !important;
                flex-direction: column !important;
                align-items: flex-start !important;
                gap: 8px !important;
            }
            
            #modal-chart-candles > div > div:first-child > div:last-child {
                font-size: 11px !important;
            }
            
            /* Candles chart container */
            #modal-chart-candles .modal-chart-wrapper,
            #modal-chart-candles > div > div[style*="background: var(--bg-tertiary)"] {
                padding: 12px !important;
                border-radius: 8px !important;
            }
            
            /* Candles legend */
            #modal-chart-candles > div > div[style*="margin-top: 20px"] {
                gap: 16px !important;
                font-size: 11px !important;
                margin-top: 12px !important;
            }
            
            #modal-chart-candles > div > div[style*="margin-top: 20px"] > div > div {
                width: 12px !important;
                height: 18px !important;
            }
            
            #candles-summary {
                grid-template-columns: repeat(2, 1fr) !important;
                gap: 8px !important;
                margin-top: 16px !important;
            }
            
            #candles-summary > div {
                padding: 12px !important;
            }
            
            #candles-summary > div > div:first-child {
                font-size: 22px !important;
            }
            
            #candles-summary > div > div:last-child {
                font-size: 10px !important;
            }
            
            /* PRS Tab mobile */
            #modal-chart-reliability > div {
                padding: 16px 12px !important;
            }
            
            #modal-chart-reliability h3 {
                font-size: 16px !important;
            }
            
            /* PRS grid - stack gauge on top of cards */
            #modal-chart-reliability > div > div[style*="grid-template-columns: 180px"] {
                grid-template-columns: 1fr !important;
                gap: 16px !important;
            }
            
            /* PRS gauge container */
            #modal-chart-reliability canvas {
                width: 100px !important;
                height: 100px !important;
            }
            
            /* PRS component cards - 2x2 grid on mobile */
            #modal-chart-reliability > div > div[style*="grid-template-columns: 180px"] > div:last-child {
                grid-template-columns: 1fr 1fr !important;
                gap: 8px !important;
            }
            
            /* PRS card text sizes */
            #modal-chart-reliability > div > div[style*="grid-template-columns: 180px"] > div:last-child > div {
                padding: 12px !important;
            }
            
            #modal-chart-reliability > div > div[style*="grid-template-columns: 180px"] > div:last-child span[style*="font-size: 13px"] {
                font-size: 11px !important;
            }
            
            #modal-chart-reliability > div > div[style*="grid-template-columns: 180px"] > div:last-child div[style*="font-size: 16px"] {
                font-size: 14px !important;
            }
            
            /* PRS tooltip positioning on mobile */
            #prs-tooltip {
                left: auto !important;
                right: 0 !important;
                width: 280px !important;
                top: 25px !important;
            }
            
            /* Modal header mobile - reduce scale */
            .modal-team-badge {
                width: 48px !important;
                height: 48px !important;
                font-size: 14px !important;
                border-radius: 6px !important;
            }
            
            /* Team modal specific mobile styling */
            #team-modal .modal-header {
                position: relative !important;
            }
            
            #team-modal .modal-player-name {
                font-size: 20px !important;
            }
            
            #team-modal .modal-player-meta {
                font-size: 11px !important;
            }
            
            /* Key players grid mobile */
            #key-players-grid {
                grid-template-columns: 1fr !important;
                gap: 8px !important;
            }
            
            .key-players-section h3 {
                font-size: 14px !important;
                margin-bottom: 10px !important;
            }
            
            /* Team modal controls */
            #team-modal-controls-grid {
                grid-template-columns: 1fr !important;
                gap: 12px !important;
                margin-bottom: 16px !important;
            }
            
            #team-modal-controls-grid label {
                font-size: 12px !important;
                margin-bottom: 6px !important;
            }
            
            #team-modal-controls-grid select {
                padding: 8px 10px !important;
                font-size: 13px !important;
            }
            
            /* Team charts mobile */
            .team-modal-charts-grid {
                grid-template-columns: 1fr !important;
                gap: 16px !important;
            }
            
            .chart-header {
                font-size: 13px !important;
                padding: 10px 12px !important;
            }
            
            .chart-wrapper {
                height: 250px !important;
            }
            
            /* Player modal header mobile - reduce scale */
            .modal-team-badge {
                width: 48px !important;
                height: 48px !important;
                font-size: 14px !important;
                border-radius: 6px !important;
            }
            
            .modal-player-name {
                font-size: 22px !important;
                line-height: 1.2 !important;
            }
            
            .modal-player-meta {
                font-size: 12px !important;
            }
            
            .modal-player-info {
                gap: 12px !important;
                margin-bottom: 12px !important;
            }
            
            .modal-header {
                padding: 16px !important;
                position: relative !important;
            }
            
            /* Reduce sentiment section on mobile */
            .modal-header .sentiment-bar-3section {
                width: 140px !important;
                height: 6px !important;
            }
            
            .modal-header [style*="font-size: 11px"] {
                font-size: 10px !important;
            }
            
            .vote-btn {
                padding: 4px 10px !important;
                font-size: 10px !important;
            }
            
            /* Reduce close button */
            .modal-close {
                width: 28px !important;
                height: 28px !important;
                font-size: 18px !important;
                top: 12px !important;
                right: 12px !important;
            }
        }

        .ticker-content {
            overflow: hidden;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: var(--spacing-md) var(--spacing-lg);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 24px;
            font-weight: 700;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #30d158, #0a84ff);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            font-size: 22px;
            font-weight: 900;
            color: white;
            box-shadow: 0 0 20px rgba(48, 209, 88, 0.4),
                        0 0 40px rgba(10, 132, 255, 0.2);
            transition: all 0.3s ease;
        }

        .logo-icon:hover {
            animation: logoPulse 2s ease-in-out infinite;
        }

        @keyframes logoPulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(48, 209, 88, 0.4),
                            0 0 40px rgba(10, 132, 255, 0.2);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 30px rgba(48, 209, 88, 0.6),
                            0 0 60px rgba(10, 132, 255, 0.4);
                transform: scale(1.05);
            }
        }

        .logo-icon::before {
            content: '>';
            transform: scaleX(1.3);
        }

        .nav-tabs {
            display: flex;
            gap: var(--spacing-sm);
        }

        .nav-tab {
            padding: var(--spacing-sm) var(--spacing-md);
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .nav-tab:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .nav-tab.active {
            background: var(--bg-tertiary);
            color: var(--positive);
            font-weight: 700;
            position: relative;
        }

        .nav-tab.active::after {
            content: '';
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 2px;
            background: var(--positive);
            border-radius: 2px;
        }

        .upload-btn {
            padding: var(--spacing-sm) var(--spacing-md);
            background: linear-gradient(135deg, #30d158, #0a84ff);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
            box-shadow: 0 0 15px rgba(48, 209, 88, 0.3),
                        0 0 30px rgba(10, 132, 255, 0.15);
        }

        .upload-btn:hover {
            box-shadow: 0 0 20px rgba(48, 209, 88, 0.5),
                        0 0 40px rgba(10, 132, 255, 0.25);
            transform: translateY(-1px);
        }

        /* ============================================
           4. TICKER
           ============================================ */

        /* Header Scoring Dropdown */
        .header-scoring-dropdown {
            position: relative;
            display: inline-block;
        }

        .header-scoring-button {
            padding: 6px 16px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-primary);
            background: var(--bg-tertiary);
            border: none;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 6px;
            position: relative;
        }

        .header-scoring-button::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 50%;
            transform: translateX(-50%);
            width: 16px;
            height: 2px;
            background: var(--positive);
            border-radius: 2px;
        }

        .header-scoring-button:hover {
            background: var(--bg-elevated);
        }

        .header-scoring-button .arrow {
            font-size: 10px;
            transition: transform 0.2s ease;
        }

        .header-scoring-dropdown.open .header-scoring-button .arrow {
            transform: rotate(180deg);
        }

        .header-scoring-menu {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: var(--bg-elevated);
            border-radius: 12px;
            padding: 6px;
            min-width: 140px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.2s ease;
            z-index: 1000;
        }

        .header-scoring-dropdown.open .header-scoring-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .header-scoring-menu button {
            width: 100%;
            padding: 10px 16px;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .header-scoring-menu button:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
        }

        .header-scoring-menu button.active {
            background: var(--positive);
            color: white;
        }

        .ticker-container {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            overflow: hidden;
            height: 40px;
            display: flex;
            align-items: center;
        }

        .ticker-track {
            display: flex;
            animation: scroll 60s linear infinite;
            white-space: nowrap;
        }

        @keyframes scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        @keyframes scrollReverse {
            0% { transform: translateX(-50%); }
            100% { transform: translateX(0%); }
        }

        .ticker-track {
            animation-duration: 540s !important;
        }

        .ticker-item {
            padding: 0 var(--spacing-lg);
            font-size: 13px;
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .ticker-item .player-name {
            font-weight: 600;
            color: var(--text-primary);
        }

        .ticker-item .avg-pts {
            color: var(--text-secondary);
        }
        
        /* Green highlight for leaderboards page ticker only */
        #analytics-insights-track .ticker-item .avg-pts {
            color: var(--positive);
            font-weight: 600;
            background: rgba(48, 209, 88, 0.15);
            padding: 2px 8px;
            border-radius: 4px;
        }

        .ticker-item .change {
            font-weight: 600;
        }

        .ticker-item .change.positive {
            color: var(--positive);
        }

        .ticker-item .change.negative {
            color: var(--negative);
        }

        /* ============================================
           SCORING FORMAT TOGGLE (Legacy - now in header)
           ============================================ */
        .scoring-toggle-container {
            display: none; /* Moved to header */
        }

        .scoring-toggle {
            display: inline-flex;
            background: var(--bg-tertiary);
            border-radius: 20px;
            padding: 4px;
            gap: 4px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .scoring-option {
            padding: 8px 20px;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            background: transparent;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
        }

        .scoring-option:hover {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.05);
        }

        .scoring-option.active {
            background: var(--bg-elevated);
            color: var(--text-primary);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .scoring-option.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 2px;
            background: var(--positive);
            border-radius: 2px;
        }

        /* Value update animation */
        @keyframes fadeUpdate {
            0% { opacity: 1; }
            50% { opacity: 0.4; }
            100% { opacity: 1; }
        }

        .updating-values {
            animation: fadeUpdate 0.6s ease-in-out;
        }

        /* ============================================
           5. TABLES
           ============================================ */
        .player-table {
            background: var(--bg-secondary);
            border-radius: 12px;
            overflow: hidden;
            margin-top: var(--spacing-lg);
        }

        .table-header {
            display: grid;
            grid-template-columns: 50px 60px 1fr 80px 80px 80px 100px 120px;
            gap: var(--spacing-md);
            padding: var(--spacing-md) var(--spacing-lg);
            background: var(--bg-tertiary);
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid var(--border-color);
        }

        .table-header > div {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .table-header > div:hover {
            color: var(--text-primary);
        }

        .player-row {
            display: grid;
            grid-template-columns: 50px 60px 1fr 80px 80px 80px 100px 120px;
            gap: var(--spacing-md);
            padding: var(--spacing-md) var(--spacing-lg);
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .mini-chart {
            width: 100%;
            height: 30px;
            position: relative;
        }

        .mini-chart canvas {
            width: 100% !important;
            height: 30px !important;
        }

        .player-row:hover {
            background: var(--bg-tertiary);
        }

        .player-row:last-child {
            border-bottom: none;
        }

        .player-rank {
            font-weight: 700;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .team-badge {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 700;
            color: white;
        }

        .player-info {
            display: flex;
            flex-direction: column;
        }

        .player-name-text {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* New Feature: Player Headshots */
        .player-headshot {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--bg-elevated);
            border: 2px solid var(--border-color);
            object-fit: cover;
            flex-shrink: 0;
        }

        .player-headshot.loading {
            background: linear-gradient(90deg, var(--bg-elevated) 25%, var(--bg-tertiary) 50%, var(--bg-elevated) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .player-position {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .player-stat {
            font-weight: 600;
            font-size: 14px;
        }

        .stat-change {
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 600;
            font-size: 14px;
        }

        .stat-change.positive {
            color: var(--positive);
        }

        .stat-change.negative {
            color: var(--negative);
        }

        /* ============================================
           6. CARDS
           ============================================ */
        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: var(--spacing-md);
            margin-top: var(--spacing-lg);
            justify-content: center;
        }

        .cards-grid.two-or-less {
            grid-template-columns: repeat(2, 1fr);
        }

        .grid-spacer {
            /* Invisible spacer to maintain grid layout */
            visibility: hidden;
        }

        .team-card {
            width: 100%;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: var(--spacing-md);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
        }

        .team-card:hover {
            transform: translateY(-2px);
            border-color: var(--border-color-light);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }

        .team-card-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-sm);
        }

        .team-card-badge {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            color: white;
        }

        .team-card-name {
            font-size: 16px;
            font-weight: 700;
        }

        .team-card-stats {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
            margin-bottom: var(--spacing-sm);
        }

        .team-stat {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            position: relative;
        }

        .team-stat:hover .stat-tooltip {
            opacity: 1;
        }

        .team-stat-label {
            color: var(--text-secondary);
            font-size: 8px;
        }

        .team-stat-value {
            font-weight: 600;
            font-size: 12px;
        }

        .team-card-chart {
            height: 140px;
            margin-top: auto;
            position: relative;
        }

        .team-card-chart canvas {
            max-height: 140px;
        }

        /* Player Cards (similar to team cards) */
        .player-card {
            width: 100%;
            max-width: 100%; /* Fill grid cell */
            min-height: 160px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: var(--spacing-lg);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
        }

        /* Player cards grid layout */
        .player-cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); /* Fixed min size, scales to fit */
            gap: 16px;
            overflow: visible;
            width: 100%;
        }
        
        /* Ensure cards fill their grid cells */
        .player-cards-grid .player-card {
            width: 100%;
        }

        .player-card:hover {
            transform: translateY(-2px);
            border-color: var(--border-color-light);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            z-index: 10; /* Ensure hovered card appears above others */
            position: relative; /* Required for z-index to work */
        }

        .player-card-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .player-card-badge {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 700;
            color: white;
            text-align: center;
        }

        .player-card-name {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .player-card-team {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .player-tags {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 6px;
        }

        .player-tag {
            font-size: 10px;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            position: relative;
            cursor: help;
        }

        .player-tag:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            font-size: 11px;
            font-weight: 500;
            border-radius: 6px;
            white-space: nowrap;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.1);
            letter-spacing: 0;
            text-transform: none;
        }

        .player-tag:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 2px;
            border: 4px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.95);
            z-index: 1000;
        }

        .player-tag.buy-low {
            background: rgba(48, 209, 88, 0.15);
            color: #30d158;
            border: 1px solid rgba(48, 209, 88, 0.3);
        }

        .player-tag.sell-high {
            background: rgba(255, 69, 58, 0.15);
            color: #ff453a;
            border: 1px solid rgba(255, 69, 58, 0.3);
        }

        .player-tag.rz-up {
            background: rgba(255, 214, 10, 0.15);
            color: #FFD60A;
            border: 1px solid rgba(255, 214, 10, 0.3);
        }

        /* Injury Status Badge */
        .injury-badge {
            font-size: 9px;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 3px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: inline-block;
            margin-left: 6px;
            position: relative;
            cursor: help;
        }

        .injury-badge.questionable {
            background: rgba(255, 214, 10, 0.2);
            color: #FFD60A;
            border: 1px solid rgba(255, 214, 10, 0.4);
        }

        .injury-badge.doubtful {
            background: rgba(255, 149, 0, 0.2);
            color: #FF9500;
            border: 1px solid rgba(255, 149, 0, 0.4);
        }

        .injury-badge.out,
        .injury-badge.ir,
        .injury-badge.pup {
            background: rgba(255, 69, 58, 0.2);
            color: #FF453A;
            border: 1px solid rgba(255, 69, 58, 0.4);
        }

        .injury-badge.suspended,
        .injury-badge.cov {
            background: rgba(142, 142, 147, 0.2);
            color: #8E8E93;
            border: 1px solid rgba(142, 142, 147, 0.4);
        }

        .injury-badge:hover::after {
            content: attr(data-injury-details);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            font-size: 11px;
            font-weight: 500;
            border-radius: 6px;
            white-space: nowrap;
            z-index: 10000;
            border: 1px solid rgba(255, 255, 255, 0.1);
            letter-spacing: 0;
            text-transform: none;
        }

        .injury-badge:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 2px;
            border: 4px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.95);
            z-index: 10000;
        }

        .player-card-stats {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
        }

        .player-stat {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            position: relative;
        }

        /* Only show stat tooltip when hovering the label specifically */
        .player-stat-label:hover + .stat-tooltip,
        .player-stat-label:hover ~ .stat-tooltip {
            opacity: 1;
        }

        /* Alternative: show on stat hover but hide when hovering comparison area */
        .player-stat:hover .stat-tooltip {
            opacity: 1;
        }

        .player-stat:hover .player-stat-with-comparison:hover ~ .stat-tooltip,
        .player-stat-with-comparison:hover ~ .stat-tooltip {
            opacity: 0 !important; /* Hide stat tooltip when hovering comparison */
        }

        .stat-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .player-stat-label {
            color: var(--text-secondary);
        }

        .player-stat-value {
            font-weight: 600;
        }

        .player-comparison {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .comparison-icon {
            font-size: 10px;
        }

        .comparison-up {
            color: var(--positive);
        }

        .comparison-down {
            color: var(--negative);
        }

        .player-stat-with-comparison {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            position: relative;
        }

        .comparison-tooltip {
            position: absolute;
            bottom: 100%;
            right: 0; /* Position relative to comparison element */
            transform: translateY(0);
            margin-bottom: 8px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1001; /* Higher than stat-tooltip */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        /* Only show comparison tooltip when hovering the comparison element itself */
        .player-comparison:hover + .comparison-tooltip,
        .player-comparison:hover ~ .comparison-tooltip {
            opacity: 1;
        }

        .tooltip-label {
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .tooltip-data {
            font-weight: 600;
            color: var(--text-primary);
        }

        .player-card-chart {
            height: 120px;
            margin-top: auto;
            position: relative;
        }

        .player-card-chart canvas {
            max-height: 120px;
        }

        .tier-section {
            margin-bottom: var(--spacing-xl);
        }

        .tier-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
            padding-bottom: var(--spacing-md);
            border-bottom: 2px solid var(--border-color);
            cursor: pointer;
            user-select: none;
            transition: opacity 0.2s ease;
        }

        .tier-header:hover {
            opacity: 0.8;
        }

        .tier-collapse-icon {
            font-size: 14px;
            color: var(--text-secondary);
            transition: transform 0.3s ease;
            margin-left: 8px;
        }

        .tier-collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .tier-cards-container {
            overflow: hidden;
            max-height: 100000px; /* Large enough for any tier */
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 1;
        }

        .tier-cards-container.collapsed {
            max-height: 0 !important;
            opacity: 0;
        }

        .tier-badge {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tier-badge.elite {
            background: rgba(48, 209, 88, 0.2);
            color: #30d158;
        }

        .tier-badge.wr2 {
            background: rgba(10, 132, 255, 0.2);
            color: #0a84ff;
        }

        .tier-badge.flex {
            background: rgba(255, 214, 10, 0.2);
            color: #FFD60A;
        }

        .tier-badge.depth {
            background: rgba(142, 142, 147, 0.2);
            color: #8e8e93;
        }

        .tier-title {
            font-size: 20px;
            font-weight: 700;
        }

        .tier-count {
            font-size: 14px;
            color: var(--text-secondary);
            text-align: right;
            margin-left: auto;
        }

        /* ============================================
           MOMENTUM BADGES & TOP MOVERS
           ============================================ */

        /* Momentum badge next to player name */
        .momentum-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            margin-left: 4px;
            cursor: help;
            position: relative;
            transition: all 0.2s ease;
        }

        .momentum-badge.up {
            background: rgba(52, 199, 89, 0.2);
            color: #34c759;
            border: 1px solid rgba(52, 199, 89, 0.4);
        }

        .momentum-badge.down {
            background: rgba(255, 69, 58, 0.2);
            color: #ff453a;
            border: 1px solid rgba(255, 69, 58, 0.4);
        }

        .momentum-badge.neutral {
            display: none; /* Hide neutral badges */
        }

        .momentum-badge:hover {
            transform: scale(1.1);
        }

        /* Tooltip for momentum badge */
        .momentum-badge::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            font-size: 11px;
            font-weight: 500;
            border-radius: 6px;
            white-space: nowrap;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .momentum-badge:hover::after {
            opacity: 1;
        }

        .momentum-badge::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 2px;
            border: 4px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .momentum-badge:hover::before {
            opacity: 1;
        }

        /* Top Movers Sidebar Widgets */
        .top-movers-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
        }

        .top-movers-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 24px;
        }

        .top-movers-widget {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid var(--border-color);
            animation: fadeInUp 0.4s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .top-movers-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            user-select: none;
        }

        .top-movers-header:hover {
            opacity: 1; /* No hover effect since not clickable */
        }

        .top-movers-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .top-movers-title {
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .top-movers-widget.risers .top-movers-title {
            color: #30d158;
        }

        .top-movers-widget.fallers .top-movers-title {
            color: #ff453a;
        }

        .top-movers-icon {
            font-size: 16px;
        }

        .top-movers-list {
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* Default to 2x2 */
            gap: 8px;
        }

        .top-mover-item {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
            padding: 10px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .top-mover-item:hover {
            background: var(--bg-elevated);
            transform: translateY(-2px);
        }

        .top-mover-rank {
            font-size: 11px;
            font-weight: 700;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .top-mover-arrow {
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 14px;
            flex-shrink: 0;
        }

        .top-movers-widget.risers .top-mover-arrow {
            color: #30d158;
        }

        .top-movers-widget.fallers .top-mover-arrow {
            color: #ff453a;
        }

        .top-mover-info {
            flex: 1;
            min-width: 0;
            width: 100%;
        }

        .top-mover-name {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 2px;
        }

        .top-mover-team {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .top-mover-score {
            font-size: 13px;
            font-weight: 700;
            flex-shrink: 0;
        }

        .top-movers-widget.risers .top-mover-score {
            color: #30d158;
        }

        .top-movers-widget.fallers .top-mover-score {
            color: #ff453a;
        }

        /* Top Movers Hidden/Expand */
        .top-mover-hidden {
            display: none;
        }

        .top-movers-expand-btn {
            width: 100%;
            padding: 10px;
            margin-top: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .top-movers-expand-btn:hover {
            background: var(--bg-elevated);
            border-color: var(--positive);
        }

        /* Collapsible content */
        .top-movers-content {
            max-height: 1000px;
            overflow: visible; /* Changed from hidden to allow tooltips to show */
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 1;
        }

        .top-movers-content.collapsed {
            max-height: 0;
            opacity: 0;
        }

        /* Responsive adjustments */
        @media (min-width: 1024px) {
            .top-movers-list {
                grid-template-columns: repeat(4, 1fr); /* 4 across on large screens */
            }
        }

        @media (max-width: 900px) {
            .top-movers-container {
                grid-template-columns: 1fr;
            }
        }

        /* Make player cards container position relative for absolute badges */
        .player-card {
            position: relative;
        }

        /* ============================================
           7. CHARTS
           ============================================ */
        .charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: var(--spacing-lg);
            margin-top: var(--spacing-lg);
        }

        .chart-card {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: var(--spacing-lg);
            overflow: hidden; /* Prevent horizontal overflow on mobile */
        }

        .chart-card canvas {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
            max-width: 100%; /* Ensure canvas doesn't exceed container */
        }

        .chart-header {
            margin-bottom: var(--spacing-md);
        }

        .chart-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: var(--spacing-xs);
        }

        .chart-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .chart-wrapper {
            position: relative;
            height: 400px;
            width: 100%; /* Ensure wrapper doesn't exceed container */
            max-width: 100%;
            overflow: hidden; /* Prevent overflow */
        }

        /* Glow effects for team outlook charts */
        #team-pie-chart, #team-secondary-chart {
            filter: drop-shadow(0 0 15px rgba(10, 132, 255, 0.4));
        }

        /* Glow effects for scatter plots */
        #team-balance-scatter, #advanced-scatter-chart, #wr-trend-chart, #rb-trend-chart {
            filter: drop-shadow(0 0 15px rgba(10, 132, 255, 0.4));
        }

        .chart-insight {
            background: var(--bg-tertiary);
            border-left: 3px solid var(--positive);
            padding: 12px 16px;
            margin-bottom: 16px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-secondary);
        }

        .chart-insight strong {
            color: var(--text-primary);
            font-weight: 600;
        }

        /* New Feature: Trend Toggle Button */
        .trend-toggle-container {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 12px;
        }

        .trend-toggle-btn {
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .trend-toggle-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        .trend-toggle-btn.active {
            background: var(--positive-bg);
            border-color: var(--positive);
            color: var(--positive);
        }

        .trend-toggle-icon {
            font-size: 14px;
        }

        /* New: Week Indicator for Trend Animation */
        .week-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 700;
            z-index: 20;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        /* Player Evaluation Matrix | Week Scrubber Styles */
        .week-scrubber-container {
            margin-top: 16px;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .scrubber-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .scrubber-label {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .playback-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .playback-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .playback-btn:hover {
            background: var(--positive-bg);
            border-color: var(--positive);
            color: var(--positive);
        }

        .playback-btn.playing {
            background: var(--positive-bg);
            border-color: var(--positive);
            color: var(--positive);
        }

        .play-icon {
            font-size: 12px;
        }

        .week-scrubber {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, var(--positive) 0%, var(--positive) 100%, var(--bg-elevated) 100%);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        .week-scrubber::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--positive);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(48, 209, 88, 0.4);
            transition: all 0.15s ease;
        }

        .week-scrubber::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 3px 10px rgba(48, 209, 88, 0.6);
        }

        .week-scrubber::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--positive);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(48, 209, 88, 0.4);
            transition: all 0.15s ease;
        }

        .week-scrubber::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 3px 10px rgba(48, 209, 88, 0.6);
        }

        /* New Feature: Quadrant Highlighting */
        .quadrant-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .quadrant-highlight {
            position: absolute;
            border: 2px solid var(--positive);
            border-radius: 8px;
            background: rgba(48, 209, 88, 0.05);
            animation: pulseHighlight 2s infinite;
            pointer-events: none;
        }

        @keyframes pulseHighlight {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.02); }
        }

        .highlighted-player {
            filter: drop-shadow(0 0 12px var(--positive));
            animation: glowPlayer 2s infinite;
        }

        @keyframes glowPlayer {
            0%, 100% { filter: drop-shadow(0 0 10px var(--positive)); }
            50% { filter: drop-shadow(0 0 18px var(--positive)); }
        }

        .chart-wrapper {
            position: relative;
        }

        /* Quadrant labels removed - now using chart annotations */

        /* ============================================
           7. SENTIMENT & VOTING
           ============================================ */
        .sentiment-bar-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
        }

        .sentiment-bar {
            flex: 1;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
            display: flex;
            position: relative;
        }

        .sentiment-bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            position: absolute;
            top: 0;
            left: 0;
        }

        .sentiment-bar-buy {
            background: var(--positive);
            z-index: 2;
        }

        .sentiment-bar-sell {
            background: var(--negative);
            z-index: 1;
            width: 100% !important;
        }

        /* 3-Section Sentiment Bar */
        .sentiment-segment-buy {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }

        .sentiment-segment-hold {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
        }

        .sentiment-segment-sell {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }

        .sentiment-label {
            font-size: 11px;
            color: var(--text-secondary);
            min-width: 45px;
            text-align: right;
        }

        .vote-buttons {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .vote-btn {
            flex: 1;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .vote-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        .vote-btn.active {
            border-color: currentColor;
        }

        .vote-btn.buy-btn {
            color: var(--positive);
        }

        .vote-btn.buy-btn.active {
            background: var(--positive-bg);
        }

        .vote-btn.sell-btn {
            color: var(--negative);
        }

        .vote-btn.sell-btn.active {
            background: var(--negative-bg);
        }

        .vote-btn.hold-btn.active {
            background: rgba(142, 142, 147, 0.15);
        }

        .vote-count {
            font-size: 11px;
            opacity: 0.7;
        }

        .signal-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .signal-tag.positive {
            background: var(--positive-bg);
            color: var(--positive);
        }

        .signal-tag.neutral {
            background: rgba(142, 142, 147, 0.15);
            color: var(--text-secondary);
        }

        .signal-tag.opportunity {
            background: rgba(10, 132, 255, 0.15);
            color: #0a84ff;
        }

        .comment-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .comment-header {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-primary);
        }

        .comment-input-container {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .comment-input {
            flex: 1;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
            font-family: inherit;
        }

        .comment-input:focus {
            outline: none;
            border-color: var(--positive);
        }

        .comment-submit {
            padding: 8px 16px;
            background: var(--positive);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
        }

        .comment-submit:hover {
            background: #28c149;
        }

        .comment-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .comment-item {
            padding: 10px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 13px;
            line-height: 1.4;
        }

        .comment-meta {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        /* ============================================
           8. MODAL
           ============================================ */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000; /* Higher than info icons (9999) to ensure modal sits on top */
            animation: fadeIn 0.2s ease;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: 16px;
            width: 90%;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .modal-header {
            padding: var(--spacing-lg);
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            background: var(--bg-secondary);
            z-index: 10;
        }

        .modal-player-info {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .modal-team-badge {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 700;
            color: white;
        }

        .modal-player-details {
            flex: 1;
        }

        .modal-player-name {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .modal-player-meta {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .modal-close {
            background: var(--bg-tertiary);
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        .modal-stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0;
        }

        .modal-section-header {
            font-size: 11px;
            color: rgba(235, 235, 245, 0.5);
            text-transform: uppercase;
            letter-spacing: 0.8px;
            font-weight: 600;
            padding: 16px 0 12px 0;
            margin-top: 8px;
        }

        .modal-section-header:first-child {
            margin-top: 0;
        }

        .modal-stats-table {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0;
            border-top: 1px solid rgba(142, 142, 147, 0.2);
        }

        .modal-stat-cell {
            padding: 14px 12px;
            border-right: 1px solid rgba(142, 142, 147, 0.15);
            border-bottom: 1px solid rgba(142, 142, 147, 0.2);
            display: flex;
            flex-direction: column;
            gap: 4px;
            position: relative;
            cursor: help;
        }

        .modal-stat-cell:nth-child(4n) {
            border-right: none;
        }

        .modal-stat-cell:hover .stat-tooltip {
            opacity: 1;
        }

        .modal-stat-cell .stat-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            color: var(--text-primary);
            min-width: 200px;
            white-space: normal;
            text-align: left;
            line-height: 1.4;
        }
        
        /* Mobile: Prevent tooltips from going off screen */
        @media (max-width: 768px) {
            .modal-stat-cell .stat-tooltip {
                left: auto;
                right: 0;
                transform: none;
                min-width: 180px;
                max-width: 250px;
            }
            
            .modal-stat-cell:first-child .stat-tooltip,
            .modal-stat-cell:nth-child(2) .stat-tooltip {
                left: 0;
                right: auto;
            }
        }

        .modal-stat-empty {
            border: none;
            background: transparent;
        }

        /* Legacy styles for old stat-box class */
        .modal-stat-box {
            padding: 16px 12px;
            position: relative;
            cursor: help;
            border-right: 1px solid rgba(142, 142, 147, 0.2);
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            justify-content: flex-start;
            min-height: 90px;
        }

        .modal-stat-box:nth-child(4n) {
            border-right: none;
        }

        .modal-stat-box:hover .stat-tooltip {
            opacity: 1;
        }

        .modal-stat-box .stat-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            color: var(--text-primary);
            min-width: 200px;
            white-space: normal;
            text-align: left;
            line-height: 1.4;
        }

        .modal-stat-label {
            font-size: 13px;
            color: rgba(235, 235, 245, 0.6);
            font-weight: 400;
        }

        .modal-stat-value {
            font-size: 17px;
            font-weight: 600;
            color: #ffffff;
            line-height: 1.2;
        }

        .modal-stat-comparison {
            font-size: 13px;
            font-weight: 500;
            line-height: 1.2;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .modal-body {
            padding: 8px var(--spacing-lg) var(--spacing-lg) var(--spacing-lg);
        }

        .chart-tabs {
            display: flex;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-lg);
            border-bottom: 1px solid var(--border-color);
        }

        .chart-tab {
            padding: var(--spacing-md);
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s ease;
        }

        .chart-tab:hover {
            color: var(--text-primary);
        }

        .chart-tab.active {
            color: var(--text-primary);
            border-bottom-color: var(--positive);
        }

        .chart-content {
            display: none;
        }

        .chart-content.active {
            display: block;
        }

        .modal-chart-wrapper {
            position: relative;
            height: 350px;
        }

        /* Floor Metrics - Radial Tooltip Styles */
        .radial-with-tooltip:hover .radial-tooltip {
            opacity: 1 !important;
        }

        /* Mobile: Show tooltip on tap */
        @media (max-width: 768px) {
            .radial-with-tooltip.active .radial-tooltip {
                opacity: 1 !important;
            }
        }

        /* ============================================
           10. UPLOAD SECTION
           ============================================ */
        .upload-section {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: var(--spacing-xl);
            text-align: center;
            margin-top: var(--spacing-lg);
        }

        .upload-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
        }

        .upload-subtitle {
            color: var(--text-secondary);
            margin-bottom: var(--spacing-lg);
        }

        .upload-buttons {
            display: flex;
            gap: var(--spacing-md);
            justify-content: center;
            flex-wrap: wrap;
        }

        .upload-file-btn {
            padding: var(--spacing-md) var(--spacing-lg);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 2px dashed var(--border-color-light);
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
        }

        .upload-file-btn:hover {
            border-color: var(--positive);
            background: var(--bg-elevated);
        }

        input[type="file"] {
            display: none;
        }

        .data-status {
            margin-top: var(--spacing-lg);
            padding: var(--spacing-md);
            background: var(--positive-bg);
            border-radius: 8px;
            color: var(--positive);
            font-weight: 600;
        }

        /* ============================================
           11. RESPONSIVE
           ============================================ */

        /* Large tablets and small laptops (3 columns) */
        @media (max-width: 1200px) {
            .cards-grid {
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            }
        }

        /* Tablets (2 columns) */
        @media (max-width: 900px) {
            .cards-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }
        }

        /* Mobile (2 columns, smaller cards) */
        @media (max-width: 768px) {
            .nav-tabs {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .table-header,
            .player-row {
                grid-template-columns: 40px 50px 1fr 70px;
                font-size: 12px;
            }

            .table-header > div:nth-child(5),
            .table-header > div:nth-child(6),
            .table-header > div:nth-child(7),
            .table-header > div:nth-child(8),
            .player-row > div:nth-child(5),
            .player-row > div:nth-child(6),
            .player-row > div:nth-child(7),
            .player-row > div:nth-child(8) {
                display: none;
            }

            .modal-stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .modal-stats-table {
                grid-template-columns: repeat(2, 1fr);
            }

            .modal-stat-cell:nth-child(2n) {
                border-right: none;
            }

            .modal-stat-cell:nth-child(4n) {
                border-right: 1px solid rgba(142, 142, 147, 0.15);
            }

            .modal-stat-box:nth-child(2n) {
                border-right: none;
            }

            .modal-stat-box:nth-child(4n) {
                border-right: 1px solid rgba(142, 142, 147, 0.2);
            }

            .modal-stat-value {
                font-size: 16px;
            }

            .modal-stat-comparison {
                font-size: 12px;
            }

            .modal-stat-label {
                font-size: 12px;
            }

            .charts-container {
                grid-template-columns: 1fr;
            }

            .movers-container {
                grid-template-columns: 1fr;
            }

            .cards-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }

            /* REFACTORED: Better mobile support for new features */
            .player-headshot {
                width: 28px;
                height: 28px;
                font-size: 10px;
            }

            .chart-wrapper {
                height: 300px !important; /* Shorter charts on mobile */
            }

            .trend-toggle-btn {
                font-size: 11px;
                padding: 4px 8px;
            }

            .signal-tag {
                font-size: 9px;
                padding: 3px 6px;
            }

            /* Mobile Modal Optimizations */
            .modal-overlay {
                padding: 10px;
            }

            .modal-header {
                padding: 16px;
            }
            
            /* Stack sentiment below player info on mobile */
            .modal-header > div:first-child {
                flex-direction: column !important;
                gap: 16px !important;
            }
            
            /* Sentiment section mobile adjustments */
            .modal-header > div:first-child > div:nth-child(2) {
                width: 100% !important;
                margin-right: 0 !important;
                align-items: flex-start !important;
            }
            
            /* Reduce sentiment bar width on mobile */
            .modal-header .sentiment-bar-3section {
                width: 150px !important;
            }
            
            /* Make vote buttons full width on mobile */
            .modal-header .vote-buttons {
                width: 100% !important;
            }
            
            .modal-header .vote-btn {
                flex: 1 !important;
            }

            .modal-title {
                font-size: 18px;
            }

            .modal-subtitle {
                font-size: 12px;
            }

            .modal-body {
                padding: 16px;
                max-height: calc(90vh - 120px);
                overflow-y: auto;
            }

            .modal-stat-box {
                padding: 10px;
            }

            .modal-stat-label {
                font-size: 10px;
            }

            .modal-stat-value {
                font-size: 18px;
            }

            .modal-stat-change {
                font-size: 11px;
            }

            /* Mobile Sentiment in Modal */
            .sentiment-card {
                padding: 12px;
            }

            .sentiment-percentage {
                font-size: 28px;
            }

            .sentiment-label {
                font-size: 11px;
            }

            .sentiment-breakdown {
                font-size: 10px;
            }

            /* Mobile - Reconfigure Horizontal Sentiment Bar */
            .modal-body > div[style*="display: flex"][style*="gap: 20px"] {
                flex-direction: column !important;
                gap: 12px !important;
                padding: 12px 16px !important;
            }

            /* Sentiment Label Section */
            .modal-body > div[style*="display: flex"] > div[style*="flex-shrink: 0"]:first-child {
                display: flex;
                justify-content: space-between;
                align-items: center;
                width: 100%;
            }

            /* Mobile Swipeable Stats Grid */
            .modal-stats-container {
                position: relative;
                overflow: hidden;
                margin-top: 32px;
                padding-top: 16px;
                border-top: 1px solid rgba(142, 142, 147, 0.2);
            }

            .modal-stats-wrapper {
                display: flex;
                transition: transform 0.3s ease;
                touch-action: pan-y;
            }

            .modal-stats-page {
                min-width: 100%;
                flex-shrink: 0;
            }

            .modal-stats-grid {
                grid-template-columns: repeat(2, 1fr) !important;
                gap: 12px !important;
            }

            /* Stats Page Dots */
            .stats-dots {
                display: flex;
                justify-content: center;
                gap: 8px;
                margin-top: 16px;
                padding-bottom: 4px;
                margin-bottom: 8px;
            }

            .stats-dot {
                width: 8px;
                height: 8px;
                border-radius: 50%;
                background: #6b7280;
                opacity: 0.5;
                transition: all 0.3s ease;
                cursor: pointer;
            }

            .stats-dot.active {
                opacity: 1;
                background: #10b981;
                transform: scale(1.2);
            }

            /* Mobile Chart Tabs */
            .chart-tabs {
                gap: 6px;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .chart-tab {
                padding: 6px 12px;
                font-size: 11px;
                white-space: nowrap;
            }

            /* Mobile Tooltips - Keep near element but prevent off-screen */
            [data-tooltip]::after,
            .stat-tooltip,
            .comparison-tooltip,
            .ticker-tooltip,
            .leaderboard-tooltip,
            .player-tag:hover::after,
            .injury-badge:hover::after,
            .momentum-badge:hover::after {
                position: absolute !important;
                left: auto !important;
                right: auto !important;
                transform: translateX(-50%) !important;
                max-width: min(200px, 90vw) !important;
                white-space: normal !important;
                text-align: center !important;
                margin-left: 0 !important;
                margin-right: 0 !important;
            }

            /* Remove the fixed positioning override */
            .tooltip,
            [class*="tooltip"]:not(.stat-tooltip):not(.comparison-tooltip):not(.ticker-tooltip):not(.leaderboard-tooltip) {
                max-width: min(250px, 90vw) !important;
            }

            /* Top Movers Info Icon - Prevent Leaking Through Menu */
            .ticker-info-icon {
                z-index: 100 !important; /* Lower than mobile menu */
            }

            .ticker-tooltip {
                z-index: 101 !important; /* Lower than mobile menu */
            }

            /* Ensure hamburger menu is above everything */
            .mobile-nav-toggle {
                z-index: 10001 !important;
            }

            .nav-tabs {
                z-index: 10000 !important;
            }
        }

        /* ============================================
           COLLAPSIBLE DIVISIONS
           ============================================ */
        .division-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            margin-bottom: 16px;
            overflow: hidden;
        }

        .division-header {
            padding: 16px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background 0.2s ease;
            user-select: none;
        }

        .division-header:hover {
            background: var(--bg-tertiary);
        }

        .division-title {
            font-size: 15px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .division-arrow {
            font-size: 12px;
            color: var(--text-secondary);
            transition: transform 0.3s ease;
        }

        .division-arrow.expanded {
            transform: rotate(180deg);
        }

        .division-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }

        .division-content.expanded {
            max-height: 1000px;
            padding: 0 20px 20px 20px;
        }

        .division-teams-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 12px;
        }

        .division-team-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .division-team-card:hover {
            background: var(--bg-elevated);
            border-color: var(--positive);
        }

        .division-team-logo {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--bg-elevated);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 14px;
            color: white;
        }

        .division-team-info {
            flex: 1;
        }

        .division-team-name {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .division-team-stats {
            font-size: 11px;
            color: var(--text-secondary);
        }

        /* ============================================
           ANALYTICS DASHBOARD
           ============================================ */
        .analytics-dashboard-container {
            padding: 24px 0;
        }

        /* Heatmap Container */
        .heatmap-widget {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 32px;
        }

        /* Position Dropdown Selector */
        .position-selector {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .dropdown-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .position-select {
            padding: 10px 16px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            min-width: 220px;
        }

        .position-select:focus {
            outline: none;
            border-color: var(--positive);
        }

        /* Heatmap Controls */
        .heatmap-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: flex-end;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .heatmap-control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .heatmap-control-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Info Icon */
        .info-icon {
            display: inline-block;
            margin-left: 6px;
            font-size: 13px;
            color: rgba(10, 132, 255, 0.7);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .info-icon:hover {
            color: rgba(10, 132, 255, 1);
            transform: scale(1.15);
        }

        /* Metric Tooltip */
        .metric-tooltip {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 8px;
            background: rgba(28, 28, 30, 0.98);
            border: 1px solid rgba(142, 142, 147, 0.3);
            border-radius: 8px;
            padding: 16px;
            z-index: 1000;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            animation: tooltipFadeIn 0.2s ease;
        }

        @keyframes tooltipFadeIn {
            from {
                opacity: 0;
                transform: translateY(-4px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .metric-tooltip-content {
            font-size: 12px;
            line-height: 1.6;
            color: var(--text-primary);
        }

        .metric-tooltip-content strong {
            color: rgba(10, 132, 255, 1);
            display: block;
            margin-bottom: 6px;
            font-size: 13px;
        }

        .metric-tooltip-content .tooltip-section {
            margin-bottom: 10px;
        }

        .metric-tooltip-content .tooltip-section:last-child {
            margin-bottom: 0;
        }

        .metric-tooltip-content .tooltip-label {
            color: rgba(235, 235, 245, 0.6);
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .heatmap-control-group {
            position: relative;
        }

        .heatmap-toggle-group {
            display: flex;
            gap: 8px;
        }

        .heatmap-toggle-btn {
            padding: 8px 16px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .heatmap-toggle-btn:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
        }

        .heatmap-toggle-btn.active {
            background: var(--positive);
            border-color: var(--positive);
            color: #ffffff;
            font-weight: 600;
        }

        .metric-select {
            padding: 8px 16px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            min-width: 240px;
        }

        .metric-select:focus {
            outline: none;
            border-color: var(--positive);
        }

        /* Position Stats Row */
        .position-stats-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .position-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .position-badge {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 700;
            letter-spacing: 0.5px;
        }

        .position-badge.wr-badge {
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
            border: 1px solid rgba(0, 212, 255, 0.4);
        }

        .position-badge.rb-badge {
            background: rgba(48, 209, 88, 0.2);
            color: var(--positive);
            border: 1px solid rgba(48, 209, 88, 0.4);
        }

        .position-badge.te-badge {
            background: rgba(255, 214, 10, 0.2);
            color: #FFD60A;
            border: 1px solid rgba(255, 214, 10, 0.4);
        }

        .position-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .position-stats {
            display: flex;
            gap: 24px;
            align-items: center;
        }

        .position-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            cursor: help;
            position: relative;
        }

        .position-stat-label {
            font-size: 10px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .position-stat-value {
            font-size: 16px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .position-delta {
            font-size: 16px;
            font-weight: 700;
        }

        .positive-delta {
            color: var(--positive);
        }

        .negative-delta {
            color: var(--negative);
        }

        /* Player Heatmap Grid */
        .heatmap-player-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
        }

        .heatmap-player-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
            min-height: 120px;
            display: flex;
            flex-direction: column;
        }

        .heatmap-player-card:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            z-index: 10;
        }

        .heatmap-player-name {
            font-size: 13px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 4px;
            line-height: 1.2;
        }

        .heatmap-player-team {
            font-size: 10px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .heatmap-bottom-row {
            display: flex;
            align-items: flex-end;
            justify-content: space-between;
            margin-top: auto;
        }

        .heatmap-value {
            font-size: 22px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .heatmap-delta-group {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .heatmap-arrow {
            font-size: 24px;
            line-height: 1;
        }

        .heatmap-delta-value {
            font-size: 11px;
            font-weight: 700;
        }

        /* Color Classes for Heatmap Cards */
        .heatmap-player-card.extreme-positive {
            background: rgba(48, 209, 88, 0.4) !important;
            border-color: rgba(48, 209, 88, 0.6) !important;
        }

        .heatmap-player-card.strong-positive {
            background: rgba(48, 209, 88, 0.3) !important;
            border-color: rgba(48, 209, 88, 0.5) !important;
        }

        .heatmap-player-card.moderate-positive {
            background: rgba(48, 209, 88, 0.2) !important;
            border-color: rgba(48, 209, 88, 0.4) !important;
        }

        .heatmap-player-card.slight-positive {
            background: rgba(48, 209, 88, 0.1) !important;
            border-color: rgba(48, 209, 88, 0.3) !important;
        }

        .heatmap-player-card.neutral {
            background: rgba(255, 255, 255, 0.05) !important;
            border-color: var(--border-color) !important;
        }

        .heatmap-player-card.slight-negative {
            background: rgba(255, 69, 58, 0.1) !important;
            border-color: rgba(255, 69, 58, 0.3) !important;
        }

        .heatmap-player-card.moderate-negative {
            background: rgba(255, 69, 58, 0.2) !important;
            border-color: rgba(255, 69, 58, 0.4) !important;
        }

        .heatmap-player-card.strong-negative {
            background: rgba(255, 69, 58, 0.3) !important;
            border-color: rgba(255, 69, 58, 0.5) !important;
        }

        .heatmap-player-card.extreme-negative {
            background: rgba(255, 69, 58, 0.4) !important;
            border-color: rgba(255, 69, 58, 0.6) !important;
        }

        /* Heatmap Legend */
        .heatmap-legend {
            margin-top: 24px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
            border: 1px solid rgba(142, 142, 147, 0.2);
        }

        .heatmap-legend-title {
            font-size: 12px;
            font-weight: 600;
            color: rgba(235, 235, 245, 0.8);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .heatmap-legend-items {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }
        
        @media (max-width: 768px) {
            .heatmap-legend-items {
                gap: 4px;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                padding-bottom: 4px;
                scroll-snap-type: x mandatory;
            }
            
            .heatmap-legend-item {
                min-width: 60px;
                scroll-snap-align: center;
            }
            
            .heatmap-legend-label {
                font-size: 9px;
                white-space: nowrap;
            }
            
            /* Center the scroll position on load */
            .heatmap-legend-items::-webkit-scrollbar {
                display: none;
            }
        }

        .heatmap-legend-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            flex: 1;
        }

        .heatmap-legend-color {
            width: 100%;
            height: 24px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .heatmap-legend-label {
            font-size: 10px;
            color: var(--text-secondary);
            text-align: center;
        }

        /* Legend Color Classes */
        .heatmap-legend-color.extreme-negative {
            background: rgba(255, 69, 58, 0.3);
            border-color: rgba(255, 69, 58, 0.5);
        }

        .heatmap-legend-color.strong-negative {
            background: rgba(255, 69, 58, 0.25);
            border-color: rgba(255, 69, 58, 0.4);
        }

        .heatmap-legend-color.moderate-negative {
            background: rgba(255, 69, 58, 0.2);
            border-color: rgba(255, 69, 58, 0.3);
        }

        .heatmap-legend-color.slight-negative {
            background: rgba(255, 69, 58, 0.15);
            border-color: rgba(255, 69, 58, 0.25);
        }

        .heatmap-legend-color.neutral {
            background: rgba(142, 142, 147, 0.2);
            border-color: rgba(142, 142, 147, 0.3);
        }

        .heatmap-legend-color.slight-positive {
            background: rgba(48, 209, 88, 0.15);
            border-color: rgba(48, 209, 88, 0.25);
        }

        .heatmap-legend-color.moderate-positive {
            background: rgba(48, 209, 88, 0.2);
            border-color: rgba(48, 209, 88, 0.3);
        }

        .heatmap-legend-color.strong-positive {
            background: rgba(48, 209, 88, 0.25);
            border-color: rgba(48, 209, 88, 0.4);
        }

        .heatmap-legend-color.extreme-positive {
            background: rgba(48, 209, 88, 0.3);
            border-color: rgba(48, 209, 88, 0.5);
        }

        /* Market Opportunities */
        .market-opportunities-widget {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 32px;
        }

        .market-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 2px solid var(--border-color);
        }

        .market-title {
            font-size: 20px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .market-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
        }

        .market-column {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .market-column-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .market-column-title {
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .market-column-title.buy-low {
            color: var(--positive);
        }

        .market-column-title.sell-high {
            color: var(--negative);
        }

        .market-column-count {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .opportunity-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .opportunity-card:hover {
            transform: translateY(-2px);
            border-color: rgba(142, 142, 147, 0.5);
            background: rgba(255, 255, 255, 0.02);
        }

        .opportunity-badge {
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.3px;
            flex-shrink: 0;
        }

        .opportunity-badge.buy {
            background: rgba(48, 209, 88, 0.2);
            color: var(--positive);
            border: 1px solid rgba(48, 209, 88, 0.4);
        }

        .opportunity-badge.sell {
            background: rgba(255, 69, 58, 0.2);
            color: var(--negative);
            border: 1px solid rgba(255, 69, 58, 0.4);
        }

        .opportunity-info {
            flex: 1;
        }

        .opportunity-name {
            font-size: 15px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .opportunity-reason {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .opportunity-percentage {
            font-size: 20px;
            font-weight: 700;
            flex-shrink: 0;
        }

        .opportunity-percentage.positive {
            color: var(--positive);
        }

        .opportunity-percentage.negative {
            color: var(--negative);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .market-grid {
                grid-template-columns: 1fr;
            }

            .heatmap-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .heatmap-toggle-group {
                flex-wrap: wrap;
            }

            .heatmap-player-grid {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            }

            .position-stats {
                flex-wrap: wrap;
                gap: 12px;
            }
        }

        /* ============================================
           12. UTILITIES
           ============================================ */
        .hidden {
            display: none !important;
        }

        .loading {
            text-align: center;
            padding: var(--spacing-xl);
            color: var(--text-secondary);
        }

        .empty-state {
            text-align: center;
            padding: var(--spacing-xl);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: var(--spacing-md);
        }

        .empty-state-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
        }

        .empty-state-subtitle {
            color: var(--text-secondary);
        }

        /* Matrix tabs styling */
        .matrix-tab {
            transition: all 0.2s ease;
        }

        .matrix-tab:hover {
            background: var(--bg-elevated) !important;
        }

        .matrix-tab.active {
            background: var(--positive) !important;
            color: white !important;
        }

        .matrix-chart-tab {
            transition: all 0.2s ease;
        }

        .matrix-chart-tab:hover {
            color: var(--text-primary) !important;
        }

        .matrix-chart-tab.active {
            color: var(--text-primary) !important;
            border-bottom-color: var(--positive) !important;
        }

        .matrix-section {
            animation: fadeIn 0.3s ease;
        }

        .matrix-chart-content {
            animation: fadeIn 0.3s ease;
        }
        /* ============================================
           CATEGORY CARDS (Dashboard)
           ============================================ */
        /* Dashboard Header Widgets */
        .dashboard-header-widgets {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 16px;
        }

        .dashboard-widget {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            overflow: hidden;
        }

        .widget-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            background: var(--bg-tertiary);
        }

        .mover-filter-btns {
            display: flex;
            gap: 4px;
        }

        .filter-btn {
            padding: 6px 12px;
            font-size: 11px;
            font-weight: 600;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .filter-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        .filter-btn.active {
            background: var(--positive);
            color: white;
            border-color: var(--positive);
        }

        .widget-title {
            font-size: 13px;
            font-weight: 700;
            color: var(--text-primary);
        }

        /* Expand button */
        .expand-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            line-height: 1;
        }

        .expand-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
            border-color: var(--positive);
        }

        /* Expanded state for charts */
        .dashboard-widget.expanded {
            grid-column: span 2 !important;
        }

        .dashboard-widget.collapsed {
            display: none;
        }

        .dashboard-widget.expanded .expand-btn {
            background: var(--positive);
            color: white;
            border-color: var(--positive);
        }

        .widget-body {
            padding: 16px;
        }

        /* Dashboard scatter info icon (mobile only) */
        .dashboard-scatter-info {
            display: none; /* Hidden on desktop */
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 1.5px solid var(--text-tertiary);
            color: var(--text-tertiary);
            font-size: 11px;
            font-weight: 700;
            font-style: normal;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            flex-shrink: 0;
            margin-left: 6px;
        }

        .dashboard-scatter-info:hover {
            border-color: var(--text-secondary);
            color: var(--text-secondary);
            background: rgba(255, 255, 255, 0.05);
        }

        .dashboard-scatter-tooltip {
            position: absolute;
            left: calc(100% + 8px);
            top: 50%;
            transform: translateY(-50%);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 11px;
            color: var(--text-primary);
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .dashboard-scatter-info:hover .dashboard-scatter-tooltip,
        .dashboard-scatter-info.active .dashboard-scatter-tooltip {
            opacity: 1;
            visibility: visible;
        }

        /* Full Width Stat of the Week Widget */
        .stat-widget-full {
            margin-bottom: 24px;
        }

        .stat-widget-full .widget-body {
            padding: 16px 24px;
        }

        .stat-highlight-horizontal {
            display: flex;
            align-items: center;
            gap: 24px;
        }

        .stat-highlight-horizontal .stat-highlight-value {
            font-size: 48px;
            font-weight: 900;
            background: linear-gradient(135deg, #30d158, #0a84ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            flex-shrink: 0;
        }

        .stat-highlight-content {
            flex: 1;
        }

        .stat-highlight-horizontal .stat-highlight-label {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .stat-highlight-horizontal .stat-highlight-text {
            font-size: 13px;
            line-height: 1.5;
            color: var(--text-secondary);
        }

        .stat-highlight-horizontal .stat-highlight-text strong {
            color: var(--positive);
            font-weight: 700;
        }

        /* Insight Navigation Buttons */
        .insight-nav-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            width: 28px;
            height: 28px;
            border-radius: 6px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            padding: 0;
            line-height: 1;
        }

        .insight-nav-btn:hover {
            background: var(--bg-elevated);
            border-color: var(--text-tertiary);
            transform: translateY(-1px);
        }

        .insight-nav-btn:active {
            transform: translateY(0);
        }

        /* Legacy vertical stat styling */
        .stat-highlight {
            text-align: center;
        }

        .stat-highlight-value {
            font-size: 32px;
            font-weight: 900;
            background: linear-gradient(135deg, #30d158, #0a84ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 4px;
        }

        .stat-highlight-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .stat-highlight-text {
            font-size: 11px;
            line-height: 1.5;
            color: var(--text-secondary);
        }

        .stat-highlight-text strong {
            color: var(--positive);
            font-weight: 700;
        }

        /* Trend Widget */
        .trend-widget {
            display: flex;
            flex-direction: column;
        }

        .trend-widget .widget-body {
            padding: 12px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .dashboard-chart-wrapper {
            flex: 1;
            min-height: 220px;
            position: relative;
        }

        .dashboard-chart-wrapper canvas {
            width: 100% !important;
            height: 100% !important;
        }

        .dashboard-scrubber {
            margin-top: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .scrubber-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            min-width: 80px;
        }

        .dashboard-scrubber .week-scrubber {
            flex: 1;
        }

        .playback-btn-small {
            width: 28px;
            height: 28px;
            background: var(--positive);
            border: none;
            border-radius: 4px;
            color: #000;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .playback-btn-small:hover {
            background: #28c149;
        }

        .playback-btn-small.playing {
            background: var(--negative);
        }

        /* Categories Section */
        .categories-section {
            margin: 16px 0;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            max-height: none; /* Remove height restriction */
            overflow: visible; /* Allow full height */
            padding-right: 8px;
        }

        /* Override grid when carousel is present */
        .categories-section:has(.categories-carousel-container) {
            display: block;
            padding-right: 0;
        }

        /* Custom scrollbar for categories section */
        .categories-section::-webkit-scrollbar {
            width: 8px;
        }

        .categories-section::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        .categories-section::-webkit-scrollbar-thumb {
            background: var(--bg-elevated);
            border-radius: 4px;
        }

        .categories-section::-webkit-scrollbar-thumb:hover {
            background: var(--border-color-light);
        }

        .category-row {
            margin-bottom: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
        }

        /* Categories Carousel */
        .categories-carousel-container {
            position: relative;
            margin-bottom: 0;
            margin-top: -24px; /* Closer to header */
            min-height: 340px; /* Reduced for tighter spacing */
            overflow: hidden; /* Clip carousel to container width - critical for alignment */
            width: 100%; /* Stay within parent container */
            max-width: 100%; /* Enforce boundary */
        }

        .categories-carousel-scroll {
            display: flex;
            gap: 20px;
            overflow: visible; /* Allow items to exist but container clips them */
            scrollbar-width: none;
            -ms-overflow-style: none;
            padding: 20px 0;  /* Vertical padding only - no horizontal padding */
            margin: 0;        /* No margins that could push beyond bounds */
            animation: scrollReverse 240s linear infinite;
            white-space: nowrap;
            width: fit-content; /* Only as wide as content */
        }

        .categories-carousel-scroll:hover {
            animation-play-state: paused; /* Pause animation on hover */
        }

        .categories-carousel-scroll::-webkit-scrollbar {
            display: none;
        }

        .category-carousel-item {
            flex: 0 0 calc(50% - 10px);
            scroll-snap-align: start;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 10px;
            min-width: 360px;
            max-width: 400px;
            min-height: 160px; /* Ultra-compact cards */
            overflow: visible; /* Show all content */
        }

        .carousel-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color);
            width: 48px;
            height: 48px;
            border-radius: 50%;
            font-size: 28px;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .carousel-nav:hover {
            background: var(--text-primary);
            color: var(--bg-primary);
            transform: translateY(-50%) scale(1.1);
        }

        .carousel-nav-left {
            left: 10px;
        }

        .carousel-nav-right {
            right: 10px;
        }

        /* Category Footnote */
        .category-footnote {
            margin-top: 16px;
            text-align: center;
        }

        .footnote-toggle {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 16px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .footnote-toggle:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        .footnote-content {
            margin-top: 12px;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 11px;
            line-height: 1.6;
            color: var(--text-secondary);
            text-align: left;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        /* Team Modal Enhancements */
        .team-stat-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            transition: all 0.2s ease;
        }

        .team-stat-card:hover {
            transform: translateY(-2px);
            border-color: var(--border-color-light);
        }

        .team-stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .team-stat-label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .team-stats-summary {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }

        .key-player-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .key-player-card:hover {
            transform: translateY(-2px);
            border-color: var(--positive);
            background: var(--bg-elevated);
        }

        .key-player-position {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            color: white;
            flex-shrink: 0;
        }

        .key-player-info {
            flex: 1;
        }

        .key-player-name {
            font-size: 12px;
            font-weight: 600;
            color: #ffffff !important;
            margin-bottom: 2px;
        }

        .key-player-stat {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 2px solid var(--border-color);
        }

        .category-title {
            font-size: 16px;
            font-weight: 700;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 6px;
            letter-spacing: 0.3px;
        }

        .category-icon {
            font-size: 18px;
            filter: brightness(1.2);
        }

        .category-expand-btn {
            padding: 6px 12px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .category-expand-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-color: var(--border-color-light);
        }

        .category-cards-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 4px;
            margin-top: 6px;
            max-height: none; /* Remove any height restrictions */
            overflow: visible; /* Ensure all cards are visible */
        }

        /* Category rank - simple text on right */
        .category-rank-simple {
            font-size: 14px;
            font-weight: 700;
            color: var(--text-secondary);
            flex-shrink: 0;
        }

        /* Make dashboard category cards very compact */
        .category-cards-container .player-card {
            padding: 4px;
            position: relative;
            margin-bottom: 0;
            min-height: 38px !important; /* Override base min-height for tight fit */
            height: auto;
        }

        .category-cards-container .player-card-header {
            margin-bottom: 0;
            gap: 8px;
        }

        .category-cards-container .player-card-badge {
            width: 28px;
            height: 28px;
            font-size: 9px;
        }

        .category-cards-container .player-card-name {
            font-size: 12px;
            line-height: 1.2;
        }

        .category-cards-container .player-card-team {
            font-size: 10px;
            margin-top: 0;
        }

        .category-cards-container .player-card-stats {
            gap: 4px;
            margin-bottom: 0;
            display: grid;
            grid-template-columns: 1fr 1fr;
        }

        .category-cards-container .player-stat {
            font-size: 10px;
            justify-content: flex-start;
            gap: 2px;
            position: relative;
        }

        /* Show tooltip only when hovering over the info icon */
        .category-info-icon:hover .stat-tooltip {
            opacity: 1;
        }

        /* Show tooltip when hovering over stat value */
        .category-cards-container .player-stat-value:hover .stat-tooltip {
            opacity: 1;
        }

        /* Show change tooltip when hovering over comparison */
        .category-cards-container .player-comparison:hover .change-tooltip {
            opacity: 1;
        }

        /* Also show tooltip on hover of comparison span inside */
        .category-cards-container .player-comparison span:hover .change-tooltip {
            opacity: 1;
        }

        .category-cards-container .player-stat-label {
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .category-cards-container .player-stat-value {
            font-size: 12px;
            font-weight: 700;
        }

        .category-cards-container .player-comparison {
            font-size: 12px;
        }

        .category-cards-container .player-card-chart {
            display: none;
        }

        /* Enable tooltips on category cards with proper styling */
        .category-cards-container .stat-tooltip {
            font-size: 10px;
            white-space: normal;
            max-width: 200px;
            z-index: 2000;
            line-height: 1.4;
        }

        .category-cards-container .comparison-tooltip {
            display: none; /* Keep comparison tooltips hidden for cleaner UI */
        }

        /* Change tooltip for leaderboard cards */
        .change-tooltip {
            position: absolute;
            bottom: 100%;
            right: 0;
            transform: translateY(0);
            margin-bottom: 8px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 10px;
            white-space: normal;
            max-width: 180px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 2001;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            line-height: 1.4;
        }

        .player-comparison:hover .change-tooltip {
            opacity: 1;
        }

        /* Compact player cards for all-leaderboards page */
        .compact-player-card:hover {
            background: var(--bg-elevated);
            border-color: var(--border-color-light);
            transform: translateY(-1px);
        }

        .compact-player-card .player-comparison:hover .change-tooltip {
            opacity: 1;
        }

        .compact-metric-value:hover .stat-tooltip {
            opacity: 1;
        }

        /* Portal-style tooltip */
        #portal-tooltip {
            position: fixed;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 11px;
            line-height: 1.5;
            color: var(--text-primary);
            max-width: 280px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s ease;
            z-index: 99999;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
        }

        #portal-tooltip.visible {
            opacity: 1;
        }

        #portal-tooltip .tooltip-secondary {
            color: var(--text-tertiary);
            margin-top: 6px;
            display: block;
            font-size: 10px;
        }

        /* Horizontal bar for leaderboard metrics */
        .metric-bar-container {
            position: relative;
            width: 100%;
            height: 10px;
            margin-top: 4px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.05);
            overflow: hidden;
        }

        .metric-bar {
            height: 100%;
            border-radius: 5px;
            transition: width 0.6s ease;
        }

        /* Category card specific styles - Using player-card base styles */
        /* Rank badges handled inline in renderCategoryCard */

        /* Expanded state */
        .category-cards-expanded {
            grid-template-columns: 1fr;
        }

        .category-card-hidden {
            display: none;
        }

        /* ============================================
           ADVANCED ANALYTICS STYLES
           ============================================ */
        .advanced-analytics-container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .advanced-header {
            margin-bottom: 32px;
        }

        .advanced-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .advanced-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .position-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 24px;
            padding: 4px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            width: fit-content;
        }

        .position-toggle-btn {
            padding: 10px 24px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .position-toggle-btn.active {
            background: var(--bg-secondary);
            color: var(--text-primary);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        /* Player Count Filter Buttons */
        .player-count-btn {
            padding: 6px 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s ease;
            min-width: 40px;
        }

        .player-count-btn:hover {
            background: var(--bg-secondary);
            border-color: var(--border-color-light);
            color: var(--text-primary);
        }

        .player-count-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        /* Zoom Button */
        .zoom-btn {
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .zoom-btn:hover {
            background: var(--bg-secondary);
            border-color: var(--border-color-light);
            color: var(--text-primary);
        }

        .zoom-btn svg {
            flex-shrink: 0;
        }

        .preset-section {
            margin-bottom: 24px;
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .preset-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 8px;
        }

        .preset-btn {
            padding: 10px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color-light);
            color: var(--text-primary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
            white-space: nowrap;
            text-align: center;
        }

        .preset-btn:hover {
            background: var(--bg-elevated);
            border-color: var(--positive);
            transform: translateY(-1px);
        }

        .preset-btn:active {
            transform: translateY(0);
        }

        .axis-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-bottom: 32px;
        }

        .axis-control {
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        /* Subtle pulse animation for axis labels */
        @keyframes subtle-pulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(10, 132, 255, 0);
            }
            50% {
                box-shadow: 0 0 8px 2px rgba(10, 132, 255, 0.3);
            }
        }

        .axis-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
            padding: 8px 12px;
            margin: -8px -12px 4px -12px;
            border-radius: 8px;
            transition: all 0.3s ease;
            animation: subtle-pulse 3s ease-in-out infinite;
        }

        .axis-label:hover {
            background: var(--bg-secondary);
            color: var(--accent);
            animation: none;
        }

        /* Non-clickable labels (for Highlight Player, Week Range) - no animations */
        .axis-label-static {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
        }

        .axis-label-text {
            flex: 1;
        }

        .axis-collapse-icon {
            font-size: 14px;
            transition: transform 0.2s ease;
            color: var(--text-tertiary);
        }

        .axis-collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .axis-control-content {
            max-height: 200px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 1;
        }

        .axis-control-content.collapsed {
            max-height: 0;
            opacity: 0;
        }

        .axis-select {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .axis-select:hover {
            border-color: var(--positive);
        }

        .axis-select:focus {
            outline: none;
            border-color: var(--positive);
            box-shadow: 0 0 0 3px rgba(48, 209, 88, 0.1);
        }

        .scatter-chart-card {
            background: var(--bg-tertiary);
            border-radius: 16px;
            padding: 24px;
            border: 1px solid var(--border-color);
        }

        .scatter-chart-header {
            margin-bottom: 20px;
        }

        .scatter-chart-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .scatter-chart-description {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .scatter-chart-description strong {
            color: var(--text-primary);
            font-weight: 600;
        }

        .scatter-chart-wrapper {
            position: relative;
            height: 600px;
        }

        /* ============================================
           FOOTER
           ============================================ */
        .footer {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 48px 24px 24px;
            margin-top: 80px;
        }

        .footer-content {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 2fr 1fr 1fr;
            gap: 48px;
        }

        .footer-section h3 {
            font-size: 14px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 16px;
            letter-spacing: 0.5px;
        }

        .footer-section p {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 16px;
        }

        .waitlist-form {
            display: flex;
            gap: 8px;
            margin-top: 16px;
        }

        .waitlist-input {
            flex: 1;
            padding: 10px 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 13px;
            transition: all 0.2s ease;
        }

        .waitlist-input:focus {
            outline: none;
            border-color: #0a84ff;
            background: var(--bg-elevated);
        }

        .waitlist-input::placeholder {
            color: var(--text-tertiary);
        }

        .waitlist-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #30d158, #0a84ff);
            border: none;
            border-radius: 8px;
            color: #fff;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            box-shadow: 0 0 15px rgba(48, 209, 88, 0.3),
                        0 0 30px rgba(10, 132, 255, 0.15);
        }

        .waitlist-btn:hover {
            box-shadow: 0 0 20px rgba(48, 209, 88, 0.5),
                        0 0 40px rgba(10, 132, 255, 0.25);
            transform: translateY(-1px);
        }

        .waitlist-btn:active {
            transform: translateY(0);
        }

        .footer-links {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .footer-link {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 13px;
            transition: color 0.2s ease;
        }

        .footer-link:hover {
            color: var(--text-primary);
        }

        .footer-bottom {
            max-width: 1400px;
            margin: 32px auto 0;
            padding-top: 24px;
            border-top: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 12px;
            color: var(--text-tertiary);
        }

        .footer-logo {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 16px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .footer-logo-icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #30d158, #0a84ff);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 900;
            color: white;
            box-shadow: 0 0 15px rgba(48, 209, 88, 0.3),
                        0 0 30px rgba(10, 132, 255, 0.15);
        }

        .footer-logo-icon::before {
            content: '>';
            transform: scaleX(1.3);
        }

        .footer-copyright {
            flex: 1;
            text-align: center;
        }

        .success-message {
            padding: 10px 14px;
            background: var(--positive-bg);
            border: 1px solid var(--positive);
            border-radius: 8px;
            color: var(--positive);
            font-size: 13px;
            margin-top: 8px;
            display: none;
        }

        .success-message.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        /* Waitlist Confirmation Modal */
        .waitlist-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(4px);
        }

        .waitlist-modal.show {
            display: flex;
            animation: fadeIn 0.3s ease;
        }

        .waitlist-modal-content {
            background: var(--bg-elevated);
            border-radius: 16px;
            padding: 32px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            border: 1px solid var(--border-color-light);
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .waitlist-modal-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .waitlist-modal-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .waitlist-modal-message {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 24px;
            line-height: 1.5;
        }

        .waitlist-modal-btn {
            padding: 12px 32px;
            background: var(--positive);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .waitlist-modal-btn:hover {
            background: #28c149;
            transform: translateY(-1px);
        }

        @media (max-width: 768px) {
            .footer-content {
                grid-template-columns: 1fr;
                gap: 32px;
            }

            /* Mobile carousel - swipeable, one card at a time */
            .category-carousel-item {
                flex: 0 0 100%;
                min-width: calc(100vw - 80px);
                max-width: calc(100vw - 80px);
                scroll-snap-align: center;
            }

            .categories-carousel-container {
                overflow-x: scroll;
                overflow-y: hidden;
                scroll-snap-type: x mandatory;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
                -ms-overflow-style: none;
                scroll-behavior: smooth;
                touch-action: pan-x;
            }

            .categories-carousel-container::-webkit-scrollbar {
                display: none;
            }

            .categories-carousel-scroll {
                animation: none !important; /* Disable auto-scroll on mobile */
                gap: 20px;
                padding: 20px 40px;
                display: flex;
                width: auto;
            }
        }

        @media (min-width: 769px) {
            .category-carousel-item {
                flex: 0 0 calc(50% - 10px);
                min-width: 360px;
                max-width: 400px;
            }
        }

        /* ============================================
           MOBILE HAMBURGER MENU
           ============================================ */
        .mobile-menu-button {
            display: none; /* Hidden on desktop */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 40px;
            height: 40px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 10002; /* Above everything including tooltips */
            position: relative;
        }

        .mobile-menu-button:hover {
            background: var(--bg-elevated);
        }

        .hamburger-line {
            width: 20px;
            height: 2px;
            background: var(--text-primary);
            margin: 3px 0;
            transition: all 0.3s ease;
        }

        .mobile-menu-button.active .hamburger-line:nth-child(1) {
            transform: rotate(45deg) translate(6px, 6px);
        }

        .mobile-menu-button.active .hamburger-line:nth-child(2) {
            opacity: 0;
        }

        .mobile-menu-button.active .hamburger-line:nth-child(3) {
            transform: rotate(-45deg) translate(6px, -6px);
        }

        .mobile-menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000; /* Above tooltips but below menu button */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .mobile-menu-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .mobile-menu {
            position: fixed;
            top: 0;
            right: -100%;
            width: 280px;
            height: 100vh;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            z-index: 10001; /* Above overlay and tooltips */
            padding: 24px;
            overflow-y: auto;
            transition: right 0.3s ease;
        }

        .mobile-menu.active {
            right: 0;
        }

        .mobile-menu-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 32px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .mobile-menu-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .mobile-menu-close {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .mobile-menu-close:hover {
            background: var(--bg-elevated);
        }

        .mobile-menu-items {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .mobile-menu-item {
            padding: 14px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }

        .mobile-menu-item:hover {
            background: var(--bg-elevated);
            border-color: var(--positive);
        }

        .mobile-menu-item.active {
            background: var(--positive-bg);
            border-color: var(--positive);
            color: var(--positive);
        }

        .mobile-menu-divider {
            height: 1px;
            background: var(--border-color);
            margin: 16px 0;
        }

        .mobile-menu-waitlist {
            margin-top: 16px;
            padding: 14px 16px;
            background: var(--positive);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
        }

        .mobile-menu-waitlist:hover {
            background: #28c149;
            transform: translateY(-1px);
        }

        /* Carousel Pagination Dots (Mobile) */
        .carousel-dots {
            display: none; /* Hidden on desktop */
            justify-content: center;
            gap: 8px;
            padding: 16px 0;
            margin-top: -16px;
        }

        .carousel-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-tertiary);
            opacity: 0.3;
            transition: all 0.3s ease;
            cursor: pointer; /* Make dots clickable */
        }

        .carousel-dot:hover {
            opacity: 0.6; /* Hover feedback */
        }

        .carousel-dot.active {
            width: 24px;
            border-radius: 4px;
            background: var(--positive);
            opacity: 1;
        }

        @media (max-width: 768px) {
            .carousel-dots {
                display: flex;
            }
        }

        /* ============================================
           MOBILE RESPONSIVE
           ============================================ */
        @media (max-width: 1200px) {
            .player-cards-grid {
                grid-template-columns: repeat(2, 1fr); /* Keep 2 columns for consistency */
                gap: 16px;
            }
        }

        @media (max-width: 1024px) {
            .main-content {
                padding: var(--spacing-md);
            }

            .player-cards-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 16px;
            }
        }

        @media (max-width: 768px) {
            body {
                overflow-x: hidden;
                max-width: 100vw;
            }

            .header {
                padding: 12px 16px;
            }

            .logo {
                font-size: 18px;
            }

            /* Hide desktop navigation on mobile */
            .nav-tabs {
                display: none;
            }

            /* Show scoring dropdown and hamburger on mobile, hide join waitlist */
            .header-right-section {
                display: flex !important;
            }

            .header-right-section .upload-btn {
                display: none !important;
            }

            .header-right-section .header-scoring-dropdown {
                display: block !important;
            }

            /* Show hamburger menu button */
            .mobile-menu-button {
                display: flex !important;
            }

            .nav-tab {
                padding: 8px 12px;
                font-size: 12px;
                flex-shrink: 0;
            }

            .upload-btn {
                padding: 8px 14px;
                font-size: 12px;
            }

            .main-content {
                padding: 16px;
                overflow-x: hidden;
                max-width: 100vw;
            }

            .page-title {
                font-size: 20px;
            }

            .page-subtitle {
                font-size: 13px;
            }

            .player-cards-grid {
                grid-template-columns: repeat(2, 1fr) !important;
                gap: 12px;
                max-width: 100%;
                overflow: hidden;
            }

            .player-card {
                padding: 12px;
                max-width: 100%;
                overflow: hidden;
                box-sizing: border-box;
            }

            /* Compact player card elements for 2-column layout */
            .player-card-badge {
                width: 40px;
                height: 40px;
                font-size: 10px;
            }

            .player-card-name {
                font-size: 14px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            .player-card-team {
                font-size: 11px;
            }

            .player-card-header {
                gap: 10px;
                margin-bottom: 10px;
            }

            .stat-value {
                font-size: 18px;
            }

            .stat-label {
                font-size: 10px;
            }

            .player-tags {
                gap: 4px;
            }

            .player-tag {
                font-size: 9px;
                padding: 2px 6px;
            }

            .teams-grid {
                grid-template-columns: 1fr;
            }

            /* Team Analysis Controls - 2x2 on mobile */
            .team-analysis-controls {
                grid-template-columns: repeat(2, 1fr) !important;
            }

            /* Stack team charts on mobile - pie on top, bar below */
            #team-charts-container {
                grid-template-columns: 1fr !important;
                min-height: auto !important;
            }

            /* Make scatter plot more readable on mobile */
            #team-balance-scatter {
                height: 350px !important;
            }

            .chart-wrapper {
                height: 300px !important;
                width: 100% !important;
                max-width: 100% !important;
                overflow: hidden;
            }

            .chart-card {
                padding: 12px !important;
                overflow: hidden;
            }

            .chart-card canvas {
                max-width: 100% !important;
                height: auto !important;
            }

            /* Ensure team charts fit on mobile */
            #team-pie-chart, #team-secondary-chart {
                max-width: 100% !important;
            }

            .categories-grid {
                grid-template-columns: 1fr;
            }

            .scatter-plots {
                grid-template-columns: 1fr;
            }

            /* Stack dashboard scatter plots on mobile */
            .dashboard-header-widgets {
                grid-template-columns: 1fr !important;
            }

            /* Hide animated trend controls on mobile */
            .dashboard-scrubber {
                display: none !important;
            }

            /* Hide filter buttons and expand button on dashboard scatter plots (mobile) */
            .dashboard-widget .mover-filter-btns {
                display: none !important;
            }

            .dashboard-widget .expand-btn {
                display: none !important;
            }

            /* Show info icon on mobile for dashboard scatters */
            .dashboard-scatter-info {
                display: inline-flex !important;
            }

            /* Fix ticker to top-movers spacing on mobile */
            .ticker-section {
                position: relative !important; /* Disable sticky on mobile */
                top: auto !important;
                margin-bottom: 24px !important;
            }

            #wr-top-movers-sidebar,
            #rb-top-movers-sidebar,
            #te-top-movers-sidebar {
                margin-top: 0 !important;
            }

            .modal {
                width: 95%;
                max-width: 95%;
                margin: 20px;
                max-height: 90vh;
                padding: 20px;
            }

            /* Team Modal - Stack charts on mobile */
            .team-modal-charts-grid {
                grid-template-columns: 1fr !important;
                gap: 16px !important;
            }

            #team-modal-controls-grid {
                gap: 12px !important;
            }

            /* Adjust team modal stats summary */
            #team-stats-summary {
                grid-template-columns: repeat(2, 1fr) !important;
            }

            /* Key players grid - keep 2 columns or stack */
            #key-players-grid {
                gap: 12px !important;
            }

            .modal-charts-grid {
                grid-template-columns: 1fr !important;
            }

            .axis-controls {
                grid-template-columns: 1fr;
            }

            .preset-buttons {
                grid-template-columns: 1fr;
            }

            /* Advanced Analytics - Reorder on mobile and make presets 2x2 */
            .advanced-analytics-charts-wrapper {
                display: flex;
                flex-direction: column-reverse; /* Scatter first, presets second */
            }

            .preset-buttons {
                grid-template-columns: repeat(2, 1fr) !important;
            }

            .footer {
                padding: 32px 16px 16px;
            }

            .footer-content {
                grid-template-columns: 1fr;
                gap: 24px;
            }

            .footer-bottom {
                flex-direction: column;
                gap: 16px;
                text-align: center;
            }

            .footer-copyright {
                text-align: center;
            }

            .waitlist-form {
                flex-direction: column;
            }

            .waitlist-btn {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            .logo span {
                display: inline;
                font-size: 16px;
            }

            .nav-tab {
                padding: 6px 10px;
                font-size: 11px;
            }

            .page-title {
                font-size: 18px;
            }

            /* Single column for very small screens */
            .cards-grid {
                grid-template-columns: 1fr !important;
                gap: 12px;
            }

            /* Even more compact player cards on small phones */
            .player-card {
                padding: 10px;
            }

            .player-stat-value {
                font-size: 14px;
            }

            /* Top Movers - Stack on mobile */
            #wide-receivers > div[style*="grid-template-columns"],
            #running-backs > div[style*="grid-template-columns"] {
                grid-template-columns: 1fr !important;
            }

            #wr-top-movers-sidebar,
            #rb-top-movers-sidebar {
                position: static !important;
                margin-top: 20px;
            }
        }

        /* ============================================
           LOADING SPINNER
           ============================================ */
        .loading-spinner {
            width: 40px;
            height: 40px;
            margin: 0 auto;
            border: 4px solid var(--bg-tertiary);
            border-top: 4px solid var(--positive);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* ============================================
           INITIAL LOADING SCREEN
           ============================================ */
        #initial-loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            z-index: 99999;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease-out;
        }

        #initial-loading-screen.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .loading-container {
            text-align: center;
            padding: 40px;
            max-width: 500px;
            width: 90%;
        }

        .loading-logo {
            width: 64px;
            height: 64px;
            margin: 0 auto 24px;
            background: linear-gradient(135deg, #30d158, #0a84ff);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            font-size: 44px;
            font-weight: 900;
            box-shadow: 0 0 20px rgba(48, 209, 88, 0.4),
                        0 0 40px rgba(10, 132, 255, 0.2);
        }

        .loading-logo::before {
            content: '>';
            transform: scaleX(1.3);
            color: #fff;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .loading-logo-icon {
            display: none; /* Hide the separate icon div */
        }

        @keyframes pulse-logo {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 20px rgba(48, 209, 88, 0.4),
                            0 0 40px rgba(10, 132, 255, 0.2);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 30px rgba(48, 209, 88, 0.6),
                            0 0 60px rgba(10, 132, 255, 0.4);
            }
        }

        .loading-title {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 8px;
            letter-spacing: -0.5px;
        }

        .loading-subtitle {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 32px;
        }

        .loading-ticker {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 16px;
            margin-bottom: 40px;
        }

        .ticker-arrow {
            font-size: 24px;
            font-weight: 700;
            opacity: 0.3;
            animation: ticker-pulse 1.5s ease-in-out infinite;
        }

        .ticker-arrow:nth-child(1) {
            color: var(--positive);
            animation-delay: 0s;
        }

        .ticker-arrow:nth-child(2) {
            color: var(--negative);
            animation-delay: 0.5s;
        }

        .ticker-arrow:nth-child(3) {
            color: var(--positive);
            animation-delay: 1s;
        }

        @keyframes ticker-pulse {
            0%, 100% {
                opacity: 0.3;
                transform: scale(1);
            }
            50% {
                opacity: 1;
                transform: scale(1.2);
            }
        }

        .loading-progress-container {
            margin-bottom: 16px;
            width: 60%;
            max-width: 300px;
            margin-left: auto;
            margin-right: auto;
        }

        .loading-progress-bar {
            width: 100%;
            height: 2px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }

        .loading-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--positive) 0%, #00d9ff 100%);
            border-radius: 2px;
            transition: width 0.3s ease-out;
            width: 0%;
            box-shadow: 0 0 6px rgba(48, 209, 88, 0.3);
        }

        .loading-progress-text {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 12px;
        }

        .loading-percentage {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .loading-status {
            font-size: 13px;
            color: var(--text-secondary);
        }

        @media (max-width: 768px) {
            .loading-container {
                padding: 24px;
            }

            .loading-logo {
                width: 56px;
                height: 56px;
                font-size: 38px;
            }

            .loading-title {
                font-size: 24px;
            }

            .loading-subtitle {
                font-size: 13px;
                margin-bottom: 24px;
            }

            .loading-ticker {
                gap: 12px;
                margin-bottom: 32px;
            }

            .ticker-arrow {
                font-size: 20px;
            }

            .loading-progress-container {
                width: 70%;
                max-width: 250px;
            }

            .loading-progress-bar {
                height: 1.5px;
            }

            .loading-progress-fill {
                border-radius: 1.5px;
            }
        }

        /* Floor Metrics Tooltip Hover */
        .radial-with-tooltip:hover .radial-tooltip {
            opacity: 1 !important;
            pointer-events: auto;
        }


        /* ============================================
           SCHEDULE TAB STYLES
           ============================================ */

        .schedule-content {
            padding: 30px;
        }

        .schedule-header {
            text-align: center;
            margin-bottom: 24px;
        }

        .schedule-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .schedule-subtitle {
            font-size: 13px;
            color: #8e8e93;
        }

        .schedule-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .schedule-row {
            display: grid;
            grid-template-columns: 100px 180px 160px 160px;
            gap: 20px;
            background: #2c2c2e;
            padding: 12px 16px;
            border-radius: 10px;
            align-items: center;
            border: 1px solid #3c3c3e;
            transition: all 0.2s ease;
        }

        .schedule-row:hover {
            background: #3c3c3e;
            transform: translateX(2px);
            border-color: #30d158;
        }

        .schedule-row.bye-week {
            opacity: 0.5;
        }

        /* Week column */
        .week-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .week-label {
            font-size: 11px;
            color: #8e8e93;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .week-number {
            font-size: 15px;
            font-weight: 700;
            color: #fff;
        }


        /* Matchup column */
        .matchup-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .opponent-line {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .vs-label {
            font-size: 11px;
            color: #8e8e93;
            font-weight: 600;
        }

        .opponent-team {
            font-size: 15px;
            font-weight: 700;
            color: #fff;
        }

        /* Mobile defense ranks - hidden on desktop */
        .mobile-defense-ranks {
            display: none;
            margin-top: 6px;
            font-size: 11px;
            color: #8e8e93;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .mobile-rank {
            font-weight: 600;
        }

        .mobile-rank.good {
            color: #30d158;
        }

        .mobile-rank.neutral {
            color: #ffd60a;
        }

        .mobile-rank.bad {
            color: #ff453a;
        }

        .mobile-rank-separator {
            color: #636366;
        }

        .desktop-only {
            display: block;
        }

        .betting-info {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .betting-odds-column {
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: flex-end;
            justify-content: center;
        }

        .spread-badge {
            display: inline-block;
            background: rgba(10, 132, 255, 0.15);
            color: #0a84ff;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
        }

        .over-under-badge {
            display: inline-block;
            background: rgba(255, 214, 10, 0.15);
            color: #ffd60a;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
        }

        /* Defense rankings */
        .defense-rank {
            text-align: center;
            position: relative;
            cursor: help;
        }

        .rank-label {
            font-size: 9px;
            color: #8e8e93;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 3px;
        }

        .info-icon {
            display: inline-block;
            width: 12px;
            height: 12px;
            background: #3c3c3e;
            border-radius: 50%;
            text-align: center;
            line-height: 12px;
            font-size: 9px;
            color: #8e8e93;
            font-weight: 700;
        }

        .rank-value {
            font-size: 16px;
            font-weight: 700;
            padding: 4px 10px;
            border-radius: 6px;
        }

        .rank-value.elite {
            background: rgba(48, 209, 88, 0.15);
            color: #30d158;
            border: 1px solid rgba(48, 209, 88, 0.3);
        }

        .rank-value.elite {
            background: rgba(48, 209, 88, 0.2);
            color: #30d158;
            border: 1px solid rgba(48, 209, 88, 0.4);
            font-weight: 700;
        }

        .rank-value.good {
            background: rgba(48, 209, 88, 0.12);
            color: #30d158;
            border: 1px solid rgba(48, 209, 88, 0.25);
        }

        .rank-value.average {
            background: rgba(255, 214, 10, 0.15);
            color: #ffd60a;
            border: 1px solid rgba(255, 214, 10, 0.3);
        }

        .rank-value.tough {
            background: rgba(255, 159, 10, 0.15);
            color: #ff9f0a;
            border: 1px solid rgba(255, 159, 10, 0.3);
        }

        .rank-value.bad {
            background: rgba(255, 69, 58, 0.15);
            color: #ff453a;
            border: 1px solid rgba(255, 69, 58, 0.3);
        }

        /* Tooltip */
        .rank-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            padding: 10px 12px;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid #30d158;
            border-radius: 8px;
            font-size: 11px;
            line-height: 1.5;
            color: #fff;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .rank-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: #30d158;
        }

        .defense-rank:hover .rank-tooltip {
            opacity: 1;
        }

        .tooltip-title {
            color: #30d158;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .tooltip-text {
            color: #ddd;
        }
    </style>
</head>
<body>
    <!-- Initial Loading Screen -->
    <div id="initial-loading-screen">
        <div class="loading-container">
            <div class="loading-logo"></div>
            <div class="loading-title">FFSE Loading</div>
            <div class="loading-subtitle">Fantasy Football Stock Exchange</div>
            <div class="loading-progress-container">
                <div class="loading-progress-bar">
                    <div class="loading-progress-fill" id="loading-progress-fill"></div>
                </div>
                <div class="loading-progress-text">
                    <span class="loading-status" id="loading-status">Initializing...</span>
                    <span class="loading-percentage" id="loading-percentage">0%</span>
                </div>
            </div>
        </div>
    </div>

    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="header-content">
                <div class="logo" onclick="
                    document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                    document.querySelector('.nav-tab[data-page=\'top-movers\']').classList.add('active');
                    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
                    document.getElementById('top-movers').classList.add('active');

                    // Update mobile menu active state
                    document.querySelectorAll('.mobile-menu-item').forEach(item => item.classList.remove('active'));
                    const mobileMenuItem = document.querySelector('.mobile-menu-item[data-page=\'top-movers\']');
                    if (mobileMenuItem) mobileMenuItem.classList.add('active');

                    setTimeout(() => {
                        renderDashboardCategories();
                        setTimeout(renderMiniScatterPlots, 100);
                    }, 100);
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                " style="cursor: pointer;">
                    <div class="logo-icon"></div>
                    <span>FFSE</span>
                </div>

                <nav class="nav-tabs">
                    <button class="nav-tab" data-page="analytics-dashboard">Heatmap</button>
                    <button class="nav-tab" data-page="top-movers">Leaderboards</button>
                    <button class="nav-tab active" data-page="wide-receivers">WR</button>
                    <button class="nav-tab" data-page="running-backs">RB</button>
                    <button class="nav-tab" data-page="tight-ends">TE</button>
                    <button class="nav-tab" data-page="teams">Team Outlook</button>
                    <button class="nav-tab" data-page="advanced-analytics">Advanced Analytics</button>
                    <button class="nav-tab" id="admin-tab" data-page="admin-panel" style="display: none;">Admin</button>
                </nav>
                <div class="header-right-section" style="display: flex; align-items: center; gap: 16px;">
                    <!-- Header Scoring Dropdown -->
                    <div class="header-scoring-dropdown" id="header-scoring-dropdown">
                        <button class="header-scoring-button" onclick="toggleHeaderScoringDropdown()">
                            <span id="header-scoring-label">PPR</span>
                            <span class="arrow">▼</span>
                        </button>
                        <div class="header-scoring-menu">
                            <button class="active" onclick="setHeaderScoringFormat('ppr')">PPR</button>
                            <button onclick="setHeaderScoringFormat('half')">Half-PPR</button>
                            <button onclick="setHeaderScoringFormat('std')">Standard</button>
                        </div>
                    </div>
                    <button class="upload-btn" onclick="scrollToWaitlist()">Join Waitlist</button>

                    <!-- Hamburger Menu Button (Mobile Only) - Now on the right -->
                    <button class="mobile-menu-button" onclick="toggleMobileMenu()">
                        <div class="hamburger-line"></div>
                        <div class="hamburger-line"></div>
                        <div class="hamburger-line"></div>
                    </button>
                </div>
            </div>
        </header>

        <!-- Mobile Menu Overlay -->
        <div class="mobile-menu-overlay" id="mobile-menu-overlay" onclick="closeMobileMenu()"></div>
        <div class="mobile-menu" id="mobile-menu">
            <div class="mobile-menu-header">
                <div class="mobile-menu-title">Menu</div>
                <button class="mobile-menu-close" onclick="closeMobileMenu()">×</button>
            </div>
            <div class="mobile-menu-items">
                <button class="mobile-menu-item" data-page="analytics-dashboard" onclick="navigateFromMobileMenu('analytics-dashboard')">
                    Heatmap
                </button>
                <button class="mobile-menu-item" data-page="top-movers" onclick="navigateFromMobileMenu('top-movers')">
                    Leaderboards
                </button>
                <button class="mobile-menu-item active" data-page="wide-receivers" onclick="navigateFromMobileMenu('wide-receivers')">
                    Wide Receivers
                </button>
                <button class="mobile-menu-item" data-page="running-backs" onclick="navigateFromMobileMenu('running-backs')">
                    Running Backs
                </button>
                <button class="mobile-menu-item" data-page="tight-ends" onclick="navigateFromMobileMenu('tight-ends')">
                    Tight Ends
                </button>
                <button class="mobile-menu-item" data-page="teams" onclick="navigateFromMobileMenu('teams')">
                    Team Outlook
                </button>
                <button class="mobile-menu-item" data-page="advanced-analytics" onclick="navigateFromMobileMenu('advanced-analytics')">
                    Advanced Analytics
                </button>
                <button class="mobile-menu-item" id="mobile-admin-tab" data-page="admin-panel" onclick="navigateFromMobileMenu('admin-panel')" style="display: none;">
                    Admin Panel
                </button>
            </div>
            <div class="mobile-menu-divider"></div>
            <button class="mobile-menu-waitlist" onclick="closeMobileMenu(); scrollToWaitlist();">
                Join Waitlist
            </button>
        </div>

        <!-- Scoring Format Toggle -->
        <div class="scoring-toggle-container">
            <div class="scoring-toggle">
                <button class="scoring-option active" data-format="ppr" onclick="setScoringFormat('ppr')">PPR</button>
                <button class="scoring-option" data-format="half" onclick="setScoringFormat('half')">Half-PPR</button>
                <button class="scoring-option" data-format="std" onclick="setScoringFormat('std')">Standard</button>
            </div>
        </div>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Analytics Dashboard Page -->
            <div id="analytics-dashboard" class="page">
                <div class="page-header">
                    <h1 class="page-title">Heatmap</h1>
                </div>
                <div class="analytics-dashboard-container">
                    <!-- Key Insight -->
                    <div class="dashboard-widget stat-widget-full" style="margin-bottom: 32px;">
                        <div class="widget-header">
                            <span class="widget-title" style="font-size: 16px;">Key Insight</span>
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <button onclick="previousInsight()" class="insight-nav-btn" title="Previous insight">‹</button>
                                <span id="analytics-insight-indicator" style="font-size: 11px; color: var(--text-tertiary);">1/4</span>
                                <button onclick="nextInsight()" class="insight-nav-btn" title="Next insight">›</button>
                            </div>
                        </div>
                        <div class="widget-body">
                            <div class="stat-highlight-horizontal" id="analytics-stat-of-week" style="transition: opacity 0.3s ease;">
                                <div class="stat-highlight-value">Loading...</div>
                                <div class="stat-highlight-content">
                                    <div class="stat-highlight-label">Analyzing data...</div>
                                    <div class="stat-highlight-text">
                                        Processing player statistics to find actionable insights.
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Position Performance Heatmap -->
                    <div class="heatmap-widget">
                        <!-- Position Dropdown Selector -->
                        <div class="position-selector">
                            <label class="dropdown-label">Position</label>
                            <select class="position-select" id="heatmap-position-select" onchange="updateHeatmap()">
                                <option value="WR">Wide Receivers (WR)</option>
                                <option value="RB">Running Backs (RB)</option>
                                <option value="TE">Tight Ends (TE)</option>
                            </select>
                        </div>

                        <!-- Controls -->
                        <div class="heatmap-controls">
                            <div class="heatmap-control-group">
                                <div class="heatmap-control-label">Time Period</div>
                                <div class="heatmap-toggle-group">
                                    <button class="heatmap-toggle-btn active" data-period="last3" onclick="setHeatmapPeriod('last3')">Last 3</button>
                                    <button class="heatmap-toggle-btn" data-period="last5" onclick="setHeatmapPeriod('last5')">Last 5</button>
                                </div>
                            </div>

                            <div class="heatmap-control-group">
                                <div class="heatmap-control-label">
                                    Metric
                                    <span class="info-icon" id="metric-info-icon">ⓘ</span>
                                </div>
                                <select class="metric-select" id="heatmap-metric-select" onchange="updateHeatmap()">
                                    <option value="actual-vs-expected">Actual vs Expected Points</option>
                                    <option value="target-share">Target/Opportunity Share (%)</option>
                                    <option value="rz-opp-share">RZ Opp Share (%)</option>
                                </select>
                                
                                <!-- Metric Explanation Tooltip -->
                                <div class="metric-tooltip" id="metric-tooltip" style="display: none;">
                                    <div class="metric-tooltip-content" id="metric-tooltip-content">
                                        <!-- Content will be populated by JavaScript based on selected metric -->
                                    </div>
                                </div>
                            </div>

                            <div class="heatmap-control-group">
                                <div class="heatmap-control-label">Display</div>
                                <div class="heatmap-toggle-group">
                                    <button class="heatmap-toggle-btn active" data-display="24" onclick="setHeatmapDisplay('24')">Top 24</button>
                                    <button class="heatmap-toggle-btn" data-display="36" onclick="setHeatmapDisplay('36')">Top 36</button>
                                    <button class="heatmap-toggle-btn" data-display="50" onclick="setHeatmapDisplay('50')">Top 50</button>
                                    <button class="heatmap-toggle-btn" data-display="all" onclick="setHeatmapDisplay('all')">All</button>
                                </div>
                            </div>
                        </div>

                        <!-- Position Stats -->
                        <div class="position-stats-row" id="heatmap-position-stats">
                            <!-- Stats will be populated by JavaScript -->
                        </div>

                        <!-- Player Grid -->
                        <div class="heatmap-player-grid" id="heatmap-player-grid">
                            <!-- Cards will be populated by JavaScript -->
                        </div>

                        <!-- Legend -->
                        <div class="heatmap-legend">
                            <div class="heatmap-legend-title" id="heatmap-legend-title">Performance vs Expected</div>
                            <div class="heatmap-legend-items" id="heatmap-legend-items">
                                <div class="heatmap-legend-item">
                                    <div class="heatmap-legend-color extreme-negative"></div>
                                    <div class="heatmap-legend-label" id="legend-label-0">-20%+<br>Extreme Under</div>
                                </div>
                                <div class="heatmap-legend-item">
                                    <div class="heatmap-legend-color strong-negative"></div>
                                    <div class="heatmap-legend-label" id="legend-label-1">-15 to -20%<br>Strong Under</div>
                                </div>
                                <div class="heatmap-legend-item">
                                    <div class="heatmap-legend-color moderate-negative"></div>
                                    <div class="heatmap-legend-label" id="legend-label-2">-10 to -15%<br>Moderate Under</div>
                                </div>
                                <div class="heatmap-legend-item">
                                    <div class="heatmap-legend-color slight-negative"></div>
                                    <div class="heatmap-legend-label" id="legend-label-3">-5 to -10%<br>Slight Under</div>
                                </div>
                                <div class="heatmap-legend-item">
                                    <div class="heatmap-legend-color neutral"></div>
                                    <div class="heatmap-legend-label" id="legend-label-4">±5%<br>On Target</div>
                                </div>
                                <div class="heatmap-legend-item">
                                    <div class="heatmap-legend-color slight-positive"></div>
                                    <div class="heatmap-legend-label" id="legend-label-5">+5 to +10%<br>Slight Over</div>
                                </div>
                                <div class="heatmap-legend-item">
                                    <div class="heatmap-legend-color moderate-positive"></div>
                                    <div class="heatmap-legend-label" id="legend-label-6">+10 to +15%<br>Moderate Over</div>
                                </div>
                                <div class="heatmap-legend-item">
                                    <div class="heatmap-legend-color strong-positive"></div>
                                    <div class="heatmap-legend-label" id="legend-label-7">+15 to +20%<br>Strong Over</div>
                                </div>
                                <div class="heatmap-legend-item">
                                    <div class="heatmap-legend-color extreme-positive"></div>
                                    <div class="heatmap-legend-label" id="legend-label-8">+20%+<br>Extreme Over</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Market Opportunities -->
                    <div class="market-opportunities-widget">
                        <div class="market-header">
                            <div class="market-title">Market Opportunities</div>
                        </div>
                        <div class="market-grid" id="market-opportunities-grid">
                            <!-- Opportunities will be populated by JavaScript -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Wide Receivers Page -->
            <div id="wide-receivers" class="page active">
                <!-- WR Ticker -->
                <div class="ticker-section" id="wr-ticker-section">
                    <div class="ticker-header">
                        <span>Wide Receivers - Top 50 by Avg Points</span>
                        <div class="ticker-info-icon" onclick="toggleTickerTooltip(event)">
                            i
                            <div class="ticker-tooltip">
                                Shows average fantasy points per game and % change in target share (week-over-week).
                            </div>
                        </div>
                    </div>
                    <div class="ticker-content" id="wr-ticker-content">
                        <div class="ticker-container">
                            <div class="ticker-track" id="wr-ticker-track" style="animation-duration: 720s !important;">
                                <!-- WR ticker items will be inserted here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Top Movers Widgets at Top -->
                <div id="wr-top-movers-sidebar" style="margin-bottom: 24px;">
                    <!-- Top movers widgets will be inserted here -->
                </div>

                <!-- Main content area -->
                <div>
                    <!-- Rankings Tab Content (Default) -->
                    <div id="wr-rankings-content" class="sub-content active">
                        <div id="wr-players-grid">
                            <!-- WR player cards will be inserted here by tier -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Running Backs Page -->
            <div id="running-backs" class="page">
                <!-- RB Ticker -->
                <div class="ticker-section" id="rb-ticker-section">
                    <div class="ticker-header">
                        <span>Running Backs - Top 50 by Avg Points</span>
                        <div class="ticker-info-icon" onclick="toggleTickerTooltip(event)">
                            i
                            <div class="ticker-tooltip">
                                Shows average fantasy points per game and % change in opportunity share (rush attempts + targets, week-over-week).
                            </div>
                        </div>
                    </div>
                    <div class="ticker-content" id="rb-ticker-content">
                        <div class="ticker-container">
                            <div class="ticker-track" id="rb-ticker-track" style="animation-duration: 720s !important;">
                                <!-- RB ticker items will be inserted here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Top Movers Widgets at Top -->
                <div id="rb-top-movers-sidebar" style="margin-bottom: 24px;">
                    <!-- Top movers widgets will be inserted here -->
                </div>

                <!-- Main content area -->
                <div>
                    <!-- Rankings Tab Content (Default) -->
                    <div id="rb-rankings-content" class="sub-content active">
                        <div id="rb-players-grid">
                            <!-- RB player cards will be inserted here by tier -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tight Ends Page -->
            <div id="tight-ends" class="page">
                <!-- TE Ticker -->
                <div class="ticker-section" id="te-ticker-section">
                    <div class="ticker-header">
                        <span>Tight Ends - Top 50 by Avg Points</span>
                        <div class="ticker-info-icon" onclick="toggleTickerTooltip(event)">
                            i
                            <div class="ticker-tooltip">
                                Shows average fantasy points per game and % change in target share (week-over-week).
                            </div>
                        </div>
                    </div>
                    <div class="ticker-content" id="te-ticker-content">
                        <div class="ticker-container">
                            <div class="ticker-track" id="te-ticker-track" style="animation-duration: 720s !important;">
                                <!-- TE ticker items will be inserted here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Top Movers Widgets at Top -->
                <div id="te-top-movers-sidebar" style="margin-bottom: 24px;">
                    <!-- Top movers widgets will be inserted here -->
                </div>

                <!-- Main content area -->
                <div>
                    <!-- Rankings Tab Content (Default) -->
                    <div id="te-rankings-content" class="sub-content active">
                        <div id="te-players-grid">
                            <!-- TE player cards will be inserted here by tier -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Teams Page -->
            <div id="teams" class="page">
                <!-- Teams Ticker -->
                <div class="ticker-section" id="teams-ticker-section">
                    <div class="ticker-header">
                        <span>Teams - Ranked by Total Fantasy Points</span>
                        <div class="ticker-info-icon" onclick="toggleTickerTooltip(event)">
                            i
                            <div class="ticker-tooltip">
                                Shows total fantasy points (WR + RB combined) from the latest week and % change from previous week.
                            </div>
                        </div>
                    </div>
                    <div class="ticker-content" id="teams-ticker-content">
                        <div class="ticker-container">
                            <div class="ticker-track" id="teams-ticker-track" style="animation-duration: 480s !important;">
                                <!-- Teams ticker items will be inserted here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Team Analysis Section -->
                <div class="advanced-analytics-container" style="margin-bottom: 32px;">
                    <div class="advanced-header">
                        <div class="advanced-title">Team Analysis</div>
                        <div class="advanced-subtitle">Deep dive into team-level target and opportunity distribution</div>
                    </div>

                    <!-- League Comparison Toggle -->
                    <div style="margin-bottom: 16px; display: flex; align-items: center; gap: 12px;">
                        <button
                            id="league-comparison-toggle"
                            onclick="toggleLeagueComparison()"
                            style="padding: 8px 16px; background: var(--positive); border: 1px solid var(--positive); border-radius: 8px; color: white; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 8px;"
                        >
                            <span id="league-comparison-icon">●</span>
                            <span>Show League Comparison</span>
                        </button>
                        <span style="font-size: 12px; color: var(--text-tertiary);">Compare team's volume to league average</span>
                    </div>

                    <!-- Team Analysis Controls -->
                    <div class="team-analysis-controls" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin-bottom: 16px;">
                        <!-- Team Selector -->
                        <div class="axis-control">
                            <div class="axis-label-static">Select Team</div>
                            <select class="axis-select" id="team-select" onchange="updateTeamAnalysis()">
                                <!-- Teams will be populated by JavaScript -->
                            </select>
                        </div>

                        <!-- Position Group -->
                        <div class="axis-control">
                            <div class="axis-label-static">Position Group</div>
                            <select class="axis-select" id="position-group-select" onchange="updateTeamAnalysis()">
                                <option value="WR">Pass-Catchers</option>
                                <option value="RB">Running Backs</option>
                            </select>
                        </div>

                        <!-- Time Frame -->
                        <div class="axis-control">
                            <div class="axis-label-static">Time Frame</div>
                            <select class="axis-select" id="time-frame-select" onchange="updateTeamAnalysis()">
                                <option value="single">Single Week</option>
                                <option value="last3">Last 3 Weeks</option>
                                <option value="last5">Last 5 Weeks</option>
                                <option value="season">Season Long</option>
                            </select>
                        </div>

                        <!-- Week Selector (shown only for single week) -->
                        <div class="axis-control" id="week-select-container">
                            <div class="axis-label-static">Select Week</div>
                            <select class="axis-select" id="week-select" onchange="updateTeamAnalysis()">
                                <!-- Weeks will be populated by JavaScript -->
                            </select>
                        </div>
                    </div>

                    <!-- Chart Area -->
                    <div class="scatter-chart-card">
                        <div class="scatter-chart-header">
                            <div class="scatter-chart-title" id="team-chart-title">Team Target Distribution</div>
                            <div class="scatter-chart-description" id="team-chart-description">
                                Select a team and time frame to view distribution
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; min-height: 420px;" id="team-charts-container">
                            <!-- Placeholder message when no team selected -->
                            <div id="team-chart-placeholder" style="grid-column: 1; display: flex; align-items: center; justify-content: center;">
                                <div style="text-align: center; color: #8e8e93; font-size: 18px; font-weight: 600;">
                                    Select a Team
                                </div>
                            </div>
                            <!-- Charts will be rendered here -->
                            <div class="chart-wrapper" style="display: none;">
                                <canvas id="team-pie-chart"></canvas>
                            </div>
                            <div class="chart-wrapper" id="team-secondary-chart-wrapper" style="display: none;">
                                <canvas id="team-secondary-chart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Team Offensive Balance Scatter -->
                <div class="chart-card" style="margin-bottom: 32px;">
                    <div class="chart-header">
                        <div class="chart-title">Offensive Identity Map</div>
                        <div class="chart-subtitle">Pass-Heavy vs Run-Heavy Offenses</div>
                    </div>
                    <div class="chart-insight">
                        <strong>What to look for:</strong> Top Right = Pass Heavy + Run Heavy, Bottom Right = Pass Heavy, Top Left = Run Heavy, Bottom Left = Avoid. Bigger Circles = More Total Fantasy Output.
                    </div>
                    <div class="chart-wrapper">
                        <canvas id="team-balance-scatter"></canvas>
                    </div>
                </div>

                <div class="cards-grid" id="teams-grid" style="display: none;">
                    <!-- Legacy team cards (hidden, keeping for backward compatibility) -->
                </div>
            </div>

            <!-- Insights Page -->
            <div id="top-movers" class="page">
                <!-- Insights Ticker -->
                <div class="ticker-section" id="insights-ticker-section">
                    <div class="ticker-header">
                        <span>Trending Opportunity Shifts Over Last 3 Weeks</span>
                        <div class="ticker-info-icon" onclick="toggleTickerTooltip(event)">
                            i
                            <div class="ticker-tooltip">
                                Shows players with the biggest changes in target/opportunity share over the last 3 weeks.
                            </div>
                        </div>
                    </div>
                    <div class="ticker-content" id="insights-ticker-content">
                        <div class="ticker-container">
                            <div class="ticker-track" id="insights-ticker-track" style="animation-duration: 540s !important;">
                                <!-- Ticker items will be inserted here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- PRS Leaderboard -->
                <div style="background: var(--bg-secondary); border-radius: 12px; padding: 24px; border: 1px solid var(--border-color); margin-bottom: 24px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <div>
                            <h2 style="font-size: 18px; font-weight: 700; color: var(--text-primary); margin-bottom: 4px;">Player Rating System (PRS)</h2>
                            <p style="font-size: 12px; color: var(--text-tertiary);">Composite score combining PPG, volume, efficiency, and consistency (min. 3 games)</p>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button class="prs-position-btn active" data-position="WR" onclick="filterPRSLeaderboard('WR')" style="padding: 6px 12px; background: var(--positive); border: 1px solid var(--positive); border-radius: 6px; color: white; font-size: 12px; font-weight: 600; cursor: pointer;">WR</button>
                            <button class="prs-position-btn" data-position="RB" onclick="filterPRSLeaderboard('RB')" style="padding: 6px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-secondary); font-size: 12px; font-weight: 600; cursor: pointer;">RB</button>
                            <button class="prs-position-btn" data-position="TE" onclick="filterPRSLeaderboard('TE')" style="padding: 6px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-secondary); font-size: 12px; font-weight: 600; cursor: pointer;">TE</button>
                        </div>
                    </div>
                    <div id="prs-leaderboard-content" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 12px;">
                        <!-- PRS leaders will be inserted here -->
                    </div>
                </div>

                <!-- Leaderboards Section Header -->
                <div class="dashboard-widget" style="margin-bottom: 24px;">
                    <div class="widget-header">
                        <div>
                            <span class="widget-title" style="font-size: 18px; text-transform: uppercase; letter-spacing: 0.5px;">Leaderboards</span>
                            <div style="font-size: 11px; color: var(--text-tertiary); margin-top: 2px;">Last 3 Weeks Performance</div>
                        </div>
                        <button onclick="navigateToPage('all-leaderboards')" style="padding: 8px 16px; background: var(--positive); color: white; border: none; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">
                            See All
                        </button>
                    </div>
                </div>

                <!-- Categories Section - Now at top -->
                <div class="categories-section" id="dashboard-categories">
                    <!-- Categories will be dynamically inserted here -->
                </div>

                <!-- Category Methodology Footnote -->
                <div class="category-footnote">
                    <button class="footnote-toggle" onclick="toggleFootnote()">
                        <span id="footnote-icon">ⓘ</span> Methodology
                    </button>
                    <div class="footnote-content" id="footnote-content" style="display: none;">
                        <strong>📊 Category Leaderboard Methodology</strong><br><br>

                        <strong>Time Window:</strong> All rankings are based on performance over the <strong>last 3 weeks of the season</strong>. Players must have played (with fantasy points scored) in at least <strong>2 of the last 3 weeks</strong> to be eligible for any category.<br><br>

                        <strong>Minimum Threshold:</strong> Players must average <strong>7.0+ fantasy points per game</strong> over their qualifying games to appear on leaderboards.<br><br>

                        <strong>Category Definitions:</strong><br>
                        • <strong>Volume Monsters (RB):</strong> Running backs with the highest opportunities per game (rush attempts + targets) over the last 3 weeks. Identifies true workhorse backs.<br>
                        • <strong>Efficiency Elites:</strong> Players with the best points per touch/target ratio over the last 3 weeks. Shows who's doing the most with their opportunities.<br>
                        • <strong>Red Zone Kings:</strong> Players with the most red zone opportunities per game. For WRs: red zone targets. For RBs: red zone rush attempts + targets. High TD upside.<br>
                        • <strong>High-Volume Alphas (WR):</strong> Wide receivers with the most targets per game over the last 3 weeks. High-volume pass catchers dominating their team's offense.<br><br>

                        <strong>Why Last 3 Weeks?</strong> Recent performance is more predictive than season-long averages. Player roles evolve, injuries affect usage, and offensive schemes shift throughout the season. The last 3 weeks capture current reality and help identify emerging trends and hot streaks.
                    </div>
                </div>

            </div>

            <!-- Advanced Analytics Page -->
            <div id="advanced-analytics" class="page">
                <div class="advanced-analytics-container">
                    <div class="advanced-header">
                        <div class="advanced-title">Advanced Analytics</div>
                        <div class="advanced-subtitle">Build custom scatterplots to explore correlations between any stats</div>
                    </div>

                    <div class="position-toggle">
                        <button class="position-toggle-btn active" onclick="switchAdvancedPosition('WR')" id="advanced-wr-btn">
                            Wide Receivers
                        </button>
                        <button class="position-toggle-btn" onclick="switchAdvancedPosition('RB')" id="advanced-rb-btn">
                            Running Backs
                        </button>
                        <button class="position-toggle-btn" onclick="switchAdvancedPosition('TE')" id="advanced-te-btn">
                            Tight Ends
                        </button>
                    </div>

                    <!-- Player Search and Week Selector -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
                        <!-- Player Search -->
                        <div class="axis-control">
                            <div class="axis-label-static">Highlight Player</div>
                            <div id="selected-players-container" style="display: none; margin-bottom: 8px; display: flex; gap: 8px; flex-wrap: wrap;">
                                <!-- Selected players will appear here -->
                            </div>
                            <div style="position: relative;">
                                <input
                                    type="text"
                                    id="player-search-input"
                                    class="axis-select"
                                    placeholder="Search to highlight players (Max 4)"
                                    oninput="filterPlayerSearch()"
                                    onfocus="showPlayerSearchDropdown()"
                                    style="padding-right: 30px;"
                                />
                                <button
                                    id="clear-player-btn"
                                    onclick="clearPlayerHighlight()"
                                    style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: transparent; border: none; color: var(--text-secondary); cursor: pointer; font-size: 18px; display: none; padding: 0; width: 20px; height: 20px; line-height: 1;"
                                    title="Clear highlighted players"
                                >×</button>
                                <div id="player-search-dropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: var(--bg-elevated); border: 1px solid var(--border-color); border-radius: 8px; margin-top: 4px; max-height: 200px; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);">
                                    <!-- Player options will be populated by JavaScript -->
                                </div>
                            </div>
                        </div>

                        <!-- Week Selector -->
                        <div class="axis-control">
                            <div class="axis-label-static">Week Range</div>
                            <select class="axis-select" id="week-range-select" onchange="updateAdvancedScatter()">
                                <option value="all">All Weeks</option>
                                <option value="last3">Last 3 Weeks</option>
                                <option value="last5">Last 5 Weeks</option>
                                <option value="1-4">Weeks 1-4</option>
                                <option value="5-8">Weeks 5-8</option>
                                <!-- Dynamic week options will be added by JavaScript -->
                            </select>
                        </div>
                    </div>

                    <!-- Wrapper for mobile reordering -->
                    <div class="advanced-analytics-charts-wrapper">
                        <!-- Preset Scatterplots - Moved below axis controls -->
                        <div class="preset-section" style="margin-top: 16px;">
                            <div class="preset-label">Quick Presets</div>
                            <div class="preset-buttons" id="preset-buttons-container">
                                <!-- Preset buttons will be populated by JavaScript -->
                            </div>
                        </div>

                        <div class="scatter-chart-card">
                            <div class="scatter-chart-header">
                                <div class="scatter-chart-title" id="scatter-title">Fantasy Points vs Targets</div>
                                <div class="scatter-chart-description" id="scatter-description">
                                    Click on any point to view player details
                                </div>
                            </div>
                            
                            <!-- X/Y Axis Controls - Inside chart container -->
                            <div class="axis-controls" style="margin: 0 20px 16px 20px;">
                                <div class="axis-control">
                                    <div class="axis-label-static">X-Axis Stat</div>
                                    <select class="axis-select" id="x-axis-select" onchange="currentQuadrantExplanation = ''; updateAdvancedScatter()">
                                        <!-- Options will be populated by JavaScript -->
                                    </select>
                                </div>
                                <div class="axis-control">
                                    <div class="axis-label-static">Y-Axis Stat</div>
                                    <select class="axis-select" id="y-axis-select" onchange="currentQuadrantExplanation = ''; updateAdvancedScatter()">
                                        <!-- Options will be populated by JavaScript -->
                                    </select>
                                </div>
                            </div>
                            
                            <!-- Player Count Filter & Zoom Controls - Right above chart -->
                            <div style="display: flex; gap: 16px; margin: 0 20px 12px 20px; flex-wrap: wrap; align-items: center;">
                                <!-- Player Count Filter -->
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <span style="color: var(--text-secondary); font-size: 13px; white-space: nowrap;">Show Top:</span>
                                    <button class="player-count-btn active" onclick="setPlayerCount(12)" id="count-12">12</button>
                                    <button class="player-count-btn" onclick="setPlayerCount(24)" id="count-24">24</button>
                                    <button class="player-count-btn" onclick="setPlayerCount(36)" id="count-36">36</button>
                                    <button class="player-count-btn" onclick="setPlayerCount(50)" id="count-50">50</button>
                                    <button class="player-count-btn" onclick="setPlayerCount(null)" id="count-all">All</button>
                                </div>
                                
                                <!-- Zoom Controls -->
                                <div style="display: flex; gap: 8px; align-items: center; margin-left: auto;">
                                    <span style="color: var(--text-secondary); font-size: 13px; white-space: nowrap;">Zoom:</span>
                                    <button class="zoom-btn" onclick="resetAdvancedZoom()" title="Reset Zoom">
                                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
                                            <circle cx="8" cy="8" r="6"/>
                                            <path d="M8 5v6M5 8h6"/>
                                        </svg>
                                        Reset
                                    </button>
                                </div>
                            </div>
                            
                            <div class="scatter-chart-wrapper">
                                <canvas id="advanced-scatter-chart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- All Leaderboards Page -->
            <div id="all-leaderboards" class="page">
                <div class="page-header">
                    <h1 class="page-title">All Leaderboards</h1>
                </div>

                <!-- Ticker Section -->
                <div class="ticker-section" style="margin-top: 24px; margin-bottom: 32px;">
                    <div class="ticker-header">
                        <span>Top 10 by Position - Avg Fantasy Points</span>
                    </div>
                    <div class="ticker-content">
                        <div class="ticker-container">
                            <div class="ticker-track" id="analytics-insights-track" style="animation-duration: 540s !important;">
                                <!-- Ticker items will be inserted here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- PPG Leaderboard -->
                <div style="background: var(--bg-secondary); border-radius: 12px; padding: 24px; border: 1px solid var(--border-color); margin-bottom: 24px; margin-top: 8px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <div>
                            <h2 style="font-size: 18px; font-weight: 700; color: var(--text-primary); margin-bottom: 4px;">Points Per Game Leaders</h2>
                            <p style="font-size: 12px; color: var(--text-tertiary);">Top performers by average fantasy points per game (min. 3 games played)</p>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button class="ppg-position-btn active" data-position="WR" onclick="filterPPGLeaderboard('WR')" style="padding: 6px 12px; background: var(--positive); border: 1px solid var(--positive); border-radius: 6px; color: white; font-size: 12px; font-weight: 600; cursor: pointer;">WR</button>
                            <button class="ppg-position-btn" data-position="RB" onclick="filterPPGLeaderboard('RB')" style="padding: 6px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-secondary); font-size: 12px; font-weight: 600; cursor: pointer;">RB</button>
                            <button class="ppg-position-btn" data-position="TE" onclick="filterPPGLeaderboard('TE')" style="padding: 6px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-secondary); font-size: 12px; font-weight: 600; cursor: pointer;">TE</button>
                        </div>
                    </div>
                    <div id="ppg-leaderboard-content" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 12px;">
                        <!-- PPG leaders will be inserted here -->
                    </div>
                </div>

                <div class="all-leaderboards-wrapper">
                    <!-- All 11 leaderboards will be rendered here -->
                    <div id="all-leaderboards-grid"></div>
                </div>

                <!-- PRS Methodology -->
                <div class="category-footnote" style="margin-top: 24px;">
                    <button class="footnote-toggle" onclick="togglePRSFootnote()">
                        <span id="prs-footnote-icon">ⓘ</span> PRS Methodology
                    </button>
                    <div class="footnote-content" id="prs-footnote-content" style="display: none;">
                        <strong>📊 Player Rating System (PRS) Methodology</strong><br><br>
                        
                        <strong>What is PRS?</strong> PRS is a comprehensive player evaluation metric that combines multiple performance factors into a single score to identify true fantasy standouts.<br><br>
                        
                        <strong>Calculation:</strong> PRS = (Avg PPG × 0.4) + (Volume Score × 0.3) + (Efficiency Score × 0.2) + (Consistency Score × 0.1)<br><br>
                        
                        <strong>Component Breakdown:</strong><br>
                        • <strong>Avg PPG (40%):</strong> Average fantasy points per game - the most important factor<br>
                        • <strong>Volume Score (30%):</strong> Normalized opportunity share (targets for WR/TE, opportunities for RB)<br>
                        • <strong>Efficiency Score (20%):</strong> Points per touch/target compared to position average<br>
                        • <strong>Consistency Score (10%):</strong> Standard deviation of weekly scores (lower is better)<br><br>
                        
                        <strong>Why PRS?</strong> Unlike raw PPG, PRS accounts for opportunity volume and efficiency, helping identify players who are both productive AND sustainable. High PRS = High production + High volume + High efficiency + Consistent output.
                    </div>
                </div>
            </div>

            <!-- Admin Panel Page -->
            <div id="admin-panel" class="page">
                <div class="page-header">
                    <h1 class="page-title">Admin Panel</h1>
                    <p class="page-subtitle">Upload new data and manage the site</p>
                </div>

                <div style="max-width: 800px; margin: 0 auto;">
                    <!-- Admin Info Card -->
                    <div style="background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 24px; margin-bottom: 24px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                            <div>
                                <div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">Logged in as Admin</div>
                                <div style="font-size: 12px; color: var(--text-tertiary);" id="admin-email-display">aryi3025@gmail.com</div>
                            </div>
                            <button onclick="logoutAdmin()" style="padding: 8px 16px; background: var(--negative); border: none; border-radius: 8px; color: white; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">
                                Sign Out
                            </button>
                        </div>
                        <div style="padding-top: 16px; border-top: 1px solid var(--border-color); font-size: 12px; color: var(--text-secondary);">
                            Last updated: <span id="admin-last-updated">No data uploaded</span>
                        </div>
                    </div>

                    <!-- Upload Data Card -->
                    <div style="background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 24px;">
                        <h2 style="font-size: 18px; font-weight: 700; color: var(--text-primary); margin-bottom: 16px;">Upload New Data</h2>

                        <div style="display: flex; flex-direction: column; gap: 20px;">
                            <!-- WR Upload -->
                            <div>
                                <label style="display: block; font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">Wide Receiver Data (CSV)</label>
                                <input type="file" id="admin-wr-upload" accept=".csv" onchange="handleAdminWRUpload(event)" style="display: block; width: 100%; padding: 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 13px; cursor: pointer;">
                                <div id="admin-wr-status" style="margin-top: 6px; font-size: 12px; color: var(--text-tertiary);"></div>
                            </div>

                            <!-- RB Upload -->
                            <div>
                                <label style="display: block; font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">Running Back Data (CSV)</label>
                                <input type="file" id="admin-rb-upload" accept=".csv" onchange="handleAdminRBUpload(event)" style="display: block; width: 100%; padding: 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 13px; cursor: pointer;">
                                <div id="admin-rb-status" style="margin-top: 6px; font-size: 12px; color: var(--text-tertiary);"></div>
                            </div>

                            <!-- TE Upload -->
                            <div>
                                <label style="display: block; font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">Tight End Data (CSV)</label>
                                <input type="file" id="admin-te-upload" accept=".csv" onchange="handleAdminTEUpload(event)" style="display: block; width: 100%; padding: 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 13px; cursor: pointer;">
                                <div id="admin-te-status" style="margin-top: 6px; font-size: 12px; color: var(--text-tertiary);"></div>
                            </div>

                            <!-- Instructions -->
                            <div style="margin-top: 8px; padding: 16px; background: var(--bg-tertiary); border-radius: 8px; font-size: 13px; color: var(--text-secondary); line-height: 1.6;">
                                <strong style="color: var(--text-primary);">Instructions:</strong><br>
                                1. Upload WR, RB, and TE CSV files<br>
                                2. Data will be processed automatically<br>
                                3. All pages will update with new data<br>
                                4. "Last updated" date will be set to today<br>
                                5. Data persists until you upload again
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Footer -->
        <footer class="footer">
            <div class="footer-content">
                <!-- Waitlist Section -->
                <div class="footer-section">
                    <h3>JOIN THE WAITLIST</h3>
                    <p>Get early access to premium features, real-time updates, and exclusive fantasy football insights.</p>
                    <form class="waitlist-form" onsubmit="submitWaitlist(event)">
                        <input
                            type="email"
                            class="waitlist-input"
                            id="waitlist-email"
                            placeholder="Enter your email"
                            required
                        />
                        <button type="submit" class="waitlist-btn">Join Waitlist</button>
                    </form>
                    <div class="success-message" id="waitlist-success">
                        ✓ Thanks! You've been added to the waitlist.
                    </div>
                </div>

                <!-- Quick Links -->
                <div class="footer-section">
                    <h3>QUICK LINKS</h3>
                    <div class="footer-links">
                        <a href="#" class="footer-link" id="admin-login-link" onclick="showLoginModal(); return false;">Admin Login</a>
                        <a href="#" class="footer-link" onclick="navigateToPage('analytics-dashboard'); return false;">Heatmap</a>
                        <a href="#" class="footer-link" onclick="navigateToPage('top-movers'); return false;">Leaderboards</a>
                        <a href="#" class="footer-link" onclick="navigateToPage('advanced-analytics'); return false;">Analytics</a>
                    </div>
                </div>

                <!-- About -->
                <div class="footer-section">
                    <h3>ABOUT FFSE</h3>
                    <div class="footer-links">
                        <a href="#" class="footer-link" onclick="showPrivacyModal(); return false;">Privacy Policy</a>
                        <a href="#" class="footer-link">Contact</a>
                    </div>
                    <div style="margin-top: 16px; font-size: 11px; color: var(--text-tertiary);">
                        Last updated: <span id="last-updated-date">No data uploaded</span>
                    </div>
                </div>
            </div>

            <div class="footer-bottom">
                <div class="footer-logo">
                    <div class="footer-logo-icon"></div>
                    <span>FFSE</span>
                </div>
                <div class="footer-copyright">
                    © 2025 Fantasy Football Stock Exchange. All rights reserved. | Data updated weekly during NFL season.
                </div>
            </div>
        </footer>

        <!-- Waitlist Confirmation Modal -->
        <div class="waitlist-modal" id="waitlist-modal">
            <div class="waitlist-modal-content">
                <div class="waitlist-modal-icon">🎉</div>
                <div class="waitlist-modal-title">Welcome to the Waitlist!</div>
                <div class="waitlist-modal-message">
                    Thanks for signing up! We'll keep you updated on new features, premium analytics, and exclusive fantasy football insights.
                </div>
                <button class="waitlist-modal-btn" onclick="closeWaitlistModal()">Got it!</button>
            </div>
        </div>
    </div>

    <!-- Player Modal -->
    <div class="modal-overlay" id="player-modal">
        <div class="modal">
            <div class="modal-header">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; width: 100%;">
                    <div class="modal-player-info">
                        <div class="modal-team-badge" id="modal-team-badge"></div>
                        <div class="modal-player-details">
                            <div class="modal-player-name" id="modal-player-name"></div>
                            <div class="modal-player-meta" id="modal-player-meta"></div>
                        </div>
                    </div>

                    <!-- Community Sentiment - Top Right Corner -->
                    <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 8px; margin-right: 40px;">
                        <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; font-weight: 500;">
                            COMMUNITY SENTIMENT
                        </div>
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <!-- 3-Section Bar -->
                            <div class="sentiment-bar-3section" style="height: 8px; width: 200px; border-radius: 4px; display: flex; overflow: hidden; background: var(--bg-secondary);">
                                <div class="sentiment-segment sentiment-segment-buy" id="modal-sentiment-segment-buy" style="transition: width 0.3s ease;"></div>
                                <div class="sentiment-segment sentiment-segment-hold" id="modal-sentiment-segment-hold" style="transition: width 0.3s ease;"></div>
                                <div class="sentiment-segment sentiment-segment-sell" id="modal-sentiment-segment-sell" style="transition: width 0.3s ease;"></div>
                            </div>
                            <!-- Vote Count -->
                            <div id="modal-sentiment-vote-count" style="font-size: 11px; color: var(--text-secondary); font-weight: 500; white-space: nowrap;">
                                <!-- Vote count will be filled dynamically -->
                            </div>
                        </div>
                        <!-- Vote Buttons -->
                        <div class="vote-buttons" style="gap: 6px; display: flex;">
                            <button class="vote-btn buy-btn" onclick="castVote('buy')" style="padding: 6px 12px; font-size: 11px; font-weight: 600;">
                                Buy
                            </button>
                            <button class="vote-btn hold-btn" onclick="castVote('hold')" style="padding: 6px 12px; font-size: 11px; font-weight: 600;">
                                Hold
                            </button>
                            <button class="vote-btn sell-btn" onclick="castVote('sell')" style="padding: 6px 12px; font-size: 11px; font-weight: 600;">
                                Sell
                            </button>
                        </div>
                    </div>

                    <button class="modal-close" onclick="closeModal()" style="position: absolute; top: 16px; right: 16px;">×</button>
                </div>

                <!-- Category Context (shown when opened from a category) -->
                <div id="modal-category-context" style="display: none; margin-top: 16px; padding: 12px 16px; background: var(--bg-elevated); border-radius: 8px; border-left: 3px solid var(--positive);">
                    <div style="font-size: 11px; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 4px;">
                        Category Ranking
                    </div>
                    <div style="font-size: 14px; font-weight: 700; color: var(--text-primary); margin-bottom: 8px;">
                        <span id="modal-category-title"></span> - <span id="modal-category-rank"></span>
                    </div>
                    <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                        <span id="modal-category-explanation"></span>
                    </div>
                    <div style="display: flex; gap: 16px; margin-top: 8px; font-size: 12px;">
                        <div>
                            <span style="color: var(--text-secondary);"><span id="modal-category-metric-label"></span>:</span>
                            <span style="color: var(--text-primary); font-weight: 600; margin-left: 4px;" id="modal-category-metric-value"></span>
                        </div>
                    </div>
                </div>

                <!-- Collapse Stats Button -->
                <button onclick="toggleStatsCollapse()" id="stats-collapse-btn" style="width: 100%; padding: 8px; background: transparent; border: none; border-top: 1px solid var(--border-color); color: var(--text-secondary); font-size: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px; transition: all 0.2s;">
                    <span id="stats-collapse-icon">▼</span>
                    <span id="stats-collapse-text">Hide Stats</span>
                </button>

                <!-- Mobile Swipeable Stats Container -->
                <div class="modal-stats-container" id="modal-stats-container">
                    <div class="modal-stats-wrapper" id="modal-stats-wrapper">
                        <!-- Page 1: Performance (2x2 mobile) -->
                        <div class="modal-stats-page">
                            <div class="modal-section-header">Performance</div>
                            <div class="modal-stats-table">
                                <!-- Stat 1: FPTS/G -->
                                <div class="modal-stat-cell">
                                    <div class="modal-stat-label">FPTS/G</div>
                                    <div class="modal-stat-value" id="modal-avg-pts">--</div>
                                    <div class="modal-stat-comparison" id="modal-avg-pts-comparison"></div>
                                    <div class="stat-tooltip">Average fantasy points per game across all weeks played</div>
                                </div>
                                
                                <!-- Stat 2: Actual Pts (Last Week) -->
                                <div class="modal-stat-cell">
                                    <div class="modal-stat-label" id="modal-actual-pts-label">Actual Pts (W9)</div>
                                    <div class="modal-stat-value" id="modal-actual-pts">--</div>
                                    <div class="modal-stat-comparison" id="modal-actual-comparison"></div>
                                    <div class="stat-tooltip">Actual fantasy points scored in the most recent week</div>
                                </div>
                                
                                <!-- Stat 3: Momentum -->
                                <div class="modal-stat-cell">
                                    <div class="modal-stat-label">Momentum</div>
                                    <div class="modal-stat-value" id="modal-momentum">--</div>
                                    <div class="modal-stat-comparison" id="modal-momentum-comparison"></div>
                                    <div class="stat-tooltip">Trend direction based on last 3 weeks vs previous 3 weeks performance</div>
                                </div>
                                
                                <!-- Stat 4: PPG vs Expected -->
                                <div class="modal-stat-cell">
                                    <div class="modal-stat-label">PPG vs Expected</div>
                                    <div class="modal-stat-value" id="modal-ppg-expected">--</div>
                                    <div class="modal-stat-comparison" id="modal-ppg-expected-comparison"></div>
                                    <div class="stat-tooltip">Season-long average actual points compared to expected points based on opportunities</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Page 2: Volume & Opportunity (2x2 mobile) -->
                        <div class="modal-stats-page">
                            <div class="modal-section-header">Volume & Opportunity</div>
                            <div class="modal-stats-table">
                                <!-- Stat 5: Tgt/Opp Share (Last Week) -->
                                <div class="modal-stat-cell">
                                    <div class="modal-stat-label" id="modal-opp-share-label">Tgt Share (W9)</div>
                                    <div class="modal-stat-value" id="modal-opp-share">--</div>
                                    <div class="modal-stat-comparison" id="modal-opp-share-comparison"></div>
                                    <div class="stat-tooltip" id="modal-opp-share-tooltip">Player's share of team targets in the most recent week</div>
                                </div>
                                
                                <!-- Stat 6: Avg Tgt/Opp vs Top 24 -->
                                <div class="modal-stat-cell">
                                    <div class="modal-stat-label" id="modal-avg-volume-label">Avg Tgt vs Top 24</div>
                                    <div class="modal-stat-value" id="modal-avg-volume">--</div>
                                    <div class="modal-stat-comparison" id="modal-avg-volume-comparison"></div>
                                    <div class="stat-tooltip" id="modal-avg-volume-tooltip">Average targets per game compared to Top 24 WR average</div>
                                </div>
                                
                                <!-- Stat 7: RZ Opp Share -->
                                <div class="modal-stat-cell">
                                    <div class="modal-stat-label">RZ Opp Share</div>
                                    <div class="modal-stat-value" id="modal-rz-share">--</div>
                                    <div class="modal-stat-comparison" id="modal-rz-share-comparison"></div>
                                    <div class="stat-tooltip">Player's share of team's red zone opportunities across all weeks</div>
                                </div>
                                
                                <!-- Stat 8: RZ Opp Avg vs Top 24 -->
                                <div class="modal-stat-cell">
                                    <div class="modal-stat-label" id="modal-rz-avg-label">RZ Avg vs Top 24</div>
                                    <div class="modal-stat-value" id="modal-rz-avg">--</div>
                                    <div class="modal-stat-comparison" id="modal-rz-avg-comparison"></div>
                                    <div class="stat-tooltip" id="modal-rz-avg-tooltip">Average red zone opportunities per game compared to Top 24 average</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Page Dots -->
                    <div class="stats-dots">
                        <div class="stats-dot active" data-page="0"></div>
                        <div class="stats-dot" data-page="1"></div>
                    </div>
                </div>
            </div>
            <div class="modal-body">
                <div class="chart-tabs">
                    <button class="chart-tab active" onclick="switchModalChart('reliability')">Reliability</button>
                    <button class="chart-tab" onclick="switchModalChart('outcomes')">Performance Consistency</button>
                    <button class="chart-tab" onclick="switchModalChart('spider')">Player Profile</button>
                    <button class="chart-tab" onclick="switchModalChart('floor')">Floor Metrics</button>
                    <button class="chart-tab" onclick="switchModalChart('candles')">Performance Candles</button>
                    <button class="chart-tab" onclick="switchModalChart('schedule')">Schedule</button>
                </div>
                <div id="modal-chart-variance" class="chart-content">
                    <div class="modal-chart-wrapper">
                        <canvas id="modal-variance-chart"></canvas>
                    </div>
                </div>
                <div id="modal-chart-outcomes" class="chart-content">
                    <div class="modal-chart-wrapper">
                        <canvas id="modal-outcomes-chart"></canvas>
                    </div>
                </div>
                <div id="modal-chart-spider" class="chart-content">
                    <div class="modal-chart-wrapper">
                        <canvas id="modal-spider-chart"></canvas>
                    </div>

                    <!-- Metrics Explanation Section -->
                    <div style="margin-top: 16px; border-top: 1px solid var(--border-color); padding-top: 12px;">
                        <button onclick="toggleSpiderExplanation()"
                                style="display: flex; align-items: center; gap: 6px; background: transparent; border: none; color: var(--text-secondary); cursor: pointer; font-size: 12px; padding: 0; font-weight: 500; transition: color 0.2s;"
                                onmouseover="this.style.color='var(--text-primary)'"
                                onmouseout="this.style.color='var(--text-secondary)'">
                            <span id="spider-explanation-icon" style="font-size: 14px;">ℹ️</span>
                            <span>How rankings are calculated</span>
                        </button>

                        <div id="spider-explanation" style="display: none; margin-top: 12px; background: var(--bg-elevated); border-radius: 8px; padding: 16px; font-size: 13px; line-height: 1.6;">
                            <div style="color: var(--text-primary); font-weight: 600; margin-bottom: 8px;">Player Profile Rankings</div>
                            <div style="color: var(--text-secondary); margin-bottom: 12px;">
                                Each metric is ranked against <strong style="color: var(--text-primary);">all eligible players</strong> (minimum 3 games played) using per-game averages. Your rank determines your score: <strong style="color: var(--positive);">#1 = 100 points</strong>, <strong style="color: var(--text-primary);">#100 = 50 points</strong>, <strong style="color: var(--text-tertiary);">#200 = 0.5 points</strong>.
                            </div>

                            <div id="spider-wr-metrics" style="display: none;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px; font-size: 12px;">WR Metrics:</div>
                                <div style="display: grid; gap: 8px; color: var(--text-secondary); font-size: 12px;">
                                    <div><strong style="color: var(--text-primary);">Volume:</strong> Targets per game (total targets ÷ games played)</div>
                                    <div><strong style="color: var(--text-primary);">Efficiency:</strong> Fantasy points per target (avg points ÷ targets per game)</div>
                                    <div><strong style="color: var(--text-primary);">Red Zone:</strong> Red zone opportunities per game (total RZ opps ÷ games played)</div>
                                    <div><strong style="color: var(--text-primary);">Team Share:</strong> Target share % in most recent week</div>
                                    <div><strong style="color: var(--text-primary);">Catch Rate:</strong> Receptions per target (total receptions ÷ total targets × 100%)</div>
                                </div>
                            </div>

                            <div id="spider-rb-metrics" style="display: none;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px; font-size: 12px;">RB Metrics:</div>
                                <div style="display: grid; gap: 8px; color: var(--text-secondary); font-size: 12px;">
                                    <div><strong style="color: var(--text-primary);">Volume:</strong> Opportunities per game (total opportunities ÷ games played)</div>
                                    <div><strong style="color: var(--text-primary);">Efficiency:</strong> Fantasy points per opportunity (avg points ÷ opps per game)</div>
                                    <div><strong style="color: var(--text-primary);">Red Zone:</strong> Red zone opportunities per game (total RZ opps ÷ games played)</div>
                                    <div><strong style="color: var(--text-primary);">Team Share:</strong> Opportunity share % in most recent week</div>
                                    <div><strong style="color: var(--text-primary);">Yards After Contact:</strong> Yards after contact per attempt (total YACON ÷ total attempts)</div>
                                </div>
                            </div>

                            <div id="spider-te-metrics" style="display: none;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px; font-size: 12px;">TE Metrics:</div>
                                <div style="display: grid; gap: 8px; color: var(--text-secondary); font-size: 12px;">
                                    <div><strong style="color: var(--text-primary);">Volume:</strong> Targets per game (total targets ÷ games played)</div>
                                    <div><strong style="color: var(--text-primary);">Efficiency:</strong> Fantasy points per target (avg points ÷ targets per game)</div>
                                    <div><strong style="color: var(--text-primary);">Red Zone:</strong> Red zone opportunities per game (total RZ opps ÷ games played)</div>
                                    <div><strong style="color: var(--text-primary);">Team Share:</strong> Target share % in most recent week</div>
                                    <div><strong style="color: var(--text-primary);">Catch Rate:</strong> Receptions per target (total receptions ÷ total targets × 100%)</div>
                                </div>
                            </div>

                            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color); font-size: 11px; color: var(--text-tertiary);">
                                <strong style="color: var(--text-secondary);">Note:</strong> Rankings only shown for Top 200 players. All metrics are calculated as per-game averages to ensure fair comparison regardless of games played.
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Player Reliability Score (PRS) Chart -->
                <div id="modal-chart-reliability" class="chart-content active">
                    <div style="padding: 20px;">
                        <!-- PRS Header with Tooltip -->
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 24px;">
                            <h3 style="font-size: 18px; font-weight: 700; color: var(--text-primary); margin: 0;">Player Reliability Score (PRS)</h3>
                            <div style="position: relative; display: inline-block;">
                                <span style="cursor: help; color: var(--text-secondary); font-size: 16px;" onmouseover="document.getElementById('prs-tooltip').style.display='block'" onmouseout="document.getElementById('prs-tooltip').style.display='none'">ⓘ</span>
                                <div id="prs-tooltip" style="display: none; position: absolute; left: 25px; top: -10px; background: var(--bg-elevated); border: 1px solid var(--border-color); border-radius: 8px; padding: 12px; width: 320px; z-index: 1000; font-size: 12px; color: var(--text-secondary); box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
                                    <div style="color: var(--text-primary); font-weight: 600; margin-bottom: 6px;">How PRS is Calculated</div>
                                    <div style="line-height: 1.5;">
                                        PRS measures role stability and reliability on a 0-100 scale:
                                        <div style="margin-top: 8px; display: grid; gap: 4px;">
                                            <div>• <strong style="color: var(--text-primary);">Opportunity Value</strong> - Production-weighted usage</div>
                                            <div>• <strong style="color: var(--text-primary);">Scoring Role</strong> - Production-weighted RZ involvement</div>
                                            <div>• <strong style="color: var(--text-primary);">Floor Reliability</strong> - Hitting expected points</div>
                                            <div>• <strong style="color: var(--text-primary);">Games</strong> - Availability/games played</div>
                                        </div>
                                        <div style="margin-top: 8px; font-size: 11px; color: var(--text-tertiary);">
                                            <strong>Note:</strong> WRs weight floor reliability higher (30%) vs RB/TE (20%). Exact weights shown on cards.
                                        </div>
                                        <div style="margin-top: 4px; font-size: 11px; color: var(--text-tertiary);">Higher score = more reliable fantasy asset</div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Main Gauge and Component Cards Container -->
                        <div style="display: grid; grid-template-columns: 180px 1fr; gap: 24px; align-items: start;">
                            <!-- Smaller Circular Gauge -->
                            <div style="display: flex; flex-direction: column; align-items: center;">
                                <canvas id="prs-gauge-chart" width="120" height="120"></canvas>
                            </div>

                            <!-- 2x2 Component Cards Grid -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                                <!-- Opportunity Value Card -->
                                <div style="background: #2c2c2e; border-radius: 8px; padding: 16px;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                        <span style="font-size: 13px; color: var(--text-primary); font-weight: 600;">Opportunity Value</span>
                                        <span id="prs-usage-weight" style="font-size: 11px; color: #8e8e93;">40%</span>
                                    </div>
                                    <div style="height: 6px; background: #1c1c1e; border-radius: 3px; overflow: hidden; margin-bottom: 10px;">
                                        <div id="prs-usage-bar" style="height: 100%; width: 0%; transition: width 0.3s ease, background 0.3s ease;"></div>
                                    </div>
                                    <div id="prs-usage-value" style="font-size: 16px; font-weight: 600;">--</div>
                                </div>

                                <!-- Scoring Role Card -->
                                <div style="background: #2c2c2e; border-radius: 8px; padding: 16px;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                        <span style="font-size: 13px; color: var(--text-primary); font-weight: 600;">Scoring Role</span>
                                        <span id="prs-rz-weight" style="font-size: 11px; color: #8e8e93;">30%</span>
                                    </div>
                                    <div style="height: 6px; background: #1c1c1e; border-radius: 3px; overflow: hidden; margin-bottom: 10px;">
                                        <div id="prs-rz-bar" style="height: 100%; width: 0%; transition: width 0.3s ease, background 0.3s ease;"></div>
                                    </div>
                                    <div id="prs-rz-value" style="font-size: 16px; font-weight: 600;">--</div>
                                </div>

                                <!-- Floor Reliability Card -->
                                <div style="background: #2c2c2e; border-radius: 8px; padding: 16px;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                        <span style="font-size: 13px; color: var(--text-primary); font-weight: 600;">Floor Reliability</span>
                                        <span id="prs-consistency-weight" style="font-size: 11px; color: #8e8e93;">20%</span>
                                    </div>
                                    <div style="height: 6px; background: #1c1c1e; border-radius: 3px; overflow: hidden; margin-bottom: 10px;">
                                        <div id="prs-consistency-bar" style="height: 100%; width: 0%; transition: width 0.3s ease, background 0.3s ease;"></div>
                                    </div>
                                    <div id="prs-consistency-value" style="font-size: 16px; font-weight: 600;">--</div>
                                </div>

                                <!-- Games Played Card -->
                                <div style="background: #2c2c2e; border-radius: 8px; padding: 16px;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                        <span style="font-size: 13px; color: var(--text-primary); font-weight: 600;">Games Played</span>
                                        <span id="prs-games-weight" style="font-size: 11px; color: #8e8e93;">10%</span>
                                    </div>
                                    <div style="height: 6px; background: #1c1c1e; border-radius: 3px; overflow: hidden; margin-bottom: 10px;">
                                        <div id="prs-games-bar" style="height: 100%; width: 0%; transition: width 0.3s ease, background 0.3s ease;"></div>
                                    </div>
                                    <div id="prs-games-value" style="font-size: 16px; font-weight: 600;">--</div>
                                </div>
                            </div>
                        </div>

                        <!-- Expandable Methodology Section -->
                        <div style="margin-top: 24px; border-top: 1px solid var(--border-color); padding-top: 16px;">
                            <div onclick="document.getElementById('prs-methodology').style.display = document.getElementById('prs-methodology').style.display === 'none' ? 'block' : 'none'; document.getElementById('prs-methodology-icon').textContent = document.getElementById('prs-methodology').style.display === 'none' ? '▶' : '▼';" style="cursor: pointer; display: flex; align-items: center; gap: 8px; padding: 8px; border-radius: 6px; transition: background 0.2s;" onmouseover="this.style.background='var(--bg-tertiary)'" onmouseout="this.style.background='transparent'">
                                <span id="prs-methodology-icon" style="font-size: 12px; color: var(--text-secondary);">▶</span>
                                <span style="font-size: 13px; font-weight: 600; color: var(--text-primary);">Methodology</span>
                            </div>
                            <div id="prs-methodology" style="display: none; margin-top: 12px; padding: 12px; background: var(--bg-tertiary); border-radius: 8px; font-size: 12px; color: var(--text-secondary); line-height: 1.6;">
                                <div style="color: var(--text-primary); font-weight: 600; margin-bottom: 8px;">How PRS Components Are Calculated</div>
                                
                                <div style="margin-bottom: 12px;">
                                    <strong style="color: var(--text-primary);">Opportunity Value:</strong> Production-weighted opportunity score = Usage Share × Average Fantasy Points. Rewards players whose touches translate to actual fantasy production. Example: A WR with 25% usage averaging 18 PPG scores higher than a WR with 30% usage averaging 10 PPG.
                                </div>
                                
                                <div style="margin-bottom: 12px;">
                                    <strong style="color: var(--text-primary);">Scoring Role:</strong> Production-weighted red zone opportunity = RZ Share × Average Fantasy Points. Elite scorers with significant RZ usage score higher than low-volume RZ specialists. Measures touchdown upside potential.
                                </div>
                                
                                <div style="margin-bottom: 12px;">
                                    <strong style="color: var(--text-primary);">Floor Reliability:</strong> Measures how often a player meets or exceeds expected points. Formula: 60% hit rate + 40% average differential + bonus for elite scorers. Hit threshold: within 15% of expected for 14+ PPG players, 10% for others. Rewards players who consistently deliver on projections.
                                </div>
                                
                                <div style="margin-bottom: 12px;">
                                    <strong style="color: var(--text-primary);">Games Played:</strong> Percentage of maximum games played in dataset. Availability is critical for reliability - you can't rely on a player who isn't on the field.
                                </div>
                                
                                <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color); font-size: 11px;">
                                    <strong style="color: var(--text-primary);">Position-Specific Weights:</strong><br>
                                    • <strong>WR:</strong> Opportunity Value 40%, Scoring Role 20%, Floor Reliability 30%, Games 10%<br>
                                    • <strong>RB/TE:</strong> Opportunity Value 40%, Scoring Role 30%, Floor Reliability 20%, Games 10%
                                </div>
                                
                                <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color); font-size: 11px;">
                                    <strong style="color: var(--text-primary);">Color Legend:</strong>
                                    <span style="color: #30d158;">■</span> Green (80-100) = Elite
                                    <span style="color: #0a84ff;">■</span> Blue (60-79) = Above Average
                                    <span style="color: #ffd60a;">■</span> Yellow (40-59) = Average
                                    <span style="color: #ff453a;">■</span> Red (0-39) = Below Average
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Floor Metrics Chart (Negative Framing) -->

                <!-- Floor Metrics Tab -->
                <div id="modal-chart-floor" class="chart-content">
                    <div style="padding: 32px 20px;">
                        <div style="text-align: center; margin-bottom: 32px;">
                            <h3 style="font-size: 20px; font-weight: 700; color: var(--text-primary); margin: 0 0 8px 0;">Floor Metrics</h3>
                            <p style="font-size: 13px; color: var(--text-secondary); margin: 0;">Risk indicators for fantasy reliability (lower is better)</p>
                        </div>

                        <div style="display: flex; flex-direction: column; gap: 32px; max-width: 700px; margin: 0 auto;">
                            <!-- Fragility Score -->
                            <div style="display: flex; flex-direction: column; gap: 12px;">
                                <div style="display: flex; justify-content: space-between; align-items: baseline;">
                                    <span style="font-size: 16px; font-weight: 600; color: var(--text-primary);">Fragility Score</span>
                                    <span id="floor-fragility-value" style="font-size: 24px; font-weight: 700;">--<span style="font-size: 16px; color: rgba(235, 235, 245, 0.5);">/100</span></span>
                                </div>
                                <div style="height: 32px; background: rgba(255, 255, 255, 0.1); border-radius: 16px; overflow: hidden; position: relative;">
                                    <div id="floor-fragility-bar" style="height: 100%; border-radius: 16px; transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1); display: flex; align-items: center; justify-content: flex-end; padding-right: 12px; width: 0%;">
                                        <span id="floor-fragility-pill" style="background: rgba(0, 0, 0, 0.3); padding: 4px 10px; border-radius: 12px; font-size: 11px; font-weight: 700; color: #ffffff;"></span>
                                    </div>
                                </div>
                                <div style="display: flex; gap: 16px; font-size: 12px; color: rgba(235, 235, 245, 0.7); margin-top: 4px; flex-wrap: wrap;">
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <div style="width: 6px; height: 6px; border-radius: 50%; background: rgba(235, 235, 245, 0.5);"></div>
                                        <span id="floor-fragility-td">TD Dependency: --</span>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <div style="width: 6px; height: 6px; border-radius: 50%; background: rgba(235, 235, 245, 0.5);"></div>
                                        <span id="floor-fragility-var">Variance: --</span>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <div style="width: 6px; height: 6px; border-radius: 50%; background: rgba(235, 235, 245, 0.5);"></div>
                                        <span id="floor-fragility-vol">Volume Penalty: --</span>
                                    </div>
                                </div>
                            </div>

                            <!-- Ghost Rate -->
                            <div style="display: flex; flex-direction: column; gap: 12px;">
                                <div style="display: flex; justify-content: space-between; align-items: baseline;">
                                    <span style="font-size: 16px; font-weight: 600; color: var(--text-primary);">Ghost Rate</span>
                                    <span id="floor-ghost-value" style="font-size: 24px; font-weight: 700;">--<span style="font-size: 16px; color: rgba(235, 235, 245, 0.5);">%</span></span>
                                </div>
                                <div style="height: 32px; background: rgba(255, 255, 255, 0.1); border-radius: 16px; overflow: hidden; position: relative;">
                                    <div id="floor-ghost-bar" style="height: 100%; border-radius: 16px; transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1); display: flex; align-items: center; justify-content: flex-end; padding-right: 12px; width: 0%;">
                                        <span id="floor-ghost-pill" style="background: rgba(0, 0, 0, 0.3); padding: 4px 10px; border-radius: 12px; font-size: 11px; font-weight: 700; color: #ffffff;"></span>
                                    </div>
                                </div>
                                <div style="display: flex; gap: 16px; font-size: 12px; color: rgba(235, 235, 245, 0.7); margin-top: 4px; flex-wrap: wrap;">
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <div style="width: 6px; height: 6px; border-radius: 50%; background: rgba(235, 235, 245, 0.5);"></div>
                                        <span id="floor-ghost-playable">Playable: -- games</span>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <div style="width: 6px; height: 6px; border-radius: 50%; background: rgba(235, 235, 245, 0.5);"></div>
                                        <span id="floor-ghost-boom">Boom: -- games</span>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 6px;">
                                        <div style="width: 6px; height: 6px; border-radius: 50%; background: rgba(235, 235, 245, 0.5);"></div>
                                        <span id="floor-ghost-bust">Bust: -- games</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Explanatory Text -->
                        <div style="margin-top: 32px; padding: 16px; background: rgba(255, 255, 255, 0.05); border-radius: 12px; max-width: 700px; margin-left: auto; margin-right: auto;">
                            <div style="display: grid; gap: 12px; font-size: 12px; color: var(--text-secondary); line-height: 1.5;">
                                <div>
                                    <strong style="color: var(--text-primary);">Fragility Score (0-100):</strong> Measures scoring volatility and touchdown dependency. Lower scores indicate more reliable, consistent fantasy production.
                                </div>
                                <div>
                                    <strong style="color: var(--text-primary);">Ghost Rate:</strong> Percentage of games scoring under 8 fantasy points. Lower rates indicate a more dependable fantasy floor.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Performance Candles Tab -->
                <div id="modal-chart-candles" class="chart-content">
                    <div style="padding: 20px;">
                        <!-- Candles Header -->
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 24px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <h3 style="font-size: 20px; font-weight: 700; color: var(--text-primary); margin: 0;">Performance Candles</h3>
                                <div style="position: relative; display: inline-block;">
                                    <span style="cursor: help; color: var(--text-secondary); font-size: 16px;" 
                                          onmouseover="document.getElementById('candles-tooltip').style.display='block'" 
                                          onmouseout="document.getElementById('candles-tooltip').style.display='none'">ⓘ</span>
                                    <div id="candles-tooltip" style="display: none; position: absolute; left: 100%; top: 50%; transform: translateY(-50%); margin-left: 8px; background: var(--bg-elevated); padding: 12px; border-radius: 8px; width: 280px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 1000; font-size: 12px; color: var(--text-secondary); line-height: 1.5;">
                                        Shows weekly points scored above or below expected value. Green candles = exceeded projection, Red candles = missed projection. Adjusted for your scoring format.
                                    </div>
                                </div>
                            </div>
                            <div style="font-size: 12px; color: var(--text-secondary);">
                                <span id="candles-scoring-format">PPR</span> Scoring
                            </div>
                        </div>

                        <!-- Candles Chart Container -->
                        <div style="background: var(--bg-tertiary); border-radius: 12px; padding: 24px; max-width: 900px; margin: 0 auto;">
                            <canvas id="modal-candles-chart" style="max-height: 400px;"></canvas>
                        </div>

                        <!-- Candles Legend -->
                        <div style="margin-top: 20px; display: flex; justify-content: center; gap: 32px; flex-wrap: wrap; font-size: 13px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <div style="width: 16px; height: 24px; background: var(--positive); border-radius: 2px;"></div>
                                <span style="color: var(--text-secondary);">Above Expected</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <div style="width: 16px; height: 24px; background: var(--negative); border-radius: 2px;"></div>
                                <span style="color: var(--text-secondary);">Below Expected</span>
                            </div>
                        </div>

                        <!-- Summary Stats -->
                        <div id="candles-summary" style="margin-top: 32px; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; max-width: 700px; margin-left: auto; margin-right: auto;">
                            <!-- Summary cards will be inserted here -->
                        </div>
                    </div>
                </div>

                <!-- Schedule Tab -->
                <div id="modal-chart-schedule" class="chart-content">
                    <div style="padding: 32px 20px;">
                        <div id="modal-schedule-chart-content" style="max-width: 800px; margin: 0 auto;">
                            <div style="text-align: center; color: var(--text-secondary); padding: 40px 20px;">
                                Loading schedule data...
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Comments Section -->
                <div class="comment-section">
                    <div class="comment-header">Quick Takes</div>
                    <div class="comment-input-container">
                        <input type="text" class="comment-input" id="comment-input" placeholder="Share your take (280 chars max)" maxlength="280">
                        <button class="comment-submit" onclick="submitComment()">Post</button>
                    </div>
                    <div class="comment-list" id="comment-list">
                        <!-- Comments will be inserted here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Team Modal -->
    <div class="modal-overlay" id="team-modal">
        <div class="modal">
            <div class="modal-header">
                <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                    <div class="modal-player-info">
                        <div class="modal-team-badge" id="team-modal-badge"></div>
                        <div class="modal-player-details">
                            <div class="modal-player-name" id="team-modal-name"></div>
                            <div class="modal-player-meta" id="team-modal-meta"></div>
                        </div>
                    </div>
                    <button class="modal-close" onclick="closeTeamModal()">×</button>
                </div>
            </div>
            <div class="modal-body">
                <!-- Team Stats Summary -->
                <div class="team-stats-summary" id="team-stats-summary" style="display: none;">
                    <!-- Stats will be inserted here -->
                </div>

                <!-- Collapse Key Players Button -->
                <button onclick="toggleTeamPlayers()" id="team-players-collapse-btn" style="width: 100%; padding: 8px; background: transparent; border: none; border-top: 1px solid var(--border-color); color: var(--text-secondary); font-size: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px; transition: all 0.2s;">
                    <span id="team-players-collapse-icon">▼</span>
                    <span id="team-players-collapse-text">Hide Players</span>
                </button>

                <!-- Key Players Section -->
                <div class="key-players-section" id="key-players-section" style="margin-bottom: 24px;">
                    <h3 style="font-size: 16px; font-weight: 700; margin-bottom: 12px; color: var(--text-primary);">Key Players</h3>
                    <div id="key-players-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
                        <!-- Key players will be inserted here -->
                    </div>
                </div>

                <!-- Time Frame and Week Selectors in Grid -->
                <div id="team-modal-controls-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                    <!-- Metric Selector -->
                    <div>
                        <label style="display: block; font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px;">Metric</label>
                        <select id="team-modal-metric" onchange="updateTeamModalCharts()" style="width: 100%; padding: 10px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 14px; cursor: pointer;">
                            <option value="points">Points</option>
                            <option value="targets">Targets</option>
                            <option value="redzone">Red Zone Opps</option>
                        </select>
                    </div>

                    <!-- Time Frame Selector -->
                    <div>
                        <label style="display: block; font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px;">Time Frame</label>
                        <select id="team-modal-timeframe" onchange="updateTeamModalCharts()" style="width: 100%; padding: 10px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 14px; cursor: pointer;">
                            <option value="season">Season Long</option>
                            <option value="season-avg">Season Avg (PPG)</option>
                            <option value="last5">Last 5 Weeks</option>
                            <option value="last3">Last 3 Weeks</option>
                            <option value="single">Single Week</option>
                        </select>
                    </div>

                    <!-- Week Selector (only shown for Single Week) -->
                    <div id="team-modal-week-selector" style="display: none; grid-column: span 2;">
                        <label style="display: block; font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px;">Select Week</label>
                        <select id="team-modal-week" onchange="updateTeamModalCharts()" style="width: 100%; padding: 10px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 14px; cursor: pointer;">
                            <!-- Weeks will be populated dynamically -->
                        </select>
                    </div>
                </div>

                <!-- Charts -->
                <div class="team-modal-charts-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div class="chart-card">
                        <div class="chart-header" id="team-modal-players-chart-header">Top 6 Players by Points</div>
                        <div class="chart-wrapper" style="height: 300px;">
                            <canvas id="team-modal-players-chart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header" id="team-modal-position-chart-header">Points by Position</div>
                        <div class="chart-wrapper" style="height: 300px;">
                            <canvas id="team-modal-position-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Login Modal -->
    <div class="modal-overlay" id="login-modal" style="display: none;">
        <div class="modal" style="max-width: 400px;">
            <div class="modal-header">
                <h2 style="font-size: 20px; font-weight: 700; color: var(--text-primary);">Admin Login</h2>
                <button class="modal-close" onclick="closeLoginModal()">×</button>
            </div>
            <div class="modal-body">
                <form onsubmit="handleLogin(event)" style="display: flex; flex-direction: column; gap: 16px;">
                    <div>
                        <label style="display: block; font-size: 13px; color: var(--text-secondary); margin-bottom: 6px;">Email</label>
                        <input
                            type="email"
                            id="login-email"
                            class="waitlist-input"
                            placeholder="admin@ffse.com"
                            required
                            style="width: 100%;"
                        />
                    </div>
                    <div>
                        <label style="display: block; font-size: 13px; color: var(--text-secondary); margin-bottom: 6px;">Password</label>
                        <input
                            type="password"
                            id="login-password"
                            class="waitlist-input"
                            placeholder="Enter password"
                            required
                            style="width: 100%;"
                        />
                    </div>
                    <button type="submit" class="waitlist-btn" onclick="handleLogin(event); return false;" style="width: 100%; padding: 12px;">
                        Login
                    </button>
                </form>
                <div class="success-message" id="login-error" style="background: var(--negative-bg); border-color: var(--negative); color: var(--negative);">
                    Invalid credentials
                </div>
            </div>
        </div>
    </div>

    <!-- Privacy Policy Modal -->
    <div class="modal-overlay" id="privacy-modal" style="display: none;">
        <div class="modal" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
            <div class="modal-header">
                <h2 style="font-size: 20px; font-weight: 700; color: var(--text-primary);">Privacy Policy</h2>
                <button class="modal-close" onclick="closePrivacyModal()">×</button>
            </div>
            <div class="modal-body" style="color: var(--text-secondary); line-height: 1.6;">
                <p style="margin-bottom: 16px; color: var(--text-tertiary); font-size: 13px;">
                    <strong>Effective Date:</strong> November 2025
                </p>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">1. Information We Collect</h3>
                <p style="margin-bottom: 12px; font-size: 14px;">
                    We collect information you provide directly to us, including:
                </p>
                <ul style="margin-left: 24px; margin-bottom: 16px; font-size: 14px;">
                    <li style="margin-bottom: 8px;">Email addresses submitted through our waitlist</li>
                    <li style="margin-bottom: 8px;">Usage data and analytics about how you interact with our platform</li>
                    <li style="margin-bottom: 8px;">Device and browser information</li>
                </ul>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">2. How We Use Your Information</h3>
                <p style="margin-bottom: 12px; font-size: 14px;">
                    We use the information we collect to:
                </p>
                <ul style="margin-left: 24px; margin-bottom: 16px; font-size: 14px;">
                    <li style="margin-bottom: 8px;">Provide, maintain, and improve our services</li>
                    <li style="margin-bottom: 8px;">Send you updates about FFSE features and releases</li>
                    <li style="margin-bottom: 8px;">Respond to your comments and questions</li>
                    <li style="margin-bottom: 8px;">Analyze usage patterns to enhance user experience</li>
                </ul>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">3. Information Sharing</h3>
                <p style="margin-bottom: 16px; font-size: 14px;">
                    We do not sell, trade, or rent your personal information to third parties. We may share your information only in the following circumstances:
                </p>
                <ul style="margin-left: 24px; margin-bottom: 16px; font-size: 14px;">
                    <li style="margin-bottom: 8px;">With your consent</li>
                    <li style="margin-bottom: 8px;">To comply with legal obligations</li>
                    <li style="margin-bottom: 8px;">With service providers who assist in our operations</li>
                </ul>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">4. Data Security</h3>
                <p style="margin-bottom: 16px; font-size: 14px;">
                    We implement appropriate technical and organizational measures to protect your personal information against unauthorized access, alteration, disclosure, or destruction.
                </p>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">5. Cookies and Tracking</h3>
                <p style="margin-bottom: 16px; font-size: 14px;">
                    We use cookies and similar tracking technologies to collect information about your browsing activities and to remember your preferences. You can control cookies through your browser settings.
                </p>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">6. Your Rights</h3>
                <p style="margin-bottom: 12px; font-size: 14px;">
                    You have the right to:
                </p>
                <ul style="margin-left: 24px; margin-bottom: 16px; font-size: 14px;">
                    <li style="margin-bottom: 8px;">Access the personal information we hold about you</li>
                    <li style="margin-bottom: 8px;">Request correction of inaccurate information</li>
                    <li style="margin-bottom: 8px;">Request deletion of your information</li>
                    <li style="margin-bottom: 8px;">Opt-out of marketing communications</li>
                </ul>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">7. Children's Privacy</h3>
                <p style="margin-bottom: 16px; font-size: 14px;">
                    Our service is not directed to individuals under the age of 13. We do not knowingly collect personal information from children under 13.
                </p>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">8. Changes to This Policy</h3>
                <p style="margin-bottom: 16px; font-size: 14px;">
                    We may update this Privacy Policy from time to time. We will notify you of any changes by posting the new Privacy Policy on this page and updating the "Effective Date."
                </p>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">9. Contact Us</h3>
                <p style="margin-bottom: 16px; font-size: 14px;">
                    If you have any questions about this Privacy Policy, please contact us through the FFSE platform.
                </p>

                <div style="margin-top: 32px; padding-top: 24px; border-top: 1px solid var(--border-color);">
                    <p style="font-size: 12px; color: var(--text-tertiary);">
                        By using FFSE, you acknowledge that you have read and understood this Privacy Policy.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Upload Section (Hidden Input) -->
    <input type="file" id="wr-file-input" accept=".csv" onchange="handleWRUpload(event)">
    <input type="file" id="rb-file-input" accept=".csv" onchange="handleRBUpload(event)">

    <script>
        // ============================================
        // NFL SCHEDULE & DEFENSIVE RANKINGS DATA
        // ============================================
// NFL Team Schedules - Weeks 11-18 (2025 Season)
// Parsed from FantasyPros schedule PDF

const NFL_SCHEDULE_2025 = {
  'ARI': { // Arizona Cardinals (BYE: Week 8)
    11: { week: 11, opponent: 'SF', home: false },
    12: { week: 12, opponent: 'JAC', home: true },
    13: { week: 13, opponent: 'TB', home: false },
    14: { week: 14, opponent: 'LAR', home: true },
    15: { week: 15, opponent: 'HOU', home: false },
    16: { week: 16, opponent: 'ATL', home: true },
    17: { week: 17, opponent: 'CIN', home: false },
    18: { week: 18, opponent: 'LAR', home: false }
  },
  'ATL': { // Atlanta Falcons (BYE: Week 5)
    11: { week: 11, opponent: 'CAR', home: true },
    12: { week: 12, opponent: 'NO', home: false },
    13: { week: 13, opponent: 'NYJ', home: false },
    14: { week: 14, opponent: 'SEA', home: true },
    15: { week: 15, opponent: 'TB', home: false },
    16: { week: 16, opponent: 'ARI', home: false },
    17: { week: 17, opponent: 'LAR', home: true },
    18: { week: 18, opponent: 'NO', home: true }
  },
  'BAL': { // Baltimore Ravens (BYE: Week 7)
    11: { week: 11, opponent: 'CLE', home: false },
    12: { week: 12, opponent: 'NYJ', home: true },
    13: { week: 13, opponent: 'CIN', home: true },
    14: { week: 14, opponent: 'PIT', home: true },
    15: { week: 15, opponent: 'CIN', home: false },
    16: { week: 16, opponent: 'NE', home: true },
    17: { week: 17, opponent: 'GB', home: false },
    18: { week: 18, opponent: 'PIT', home: false }
  },
  'BUF': { // Buffalo Bills (BYE: Week 7)
    11: { week: 11, opponent: 'TB', home: true },
    12: { week: 12, opponent: 'HOU', home: false },
    13: { week: 13, opponent: 'PIT', home: false },
    14: { week: 14, opponent: 'CIN', home: true },
    15: { week: 15, opponent: 'NE', home: false },
    16: { week: 16, opponent: 'CLE', home: false },
    17: { week: 17, opponent: 'PHI', home: true },
    18: { week: 18, opponent: 'NYJ', home: true }
  },
  'CAR': { // Carolina Panthers (BYE: Week 14)
    11: { week: 11, opponent: 'ATL', home: false },
    12: { week: 12, opponent: 'SF', home: false },
    13: { week: 13, opponent: 'LAR', home: true },
    14: { week: 14, opponent: 'BYE', home: null },
    15: { week: 15, opponent: 'NO', home: false },
    16: { week: 16, opponent: 'TB', home: true },
    17: { week: 17, opponent: 'SEA', home: true },
    18: { week: 18, opponent: 'TB', home: false }
  },
  'CHI': { // Chicago Bears (BYE: Week 5)
    11: { week: 11, opponent: 'MIN', home: false },
    12: { week: 12, opponent: 'PIT', home: true },
    13: { week: 13, opponent: 'PHI', home: false },
    14: { week: 14, opponent: 'GB', home: false },
    15: { week: 15, opponent: 'CLE', home: true },
    16: { week: 16, opponent: 'GB', home: true },
    17: { week: 17, opponent: 'SF', home: false },
    18: { week: 18, opponent: 'DET', home: true }
  },
  'CIN': { // Cincinnati Bengals (BYE: Week 10)
    11: { week: 11, opponent: 'PIT', home: false },
    12: { week: 12, opponent: 'NE', home: true },
    13: { week: 13, opponent: 'BAL', home: false },
    14: { week: 14, opponent: 'BUF', home: false },
    15: { week: 15, opponent: 'BAL', home: true },
    16: { week: 16, opponent: 'MIA', home: false },
    17: { week: 17, opponent: 'ARI', home: true },
    18: { week: 18, opponent: 'CLE', home: true }
  },
  'CLE': { // Cleveland Browns (BYE: Week 9)
    11: { week: 11, opponent: 'BAL', home: true },
    12: { week: 12, opponent: 'LV', home: false },
    13: { week: 13, opponent: 'SF', home: true },
    14: { week: 14, opponent: 'TEN', home: true },
    15: { week: 15, opponent: 'CHI', home: false },
    16: { week: 16, opponent: 'BUF', home: true },
    17: { week: 17, opponent: 'PIT', home: true },
    18: { week: 18, opponent: 'CIN', home: false }
  },
  'DAL': { // Dallas Cowboys (BYE: Week 10)
    11: { week: 11, opponent: 'LV', home: false },
    12: { week: 12, opponent: 'PHI', home: true },
    13: { week: 13, opponent: 'KC', home: true },
    14: { week: 14, opponent: 'DET', home: false },
    15: { week: 15, opponent: 'MIN', home: true },
    16: { week: 16, opponent: 'LAC', home: true },
    17: { week: 17, opponent: 'WAS', home: false },
    18: { week: 18, opponent: 'NYG', home: false }
  },
  'DEN': { // Denver Broncos (BYE: Week 12)
    11: { week: 11, opponent: 'KC', home: true },
    12: { week: 12, opponent: 'BYE', home: null },
    13: { week: 13, opponent: 'WAS', home: false },
    14: { week: 14, opponent: 'LV', home: false },
    15: { week: 15, opponent: 'GB', home: true },
    16: { week: 16, opponent: 'JAC', home: true },
    17: { week: 17, opponent: 'KC', home: false },
    18: { week: 18, opponent: 'LAC', home: true }
  },
  'DET': { // Detroit Lions (BYE: Week 8)
    11: { week: 11, opponent: 'PHI', home: false },
    12: { week: 12, opponent: 'NYG', home: true },
    13: { week: 13, opponent: 'GB', home: true },
    14: { week: 14, opponent: 'DAL', home: true },
    15: { week: 15, opponent: 'LAR', home: false },
    16: { week: 16, opponent: 'PIT', home: true },
    17: { week: 17, opponent: 'MIN', home: false },
    18: { week: 18, opponent: 'CHI', home: false }
  },
  'GB': { // Green Bay Packers (BYE: Week 5)
    11: { week: 11, opponent: 'NYG', home: false },
    12: { week: 12, opponent: 'MIN', home: true },
    13: { week: 13, opponent: 'DET', home: false },
    14: { week: 14, opponent: 'CHI', home: true },
    15: { week: 15, opponent: 'DEN', home: false },
    16: { week: 16, opponent: 'CHI', home: false },
    17: { week: 17, opponent: 'BAL', home: true },
    18: { week: 18, opponent: 'MIN', home: false }
  },
  'HOU': { // Houston Texans (BYE: Week 6)
    11: { week: 11, opponent: 'TEN', home: false },
    12: { week: 12, opponent: 'BUF', home: true },
    13: { week: 13, opponent: 'IND', home: false },
    14: { week: 14, opponent: 'KC', home: false },
    15: { week: 15, opponent: 'ARI', home: true },
    16: { week: 16, opponent: 'LV', home: true },
    17: { week: 17, opponent: 'LAC', home: false },
    18: { week: 18, opponent: 'IND', home: true }
  },
  'IND': { // Indianapolis Colts (BYE: Week 11)
    11: { week: 11, opponent: 'BYE', home: null },
    12: { week: 12, opponent: 'KC', home: false },
    13: { week: 13, opponent: 'HOU', home: true },
    14: { week: 14, opponent: 'JAC', home: false },
    15: { week: 15, opponent: 'SEA', home: false },
    16: { week: 16, opponent: 'SF', home: true },
    17: { week: 17, opponent: 'JAC', home: true },
    18: { week: 18, opponent: 'HOU', home: false }
  },
  'JAC': { // Jacksonville Jaguars (BYE: Week 8)
    11: { week: 11, opponent: 'LV', home: true },
    12: { week: 12, opponent: 'ARI', home: false },
    13: { week: 13, opponent: 'SF', home: true },
    14: { week: 14, opponent: 'IND', home: true },
    15: { week: 15, opponent: 'NYJ', home: true },
    16: { week: 16, opponent: 'DEN', home: false },
    17: { week: 17, opponent: 'IND', home: false },
    18: { week: 18, opponent: 'TEN', home: true }
  },
  'KC': { // Kansas City Chiefs (BYE: Week 10)
    11: { week: 11, opponent: 'DEN', home: false },
    12: { week: 12, opponent: 'IND', home: true },
    13: { week: 13, opponent: 'DAL', home: false },
    14: { week: 14, opponent: 'HOU', home: true },
    15: { week: 15, opponent: 'LAC', home: true },
    16: { week: 16, opponent: 'TEN', home: false },
    17: { week: 17, opponent: 'DEN', home: true },
    18: { week: 18, opponent: 'LV', home: false }
  },
  'LV': { // Las Vegas Raiders (BYE: Week 8)
    11: { week: 11, opponent: 'JAC', home: false },
    12: { week: 12, opponent: 'CLE', home: true },
    13: { week: 13, opponent: 'LAC', home: false },
    14: { week: 14, opponent: 'DEN', home: true },
    15: { week: 15, opponent: 'PHI', home: false },
    16: { week: 16, opponent: 'HOU', home: false },
    17: { week: 17, opponent: 'NYG', home: true },
    18: { week: 18, opponent: 'KC', home: true }
  },
  'LAC': { // Los Angeles Chargers (BYE: Week 12)
    11: { week: 11, opponent: 'JAC', home: false },
    12: { week: 12, opponent: 'BYE', home: null },
    13: { week: 13, opponent: 'LV', home: true },
    14: { week: 14, opponent: 'PHI', home: true },
    15: { week: 15, opponent: 'KC', home: false },
    16: { week: 16, opponent: 'DAL', home: false },
    17: { week: 17, opponent: 'HOU', home: true },
    18: { week: 18, opponent: 'DEN', home: false }
  },
  'LAR': { // Los Angeles Rams (BYE: Week 8)
    11: { week: 11, opponent: 'SF', home: false },
    12: { week: 12, opponent: 'TB', home: true },
    13: { week: 13, opponent: 'CAR', home: false },
    14: { week: 14, opponent: 'ARI', home: false },
    15: { week: 15, opponent: 'DET', home: true },
    16: { week: 16, opponent: 'SEA', home: false },
    17: { week: 17, opponent: 'ATL', home: false },
    18: { week: 18, opponent: 'ARI', home: true }
  },
  'MIA': { // Miami Dolphins (BYE: Week 12)
    11: { week: 11, opponent: 'WAS', home: true },
    12: { week: 12, opponent: 'BYE', home: null },
    13: { week: 13, opponent: 'NO', home: true },
    14: { week: 14, opponent: 'NYJ', home: false },
    15: { week: 15, opponent: 'PIT', home: false },
    16: { week: 16, opponent: 'CIN', home: true },
    17: { week: 17, opponent: 'TB', home: true },
    18: { week: 18, opponent: 'NE', home: false }
  },
  'MIN': { // Minnesota Vikings (BYE: Week 6)
    11: { week: 11, opponent: 'CHI', home: true },
    12: { week: 12, opponent: 'GB', home: false },
    13: { week: 13, opponent: 'SEA', home: false },
    14: { week: 14, opponent: 'WAS', home: true },
    15: { week: 15, opponent: 'DAL', home: false },
    16: { week: 16, opponent: 'NYG', home: false },
    17: { week: 17, opponent: 'DET', home: true },
    18: { week: 18, opponent: 'GB', home: true }
  },
  'NE': { // New England Patriots (BYE: Week 14)
    11: { week: 11, opponent: 'NYJ', home: true },
    12: { week: 12, opponent: 'CIN', home: false },
    13: { week: 13, opponent: 'NYG', home: false },
    14: { week: 14, opponent: 'BYE', home: null },
    15: { week: 15, opponent: 'BUF', home: true },
    16: { week: 16, opponent: 'BAL', home: false },
    17: { week: 17, opponent: 'NYJ', home: false },
    18: { week: 18, opponent: 'MIA', home: true }
  },
  'NO': { // New Orleans Saints (BYE: Week 11)
    11: { week: 11, opponent: 'BYE', home: null },
    12: { week: 12, opponent: 'ATL', home: true },
    13: { week: 13, opponent: 'MIA', home: false },
    14: { week: 14, opponent: 'TB', home: false },
    15: { week: 15, opponent: 'CAR', home: true },
    16: { week: 16, opponent: 'NYJ', home: true },
    17: { week: 17, opponent: 'TEN', home: false },
    18: { week: 18, opponent: 'ATL', home: false }
  },
  'NYG': { // New York Giants (BYE: Week 14)
    11: { week: 11, opponent: 'GB', home: true },
    12: { week: 12, opponent: 'DET', home: false },
    13: { week: 13, opponent: 'NE', home: true },
    14: { week: 14, opponent: 'BYE', home: null },
    15: { week: 15, opponent: 'WAS', home: true },
    16: { week: 16, opponent: 'MIN', home: true },
    17: { week: 17, opponent: 'LV', home: false },
    18: { week: 18, opponent: 'DAL', home: true }
  },
  'NYJ': { // New York Jets (BYE: Week 9)
    11: { week: 11, opponent: 'NE', home: false },
    12: { week: 12, opponent: 'BAL', home: false },
    13: { week: 13, opponent: 'ATL', home: true },
    14: { week: 14, opponent: 'MIA', home: true },
    15: { week: 15, opponent: 'JAC', home: false },
    16: { week: 16, opponent: 'NO', home: false },
    17: { week: 17, opponent: 'NE', home: true },
    18: { week: 18, opponent: 'BUF', home: false }
  },
  'PHI': { // Philadelphia Eagles (BYE: Week 9)
    11: { week: 11, opponent: 'DET', home: true },
    12: { week: 12, opponent: 'DAL', home: false },
    13: { week: 13, opponent: 'CHI', home: true },
    14: { week: 14, opponent: 'LAC', home: false },
    15: { week: 15, opponent: 'LV', home: true },
    16: { week: 16, opponent: 'WAS', home: false },
    17: { week: 17, opponent: 'BUF', home: false },
    18: { week: 18, opponent: 'WAS', home: true }
  },
  'PIT': { // Pittsburgh Steelers (BYE: Week 5)
    11: { week: 11, opponent: 'CIN', home: true },
    12: { week: 12, opponent: 'CHI', home: false },
    13: { week: 13, opponent: 'BUF', home: true },
    14: { week: 14, opponent: 'BAL', home: false },
    15: { week: 15, opponent: 'MIA', home: true },
    16: { week: 16, opponent: 'DET', home: false },
    17: { week: 17, opponent: 'CLE', home: false },
    18: { week: 18, opponent: 'BAL', home: true }
  },
  'SF': { // San Francisco 49ers (BYE: Week 14)
    11: { week: 11, opponent: 'LAR', home: true },
    12: { week: 12, opponent: 'CAR', home: true },
    13: { week: 13, opponent: 'JAC', home: false },
    14: { week: 14, opponent: 'BYE', home: null },
    15: { week: 15, opponent: 'TEN', home: true },
    16: { week: 16, opponent: 'IND', home: false },
    17: { week: 17, opponent: 'CHI', home: true },
    18: { week: 18, opponent: 'SEA', home: true }
  },
  'SEA': { // Seattle Seahawks (BYE: Week 8)
    11: { week: 11, opponent: 'LAR', home: true },
    12: { week: 12, opponent: 'TEN', home: true },
    13: { week: 13, opponent: 'MIN', home: true },
    14: { week: 14, opponent: 'ATL', home: false },
    15: { week: 15, opponent: 'IND', home: true },
    16: { week: 16, opponent: 'LAR', home: true },
    17: { week: 17, opponent: 'CAR', home: false },
    18: { week: 18, opponent: 'SF', home: false }
  },
  'TB': { // Tampa Bay Buccaneers (BYE: Week 9)
    11: { week: 11, opponent: 'BUF', home: false },
    12: { week: 12, opponent: 'LAR', home: false },
    13: { week: 13, opponent: 'ARI', home: true },
    14: { week: 14, opponent: 'NO', home: true },
    15: { week: 15, opponent: 'ATL', home: true },
    16: { week: 16, opponent: 'CAR', home: false },
    17: { week: 17, opponent: 'MIA', home: false },
    18: { week: 18, opponent: 'CAR', home: true }
  },
  'TEN': { // Tennessee Titans (BYE: Week 10)
    11: { week: 11, opponent: 'HOU', home: true },
    12: { week: 12, opponent: 'SEA', home: false },
    13: { week: 13, opponent: 'JAC', home: false },
    14: { week: 14, opponent: 'CLE', home: false },
    15: { week: 15, opponent: 'SF', home: false },
    16: { week: 16, opponent: 'KC', home: true },
    17: { week: 17, opponent: 'NO', home: true },
    18: { week: 18, opponent: 'JAC', home: false }
  },
  'WAS': { // Washington Commanders (BYE: Week 12)
    11: { week: 11, opponent: 'MIA', home: false },
    12: { week: 12, opponent: 'BYE', home: null },
    13: { week: 13, opponent: 'DEN', home: true },
    14: { week: 14, opponent: 'MIN', home: false },
    15: { week: 15, opponent: 'NYG', home: false },
    16: { week: 16, opponent: 'PHI', home: true },
    17: { week: 17, opponent: 'DAL', home: true },
    18: { week: 18, opponent: 'PHI', home: false }
  }
};

// Helper function to get opponent for a team in a specific week
function getOpponent(team, week) {
  if (!NFL_SCHEDULE_2025[team] || !NFL_SCHEDULE_2025[team][week]) {
    return null;
  }
  return NFL_SCHEDULE_2025[team][week];
}

// Export for use in FFSE
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { NFL_SCHEDULE_2025, getOpponent };
}
// Defensive Rankings Data
// Source: FantasyPros Fantasy Football Points Allowed + Pass/Rush Defense Stats

// Fantasy Points Allowed by Position (Lower rank = easier matchup for fantasy)
const POINTS_ALLOWED_VS_POSITION = {
  'ARI': { vsQB: 11, vsRB: 22, vsWR: 19, vsTE: 16 },
  'ATL': { vsQB: 2, vsRB: 31, vsWR: 10, vsTE: 2 },
  'BAL': { vsQB: 5, vsRB: 28, vsWR: 29, vsTE: 10 },
  'BUF': { vsQB: 4, vsRB: 29, vsWR: 15, vsTE: 1 },
  'CAR': { vsQB: 17, vsRB: 16, vsWR: 5, vsTE: 26 },
  'CHI': { vsQB: 13, vsRB: 20, vsWR: 30, vsTE: 22 },
  'CIN': { vsQB: 1, vsRB: 32, vsWR: 11, vsTE: 32 },
  'CLE': { vsQB: 27, vsRB: 6, vsWR: 16, vsTE: 12 },
  'DAL': { vsQB: 10, vsRB: 23, vsWR: 28, vsTE: 14 },
  'DEN': { vsQB: 26, vsRB: 7, vsWR: 2, vsTE: 9 },
  'DET': { vsQB: 29, vsRB: 4, vsWR: 25, vsTE: 15 },
  'GB': { vsQB: 31, vsRB: 2, vsWR: 8, vsTE: 17 },
  'HOU': { vsQB: 21, vsRB: 12, vsWR: 6, vsTE: 4 },
  'IND': { vsQB: 22, vsRB: 11, vsWR: 23, vsTE: 27 },
  'JAC': { vsQB: 23, vsRB: 10, vsWR: 24, vsTE: 31 },
  'KC': { vsQB: 28, vsRB: 5, vsWR: 1, vsTE: 6 },
  'LV': { vsQB: 15, vsRB: 18, vsWR: 27, vsTE: 5 },
  'LAC': { vsQB: 19, vsRB: 14, vsWR: 3, vsTE: 7 },
  'LAR': { vsQB: 32, vsRB: 1, vsWR: 18, vsTE: 21 },
  'MIA': { vsQB: 7, vsRB: 26, vsWR: 4, vsTE: 30 },
  'MIN': { vsQB: 20, vsRB: 13, vsWR: 9, vsTE: 23 },
  'NE': { vsQB: 30, vsRB: 3, vsWR: 21, vsTE: 24 },
  'NO': { vsQB: 14, vsRB: 19, vsWR: 14, vsTE: 18 },
  'NYG': { vsQB: 3, vsRB: 30, vsWR: 26, vsTE: 13 },
  'NYJ': { vsQB: 12, vsRB: 21, vsWR: 13, vsTE: 20 },
  'PHI': { vsQB: 18, vsRB: 15, vsWR: 7, vsTE: 3 },
  'PIT': { vsQB: 24, vsRB: 9, vsWR: 32, vsTE: 29 },
  'SF': { vsQB: 16, vsRB: 17, vsWR: 22, vsTE: 19 },
  'SEA': { vsQB: 25, vsRB: 8, vsWR: 12, vsTE: 28 },
  'TB': { vsQB: 8, vsRB: 25, vsWR: 20, vsTE: 11 },
  'TEN': { vsQB: 9, vsRB: 24, vsWR: 17, vsTE: 8 },
  'WAS': { vsQB: 6, vsRB: 27, vsWR: 31, vsTE: 25 }
};

// Pass Defense Rankings (Yards allowed, Lower rank = more yards allowed = easier matchup)
const PASS_DEFENSE_RANKS = {
  'ATL': { rank: 1, yardsAllowed: 158.1, tdsAllowed: 13 },
  'BUF': { rank: 2, yardsAllowed: 169.9, tdsAllowed: 7 },
  'LAC': { rank: 3, yardsAllowed: 177.1, tdsAllowed: 8 },
  'HOU': { rank: 4, yardsAllowed: 177.5, tdsAllowed: 8 },
  'DEN': { rank: 5, yardsAllowed: 179.5, tdsAllowed: 8 },
  'CLE': { rank: 6, yardsAllowed: 182.6, tdsAllowed: 15 },
  'KC': { rank: 7, yardsAllowed: 187.2, tdsAllowed: 9 },
  'MIN': { rank: 8, yardsAllowed: 194.5, tdsAllowed: 13 },
  'GB': { rank: 9, yardsAllowed: 197, tdsAllowed: 12 },
  'MIA': { rank: 10, yardsAllowed: 198.1, tdsAllowed: 15 },
  'NYJ': { rank: 11, yardsAllowed: 199.6, tdsAllowed: 15 },
  'DET': { rank: 12, yardsAllowed: 200.3, tdsAllowed: 16 },
  'LAR': { rank: 13, yardsAllowed: 203.1, tdsAllowed: 9 },
  'NO': { rank: 14, yardsAllowed: 203.9, tdsAllowed: 18 },
  'CAR': { rank: 15, yardsAllowed: 205.8, tdsAllowed: 11 },
  'LV': { rank: 16, yardsAllowed: 214.2, tdsAllowed: 12 },
  'TEN': { rank: 17, yardsAllowed: 215.3, tdsAllowed: 14 },
  'PHI': { rank: 18, yardsAllowed: 215.9, tdsAllowed: 8 },
  'SEA': { rank: 19, yardsAllowed: 218, tdsAllowed: 11 },
  'NE': { rank: 20, yardsAllowed: 223.6, tdsAllowed: 15 },
  'SF': { rank: 21, yardsAllowed: 223.7, tdsAllowed: 15 },
  'TB': { rank: 22, yardsAllowed: 228.8, tdsAllowed: 11 },
  'ARI': { rank: 23, yardsAllowed: 231.8, tdsAllowed: 9 },
  'NYG': { rank: 24, yardsAllowed: 232.1, tdsAllowed: 15 },
  'CHI': { rank: 25, yardsAllowed: 237.6, tdsAllowed: 20 },
  'IND': { rank: 26, yardsAllowed: 244.8, tdsAllowed: 15 },
  'JAC': { rank: 27, yardsAllowed: 249.3, tdsAllowed: 19 },
  'BAL': { rank: 28, yardsAllowed: 250, tdsAllowed: 14 },
  'WAS': { rank: 29, yardsAllowed: 253.6, tdsAllowed: 19 },
  'DAL': { rank: 30, yardsAllowed: 254.4, tdsAllowed: 22 },
  'CIN': { rank: 31, yardsAllowed: 260.1, tdsAllowed: 23 },
  'PIT': { rank: 32, yardsAllowed: 278.3, tdsAllowed: 14 }
};

// Rush Defense Rankings (Yards allowed, Lower rank = more yards allowed = easier matchup)
const RUSH_DEFENSE_RANKS = {
  'NE': { rank: 1, yardsAllowed: 75.4, tdsAllowed: 3 },
  'SEA': { rank: 2, yardsAllowed: 85.9, tdsAllowed: 4 },
  'JAC': { rank: 3, yardsAllowed: 86.9, tdsAllowed: 4 },
  'IND': { rank: 4, yardsAllowed: 87, tdsAllowed: 6 },
  'GB': { rank: 5, yardsAllowed: 89.4, tdsAllowed: 5 },
  'HOU': { rank: 6, yardsAllowed: 89.9, tdsAllowed: 7 },
  'DEN': { rank: 7, yardsAllowed: 91.2, tdsAllowed: 7 },
  'TB': { rank: 8, yardsAllowed: 92.6, tdsAllowed: 7 },
  'CLE': { rank: 9, yardsAllowed: 94.3, tdsAllowed: 3 },
  'DET': { rank: 10, yardsAllowed: 94.5, tdsAllowed: 6 },
  'LAR': { rank: 11, yardsAllowed: 99.8, tdsAllowed: 2 },
  'ARI': { rank: 12, yardsAllowed: 103.6, tdsAllowed: 7 },
  'KC': { rank: 13, yardsAllowed: 104.6, tdsAllowed: 9 },
  'PIT': { rank: 14, yardsAllowed: 105.5, tdsAllowed: 6 },
  'LV': { rank: 15, yardsAllowed: 106.6, tdsAllowed: 12 },
  'SF': { rank: 16, yardsAllowed: 108.9, tdsAllowed: 5 },
  'LAC': { rank: 17, yardsAllowed: 109.7, tdsAllowed: 10 },
  'CAR': { rank: 18, yardsAllowed: 110.8, tdsAllowed: 10 },
  'PHI': { rank: 19, yardsAllowed: 120.4, tdsAllowed: 10 },
  'MIN': { rank: 20, yardsAllowed: 122.3, tdsAllowed: 6 },
  'BAL': { rank: 21, yardsAllowed: 123.6, tdsAllowed: 10 },
  'WAS': { rank: 22, yardsAllowed: 124.2, tdsAllowed: 7 },
  'ATL': { rank: 23, yardsAllowed: 124.4, tdsAllowed: 5 },
  'NO': { rank: 24, yardsAllowed: 129.4, tdsAllowed: 8 },
  'CHI': { rank: 25, yardsAllowed: 131.1, tdsAllowed: 6 },
  'NYJ': { rank: 26, yardsAllowed: 135.8, tdsAllowed: 8 },
  'TEN': { rank: 27, yardsAllowed: 141.3, tdsAllowed: 15 },
  'BUF': { rank: 28, yardsAllowed: 141.4, tdsAllowed: 12 },
  'DAL': { rank: 29, yardsAllowed: 143, tdsAllowed: 11 },
  'MIA': { rank: 30, yardsAllowed: 145.6, tdsAllowed: 10 },
  'NYG': { rank: 31, yardsAllowed: 150, tdsAllowed: 12 },
  'CIN': { rank: 32, yardsAllowed: 166.4, tdsAllowed: 12 }
};

// Helper functions to get rankings
function getVsPositionRank(team, position) {
  if (!POINTS_ALLOWED_VS_POSITION[team]) return null;
  
  const posMap = {
    'QB': 'vsQB',
    'RB': 'vsRB',
    'WR': 'vsWR',
    'TE': 'vsTE'
  };
  
  return POINTS_ALLOWED_VS_POSITION[team][posMap[position]] || null;
}

function getPassDefenseRank(team) {
  return PASS_DEFENSE_RANKS[team]?.rank || null;
}

function getRushDefenseRank(team) {
  return RUSH_DEFENSE_RANKS[team]?.rank || null;
}

// Get defensive rank color class based on rank
function getDefenseRankClass(rank, type = 'position') {
  if (!rank) return 'average';
  
  // For position ranks (vsWR, vsRB, vsTE) - INVERTED: Rank 1 = hardest, Rank 32 = easiest
  if (type === 'position') {
    if (rank <= 8) return 'bad';       // Hardest (1-8)
    if (rank <= 16) return 'tough';    // Tough (9-16)
    if (rank <= 24) return 'average';  // Average (17-24)
    if (rank <= 28) return 'good';     // Good (25-28)
    return 'elite';                    // Easiest (29-32)
  }
  
  // For RUSH defense - INVERTED: Rank 1 = hardest, Rank 32 = easiest
  if (type === 'rush') {
    if (rank <= 8) return 'bad';       // Hardest (1-8)
    if (rank <= 16) return 'tough';    // Tough (9-16)
    if (rank <= 24) return 'average';  // Average (17-24)
    if (rank <= 28) return 'good';     // Good (25-28)
    return 'elite';                    // Easiest (29-32)
  }
  
  // For PASS defense - INVERTED: Rank 1 = hardest, Rank 32 = easiest
  if (type === 'pass') {
    if (rank <= 8) return 'bad';       // Hardest (1-8)
    if (rank <= 16) return 'tough';    // Tough (9-16)
    if (rank <= 24) return 'average';  // Average (17-24)
    if (rank <= 28) return 'good';     // Good (25-28)
    return 'elite';                    // Easiest (29-32)
  }
  
  return 'average';
}

// Get tooltip text for rankings
function getRankTooltip(rank, type, position = null) {
  if (!rank) return '';
  
  if (type === 'position') {
    const posName = { 'QB': 'QBs', 'RB': 'RBs', 'WR': 'WRs', 'TE': 'TEs' }[position] || 'this position';
    if (rank <= 8) return `${rank}${getOrdinal(rank)} = Hardest matchup`;
    if (rank <= 16) return `${rank}${getOrdinal(rank)} = Tough matchup`;
    if (rank <= 24) return `${rank}${getOrdinal(rank)} = Average matchup`;
    if (rank <= 28) return `${rank}${getOrdinal(rank)} = Good matchup for ${posName}`;
    return `${rank}${getOrdinal(rank)} = Elite matchup for ${posName}!`;
  }
  
  // For PASS defense - Rank 1 = hardest, Rank 32 = easiest
  if (type === 'pass') {
    if (rank <= 8) return `${rank}${getOrdinal(rank)} = Toughest pass defense`;
    if (rank <= 16) return `${rank}${getOrdinal(rank)} = Tough pass defense`;
    if (rank <= 24) return `${rank}${getOrdinal(rank)} = Average pass defense`;
    if (rank <= 28) return `${rank}${getOrdinal(rank)} = Favorable pass defense`;
    return `${rank}${getOrdinal(rank)} = Best passing matchup!`;
  }
  
  // For RUSH defense - Rank 1 = hardest, Rank 32 = easiest
  if (type === 'rush') {
    if (rank <= 8) return `${rank}${getOrdinal(rank)} = Hardest rushing matchup`;
    if (rank <= 16) return `${rank}${getOrdinal(rank)} = Tough run defense`;
    if (rank <= 24) return `${rank}${getOrdinal(rank)} = Average run defense`;
    if (rank <= 28) return `${rank}${getOrdinal(rank)} = Good rushing matchup`;
    return `${rank}${getOrdinal(rank)} = Elite rushing matchup!`;
  }
  
  return '';
}

function getOrdinal(n) {
  const s = ["th", "st", "nd", "rd"];
  const v = n % 100;
  return s[(v - 20) % 10] || s[v] || s[0];
}

// Export for use in FFSE
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    POINTS_ALLOWED_VS_POSITION,
    PASS_DEFENSE_RANKS,
    RUSH_DEFENSE_RANKS,
    getVsPositionRank,
    getPassDefenseRank,
    getRushDefenseRank,
    getDefenseRankClass,
    getRankTooltip
  };
}
        // ============================================
        // LOADING SCREEN CONTROLLER
        // ============================================
        const LoadingScreen = {
            progressFill: null,
            progressText: null,
            statusText: null,
            currentProgress: 0,

            init() {
                this.progressFill = document.getElementById('loading-progress-fill');
                this.progressText = document.getElementById('loading-percentage');
                this.statusText = document.getElementById('loading-status');
            },

            updateProgress(percentage, status) {
                this.currentProgress = percentage;
                if (this.progressFill) {
                    this.progressFill.style.width = percentage + '%';
                }
                if (this.progressText) {
                    this.progressText.textContent = Math.round(percentage) + '%';
                }
                if (this.statusText && status) {
                    this.statusText.textContent = status;
                }
            },

            complete() {
                this.updateProgress(100, 'Complete!');
                setTimeout(() => {
                    const loadingScreen = document.getElementById('initial-loading-screen');
                    if (loadingScreen) {
                        loadingScreen.classList.add('fade-out');
                        setTimeout(() => {
                            loadingScreen.remove();
                        }, 500);
                    }
                }, 300);
            }
        };

        // Initialize loading screen immediately
        LoadingScreen.init();
        LoadingScreen.updateProgress(5, 'Connecting to data source...');

        // TE INTEGRATION PREPARATION
        // The code is ready for TE data! When TE CSV is uploaded:
        // 1. teData array will be populated (already declared)
        // 2. TE nav tab will auto-show (#te-tab style display)
        // 3. TE page needs to be created (copy WR page structure)
        // 4. TE Advanced Analytics button will auto-show (#advanced-te-btn)
        // 5. Team Analysis "Pass Catchers" will include TEs automatically
        // 6. Add TE leaderboards: "Volume TEs", "Red Zone TEs", "Efficiency TEs"
        // 7. TE color is orange (#FF9F0A) - use getPositionColor('TE')
        // 8. TEs use WR-style metrics (targets, receptions, air yards, etc.)

        // 1. DATA LAYER

        // Position Colors
        const positionColors = {
            'WR': '#0a84ff',  // Blue
            'RB': '#30d158',  // Green
            'TE': '#ff9f0a'   // Orange/Amber
        };

        // NFL Team Colors
        const teamColors = {
            // AFC East
            'BUF': '#00338D', 'MIA': '#008E97', 'NE': '#223C67', 'NYJ': '#125740',
            // AFC North
            'BAL': '#241773', 'CIN': '#FB4F14', 'CLE': '#5A381E', 'PIT': '#FFB612', // Fixed PIT to gold
            // AFC South
            'HOU': '#14344C', 'IND': '#002C5F', 'JAC': '#006778', 'JAX': '#006778', 'TEN': '#0C2340',
            // AFC West
            'DEN': '#FB4F14', 'KC': '#E31837', 'LV': '#A5ACAF', 'LAC': '#0080C6',
            // NFC East
            'DAL': '#003594', 'NYG': '#0B2265', 'PHI': '#004C54', 'WAS': '#7A2222',
            // NFC North
            'CHI': '#2E3E66', 'DET': '#0076B6', 'GB': '#203731', 'MIN': '#4F2683',
            // NFC South
            'ATL': '#A71930', 'CAR': '#0085CA', 'NO': '#D3BC8D', 'TB': '#D50A0A',
            // NFC West
            'ARI': '#FF2D55', 'LAR': '#003594', 'SF': '#AA0000', 'SEA': '#223C67'
        };

        // NFL Team Full Color Palettes (Primary, Secondary, Tertiary, Fallback) - Dark UI Optimized
        const teamColorPalettes = {
            // AFC North
            'BAL': ['#241773', '#9E7C0C', '#C8102E', '#8E8AFF'],
            'CIN': ['#FB4F14', '#FF8F33', '#FFD6A5', '#FFB300'],
            'CLE': ['#5A381E', '#FF3C00', '#FF8F66', '#FFB547'],
            'PIT': ['#FFB612', '#00539B', '#C8102E', '#FFD65E'],
            // AFC East
            'BUF': ['#00338D', '#C60C30', '#66A3FF', '#0096FF'],
            'MIA': ['#008E97', '#FC4C02', '#4DD5D0', '#00CFFF'],
            'NE': ['#223C67', '#C60C30', '#B0B7BC', '#748FFF'],
            'NYJ': ['#125740', '#FFFFFF', '#5DBB63', '#29D98C'],
            // AFC South
            'HOU': ['#14344C', '#A6192E', '#D6E3F8', '#007BFF'],
            'IND': ['#002C5F', '#A2AAAD', '#589BFF', '#00A3E0'],
            'JAC': ['#006778', '#D7A22A', '#9F792C', '#00CFCF'],
            'JAX': ['#006778', '#D7A22A', '#9F792C', '#00CFCF'],
            'TEN': ['#0C2340', '#4B92DB', '#C8102E', '#85BFFF'],
            // AFC West
            'DEN': ['#FB4F14', '#223C67', '#FFD6A5', '#FFB300'],
            'KC': ['#E31837', '#FFB81C', '#FF9A66', '#FFD65E'],
            'LV': ['#A5ACAF', '#FFFFFF', '#E6E6E6', '#B8C2CC'],
            'LAC': ['#0080C6', '#FFC20E', '#F4F4F4', '#00CFFF'],
            // NFC North
            'CHI': ['#2E3E66', '#C83803', '#FF8A3D', '#FFB547'],
            'DET': ['#0076B6', '#B0B7BC', '#5CB3FF', '#00A3E0'],
            'GB': ['#203731', '#FFB81C', '#9FCF5A', '#D9B200'],
            'MIN': ['#4F2683', '#FFC62F', '#A285E0', '#8E8AFF'],
            // NFC East
            'DAL': ['#003594', '#869397', '#A8B0B7', '#8CB5FF'],
            'NYG': ['#0B2265', '#A71930', '#7FA9FF', '#007BFF'],
            'PHI': ['#004C54', '#A5ACAF', '#2BAEA6', '#00D6B4'],
            'WAS': ['#7A2222', '#FFB612', '#FFD65E', '#D2691E'],
            // NFC South
            'ATL': ['#A71930', '#A5ACAF', '#E94958', '#FFB5C3'],
            'CAR': ['#0085CA', '#BFC0BF', '#59C9FF', '#00CFFF'],
            'NO': ['#D3BC8D', '#F5E6CC', '#FFF1D4', '#FFD65E'],
            'TB': ['#D50A0A', '#FF7900', '#D3D3D3', '#FFD65E'],
            // NFC West
            'ARI': ['#97233F', '#FFB612', '#E94958', '#FF8C8C'],
            'LAR': ['#003594', '#FFA300', '#FFD65E', '#00CFFF'],
            'SF': ['#AA0000', '#B3995D', '#FFD65E', '#FF8A8A'],
            'SEA': ['#223C67', '#69BE28', '#A5ACAF', '#9EFF78']
        };

        // Global data storage
        let wrData = null;
        let rbData = null;
        let teData = null;
        let injuryData = {}; // Sleeper API injury data
        let aggregatedWRs = {};
        let aggregatedRBs = {};
        let aggregatedTEs = {};
        let currentScoringFormat = localStorage.getItem('ffse_scoring_format') || 'ppr'; // 'ppr', 'half', or 'std'
        let allPlayers = {};
        let teamStats = {}; // Store team statistics globally for Advanced Analytics

        // Initialize injury data from cache immediately
        (function initInjuryDataFromCache() {
            const cachedData = localStorage.getItem('injuryData');
            if (cachedData) {
                try {
                    const parsedCache = JSON.parse(cachedData);
                    const cacheAge = Date.now() - (parsedCache.timestamp || 0);
                    // Use cache if less than 1 hour old
                    if (cacheAge < 3600000) {
                        injuryData = parsedCache.data;
                        console.log('Injury data loaded from cache on init:', Object.keys(injuryData).length, 'players');
                    } else {
                        console.log('Cached injury data expired, will fetch fresh data');
                    }
                } catch (e) {
                    console.error('Failed to parse cached injury data on init:', e);
                }
            } else {
                console.log('No cached injury data found, will fetch from API');
            }
        })();

        // Team Analysis variables
        let teamAnalysisCharts = {
            pie: null,
            secondary: null
        };
        let leagueComparisonEnabled = true; // Start with league comparison ON
        let currentTeamAnalysisTeam = null;

        // NFL Divisions structure
        const nflDivisions = {
            'AFC East': ['BUF', 'MIA', 'NYJ', 'NE'],
            'AFC North': ['BAL', 'CIN', 'CLE', 'PIT'],
            'AFC South': ['HOU', 'IND', 'JAX', 'TEN'],
            'AFC West': ['DEN', 'KC', 'LV', 'LAC'],
            'NFC East': ['DAL', 'NYG', 'PHI', 'WAS'],
            'NFC North': ['CHI', 'DET', 'GB', 'MIN'],
            'NFC South': ['ATL', 'CAR', 'NO', 'TB'],
            'NFC West': ['ARI', 'LAR', 'SF', 'SEA']
        };

        // Position colors
        const POSITION_COLORS = {
            'WR': '#0a84ff',  // Blue
            'RB': '#30d158',  // Green
            'TE': '#FF9F0A'   // Orange
        };

        // Helper function to get position color
        function getPositionColor(position) {
            return POSITION_COLORS[position] || '#8e8e93'; // Default gray
        }

        // Sentiment & voting data
        let playerVotes = {}; // { playerName: { buy: count, sell: count, hold: count, lastVote: timestamp } }
        let playerComments = {}; // { playerName: [ { text, timestamp, user } ] }

        // Load sentiment data from localStorage
        function loadSentimentData() {
            // FORCE CLEAR - Remove this after first successful load
            const forceClear = false; // Set to false after testing

            if (forceClear) {                localStorage.removeItem('ffse_player_votes');
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith('ffse_user_vote_')) {
                        localStorage.removeItem(key);
                    }
                });
                playerVotes = {};
                return; // Start completely fresh
            }

            const stored = localStorage.getItem('ffse_player_votes');
            if (stored) {
                playerVotes = JSON.parse(stored);

                // Clean old votes (older than 30 days)
                const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
                Object.keys(playerVotes).forEach(player => {
                    if (playerVotes[player].lastVote < thirtyDaysAgo) {
                        delete playerVotes[player];
                    }
                });
            }
        }

        // MANUAL RESET FUNCTION - for testing
        function resetAllSentimentData() {
            localStorage.removeItem('ffse_player_votes');
            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('ffse_user_vote_')) {
                    localStorage.removeItem(key);
                }
            });
            playerVotes = {};
            alert('✅ All sentiment data cleared! Refreshing page...');
            location.reload();
        }

        // Save sentiment data to localStorage
        function saveSentimentData() {
            localStorage.setItem('ffse_player_votes', JSON.stringify(playerVotes));
        }

        // Calculate sentiment score with 7-day decay
        function getSentimentScore(playerName) {
            if (!playerVotes[playerName]) return { score: 0, buy: 0, sell: 0, hold: 0, total: 0 };

            const votes = playerVotes[playerName];
            const now = Date.now();
            const sevenDays = 7 * 24 * 60 * 60 * 1000;

            // Apply time decay (votes older than 7 days have reduced weight)
            const daysSinceVote = (now - votes.lastVote) / (24 * 60 * 60 * 1000);
            const decayFactor = Math.max(0, 1 - (daysSinceVote / 7));

            const weightedBuy = votes.buy * decayFactor;
            const weightedSell = votes.sell * decayFactor;
            const weightedHold = votes.hold * decayFactor;
            const total = weightedBuy + weightedSell + weightedHold;

            // Score: +1 for buy, 0 for hold, -1 for sell
            const score = total > 0 ? (weightedBuy - weightedSell) / total : 0;

            return {
                score: score, // -1 to +1
                buy: votes.buy,
                sell: votes.sell,
                hold: votes.hold,
                total: votes.buy + votes.sell + votes.hold,
                decayFactor: decayFactor
            };
        }

        // Generate signal tags based on data
        function getSignalTag(playerData) {
            if (!playerData.oppShare || !playerData.weeklyData) return null;

            // Calculate opportunity share change (last 2 weeks vs previous 2 weeks)
            const weeks = playerData.weeklyData.sort((a, b) => b.week - a.week);
            if (weeks.length < 4) return null;

            const recent2 = weeks.slice(0, 2);
            const previous2 = weeks.slice(2, 4);
            const recentAvg = recent2.reduce((sum, w) => sum + (parseFloat(w.oppShare) || 0), 0) / 2;
            const previousAvg = previous2.reduce((sum, w) => sum + (parseFloat(w.oppShare) || 0), 0) / 2;
            const change = recentAvg - previousAvg;

            if (change >= 5) return { type: 'trending', label: 'Trending Up', class: 'positive' };

            // Check consistency (avg ± 3 pts for 4+ weeks)
            const avgPoints = weeks.reduce((sum, w) => sum + (parseFloat(w.fpts) || 0), 0) / weeks.length;
            const variance = weeks.reduce((sum, w) => sum + Math.pow((parseFloat(w.fpts) || 0) - avgPoints, 2), 0) / weeks.length;
            const stdDev = Math.sqrt(variance);

            if (stdDev <= 3 && weeks.length >= 4) return { type: 'consistent', label: 'Consistent', class: 'neutral' };

            // Check if undershooting projection
            const undershoots = weeks.filter(w => {
                const actual = parseFloat(w.fpts) || 0;
                const expected = parseFloat(w.expected) || actual;
                return actual < expected;
            }).length;

            if (undershoots >= 3 && weeks.length >= 4) return { type: 'oversold', label: 'Buy Low', class: 'opportunity' };

            return null;
        }

        // Chart instances
        let wrScatterChart = null;
        let rbScatterChart = null;
        let modalVarianceChart = null;
        let modalOutcomesChart = null;
        let modalSpiderChart = null;
        let modalShareChart = null;
        let modalTrendsChart = null;
        let teamModalShareChart = null;
        let teamModalTrendsChart = null;

        // Matrix chart instances
        let wrEfficiencyMatrix = null;
        let wrShareMatrix = null;
        let wrFloorMatrix = null;
        let wrRedzoneMatrix = null;
        let wrVolumeMonsterMatrix = null;
        let wrCatchRateMatrix = null;
        let rbEfficiencyMatrix = null;
        let rbTalentMatrix = null;

        // ===================================
        // MOBILE CHART INTERACTION SYSTEM
        // ===================================
        
        // Mobile detection
        function isMobileDevice() {
            return window.innerWidth <= 768 || ('ontouchstart' in window);
        }

        // Double-tap tracking variables
        let lastTapTime = 0;
        let lastTapPlayer = null;
        let stickyTooltipTimeout = null;
        let currentStickyTooltip = null;

        // Create sticky tooltip for mobile
        function createStickyChartTooltip(player, chart, event, additionalData) {
            // Remove any existing sticky tooltip
            hideStickyChartTooltip();

            // Check for overlapping players if chart data is available
            let playersToShow = [player];
            
            if (additionalData && additionalData.findOverlapping) {
                // Find all players at or near this location
                const threshold = additionalData.threshold || 0.3;
                const hoveredPoint = additionalData.point;
                const overlapping = [];
                
                // Search through all datasets
                if (chart && chart.data && chart.data.datasets) {
                    chart.data.datasets.forEach(dataset => {
                        if (dataset.data) {
                            dataset.data.forEach(point => {
                                if (point.player && hoveredPoint) {
                                    const distance = Math.sqrt(
                                        Math.pow((point.x - hoveredPoint.x), 2) + 
                                        Math.pow((point.y - hoveredPoint.y), 2)
                                    );
                                    
                                    if (distance < threshold) {
                                        // Check if not already added
                                        if (!overlapping.find(p => p.id === point.player.id)) {
                                            overlapping.push({
                                                ...point.player,
                                                x: point.x,
                                                y: point.y
                                            });
                                        }
                                    }
                                }
                            });
                        }
                    });
                }
                
                if (overlapping.length > 0) {
                    playersToShow = overlapping;
                }
            }

            const tooltip = document.createElement('div');
            tooltip.className = 'sticky-chart-tooltip';
            
            // Build HTML for all players
            let playersHtml = playersToShow.map((p, index) => {
                const color = teamColors[p.team] || '#666';
                let statsHtml = '';
                
                if (additionalData && additionalData.stats) {
                    const statsText = additionalData.stats(p);
                    // Convert newlines to HTML breaks
                    statsHtml = statsText.replace(/\n/g, '<br>');
                }
                
                return `
                    ${index > 0 ? '<div style="height: 1px; background: rgba(255,255,255,0.1); margin: 8px 0;"></div>' : ''}
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                        <div style="width: 10px; height: 10px; background: ${color}; border-radius: 2px; flex-shrink: 0;"></div>
                        <div style="font-weight: 600;">${p.name}</div>
                    </div>
                    <div style="font-size: 11px; color: #8e8e93; margin-left: 18px; margin-bottom: 2px;">${p.team}${p.pos ? ' - ' + p.pos : ''}</div>
                    ${statsHtml ? `<div style="font-size: 11px; color: #8e8e93; margin-left: 18px;">${statsHtml}</div>` : ''}
                `;
            }).join('');
            
            tooltip.innerHTML = `
                ${playersHtml}
                ${playersToShow.length > 0 ? `
                    <button id="tooltip-open-btn" style="
                        width: 100%;
                        margin-top: 10px;
                        padding: 8px 12px;
                        background: rgba(10, 132, 255, 0.15);
                        border: 1px solid rgba(10, 132, 255, 0.3);
                        border-radius: 6px;
                        color: #0a84ff;
                        font-size: 12px;
                        font-weight: 600;
                        cursor: pointer;
                        transition: all 0.2s ease;
                    ">
                        View Player Card →
                    </button>
                ` : ''}
            `;

            // Position tooltip near tap location
            const rect = chart.canvas.getBoundingClientRect();
            const x = event.clientX || (event.touches && event.touches[0].clientX) || rect.left + rect.width / 2;
            const y = event.clientY || (event.touches && event.touches[0].clientY) || rect.top + rect.height / 2;

            tooltip.style.position = 'fixed';
            tooltip.style.left = x + 'px';
            tooltip.style.top = (y - 80) + 'px';
            tooltip.style.transform = 'translateX(-50%)';
            tooltip.style.backgroundColor = 'rgba(28, 28, 30, 0.95)';
            tooltip.style.color = 'white';
            tooltip.style.padding = '10px 14px';
            tooltip.style.borderRadius = '8px';
            tooltip.style.fontSize = '13px';
            tooltip.style.zIndex = '10000';
            tooltip.style.pointerEvents = 'auto';
            tooltip.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
            tooltip.style.border = '1px solid rgba(255,255,255,0.1)';
            tooltip.style.maxWidth = '280px';
            tooltip.style.minWidth = '180px';

            document.body.appendChild(tooltip);
            currentStickyTooltip = tooltip;
            
            // Add click handler to button to open player modal
            const openBtn = document.getElementById('tooltip-open-btn');
            if (openBtn && playersToShow.length > 0) {
                openBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    hideStickyChartTooltip();
                    openPlayerModal(playersToShow[0].id);
                });
                
                // Add hover effect
                openBtn.addEventListener('mouseenter', function() {
                    this.style.background = 'rgba(10, 132, 255, 0.25)';
                    this.style.borderColor = 'rgba(10, 132, 255, 0.5)';
                });
                openBtn.addEventListener('mouseleave', function() {
                    this.style.background = 'rgba(10, 132, 255, 0.15)';
                    this.style.borderColor = 'rgba(10, 132, 255, 0.3)';
                });
            }

            // Auto-hide after 8 seconds as fallback
            stickyTooltipTimeout = setTimeout(() => {
                hideStickyChartTooltip();
            }, 8000);
        }

        // Hide sticky tooltip
        function hideStickyChartTooltip() {
            if (currentStickyTooltip) {
                currentStickyTooltip.remove();
                currentStickyTooltip = null;
            }
            if (stickyTooltipTimeout) {
                clearTimeout(stickyTooltipTimeout);
                stickyTooltipTimeout = null;
            }
        }

        // Handle chart click with double-tap detection
        function handleChartClick(event, player, openModalFn, additionalData) {
            if (!isMobileDevice()) {
                // Desktop: immediate modal open
                openModalFn(player.id);
                return;
            }

            // Mobile: single tap shows tooltip with button
            // Hide any existing tooltip first
            hideStickyChartTooltip();
            
            // Get the chart instance from the event
            const chart = event.chart || event.target?.chart;
            if (chart) {
                createStickyChartTooltip(player, chart, event.native || event, additionalData);
            }
        }

        // Get mobile-friendly tooltip config
        function getMobileChartTooltipConfig() {
            if (!isMobileDevice()) {
                return {}; // No changes for desktop
            }

            return {
                enabled: false, // Disable default tooltip on mobile
                external: function(context) {
                    // Use sticky tooltip instead
                }
            };
        }

        // Add touch listener to dismiss tooltips when tapping elsewhere
        document.addEventListener('touchstart', function(e) {
            if (!currentStickyTooltip) return;
            
            // Check if tap is on tooltip itself (including button) or on chart
            const isChart = e.target.tagName === 'CANVAS';
            const isTooltip = currentStickyTooltip.contains(e.target);
            
            // Only hide if tap is outside both tooltip and chart
            if (!isChart && !isTooltip) {
                hideStickyChartTooltip();
            }
        });

        // ===================================
        // END MOBILE CHART INTERACTION SYSTEM
        // ==================================="
        let rbOpportunityMatrix = null;
        let rbShareMatrix = null;
        let rbFloorMatrix = null;
        let rbRedzoneMatrix = null;

        /* New: Player Evaluation Metrics - Data and Chart Instances */
        let evaluationDataWR = {};
        let evaluationDataRB = {};

        /* v7: Segment averages (4-week rolling) */
        let segmentDataWR = {};
        let segmentDataRB = {};

        let wrEvalVolumeEfficiencyChart = null;
        let wrEvalShareRZChart = null;
        let rbEvalTotalRZChart = null;
        let rbEvalVolumeEfficiencyChart = null;

        // Trend animation state
        let evaluationTrendActive = {};
        let evaluationTrendIntervals = {};
        let evaluationTrendCurrentWeek = {};

        // Helper function to generate color variations for players on same team
        function getColorPalette(baseColor, count) {
            // Convert hex to RGB
            const r = parseInt(baseColor.slice(1, 3), 16);
            const g = parseInt(baseColor.slice(3, 5), 16);
            const b = parseInt(baseColor.slice(5, 7), 16);

            const colors = [];
            for (let i = 0; i < count; i++) {
                // Create more saturated variations
                // Boost saturation by 30% and increase brightness variation
                const saturationBoost = 1.3;
                const brightnessStart = 1.0; // Start at 100% brightness for first color
                const brightnessStep = 0.15; // 15% step between colors
                
                // Calculate brightness factor (100%, 85%, 70%, etc.)
                const brightnessFactor = Math.max(0.55, brightnessStart - (i * brightnessStep));
                
                // Apply saturation boost and brightness
                const newR = Math.min(255, Math.floor(r * saturationBoost * brightnessFactor));
                const newG = Math.min(255, Math.floor(g * saturationBoost * brightnessFactor));
                const newB = Math.min(255, Math.floor(b * saturationBoost * brightnessFactor));

                colors.push(`rgb(${newR}, ${newG}, ${newB})`);
            }

            return colors;
        }

        /* ============================================
           New Feature: Player Headshot Handler
           ============================================ */

        // Generate headshot URL for a player
        function getPlayerHeadshotUrl(playerName, team) {
            // Map of player names to their uploaded headshot files
            const headshotMap = {
                'Christian McCaffrey': '/mnt/user-data/uploads/McCaffrey_Christian.JPG',
                'Jonathan Taylor': '/mnt/user-data/uploads/Taylor_Jonathan.JPG',
                'Justin Jefferson': '/mnt/user-data/uploads/Jefferson_Justin.jpg',
                'Ladd McConkey': '/mnt/user-data/uploads/McConkey_Ladd.jpg',
                'Ja\'Marr Chase': '/mnt/user-data/uploads/Chase_Ja_Marr.jpg',
                'Bijan Robinson': '/mnt/user-data/uploads/Robinson_Bijan.JPG'
            };

            return headshotMap[playerName] || null;
        }

        // Create headshot img element
        function createHeadshotElement(playerName, team) {
            const url = getPlayerHeadshotUrl(playerName, team);

            if (url) {
                // REFACTORED: Lazy load images
                return `<img src="" data-src="${url}" alt="${playerName}" class="player-headshot loading" onerror="this.style.display='none'" loading="lazy">`;
            } else {
                // Placeholder: Use team color circle with initials
                const initials = playerName
                    .split(' ')
                    .map(n => n[0])
                    .join('')
                    .toUpperCase()
                    .slice(0, 2);
                const bgColor = teamColors[team] || '#666';
                return `<div class="player-headshot" style="background: ${bgColor}; display: flex; align-items: center; justify-content: center; font-size: 11px; font-weight: 700; color: white;">${initials}</div>`;
            }
        }

        // REFACTORED: Lazy load headshot images with Intersection Observer
        function initLazyLoadHeadshots() {
            if ('IntersectionObserver' in window) {
                const imageObserver = new IntersectionObserver((entries, observer) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const img = entry.target;
                            img.src = img.dataset.src;
                            img.classList.remove('loading');
                            observer.unobserve(img);
                        }
                    });
                });

                document.querySelectorAll('img.player-headshot[data-src]').forEach(img => {
                    imageObserver.observe(img);
                });
            } else {
                // Fallback for older browsers
                document.querySelectorAll('img.player-headshot[data-src]').forEach(img => {
                    img.src = img.dataset.src;
                    img.classList.remove('loading');
                });
            }
        }

        /* ============================================
           REFACTORED: Animation & Chart Utilities
           ============================================ */

        // Easing functions for smooth animations
        const Easing = {
            linear: t => t,
            easeInOutSine: t => -(Math.cos(Math.PI * t) - 1) / 2,
            easeOutCubic: t => 1 - Math.pow(1 - t, 3),
            easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2
        };

        // Chart update utility - update data instead of destroying
        function updateChartData(chart, newData) {
            if (!chart) return;
            chart.data.datasets[0].data = newData;
            chart.update('none'); // Update without animation for performance
        }

        // Smooth interpolation
        function lerp(start, end, t) {
            return start + (end - start) * t;
        }

        // Get chart instance by ID

        /* ============================================
           New Feature: Trend Animation
           ============================================ */

        let trendAnimationActive = {};
        let trendAnimationFrames = {};

        function toggleTrendAnimation(chartId) {
            trendAnimationActive[chartId] = !trendAnimationActive[chartId];
            trendAnimationFrames[chartId] = 0;

            const btn = document.querySelector(`[data-chart="${chartId}"]`);
            if (btn) {
                btn.classList.toggle('active');
            }

            // Note: Animation loop would be triggered here if we had weekly player data
            // For now, this is a placeholder for future implementation
        }

        /* ============================================
           Quadrant Highlighting Removed - Using chart annotations instead
           ============================================ */

        // Helper function for linear regression
        function calculateLinearRegression(data) {
            const n = data.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;

            data.forEach(point => {
                sumX += point.x;
                sumY += point.y;
                sumXY += point.x * point.y;
                sumX2 += point.x * point.x;
            });

            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            return { slope, intercept };
        }

        /* ============================================
           New: Player Evaluation Metrics Functions
           ============================================ */

        /**
         * Calculate evaluation metrics from raw weekly data
         * Creates per-week and aggregated metrics for WRs
         */
        function calculateWREvaluationMetrics(weeklyData) {
            const wrsByWeek = {};
            const wrTeamTotals = {}; // Track team totals by week

            // First pass: organize by player and week, calculate team totals
            weeklyData.forEach(row => {
                const week = parseInt(row.Week);
                const player = row.Player?.trim();
                const team = row.Team?.trim();

                if (!player || !week || week === 0) return;

                // Initialize player data
                if (!wrsByWeek[player]) {
                    wrsByWeek[player] = { team: team, weeks: {} };
                }

                // Extract metrics
                const targets = parseFloat(row.TGT) || 0;
                const fpts = parseFloat(row.FPTS) || 0;
                const rzTargets = parseFloat(row['RZ TGT']) || parseFloat(row['RZ_TGT']) || 0;

                // Store week data
                wrsByWeek[player].weeks[week] = {
                    targets: targets,
                    fpts: fpts,
                    rzTargets: rzTargets,
                    team: team
                };

                // Track team totals for share calculation
                const teamKey = `${team}-${week}`;
                if (!wrTeamTotals[teamKey]) {
                    wrTeamTotals[teamKey] = { targets: 0, rzTargets: 0 };
                }
                wrTeamTotals[teamKey].targets += targets;
                wrTeamTotals[teamKey].rzTargets += rzTargets;
            });

            // Second pass: calculate derived metrics
            Object.keys(wrsByWeek).forEach(player => {
                const playerData = wrsByWeek[player];
                const weeks = Object.keys(playerData.weeks).map(Number).sort((a, b) => a - b);

                weeks.forEach(week => {
                    const weekData = playerData.weeks[week];
                    const teamKey = `${weekData.team}-${week}`;
                    const teamTotals = wrTeamTotals[teamKey] || { targets: 1, rzTargets: 1 };

                    // Calculate per-game and share metrics
                    weekData.targetsPerGame = weekData.targets; // Already per-game in weekly data
                    weekData.fptsPerTarget = weekData.targets > 0 ? weekData.fpts / weekData.targets : 0;
                    weekData.targetShare = (weekData.targets / teamTotals.targets) * 100;
                    weekData.rzTargetShare = teamTotals.rzTargets > 0 ? (weekData.rzTargets / teamTotals.rzTargets) * 100 : 0;
                });

                // Calculate aggregates across all weeks
                const allWeekData = weeks.map(w => playerData.weeks[w]);
                playerData.aggregate = {
                    gamesPlayed: weeks.length,
                    totalTargets: allWeekData.reduce((sum, w) => sum + w.targets, 0),
                    totalFpts: allWeekData.reduce((sum, w) => sum + w.fpts, 0),
                    totalRZTargets: allWeekData.reduce((sum, w) => sum + w.rzTargets, 0),
                    avgTargetsPerGame: allWeekData.reduce((sum, w) => sum + w.targets, 0) / weeks.length,
                    avgFptsPerTarget: allWeekData.reduce((sum, w) => sum + w.fpts, 0) / allWeekData.reduce((sum, w) => sum + w.targets, 0.0001),
                    avgTargetShare: allWeekData.reduce((sum, w) => sum + w.targetShare, 0) / weeks.length,
                    avgRZTargetShare: allWeekData.reduce((sum, w) => sum + w.rzTargetShare, 0) / weeks.length,
                    latestWeek: Math.max(...weeks)
                };
            });

            return wrsByWeek;
        }

        /**
         * Calculate evaluation metrics from raw weekly data
         * Creates per-week and aggregated metrics for RBs
         */
        function calculateRBEvaluationMetrics(weeklyData) {
            const rbsByWeek = {};
            const rbTeamTotals = {}; // Track team totals by week

            // First pass: organize by player and week
            weeklyData.forEach(row => {
                const week = parseInt(row.Week);
                const player = row.Player?.trim();
                const team = row.Team?.trim();

                if (!player || !week || week === 0) return;

                // Initialize player data
                if (!rbsByWeek[player]) {
                    rbsByWeek[player] = { team: team, weeks: {} };
                }

                // Extract metrics
                const rushAtt = parseFloat(row.ATT) || 0;
                const targets = parseFloat(row.TGT) || 0;
                const fpts = parseFloat(row.FPTS) || 0;
                const rzRushAtt = parseFloat(row.RZ_RUSH_ATT) || 0;
                const rzTargets = parseFloat(row['RZ TGT']) || parseFloat(row['RZ_TGT']) || 0;
                const opportunities = rushAtt + targets;
                const rzOpportunities = rzRushAtt + rzTargets;

                // Store week data
                rbsByWeek[player].weeks[week] = {
                    opportunities: opportunities,
                    fpts: fpts,
                    rzOpportunities: rzOpportunities,
                    team: team
                };

                // Track team totals
                const teamKey = `${team}-${week}`;
                if (!rbTeamTotals[teamKey]) {
                    rbTeamTotals[teamKey] = { opportunities: 0, rzOpportunities: 0 };
                }
                rbTeamTotals[teamKey].opportunities += opportunities;
                rbTeamTotals[teamKey].rzOpportunities += rzOpportunities;
            });

            // Second pass: calculate derived metrics
            Object.keys(rbsByWeek).forEach(player => {
                const playerData = rbsByWeek[player];
                const weeks = Object.keys(playerData.weeks).map(Number).sort((a, b) => a - b);

                weeks.forEach(week => {
                    const weekData = playerData.weeks[week];
                    // Calculate per-game and efficiency metrics
                    weekData.opportunitiesPerGame = weekData.opportunities;
                    weekData.rzOpportunitiesPerGame = weekData.rzOpportunities;
                    weekData.efficiency = weekData.opportunities > 0 ? weekData.fpts / weekData.opportunities : 0;
                    
                    // Add team totals to each week for share calculations
                    const teamKey = `${weekData.team}-${week}`;
                    if (rbTeamTotals[teamKey]) {
                        weekData.teamOpportunities = rbTeamTotals[teamKey].opportunities;
                        weekData.teamRZOpportunities = rbTeamTotals[teamKey].rzOpportunities;
                    }
                });

                // Calculate aggregates
                const allWeekData = weeks.map(w => playerData.weeks[w]);
                playerData.aggregate = {
                    gamesPlayed: weeks.length,
                    totalOpportunities: allWeekData.reduce((sum, w) => sum + w.opportunities, 0),
                    totalFpts: allWeekData.reduce((sum, w) => sum + w.fpts, 0),
                    totalRZOpportunities: allWeekData.reduce((sum, w) => sum + w.rzOpportunities, 0),
                    avgOpportunitiesPerGame: allWeekData.reduce((sum, w) => sum + w.opportunities, 0) / weeks.length,
                    avgRZOpportunitiesPerGame: allWeekData.reduce((sum, w) => sum + w.rzOpportunities, 0) / weeks.length,
                    avgEfficiency: allWeekData.reduce((sum, w) => sum + w.fpts, 0) / allWeekData.reduce((sum, w) => sum + w.opportunities, 0.0001),
                    latestWeek: Math.max(...weeks)
                };
            });

            return rbsByWeek;
        }

        /**
         * Get the data for a specific week or latest week
         */
        function getEvaluationWeekData(evaluationData, week = null) {
            const result = [];

            Object.keys(evaluationData).forEach(player => {
                const playerData = evaluationData[player];
                const targetWeek = week || playerData.aggregate.latestWeek;
                const weekData = playerData.weeks[targetWeek];

                if (weekData) {
                    result.push({
                        player: player,
                        team: playerData.team,
                        ...weekData,
                        aggregate: playerData.aggregate
                    });
                }
            });

            return result;
        }

        /**
         * Get all available weeks from evaluation data
         */
        function getAvailableWeeks(evaluationData) {
            const weeks = new Set();
            Object.values(evaluationData).forEach(playerData => {
                Object.keys(playerData.weeks).forEach(week => weeks.add(parseInt(week)));
            });
            return Array.from(weeks).sort((a, b) => a - b);
        }

        /* ========================================================================
         * v7: SEGMENT CALCULATION FUNCTIONS
         * Calculate rolling N-week segment averages from weekly data
         * ======================================================================== */

        /**
         * Calculate NON-OVERLAPPING 4-week segment averages
         * Segments: Weeks 1-4, 5-8, 9-12, 13-16, etc.
         * @param {Object} evaluationData - Player-keyed evaluation data (wrsByWeek or rbsByWeek format)
         * @param {number} segmentSize - Number of weeks per segment (default: 4)
         * @returns {Object} Segment data keyed by segment index
         */
        function calculateSegmentAverages(evaluationData, segmentSize = 4) {
            // Get all available weeks from all players
            const allWeeks = new Set();
            Object.values(evaluationData).forEach(playerData => {
                Object.keys(playerData.weeks).forEach(week => {
                    allWeeks.add(parseInt(week));
                });
            });

            const weeks = Array.from(allWeeks).sort((a, b) => a - b);

            if (weeks.length < segmentSize) {                return {};
            }

            const minWeek = weeks[0];
            const maxWeek = weeks[weeks.length - 1];

            // Calculate number of non-overlapping segments
            const numSegments = Math.ceil(maxWeek / segmentSize);
            const segmentData = {};

            // Create each non-overlapping segment
            for (let segmentIndex = 0; segmentIndex < numSegments; segmentIndex++) {
                const segmentStartWeek = (segmentIndex * segmentSize) + 1;
                const segmentEndWeek = Math.min(segmentStartWeek + segmentSize - 1, maxWeek);
                const segmentWeeks = [];

                // Build array of weeks in this segment
                for (let w = segmentStartWeek; w <= segmentEndWeek; w++) {
                    if (weeks.includes(w)) {
                        segmentWeeks.push(w);
                    }
                }

                if (segmentWeeks.length === 0) continue;

                // Calculate averages for each player in this segment
                const segmentPlayers = [];

                Object.keys(evaluationData).forEach(playerName => {
                    const playerData = evaluationData[playerName];
                    const playerWeeksInSegment = [];

                    // Collect this player's data for weeks in this segment
                    segmentWeeks.forEach(week => {
                        if (playerData.weeks[week]) {
                            playerWeeksInSegment.push({
                                week: week,
                                ...playerData.weeks[week]
                            });
                        }
                    });

                    // Skip if player has no data in this segment
                    if (playerWeeksInSegment.length === 0) return;

                    // Calculate averages
                    const avgPlayer = {
                        player: playerName,
                        team: playerData.team,
                        segmentWeeks: segmentWeeks,
                        weeksInSegment: playerWeeksInSegment.length
                    };

                    // Fields to average - check what fields exist
                    const fieldsToAverage = [
                        'targets', 'targetsPerGame', 'fpts', 'fptsPerTarget',
                        'targetShare', 'rzTargets', 'rzTargetShare',
                        'opportunities', 'rzOpportunities', 'efficiency'
                    ];

                    fieldsToAverage.forEach(field => {
                        const values = playerWeeksInSegment
                            .map(w => w[field])
                            .filter(v => v !== undefined && v !== null && !isNaN(v));

                        if (values.length > 0) {
                            avgPlayer[field] = values.reduce((sum, v) => sum + v, 0) / values.length;
                        }
                    });

                    // Use player's aggregate data (calculated across all weeks)
                    avgPlayer.aggregate = playerData.aggregate;

                    segmentPlayers.push(avgPlayer);
                });

                segmentData[segmentIndex] = segmentPlayers;
            }

            return segmentData;
        }

        /**
         * Get available segments from segment data
         * @param {Object} segmentData - Segment data object
         * @returns {Array<number>} Sorted array of segment indices
         */
        function getAvailableSegments(segmentData) {
            return Object.keys(segmentData)
                .map(Number)
                .filter(s => !isNaN(s))
                .sort((a, b) => a - b);
        }

        /**
         * Get data for a specific segment
         * @param {Object} segmentData - Segment data object
         * @param {number} segmentIndex - Segment index (can be fractional for interpolation)
         * @returns {Array} Player data for the segment
         */
        function getEvaluationSegmentData(segmentData, segmentIndex = null) {
            const segments = getAvailableSegments(segmentData);

            if (segments.length === 0) {
                return [];
            }

            // If no segment specified, return latest
            if (segmentIndex === null) {
                return segmentData[segments[segments.length - 1]] || [];
            }

            // If integer segment, return directly
            if (Number.isInteger(segmentIndex) && segmentData[segmentIndex]) {
                return segmentData[segmentIndex] || [];
            }

            // For fractional segments, return floor value (interpolation handled by animation)
            const floorIndex = Math.floor(segmentIndex);
            return segmentData[floorIndex] || [];
        }

        /**
         * Get the week range for a segment index
         * @param {Object} segmentData - Segment data object
         * @param {number} segmentIndex - Segment index
         * @returns {Array<number>} Array of week numbers in the segment
         */
        function getSegmentWeekRange(segmentData, segmentIndex) {
            const segmentPlayers = segmentData[segmentIndex];
            if (!segmentPlayers || segmentPlayers.length === 0) {
                return [];
            }

            // Get weeks from first player (all players in segment have same weeks)
            return segmentPlayers[0].segmentWeeks || [];
        }

        /**
         * Format segment label for display
         * @param {number} segmentFloat - Segment index (can be fractional)
         * @param {Object} segmentData - Segment data object
         * @returns {string} Formatted label (e.g., "Segments 1-4")
         */
        function formatSegmentLabel(segmentFloat, segmentData) {
            const segmentIndex = Math.floor(segmentFloat);
            const weeks = getSegmentWeekRange(segmentData, segmentIndex);

            if (weeks.length === 0) {
                return `Segment ${segmentIndex}`;
            }

            const firstWeek = weeks[0];
            const lastWeek = weeks[weeks.length - 1];

            if (firstWeek === lastWeek) {
                return `Week ${firstWeek}`;
            }

            return `Segments ${firstWeek}-${lastWeek}`;
        }

        /* End of v7 Segment Calculation Functions */

        // AI Analysis Generator
        function generatePlayerAnalysis(player) {
            const insights = [];

            // 1. Opportunity Share Analysis
            const oppShare = player.latestWeekOppShare;
            if (oppShare > 30) {
                insights.push(`<strong>High target</strong> with ${oppShare.toFixed(0)}% opportunity share - commanding a significant portion of team's offense.`);
            } else if (oppShare > 20) {
                insights.push(`<strong>Solid role</strong> with ${oppShare.toFixed(0)}% opportunity share - reliable contributor in the offense.`);
            } else if (oppShare > 10) {
                insights.push(`<strong>Limited role</strong> at ${oppShare.toFixed(0)}% opportunity share - may need more involvement for consistent production.`);
            } else {
                insights.push(`<strong>Minimal role</strong> with only ${oppShare.toFixed(0)}% opportunity share - volatility risk is high.`);
            }

            // 2. Performance vs Expected
            const overPerformances = player.weeks.filter(w => w.variance > 0).length;
            const totalWeeks = player.weeks.length;
            const overPerformRate = (overPerformances / totalWeeks) * 100;

            if (overPerformRate > 65) {
                insights.push(`<strong>Exceeding expectations</strong> - outperformed projections in ${overPerformances} of ${totalWeeks} games (${overPerformRate.toFixed(0)}%). High efficiency player.`);
            } else if (overPerformRate > 35) {
                insights.push(`<strong>Meeting expectations</strong> - balanced performance around projections (${overPerformRate.toFixed(0)}% over-performance rate).`);
            } else {
                insights.push(`<strong>Underperforming</strong> - only exceeded expectations in ${overPerformances} of ${totalWeeks} games. May be dealing with efficiency issues or tough matchups.`);
            }

            // 3. Volume vs Efficiency Analysis
            const avgVariance = player.weeks.reduce((sum, w) => sum + w.variance, 0) / totalWeeks;
            const totalOpps = player.position === 'WR' ? player.totalTargets : player.totalOpportunities;

            if (totalOpps > 70 && avgVariance < -1) {
                insights.push(`<strong>High-volume, low-efficiency</strong> - receiving significant opportunities (${totalOpps}) but averaging ${Math.abs(avgVariance).toFixed(1)} points below expected per game.`);
            } else if (totalOpps > 70 && avgVariance > 1) {
                insights.push(`<strong>High-volume, high-efficiency</strong> - elite combination of opportunity (${totalOpps}) and production (+${avgVariance.toFixed(1)} vs expected per game).`);
            } else if (totalOpps < 40 && avgVariance > 1) {
                insights.push(`<strong>Limited volume, high efficiency</strong> - making the most of opportunities with +${avgVariance.toFixed(1)} vs expected, but volume (${totalOpps}) caps upside.`);
            }

            // 4. Consistency Analysis
            const variances = player.weeks.map(w => w.variance);
            const stdDev = Math.sqrt(variances.reduce((sum, v) => sum + Math.pow(v, 2), 0) / totalWeeks);

            if (stdDev < 3) {
                insights.push(`<strong>High floor, stable producer</strong> - low variance (${stdDev.toFixed(1)}) suggests consistent weekly outcomes.`);
            } else if (stdDev > 6) {
                insights.push(`<strong>Boom-or-bust profile</strong> - high variance (${stdDev.toFixed(1)}) indicates wide range of weekly outcomes.`);
            }

            // 5. Trend Analysis
            if (player.oppChange > 5) {
                insights.push(`<strong>📈 Trending up</strong> - opportunity share increased by ${player.oppChange.toFixed(1)}% recently, suggesting growing role.`);
            } else if (player.oppChange < -5) {
                insights.push(`<strong>📉 Trending down</strong> - opportunity share decreased by ${Math.abs(player.oppChange).toFixed(1)}%, role may be shrinking.`);
            }

            return insights.join(' ');
        }

        // Load data from localStorage on page load
        function loadStoredData() {
            const storedWR = localStorage.getItem('wrData');
            const storedRB = localStorage.getItem('rbData');
            const storedTE = localStorage.getItem('teData');

            if (storedWR) {
                wrData = JSON.parse(storedWR);
            }
            if (storedRB) {
                rbData = JSON.parse(storedRB);
            }
            if (storedTE) {
                teData = JSON.parse(storedTE);
            }

            if (wrData || rbData || teData) {
                processAllData();
            }
        }

        // GitHub Data URLs - update these when you upload new CSVs
        const GITHUB_DATA_URLS = {
            wr: 'https://raw.githubusercontent.com/aryi3025/ffse-data/refs/heads/main/wr_data.csv',
            rb: 'https://raw.githubusercontent.com/aryi3025/ffse-data/refs/heads/main/rb_data.csv',
            te: 'https://raw.githubusercontent.com/aryi3025/ffse-data/refs/heads/main/te_data.csv'
        };

        // Fetch data from GitHub
        async function fetchDataFromGitHub() {
            try {
                LoadingScreen.updateProgress(10, 'Connecting to data source...');
                
                const [wrResponse, rbResponse, teResponse] = await Promise.all([
                    fetch(GITHUB_DATA_URLS.wr),
                    fetch(GITHUB_DATA_URLS.rb),
                    fetch(GITHUB_DATA_URLS.te)
                ]);

                LoadingScreen.updateProgress(30, 'Downloading player data...');

                if (!wrResponse.ok || !rbResponse.ok || !teResponse.ok) {
                    throw new Error('Failed to fetch data from GitHub');
                }

                const [wrText, rbText, teText] = await Promise.all([
                    wrResponse.text(),
                    rbResponse.text(),
                    teResponse.text()
                ]);

                LoadingScreen.updateProgress(50, 'Parsing CSV data...');

                // Parse WR data
                Papa.parse(wrText, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        wrData = results.data.filter(row => row.Player && row.Week);
                        localStorage.setItem('wrData', JSON.stringify(wrData));
                        LoadingScreen.updateProgress(60, 'Processing wide receivers...');
                        checkAndProcessData();
                    }
                });

                // Parse RB data
                Papa.parse(rbText, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        rbData = results.data.filter(row => row.Player && row.Week);
                        localStorage.setItem('rbData', JSON.stringify(rbData));
                        LoadingScreen.updateProgress(70, 'Processing running backs...');
                        checkAndProcessData();
                    }
                });

                // Parse TE data
                Papa.parse(teText, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        teData = results.data.filter(row => row.Player && row.Week);
                        localStorage.setItem('teData', JSON.stringify(teData));
                        LoadingScreen.updateProgress(75, 'Processing tight ends...');
                        checkAndProcessData();
                    }
                });

            } catch (error) {                // Fall back to localStorage data if fetch fails
                loadStoredData();
                hideLoadingIndicator();
                LoadingScreen.complete();
            }
        }

        // Fetch injury data from Sleeper API
        async function fetchInjuryData() {
            try {
                // Fetch all NFL players from Sleeper API
                const response = await fetch('https://api.sleeper.app/v1/players/nfl');
                
                if (!response.ok) {
                    throw new Error('Failed to fetch injury data from Sleeper');
                }

                const players = await response.json();
                
                // Process and store injury data
                injuryData = {};
                
                for (const playerId in players) {
                    const player = players[playerId];
                    
                    // Only store players with injury status
                    if (player.injury_status && player.injury_status !== 'Healthy') {
                        const fullName = `${player.first_name} ${player.last_name}`;
                        
                        injuryData[fullName] = {
                            status: player.injury_status, // 'Questionable', 'Doubtful', 'Out', 'IR', 'PUP', etc.
                            injuryBody: player.injury_body_part || 'Unknown',
                            team: player.team || 'FA',
                            position: player.position,
                            lastUpdate: Date.now()
                        };
                    }
                }

                // Cache injury data in localStorage (expires after 1 hour)
                localStorage.setItem('injuryData', JSON.stringify({
                    data: injuryData,
                    timestamp: Date.now()
                }));

                // Log IR/PUP players for debugging
                const irPlayers = Object.entries(injuryData)
                    .filter(([name, data]) => data.status === 'IR' || data.status === 'PUP')
                    .map(([name, data]) => `${name} (${data.status})`);
                console.log('IR/PUP players in injury data:', irPlayers);

                return injuryData;
                
            } catch (error) {
                // Try to use cached data if API fails
                const cached = localStorage.getItem('injuryData');
                if (cached) {
                    const parsedCache = JSON.parse(cached);
                    const cacheAge = Date.now() - parsedCache.timestamp;
                    
                    // Use cache if less than 1 hour old
                    if (cacheAge < 3600000) {
                        injuryData = parsedCache.data;
                        return injuryData;
                    }
                }
                
                return {};
            }
        }

        // Get injury info for a specific player
        function getPlayerInjuryStatus(playerName) {
            if (!injuryData || !injuryData[playerName]) {
                return null;
            }
            
            return injuryData[playerName];
        }

        // Format injury status for display
        function formatInjuryStatus(status) {
            const statusMap = {
                'Questionable': { badge: 'Q', class: 'questionable', fullText: 'Questionable' },
                'Doubtful': { badge: 'D', class: 'doubtful', fullText: 'Doubtful' },
                'Out': { badge: 'O', class: 'out', fullText: 'Out' },
                'IR': { badge: 'IR', class: 'ir', fullText: 'Injured Reserve' },
                'PUP': { badge: 'PUP', class: 'pup', fullText: 'Physically Unable to Perform' },
                'Suspended': { badge: 'SUS', class: 'suspended', fullText: 'Suspended' },
                'COV': { badge: 'COV', class: 'cov', fullText: 'COVID-19 List' }
            };
            
            return statusMap[status] || { badge: status, class: 'questionable', fullText: status };
        }

        // Check if all data is loaded and process
        let dataLoadedCount = 0;
        function checkAndProcessData() {
            dataLoadedCount++;
            if (dataLoadedCount >= 3) { // All three datasets loaded
                LoadingScreen.updateProgress(80, 'Calculating player metrics...');
                
                processAllData();
                hideLoadingIndicator();

                LoadingScreen.updateProgress(90, 'Rendering dashboard...');

                // Render dashboard if it's the active page
                setTimeout(() => {
                    const dashboardPage = document.getElementById('top-movers');
                    if (dashboardPage && dashboardPage.classList.contains('active')) {
                        renderDashboardCategories();
                        setTimeout(renderMiniScatterPlots, 100);
                    }
                    
                    LoadingScreen.updateProgress(95, 'Finalizing...');
                    
                    // Complete loading sequence
                    setTimeout(() => {
                        LoadingScreen.complete();
                    }, 300);
                }, 200);

                dataLoadedCount = 0; // Reset for next fetch
            }
        }

        function showLoadingIndicator() {
            const mainContent = document.querySelector('.main-content');
            const loadingDiv = document.createElement('div');
            loadingDiv.id = 'data-loading-indicator';
            loadingDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--bg-elevated);
                padding: 40px 60px;
                border-radius: 16px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
                text-align: center;
                z-index: 10000;
            `;
            loadingDiv.innerHTML = `
                <div style="font-size: 24px; font-weight: 700; color: var(--text-primary); margin-bottom: 12px;">
                    Loading Latest Data...
                </div>
                <div style="font-size: 14px; color: var(--text-secondary);">
                    Fetching player stats from database
                </div>
                <div style="margin-top: 20px;">
                    <div class="loading-spinner"></div>
                </div>
            `;
            document.body.appendChild(loadingDiv);

            // Add backdrop
            const backdrop = document.createElement('div');
            backdrop.id = 'loading-backdrop';
            backdrop.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 9999;
            `;
            document.body.appendChild(backdrop);
        }

        function hideLoadingIndicator() {
            const indicator = document.getElementById('data-loading-indicator');
            const backdrop = document.getElementById('loading-backdrop');
            if (indicator) indicator.remove();
            if (backdrop) backdrop.remove();
        }

        // CSV Upload Handlers
        function showUploadSection() {
            const hasData = wrData && rbData && teData;
            if (hasData) {
                if (confirm('You already have data loaded. Do you want to upload new data?')) {
                    document.getElementById('wr-file-input').click();
                }
            } else {
                document.getElementById('wr-file-input').click();
            }
        }

        function handleWRUpload(event) {
            const file = event.target.files[0];
            if (file) {
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        wrData = results.data.filter(row => row.Player && row.Week);
                        localStorage.setItem('wrData', JSON.stringify(wrData));

                        if (rbData) {
                            processAllData();
                        } else {
                            setTimeout(() => {
                                document.getElementById('rb-file-input').click();
                            }, 300);
                        }
                    }
                });
            }
        }

        function handleRBUpload(event) {
            const file = event.target.files[0];
            if (file) {
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        rbData = results.data.filter(row => row.Player && row.Week);
                        localStorage.setItem('rbData', JSON.stringify(rbData));
                        processAllData();
                    }
                });
            }
        }

        // 2. CALCULATIONS

        function processAllData() {
            // Debug: Log first WR row to see column names
            if (wrData && wrData.length > 0) {
                console.log('🔍 First WR row columns:', Object.keys(wrData[0]));
                console.log('🔍 Expected points columns:', {
                    STD: wrData[0].Exp_Ft_Points_STD,
                    HALF: wrData[0].Exp_Ft_Points_HALF,
                    PPR: wrData[0].Exp_Ft_Points || wrData[0].Exp_Ft_Points_PPR
                });
            }
            
            if (wrData) {
                aggregatedWRs = aggregatePlayerData(wrData, 'WR');
                // New: Calculate evaluation metrics for WRs
                evaluationDataWR = calculateWREvaluationMetrics(wrData);
            }
            if (rbData) {
                aggregatedRBs = aggregatePlayerData(rbData, 'RB');
                // New: Calculate evaluation metrics for RBs
                evaluationDataRB = calculateRBEvaluationMetrics(rbData);
            }
            if (teData) {
                aggregatedTEs = aggregatePlayerData(teData, 'TE');
            }

            // v7: Calculate 4-week rolling segment averages
            if (Object.keys(evaluationDataWR).length > 0) {
                segmentDataWR = calculateSegmentAverages(evaluationDataWR, 4);            }
            if (Object.keys(evaluationDataRB).length > 0) {
                segmentDataRB = calculateSegmentAverages(evaluationDataRB, 4);            }

            // Combine all players
            allPlayers = { ...aggregatedWRs, ...aggregatedRBs, ...aggregatedTEs };


            // Calculate ROS ranks
            calculateROSRanks();

            // Calculate momentum scores
            calculateAllMomentum();

            // Render all pages
            renderAllPages();

            // Update last updated date
            setLastUpdatedDate();
        }

        function aggregatePlayerData(weeklyData, position) {
            const players = {};
            let debugLogCount = 0; // For debug logging

            // Helper function to calculate adjusted fantasy points based on scoring format
            const getAdjustedFantasyPoints = (pprPoints, receptions) => {
                if (currentScoringFormat === 'std') {
                    // Standard: Remove all reception points
                    return pprPoints - receptions;
                } else if (currentScoringFormat === 'half') {
                    // Half-PPR: Remove half of reception points
                    return pprPoints - (0.5 * receptions);
                } else {
                    // PPR: Use points as-is
                    return pprPoints;
                }
            };

            weeklyData.forEach(row => {
                if (!row.Player || !row.Week) return;

                const id = `${row.Team}-${row.Player}`;

                if (!players[id]) {
                    players[id] = {
                        id: id,
                        name: row.Player,
                        team: row.Team,
                        position: position,
                        weeks: [],
                        totalPoints: 0,
                        gamesPlayed: 0,
                        totalTargets: 0,
                        totalOpportunities: 0,
                        rzOpportunities: 0,
                        avgPoints: 0,
                        latestWeek: 0,
                        latestWeekPoints: 0,
                        latestWeekOppShare: 0,
                        oppChange: 0,
                        // WR metrics
                        totalRec: 0,
                        totalAir: 0,
                        totalCatchable: 0,
                        totalYDS: 0,
                        totalYAC: 0,
                        catchRate: 0,
                        catchableCatchRate: 0,
                        racr: 0,
                        tgtPerGame: 0,
                        airYardsPerGame: 0,
                        yacPerRec: 0,
                        // TD stats (all positions)
                        totalRecTDs: 0,
                        totalRushTDs: 0,
                        rzTDs: 0,
                        // RB metrics
                        totalCarries: 0,
                        totalRushYards: 0,
                        totalRecYards: 0,
                        totalYBCON: 0,
                        totalYACON: 0
                    };
                }

                const weekNum = parseInt(row.Week);
                const fptsPPR = parseFloat(row.FPTS || row.Fpts) || 0; // Base PPR points from CSV
                const receptions = parseFloat(row.REC) || 0; // Get receptions for adjustment

                // Calculate adjusted fantasy points based on current scoring format
                const fpts = getAdjustedFantasyPoints(fptsPPR, receptions);

                // Get expected fantasy points and variance based on current scoring format
                let expFpts, variance;
                if (currentScoringFormat === 'std') {
                    expFpts = parseFloat(row.Exp_Ft_Points_STD) || 0;
                    variance = parseFloat(row.FPTS_Variance_STD) || 0;
                } else if (currentScoringFormat === 'half') {
                    expFpts = parseFloat(row.Exp_Ft_Points_HALF) || 0;
                    variance = parseFloat(row.FPTS_Variance_HALF) || 0;
                } else { // PPR (default)
                    expFpts = parseFloat(row.Exp_Ft_Points || row.Exp_Ft_Points_PPR) || 0;
                    variance = parseFloat(row.FPTS_Variance || row.FPTS_Variance_PPR) || 0;
                }
                
                // Debug: Log first player's expected points for verification
                if (position === 'WR' && weekNum === 1 && row.Player && debugLogCount < 1) {
                    console.log(`📌 ${position} ${row.Player} Week ${weekNum}:`, {
                        scoringFormat: currentScoringFormat,
                        expectedFpts: expFpts,
                        columns: {
                            STD: row.Exp_Ft_Points_STD,
                            HALF: row.Exp_Ft_Points_HALF,
                            PPR: row.Exp_Ft_Points || row.Exp_Ft_Points_PPR
                        }
                    });
                    debugLogCount++;
                }


                const weekData = {
                    week: weekNum,
                    fpts: fpts, // Adjusted fantasy points
                    fptsPPR: fptsPPR, // Store original PPR points for reference
                    receptions: receptions, // Store receptions for future adjustments
                    expectedFpts: expFpts,
                    variance: variance
                };

                if (position === 'WR' || position === 'TE') {
                    const tgt = parseFloat(row.TGT) || 0;
                    const rzTgt = parseFloat(row['RZ TGT']) || parseFloat(row.RZ_TGT) || 0;
                    const teamShare = parseFloat(row['% TM']) || 0;
                    const usageShare = (parseFloat(row.Usage_Share) || 0) * 100; // Convert decimal to percentage
                    const rzShare = (parseFloat(row.RZ_Share) || 0) * 100; // Convert decimal to percentage
                    const rec = parseFloat(row.REC) || 0;
                    const air = parseFloat(row.AIR) || 0;
                    const catchable = parseFloat(row.CATCHABLE) || 0;
                    // For TEs, yards might be in YDS column instead of REC_YDS
                    const yds = parseFloat(row.REC_YDS) || parseFloat(row.YDS) || 0;
                    const yac = parseFloat(row.YAC) || 0;
                    const recTD = parseFloat(row.REC_TD) || 0;
                    const rushTD = parseFloat(row.RUSH_TD) || 0;
                    // RZ TDs = RZ_REC_TD + RZ_RUSH_TD
                    const rzRecTD = parseFloat(row.RZ_REC_TD) || 0;
                    const rzRushTD = parseFloat(row.RZ_RUSH_TD) || 0;
                    const rzTD = rzRecTD + rzRushTD;
                    const rushYds = parseFloat(row.RUSH_YDS) || 0;
                    const carries = parseFloat(row.CARRIES) || 0;

                    weekData.targets = tgt;
                    weekData.rzTargets = rzTgt;
                    weekData.teamShare = teamShare;
                    weekData.usageShare = usageShare;
                    weekData.rzShare = rzShare;

                    players[id].totalTargets += tgt;
                    players[id].rzOpportunities += rzTgt;
                    players[id].totalRec += rec;
                    players[id].totalAir += air;
                    players[id].totalCatchable += catchable;
                    players[id].totalYDS += yds;
                    players[id].totalYAC += yac;
                    players[id].totalRecTDs += recTD;
                    players[id].totalRushTDs += rushTD;
                    players[id].rzTDs += rzTD;
                    players[id].totalRushYards += rushYds;
                    players[id].totalCarries += carries;
                } else {
                    const rbOpp = parseFloat(row['RB Opp']) || 0;
                    const rzRushAtt = parseFloat(row['RZ_RUSH_ATT']) || 0;
                    const rzTgt = parseFloat(row['RZ TGT']) || parseFloat(row['RZ_TGT']) || 0;
                    const rushAtt = parseFloat(row.ATT) || 0;
                    const tgt = parseFloat(row.TGT) || 0;
                    const usageShare = (parseFloat(row.Usage_Share) || 0) * 100; // Convert decimal to percentage
                    const rzShare = (parseFloat(row.RZ_Share) || 0) * 100; // Convert decimal to percentage
                    const rushYds = parseFloat(row.YDS) || 0;
                    const recYds = parseFloat(row.REC_YDS) || 0;
                    const ybcon = parseFloat(row.YBCON) || 0;
                    const yacon = parseFloat(row.YACON) || 0;
                    const rec = parseFloat(row.REC) || 0;
                    const recTD = parseFloat(row.REC_TD) || 0;
                    const rushTD = parseFloat(row.RUSH_TD) || 0;
                    // RZ TDs = RZ_REC_TD + RZ_RUSH_TD
                    const rzRecTD = parseFloat(row.RZ_REC_TD) || 0;
                    const rzRushTD = parseFloat(row.RZ_RUSH_TD) || 0;
                    const rzTD = rzRecTD + rzRushTD;

                    weekData.opportunities = rbOpp;
                    weekData.rzOpportunities = rzRushAtt + rzTgt; // Include both RZ rush attempts and RZ targets
                    weekData.rushAttempts = rushAtt;
                    weekData.targets = tgt;
                    weekData.usageShare = usageShare;
                    weekData.rzShare = rzShare;

                    players[id].totalOpportunities += rbOpp;
                    players[id].rzOpportunities += (rzRushAtt + rzTgt); // Include both RZ rush attempts and RZ targets
                    players[id].totalCarries += rushAtt;
                    players[id].totalTargets += tgt;
                    players[id].totalRushYards += rushYds;
                    players[id].totalRecYards += recYds;
                    players[id].totalYBCON += ybcon;
                    players[id].totalYACON += yacon;
                    players[id].totalRec += rec;
                    players[id].totalRecTDs += recTD;
                    players[id].totalRushTDs += rushTD;
                    players[id].rzTDs += rzTD;
                }

                players[id].weeks.push(weekData);
                players[id].totalPoints += fpts;
                players[id].gamesPlayed++;

                if (weekNum > players[id].latestWeek) {
                    players[id].latestWeek = weekNum;
                    players[id].latestWeekPoints = fpts;
                    if (position === 'WR') {
                        players[id].latestWeekOppShare = parseFloat(row['% TM']) || 0;
                    }
                }
            });

            // Calculate averages and opportunity shares for RBs
            Object.values(players).forEach(player => {
                player.avgPoints = player.gamesPlayed > 0 ? player.totalPoints / player.gamesPlayed : 0;

                // Calculate percentage over expected
                const totalExpected = player.weeks.reduce((sum, w) => sum + w.expectedFpts, 0);
                player.pctOverExpected = totalExpected > 0 ? ((player.totalPoints - totalExpected) / totalExpected) * 100 : 0;

                // Calculate team RZ opportunities for RZ Opp Share stat
                const teamRzOpps = weeklyData
                    .filter(row => row.Team === player.team)
                    .reduce((sum, row) => {
                        if (position === 'WR' || position === 'TE') {
                            return sum + (parseFloat(row['RZ TGT']) || parseFloat(row.RZ_TGT) || 0);
                        } else { // RB
                            const rzRushAtt = parseFloat(row['RZ_RUSH_ATT']) || 0;
                            const rzTgt = parseFloat(row['RZ TGT']) || parseFloat(row['RZ_TGT']) || 0;
                            return sum + rzRushAtt + rzTgt;
                        }
                    }, 0);
                player.teamRzOpportunities = teamRzOpps;

                // Calculate new WR/TE metrics
                if ((position === 'WR' || position === 'TE') && player.gamesPlayed >= 3) {
                    player.catchRate = player.totalTargets > 0 ? (player.totalRec / player.totalTargets) * 100 : 0;
                    player.catchableCatchRate = player.totalCatchable > 0 ? (player.totalRec / player.totalCatchable) * 100 : 0;
                    player.racr = player.totalAir > 0 ? (player.totalYDS / player.totalAir) * 100 : 0;
                    player.tgtPerGame = player.gamesPlayed > 0 ? player.totalTargets / player.gamesPlayed : 0;
                    player.airYardsPerGame = player.gamesPlayed > 0 ? player.totalAir / player.gamesPlayed : 0;
                    player.yacPerRec = player.totalRec > 0 ? player.totalYAC / player.totalRec : 0;
                }

                // Sort weeks by week number
                player.weeks.sort((a, b) => a.week - b.week);

                if (position === 'RB') {
                    // Calculate RB opportunity share for latest week
                    player.latestWeekOppShare = calculateRBTeamShare(player, weeklyData);
                }

                // Calculate opportunity change
                player.oppChange = calculateOppChange(player);
            });

            return players;
        }

        function calculateRBTeamShare(player, weeklyData) {
            if (player.weeks.length === 0) return 0;

            const latestWeek = player.latestWeek;
            const teamData = weeklyData.filter(row =>
                row.Team === player.team &&
                parseInt(row.Week) === latestWeek &&
                row.Player &&
                parseFloat(row['RB Opp']) > 0
            );

            const teamTotal = teamData.reduce((sum, row) => sum + (parseFloat(row['RB Opp']) || 0), 0);
            const playerOpp = teamData.find(row => row.Player === player.name);
            const playerTotal = playerOpp ? parseFloat(playerOpp['RB Opp']) || 0 : 0;

            return teamTotal > 0 ? (playerTotal / teamTotal) * 100 : 0;
        }

        function calculateOppChange(player) {
            if (player.weeks.length < 2) return 0;

            const lastWeek = player.weeks[player.weeks.length - 1];
            const prevWeek = player.weeks[player.weeks.length - 2];

            let lastShare = 0;
            let prevShare = 0;

            if (player.position === 'WR') {
                lastShare = lastWeek.teamShare || 0;
                prevShare = prevWeek.teamShare || 0;
            } else {
                // For RB, we'd need to calculate team share, simplified here
                lastShare = player.latestWeekOppShare;
                // Approximate previous week share
                prevShare = lastShare;
            }

            return lastShare - prevShare;
        }

        function calculateROSRanks() {
            const allPlayersList = Object.values(allPlayers);
            allPlayersList.sort((a, b) => b.avgPoints - a.avgPoints);

            allPlayersList.forEach((player, index) => {
                player.rosRank = index + 1;
            });
        }

        // Calculate momentum scores for all players
        function calculateMomentum(player, position) {
            // Need at least 4 weeks of data
            if (!player.weeks || player.weeks.length < 4) {
                return {
                    score: 0,
                    isValid: false,
                    direction: 'neutral'
                };
            }

            const sortedWeeks = [...player.weeks].sort((a, b) => a.week - b.week);
            const totalWeeks = sortedWeeks.length;

            // Get last 3 weeks and previous 3 weeks
            const currentWindow = sortedWeeks.slice(-3);
            const previousWindow = sortedWeeks.slice(-6, -3);

            // Need both windows to have data
            if (currentWindow.length < 3 || previousWindow.length < 3) {
                return {
                    score: 0,
                    isValid: false,
                    direction: 'neutral'
                };
            }

            // Helper function to calculate average
            const avg = (arr, key) => {
                const sum = arr.reduce((s, w) => s + (w[key] || 0), 0);
                return sum / arr.length;
            };

            // Helper function to calculate % change
            const pctChange = (current, previous) => {
                if (previous === 0) return current > 0 ? 100 : 0;
                return ((current - previous) / previous) * 100;
            };

            let momentum = 0;

            if (position === 'WR') {
                // WR Momentum = 0.5 * ΔTargets% + 0.3 * ΔReceptions% + 0.2 * ΔFantasyPoints%
                const currentTargets = avg(currentWindow, 'targets');
                const previousTargets = avg(previousWindow, 'targets');
                const targetsChange = pctChange(currentTargets, previousTargets);

                const currentReceptions = avg(currentWindow, 'receptions');
                const previousReceptions = avg(previousWindow, 'receptions');
                const receptionsChange = pctChange(currentReceptions, previousReceptions);

                const currentPoints = avg(currentWindow, 'fpts');
                const previousPoints = avg(previousWindow, 'fpts');
                const pointsChange = pctChange(currentPoints, previousPoints);

                momentum = (0.5 * targetsChange) + (0.3 * receptionsChange) + (0.2 * pointsChange);

            } else if (position === 'RB') {
                // RB Momentum = 0.5 * ΔRushAttempts% + 0.4 * ΔRushYards% + 0.1 * ΔFantasyPoints%
                const currentRushAttempts = avg(currentWindow, 'rushAttempts');
                const previousRushAttempts = avg(previousWindow, 'rushAttempts');
                const rushAttemptsChange = pctChange(currentRushAttempts, previousRushAttempts);

                const currentRushYards = currentWindow.reduce((sum, w) => {
                    // Rush yards might be stored differently, need to check
                    return sum + (w.rushYards || 0);
                }, 0) / currentWindow.length;

                const previousRushYards = previousWindow.reduce((sum, w) => {
                    return sum + (w.rushYards || 0);
                }, 0) / previousWindow.length;

                const rushYardsChange = pctChange(currentRushYards, previousRushYards);

                const currentPoints = avg(currentWindow, 'fpts');
                const previousPoints = avg(previousWindow, 'fpts');
                const pointsChange = pctChange(currentPoints, previousPoints);

                momentum = (0.5 * rushAttemptsChange) + (0.4 * rushYardsChange) + (0.1 * pointsChange);
            }

            // Determine direction
            let direction = 'neutral';
            if (momentum > 5) {
                direction = 'up';
            } else if (momentum < -5) {
                direction = 'down';
            }

            return {
                score: momentum,
                isValid: true,
                direction: direction
            };
        }

        // Calculate momentum for all players
        function calculateAllMomentum() {
            // WRs
            Object.values(aggregatedWRs).forEach(player => {
                const momentum = calculateMomentum(player, 'WR');
                player.momentum = momentum;
            });

            // RBs
            Object.values(aggregatedRBs).forEach(player => {
                const momentum = calculateMomentum(player, 'RB');
                player.momentum = momentum;
            });

            // TEs (use WR momentum calculation since they're pass catchers)
            Object.values(aggregatedTEs).forEach(player => {
                const momentum = calculateMomentum(player, 'WR');
                player.momentum = momentum;
            });        }

        // Get top movers (risers and fallers) for a position
        function getTopMovers(position, count = 5) {
            const players = position === 'WR' ? Object.values(aggregatedWRs) :
                           position === 'RB' ? Object.values(aggregatedRBs) :
                           Object.values(aggregatedTEs);

            // Filter for players with valid momentum and enough games
            const validPlayers = players.filter(p =>
                p.momentum &&
                p.momentum.isValid &&
                p.gamesPlayed >= 6 // Need at least 6 weeks for momentum calculation
            );

            // Sort by momentum score
            const sorted = [...validPlayers].sort((a, b) => b.momentum.score - a.momentum.score);

            // Get top risers (highest positive momentum)
            const risers = sorted.filter(p => p.momentum.score > 0).slice(0, count);

            // Get top fallers (most negative momentum)
            const fallers = sorted.filter(p => p.momentum.score < 0).reverse().slice(0, count);

            return { risers, fallers };
        }

        // Render top movers widgets for a position
        function renderTopMoversWidgets(position, containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;

            const { risers, fallers } = getTopMovers(position, 8);

            let html = '<div class="top-movers-container">';

            // Risers widget
            if (risers.length > 0) {
                const methodologyText = position === 'WR' || position === 'TE'
                    ? 'Each player receives a <i><strong>Momentum Score</strong></i> by comparing their last 3 weeks to their previous 3 weeks. The formula weights: 50% change in targets per game + 30% change in receptions per game + 20% change in fantasy points per game. The percentage shown is the overall weighted <i><strong>Momentum Score</strong></i> - positive values indicate improvement, negative values indicate decline. Players must have at least 6 weeks of data to qualify.'
                    : 'Each player receives a <i><strong>Momentum Score</strong></i> by comparing their last 3 weeks to their previous 3 weeks. The formula weights: 50% change in rush attempts per game + 40% change in rush yards per game + 10% change in fantasy points per game. The percentage shown is the overall weighted <i><strong>Momentum Score</strong></i> - positive values indicate improvement, negative values indicate decline. Players must have at least 6 weeks of data to qualify.';

                html += `
                    <div class="top-movers-widget risers">
                        <div class="top-movers-header">
                            <div class="top-movers-header-left">
                                <span class="top-movers-title">Top Movers Up</span>
                                <div class="ticker-info-icon" onclick="event.stopPropagation(); toggleTickerTooltip(event)">
                                    i
                                    <div class="ticker-tooltip">
                                        ${methodologyText}
                                    </div>
                                </div>
                            </div>

                        </div>
                        <div class="top-movers-content" id="risers-content-${position}">
                            <div class="top-movers-list" id="risers-list-${position}">
                `;

                risers.forEach((player, index) => {
                    const escapedId = player.id.replace(/'/g, "\\'");
                    const hiddenClass = index >= 4 ? 'top-mover-hidden' : '';
                    html += `
                        <div class="top-mover-item ${hiddenClass}" onclick="openPlayerModal('${escapedId}')">
                            <div class="top-mover-rank">${index + 1}</div>
                            <div class="top-mover-arrow">↑</div>
                            <div class="top-mover-info">
                                <div class="top-mover-name">${player.name}</div>
                                <div class="top-mover-team">${player.team}</div>
                            </div>
                            <div class="top-mover-score">+${player.momentum.score.toFixed(1)}%</div>
                        </div>
                    `;
                });

                html += `
                        </div>
                        ${risers.length > 4 ? `<button class="top-movers-expand-btn" onclick="event.stopPropagation(); toggleTopMovers('risers-list-${position}', this)">Show More (4 more)</button>` : ''}
                        </div>
                    </div>
                `;
            }

            // Fallers widget
            if (fallers.length > 0) {
                const methodologyText = position === 'WR' || position === 'TE'
                    ? 'Each player receives a <i><strong>Momentum Score</strong></i> by comparing their last 3 weeks to their previous 3 weeks. The formula weights: 50% change in targets per game + 30% change in receptions per game + 20% change in fantasy points per game. The percentage shown is the overall weighted <i><strong>Momentum Score</strong></i> - positive values indicate improvement, negative values indicate decline. Players must have at least 6 weeks of data to qualify.'
                    : 'Each player receives a <i><strong>Momentum Score</strong></i> by comparing their last 3 weeks to their previous 3 weeks. The formula weights: 50% change in rush attempts per game + 40% change in rush yards per game + 10% change in fantasy points per game. The percentage shown is the overall weighted <i><strong>Momentum Score</strong></i> - positive values indicate improvement, negative values indicate decline. Players must have at least 6 weeks of data to qualify.';

                html += `
                    <div class="top-movers-widget fallers">
                        <div class="top-movers-header">
                            <div class="top-movers-header-left">
                                <span class="top-movers-title">Top Movers Down</span>
                                <div class="ticker-info-icon" onclick="event.stopPropagation(); toggleTickerTooltip(event)">
                                    i
                                    <div class="ticker-tooltip">
                                        ${methodologyText}
                                    </div>
                                </div>
                            </div>

                        </div>
                        <div class="top-movers-content" id="fallers-content-${position}">
                            <div class="top-movers-list" id="fallers-list-${position}">
                `;

                fallers.forEach((player, index) => {
                    const escapedId = player.id.replace(/'/g, "\\'");
                    const hiddenClass = index >= 4 ? 'top-mover-hidden' : '';
                    html += `
                        <div class="top-mover-item ${hiddenClass}" onclick="openPlayerModal('${escapedId}')">
                            <div class="top-mover-rank">${index + 1}</div>
                            <div class="top-mover-arrow">↓</div>
                            <div class="top-mover-info">
                                <div class="top-mover-name">${player.name}</div>
                                <div class="top-mover-team">${player.team}</div>
                            </div>
                            <div class="top-mover-score">${player.momentum.score.toFixed(1)}%</div>
                        </div>
                    `;
                });

                html += `
                        </div>
                        ${fallers.length > 4 ? `<button class="top-movers-expand-btn" onclick="event.stopPropagation(); toggleTopMovers('fallers-list-${position}', this)">Show More (4 more)</button>` : ''}
                        </div>
                    </div>
                `;
            }

            html += '</div>';
            container.innerHTML = html;
        }

        // Toggle top movers visibility
        function toggleTopMovers(listId, button) {
            const list = document.getElementById(listId);
            const hiddenItems = list.querySelectorAll('.top-mover-hidden');
            const isExpanded = button.textContent.includes('Show Less');

            if (isExpanded) {
                hiddenItems.forEach(item => item.style.display = 'none');
                button.textContent = 'Show More (4 more)';
            } else {
                hiddenItems.forEach(item => item.style.display = 'flex');
                button.textContent = 'Show Less';
            }
        }

        // Toggle tier collapse/expand
        function toggleTierCollapse(headerElement) {
            const icon = headerElement.querySelector('.tier-collapse-icon');
            const container = headerElement.nextElementSibling;

            if (icon && container) {
                // Toggle collapsed class
                icon.classList.toggle('collapsed');
                container.classList.toggle('collapsed');

                // Set max-height for smooth animation
                if (!container.classList.contains('collapsed')) {
                    container.style.maxHeight = container.scrollHeight + 'px';
                } else {
                    container.style.maxHeight = '0';
                }
            }
        }

        // Expand all tiers (called on page navigation and refresh)
        function expandAllTiers() {
            // Only expand tiers on the currently active page
            const activePage = document.querySelector('.page.active');
            if (!activePage) {                return;
            }

            const icons = activePage.querySelectorAll('.tier-collapse-icon');
            const containers = activePage.querySelectorAll('.tier-cards-container');
            icons.forEach(icon => {
                icon.classList.remove('collapsed');
            });

            containers.forEach(container => {
                container.classList.remove('collapsed');
                // Set a large max-height to ensure full visibility
                container.style.maxHeight = '100000px';
            });
        }

        // 3. UI RENDERING

        // Render mini sparkline chart
        function renderMiniChart(canvasId, player) {
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;

            const actuals = player.weeks.map(w => w.fpts);
            const expected = player.weeks.map(w => w.expectedFpts);

            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: player.weeks.map(w => w.week),
                    datasets: [
                        {
                            data: actuals,
                            borderColor: '#30d158',
                            borderWidth: 2.5, // Thicker trail for better visibility
                            fill: false,
                            pointRadius: 0,
                            tension: 0.3
                        },
                        {
                            data: expected,
                            borderColor: '#8e8e93',
                            borderWidth: 1,
                            borderDash: [2, 2],
                            fill: false,
                            pointRadius: 0,
                            tension: 0.3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    },
                    scales: {
                        x: { display: false },
                        y: { display: false }
                    },
                    interaction: { mode: null }
                }
            });
        }

        function renderAllPages() {
            renderTicker();
            renderTeamsTicker();
            renderInsightsTicker();
            renderAnalyticsTicker();
            renderDashboardCategories();
            renderStatOfTheWeek();
            renderPRSLeaderboard('WR');
            renderWRPlayerCards();
            renderRBPlayerCards();
            renderTEPlayerCards();
            renderTeamsPage();
            renderScatterPlots();

            // Render top movers widgets
            renderTopMoversWidgets('WR', 'wr-top-movers-sidebar');
            renderTopMoversWidgets('RB', 'rb-top-movers-sidebar');
            renderTopMoversWidgets('TE', 'te-top-movers-sidebar');

            // Setup dashboard trend scrubbers
            setupDashboardTrendScrubbers();

            // Initialize Advanced Analytics
            initializeAdvancedAnalytics();
            
            // Initialize Analytics Dashboard
            initializeAnalyticsDashboard();

            // Note: Trend animations for WR/RB eval charts are lazy loaded when user clicks Advanced Analytics tab
        }

        function renderTicker() {
            // WR Ticker - by avg points
            const wrTickerTrack = document.getElementById('wr-ticker-track');
            const topWRs = Object.values(aggregatedWRs)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 50);

            const wrTickerHTML = topWRs.map((player, index) => {
                // Calculate week-over-week team share change
                let shareChange = 0;
                if (player.weeks.length >= 2) {
                    // Get last two weeks where player had targets
                    const weeksWithTargets = player.weeks.filter(w => w.teamShare && w.teamShare > 0);
                    if (weeksWithTargets.length >= 2) {
                        const latestWeek = weeksWithTargets[weeksWithTargets.length - 1];
                        const previousWeek = weeksWithTargets[weeksWithTargets.length - 2];
                        shareChange = latestWeek.teamShare - previousWeek.teamShare;
                    }
                }

                const changeClass = shareChange >= 0 ? 'positive' : 'negative';
                const changeSymbol = shareChange >= 0 ? '▲' : '▼';
                const changePct = Math.abs(shareChange).toFixed(1);
                const rank = index + 1;

                return `
                    <div class="ticker-item">
                        <span class="player-name">#${rank} ${player.name}</span>
                        <span class="avg-pts">${player.avgPoints.toFixed(1)}</span>
                        <span class="change ${changeClass}">${changeSymbol} ${changePct}% tgt share</span>
                    </div>
                `;
            }).join('');

            wrTickerTrack.innerHTML = wrTickerHTML + wrTickerHTML;

            // RB Ticker - by avg points
            const rbTickerTrack = document.getElementById('rb-ticker-track');
            const topRBs = Object.values(aggregatedRBs)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 50);

            const rbTickerHTML = topRBs.map((player, index) => {
                // Calculate week-over-week RB opp share change
                let shareChange = 0;
                if (player.weeks.length >= 2) {
                    // Get last two weeks with opportunities
                    const weeksWithOpps = player.weeks.filter(w => w.opportunities && w.opportunities > 0);
                    if (weeksWithOpps.length >= 2) {
                        // Calculate share for each week
                        const latestWeek = weeksWithOpps[weeksWithOpps.length - 1];
                        const previousWeek = weeksWithOpps[weeksWithOpps.length - 2];

                        // Get team totals for those weeks
                        const latestTeamRows = rbData.filter(row =>
                            row.Team === player.team &&
                            parseInt(row.Week) === latestWeek.week &&
                            parseFloat(row['RB Opp']) > 0
                        );
                        const prevTeamRows = rbData.filter(row =>
                            row.Team === player.team &&
                            parseInt(row.Week) === previousWeek.week &&
                            parseFloat(row['RB Opp']) > 0
                        );

                        const latestTeamTotal = latestTeamRows.reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);
                        const prevTeamTotal = prevTeamRows.reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);

                        const latestShare = latestTeamTotal > 0 ? (latestWeek.opportunities / latestTeamTotal) * 100 : 0;
                        const prevShare = prevTeamTotal > 0 ? (previousWeek.opportunities / prevTeamTotal) * 100 : 0;

                        shareChange = latestShare - prevShare;
                    }
                }

                const changeClass = shareChange >= 0 ? 'positive' : 'negative';
                const changeSymbol = shareChange >= 0 ? '▲' : '▼';
                const changePct = Math.abs(shareChange).toFixed(1);
                const rank = index + 1;

                return `
                    <div class="ticker-item">
                        <span class="player-name">#${rank} ${player.name}</span>
                        <span class="avg-pts">${player.avgPoints.toFixed(1)}</span>
                        <span class="change ${changeClass}">${changeSymbol} ${changePct}% opp share</span>
                    </div>
                `;
            }).join('');

            rbTickerTrack.innerHTML = rbTickerHTML + rbTickerHTML;

            // TE Ticker - by avg points (top 24)
            const teTickerTrack = document.getElementById('te-ticker-track');
            const topTEs = Object.values(aggregatedTEs)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 24);

            const teTickerHTML = topTEs.map((player, index) => {
                // Calculate week-over-week target share change (like WRs)
                let shareChange = 0;
                if (player.weeks.length >= 2) {
                    // Get last two weeks where player had targets
                    const weeksWithTargets = player.weeks.filter(w => w.teamShare && w.teamShare > 0);
                    if (weeksWithTargets.length >= 2) {
                        const latestWeek = weeksWithTargets[weeksWithTargets.length - 1];
                        const previousWeek = weeksWithTargets[weeksWithTargets.length - 2];
                        shareChange = latestWeek.teamShare - previousWeek.teamShare;
                    }
                }

                const changeClass = shareChange >= 0 ? 'positive' : 'negative';
                const changeSymbol = shareChange >= 0 ? '▲' : '▼';
                const changePct = Math.abs(shareChange).toFixed(1);
                const rank = index + 1;

                return `
                    <div class="ticker-item">
                        <span class="player-name">#${rank} ${player.name}</span>
                        <span class="avg-pts">${player.avgPoints.toFixed(1)}</span>
                        <span class="change ${changeClass}">${changeSymbol} ${changePct}% tgt share</span>
                    </div>
                `;
            }).join('');

            teTickerTrack.innerHTML = teTickerHTML + teTickerHTML;
        }

        function renderTeamsTicker() {
            const teamsTickerTrack = document.getElementById('teams-ticker-track');
            if (!teamsTickerTrack) {                return;
            }
            if (!wrData || !rbData) {                return;
            }
            // Get the latest week from the data
            const allWeeks = [...new Set(wrData.map(row => parseInt(row.Week)))];
            const latestWeek = Math.max(...allWeeks);
            const previousWeek = latestWeek - 1;
            // Aggregate team data by week
            const teamWeeklyData = {};

            // Process WR data
            wrData.forEach(row => {
                const team = row.Team;
                const week = parseInt(row.Week);
                const points = parseFloat(row.FPTS || row.Fpts) || 0; // Handle both FPTS and Fpts

                if (team === 'FA' || !team) return;

                if (!teamWeeklyData[team]) {
                    teamWeeklyData[team] = {
                        team: team,
                        weeks: {}
                    };
                }

                if (!teamWeeklyData[team].weeks[week]) {
                    teamWeeklyData[team].weeks[week] = { wrPoints: 0, rbPoints: 0, tePoints: 0, totalPoints: 0 };
                }

                teamWeeklyData[team].weeks[week].wrPoints += points;
                teamWeeklyData[team].weeks[week].totalPoints += points;
            });
            // Process RB data
            rbData.forEach(row => {
                const team = row.Team;
                const week = parseInt(row.Week);
                const points = parseFloat(row.FPTS || row.Fpts) || 0; // Handle both FPTS and Fpts

                if (team === 'FA' || !team) return;

                if (!teamWeeklyData[team]) {
                    teamWeeklyData[team] = {
                        team: team,
                        weeks: {}
                    };
                }

                if (!teamWeeklyData[team].weeks[week]) {
                    teamWeeklyData[team].weeks[week] = { wrPoints: 0, rbPoints: 0, tePoints: 0, totalPoints: 0 };
                }

                teamWeeklyData[team].weeks[week].rbPoints += points;
                teamWeeklyData[team].weeks[week].totalPoints += points;
            });
            // Process TE data
            if (teData) {
                teData.forEach(row => {
                    const team = row.Team;
                    const week = parseInt(row.Week);
                    const points = parseFloat(row.FPTS || row.Fpts) || 0; // Handle both FPTS and Fpts

                    if (team === 'FA' || !team) return;

                    if (!teamWeeklyData[team]) {
                        teamWeeklyData[team] = {
                            team: team,
                            weeks: {}
                        };
                    }

                    if (!teamWeeklyData[team].weeks[week]) {
                        teamWeeklyData[team].weeks[week] = { wrPoints: 0, rbPoints: 0, tePoints: 0, totalPoints: 0 };
                    }

                    teamWeeklyData[team].weeks[week].tePoints += points;
                    teamWeeklyData[team].weeks[week].totalPoints += points;
                });            }

            // Calculate totals and changes for latest week
            const teamsData = Object.values(teamWeeklyData).map(teamData => {
                const latestWeekData = teamData.weeks[latestWeek] || { wrPoints: 0, rbPoints: 0, tePoints: 0, totalPoints: 0 };
                const previousWeekData = teamData.weeks[previousWeek] || { wrPoints: 0, rbPoints: 0, tePoints: 0, totalPoints: 0 };

                // Calculate percentage change
                let percentChange = 0;
                if (previousWeekData.totalPoints > 0) {
                    percentChange = ((latestWeekData.totalPoints - previousWeekData.totalPoints) / previousWeekData.totalPoints) * 100;
                } else if (latestWeekData.totalPoints > 0) {
                    percentChange = 100; // If no previous week data but has current, show +100%
                }

                return {
                    team: teamData.team,
                    wrPoints: latestWeekData.wrPoints,
                    rbPoints: latestWeekData.rbPoints,
                    tePoints: latestWeekData.tePoints,
                    totalPoints: latestWeekData.totalPoints,
                    percentChange: percentChange,
                    previousTotal: previousWeekData.totalPoints
                };
            });
            // Sort by total points for latest week
            const topTeams = teamsData
                .sort((a, b) => b.totalPoints - a.totalPoints)
                .slice(0, 32); // All teams

            const teamsTickerHTML = topTeams.map((team, index) => {
                const rank = index + 1;
                const teamColor = teamColors[team.team] || '#0a84ff';
                const changeClass = team.percentChange >= 0 ? 'positive' : 'negative';
                const changeSymbol = team.percentChange >= 0 ? '▲' : '▼';

                return `
                    <div class="ticker-item">
                        <span style="font-weight: 700; color: white;">#${rank}</span>
                        <span class="player-name">${team.team}</span>
                        <span class="avg-pts">${team.totalPoints.toFixed(1)} pts</span>
                        <span style="color: var(--text-secondary); font-size: 11px;">
                            WR: ${team.wrPoints.toFixed(0)} | RB: ${team.rbPoints.toFixed(0)} | TE: ${team.tePoints.toFixed(0)}
                        </span>
                        <span class="change ${changeClass}">${changeSymbol} ${Math.abs(team.percentChange).toFixed(1)}%</span>
                    </div>
                `;
            }).join('');

            teamsTickerTrack.innerHTML = teamsTickerHTML + teamsTickerHTML;
        }

        // Dashboard ticker - shows trending opportunity shifts
        function renderInsightsTicker() {
            const insightsTickerTrack = document.getElementById('insights-ticker-track');
            if (!insightsTickerTrack) return;

            // Find the global maximum week across ALL players (current week of season)
            let globalMaxWeek = 0;
            Object.values(aggregatedWRs).forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });
            Object.values(aggregatedRBs).forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });

            if (globalMaxWeek === 0) return;

            const last3ActualWeeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
            const prior3ActualWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];
            const allMovers = [];

            // Add WRs
            Object.values(aggregatedWRs).forEach(player => {
                if (!player.weeks || player.weeks.length === 0) return;

                const last3WeeksGames = player.weeks.filter(w =>
                    last3ActualWeeks.includes(w.week) && w.fpts > 0
                );
                if (last3WeeksGames.length < 2) return;

                const allGameScores = player.weeks.map(w => w.fpts).sort((a, b) => b - a);
                const top2Scores = allGameScores.slice(0, 2);
                const recordGamesInLast3 = last3WeeksGames.filter(w =>
                    top2Scores.includes(w.fpts)
                ).length;
                if (recordGamesInLast3 < 2) return;

                const last3Shares = player.weeks
                    .filter(w => last3ActualWeeks.includes(w.week) && w.teamShare && w.teamShare > 0)
                    .map(w => w.teamShare);
                const prior3Shares = player.weeks
                    .filter(w => prior3ActualWeeks.includes(w.week) && w.teamShare && w.teamShare > 0)
                    .map(w => w.teamShare);

                if (last3Shares.length === 0) return;

                const avgLast3 = last3Shares.reduce((sum, s) => sum + s, 0) / last3Shares.length;
                const avgPrior3 = prior3Shares.length > 0
                    ? prior3Shares.reduce((sum, s) => sum + s, 0) / prior3Shares.length
                    : 0;

                allMovers.push({
                    name: player.name,
                    team: player.team,
                    position: 'WR',
                    shareChange: avgLast3 - avgPrior3,
                    avgPoints: player.avgPoints
                });
            });

            // Add RBs
            Object.values(aggregatedRBs).forEach(player => {
                if (!player.weeks || player.weeks.length === 0) return;

                const last3WeeksGames = player.weeks.filter(w =>
                    last3ActualWeeks.includes(w.week) && w.fpts > 0
                );
                if (last3WeeksGames.length < 2) return;

                const allGameScores = player.weeks.map(w => w.fpts).sort((a, b) => b - a);
                const top2Scores = allGameScores.slice(0, 2);
                const recordGamesInLast3 = last3WeeksGames.filter(w =>
                    top2Scores.includes(w.fpts)
                ).length;
                if (recordGamesInLast3 < 2) return;

                const last3Shares = [];
                last3ActualWeeks.forEach(weekNum => {
                    const weekData = player.weeks.find(w => w.week === weekNum);
                    if (weekData && weekData.opportunities > 0) {
                        const teamRows = rbData.filter(row =>
                            row.Team === player.team &&
                            parseInt(row.Week) === weekNum &&
                            parseFloat(row['RB Opp']) > 0
                        );
                        const teamTotal = teamRows.reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);
                        if (teamTotal > 0) {
                            last3Shares.push((weekData.opportunities / teamTotal) * 100);
                        }
                    }
                });

                const prior3Shares = [];
                prior3ActualWeeks.forEach(weekNum => {
                    const weekData = player.weeks.find(w => w.week === weekNum);
                    if (weekData && weekData.opportunities > 0) {
                        const teamRows = rbData.filter(row =>
                            row.Team === player.team &&
                            parseInt(row.Week) === weekNum &&
                            parseFloat(row['RB Opp']) > 0
                        );
                        const teamTotal = teamRows.reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);
                        if (teamTotal > 0) {
                            prior3Shares.push((weekData.opportunities / teamTotal) * 100);
                        }
                    }
                });

                if (last3Shares.length === 0) return;

                const avgLast3 = last3Shares.reduce((sum, s) => sum + s, 0) / last3Shares.length;
                const avgPrior3 = prior3Shares.length > 0
                    ? prior3Shares.reduce((sum, s) => sum + s, 0) / prior3Shares.length
                    : 0;

                allMovers.push({
                    name: player.name,
                    team: player.team,
                    position: 'RB',
                    shareChange: avgLast3 - avgPrior3,
                    avgPoints: player.avgPoints
                });
            });

            const topMovers = allMovers
                .sort((a, b) => Math.abs(b.shareChange) - Math.abs(a.shareChange))
                .slice(0, 40);

            const insightsTickerHTML = topMovers.map((player, index) => {
                const changeClass = player.shareChange >= 0 ? 'positive' : 'negative';
                const changeSymbol = player.shareChange >= 0 ? '▲' : '▼';
                const rank = index + 1;

                return `
                    <div class="ticker-item">
                        <span class="player-name">#${rank} ${player.name}</span>
                        <span style="color: var(--text-secondary); font-size: 11px;">${player.position} · ${player.team}</span>
                        <span class="change ${changeClass}">${changeSymbol} ${Math.abs(player.shareChange).toFixed(1)}%</span>
                        <span class="avg-pts">${player.avgPoints.toFixed(1)} pts</span>
                    </div>
                `;
            }).join('');

            insightsTickerTrack.innerHTML = insightsTickerHTML + insightsTickerHTML;
        }

        // Leaderboard ticker - shows top 10 by position
        function renderAnalyticsTicker() {
            const analyticsInsightsTrack = document.getElementById('analytics-insights-track');
            if (!analyticsInsightsTrack) return;

            const topWRs = Object.values(aggregatedWRs)
                .filter(p => p.gamesPlayed >= 3)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 10)
                .map((p, idx) => ({ ...p, rank: idx + 1 }));

            const topRBs = Object.values(aggregatedRBs)
                .filter(p => p.gamesPlayed >= 3)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 10)
                .map((p, idx) => ({ ...p, rank: idx + 1 }));

            const topTEs = Object.values(aggregatedTEs)
                .filter(p => p.gamesPlayed >= 3)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 10)
                .map((p, idx) => ({ ...p, rank: idx + 1 }));

            const allTopPlayers = [...topWRs, ...topRBs, ...topTEs];

            const analyticsTickerHTML = allTopPlayers.map((player) => {
                return `
                    <div class="ticker-item">
                        <span style="font-weight: 700; color: var(--text-tertiary); font-size: 12px; min-width: 24px;">#${player.rank}</span>
                        <span class="player-name">${player.name}</span>
                        <span style="color: var(--text-secondary); font-size: 11px;">${player.position} · ${player.team}</span>
                        <span class="avg-pts">${player.avgPoints.toFixed(1)} PPG</span>
                    </div>
                `;
            }).join('');

            analyticsInsightsTrack.innerHTML = analyticsTickerHTML + analyticsTickerHTML;
        }

        function toggleTicker(position) {
            // WR ticker should always stay expanded
            if (position === 'wr') return;

            const content = document.getElementById(`${position}-ticker-content`);
            const toggle = document.getElementById(`${position}-ticker-toggle`);
            const section = document.getElementById(`${position}-ticker-section`);

            content.classList.toggle('collapsed');
            toggle.classList.toggle('collapsed');
            section.classList.toggle('collapsed');

            // Adjust RB ticker position when WR ticker collapses (no longer needed since WR stays expanded)
        }

        // TAGGING ENGINE

        function calculatePlayerTags(position) {
            const players = position === 'WR' ? Object.values(aggregatedWRs) :
                           position === 'RB' ? Object.values(aggregatedRBs) :
                           Object.values(aggregatedTEs);
            const rawData = position === 'WR' ? wrData :
                           position === 'RB' ? rbData :
                           teData;

            // Find global max week
            let globalMaxWeek = 0;
            players.forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });

            if (globalMaxWeek < 4) return {}; // Need at least 4 weeks of data

            // Define time windows: last 2 weeks vs weeks 3-4 back
            const last2Weeks = [globalMaxWeek, globalMaxWeek - 1];
            const prior2Weeks = [globalMaxWeek - 2, globalMaxWeek - 3];

            const tagCandidates = {
                buy_low: [],
                sell_high: [],
                rz_trend_up: []
            };

            players.forEach(player => {
                if (!player.weeks || player.weeks.length < 3) return;

                // Filter: Only tag players averaging 5+ PPG
                if (player.avgPoints < 5) return;

                // Get games from last 2 weeks and prior 2 weeks
                const last2Games = player.weeks.filter(w => last2Weeks.includes(w.week) && w.fpts > 0);
                const prior2Games = player.weeks.filter(w => prior2Weeks.includes(w.week) && w.fpts > 0);

                // Need at least 1 game in each period
                if (last2Games.length === 0 || prior2Games.length === 0) return;

                // Calculate metrics for both periods
                let last2Efficiency = 0, prior2Efficiency = 0;
                let last2Volume = 0, prior2Volume = 0;
                let last2RzShare = 0, prior2RzShare = 0;

                if (position === 'WR' || position === 'TE') {
                    // WR/TE: volume = targets, efficiency = points per target
                    const last2Targets = last2Games.reduce((sum, w) => sum + (w.targets || 0), 0);
                    const last2Points = last2Games.reduce((sum, w) => sum + w.fpts, 0);
                    last2Volume = last2Targets / last2Games.length;
                    last2Efficiency = last2Targets > 0 ? last2Points / last2Targets : 0;

                    const prior2Targets = prior2Games.reduce((sum, w) => sum + (w.targets || 0), 0);
                    const prior2Points = prior2Games.reduce((sum, w) => sum + w.fpts, 0);
                    prior2Volume = prior2Targets / prior2Games.length;
                    prior2Efficiency = prior2Targets > 0 ? prior2Points / prior2Targets : 0;

                    // RZ share calculation for WRs/TEs
                    let last2RzTargets = 0, prior2RzTargets = 0;
                    last2Weeks.forEach(weekNum => {
                        const weekRow = rawData.find(row =>
                            row.Team === player.team &&
                            row.Player === player.name &&
                            parseInt(row.Week) === weekNum
                        );
                        if (weekRow) {
                            last2RzTargets += parseFloat(weekRow.RZTGT) || parseFloat(weekRow['RZ TGT']) || 0;
                        }
                    });
                    prior2Weeks.forEach(weekNum => {
                        const weekRow = rawData.find(row =>
                            row.Team === player.team &&
                            row.Player === player.name &&
                            parseInt(row.Week) === weekNum
                        );
                        if (weekRow) {
                            prior2RzTargets += parseFloat(weekRow.RZTGT) || parseFloat(weekRow['RZ TGT']) || 0;
                        }
                    });

                    last2RzShare = last2RzTargets / last2Games.length;
                    prior2RzShare = prior2RzTargets / prior2Games.length;

                } else {
                    // RB: volume = opportunities, efficiency = points per opportunity
                    const last2Opps = last2Games.reduce((sum, w) => sum + (w.opportunities || 0), 0);
                    const last2Points = last2Games.reduce((sum, w) => sum + w.fpts, 0);
                    last2Volume = last2Opps / last2Games.length;
                    last2Efficiency = last2Opps > 0 ? last2Points / last2Opps : 0;

                    const prior2Opps = prior2Games.reduce((sum, w) => sum + (w.opportunities || 0), 0);
                    const prior2Points = prior2Games.reduce((sum, w) => sum + w.fpts, 0);
                    prior2Volume = prior2Opps / prior2Games.length;
                    prior2Efficiency = prior2Opps > 0 ? prior2Points / prior2Opps : 0;

                    // RZ share calculation for RBs
                    let last2RzOpps = 0, prior2RzOpps = 0;
                    last2Weeks.forEach(weekNum => {
                        const weekRow = rawData.find(row =>
                            row.Team === player.team &&
                            row.Player === player.name &&
                            parseInt(row.Week) === weekNum
                        );
                        if (weekRow) {
                            const rzAtt = parseFloat(weekRow.RZATT) || parseFloat(weekRow['RZ ATT']) || 0;
                            const rzTgt = parseFloat(weekRow.RZTGT) || parseFloat(weekRow['RZ TGT']) || 0;
                            last2RzOpps += rzAtt + rzTgt;
                        }
                    });
                    prior2Weeks.forEach(weekNum => {
                        const weekRow = rawData.find(row =>
                            row.Team === player.team &&
                            row.Player === player.name &&
                            parseInt(row.Week) === weekNum
                        );
                        if (weekRow) {
                            const rzAtt = parseFloat(weekRow.RZATT) || parseFloat(weekRow['RZ ATT']) || 0;
                            const rzTgt = parseFloat(weekRow.RZTGT) || parseFloat(weekRow['RZ TGT']) || 0;
                            prior2RzOpps += rzAtt + rzTgt;
                        }
                    });

                    last2RzShare = last2RzOpps / last2Games.length;
                    prior2RzShare = prior2RzOpps / prior2Games.length;
                }

                // Calculate percentage changes
                const efficiencyChange = prior2Efficiency > 0 ? ((last2Efficiency - prior2Efficiency) / prior2Efficiency) * 100 : 0;
                const volumeChange = prior2Volume > 0 ? ((last2Volume - prior2Volume) / prior2Volume) * 100 : 0;
                const rzChange = prior2RzShare > 0 ? ((last2RzShare - prior2RzShare) / prior2RzShare) * 100 : 0;

                // Tag logic with 5% threshold
                // BUY LOW: efficiency up 5%+, volume down 5%+
                // But exclude top-tier players (elite performers shouldn't be "buy low")
                const topTierThreshold = position === 'WR' ? 20 : 22; // Elite WR1 / Elite RB1 threshold
                if (efficiencyChange >= 5 && volumeChange <= -5 && player.avgPoints < topTierThreshold) {
                    tagCandidates.buy_low.push({
                        player: player,
                        score: efficiencyChange + Math.abs(volumeChange) // Combined magnitude
                    });
                }

                // SELL HIGH: efficiency down 5%+, volume up 5%+
                if (efficiencyChange <= -5 && volumeChange >= 5) {
                    tagCandidates.sell_high.push({
                        player: player,
                        score: Math.abs(efficiencyChange) + volumeChange // Combined magnitude
                    });
                }

                // RZ TREND UP: red zone share up 5%+
                if (rzChange >= 5) {
                    tagCandidates.rz_trend_up.push({
                        player: player,
                        score: rzChange
                    });
                }
            });

            // Get top 4 for each tag type
            const tags = {};

            tagCandidates.buy_low.sort((a, b) => b.score - a.score).slice(0, 4).forEach(item => {
                tags[item.player.id] = tags[item.player.id] || [];
                tags[item.player.id].push('buy_low');
            });

            tagCandidates.sell_high.sort((a, b) => b.score - a.score).slice(0, 4).forEach(item => {
                tags[item.player.id] = tags[item.player.id] || [];
                tags[item.player.id].push('sell_high');
            });

            tagCandidates.rz_trend_up.sort((a, b) => b.score - a.score).slice(0, 4).forEach(item => {
                tags[item.player.id] = tags[item.player.id] || [];
                tags[item.player.id].push('rz_trend_up');
            });

            return tags;
        }

        function renderWRPlayerCards() {
            const grid = document.getElementById('wr-players-grid');
            let wrs = Object.values(aggregatedWRs).sort((a, b) => b.avgPoints - a.avgPoints);

            // Calculate tags for WRs
            const playerTags = calculatePlayerTags('WR');

            // FILTER: Remove Malik Nabers and Tyreek Hill
            wrs = wrs.filter(p => !['Malik Nabers', 'Tyreek Hill'].includes(p.name));

            // DEMOTE: Players with no stats since Week 4
            wrs = wrs.map(player => {
                if (player.latestWeek && player.latestWeek < 5) {
                    // Apply penalty to move them down tiers (reduce avg points by 50%)
                    return {
                        ...player,
                        avgPoints: player.avgPoints * 0.5,
                        inactive: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);

            // DEMOTE: Players with only 1-2 games should max out at WR3/Flex tier
            wrs = wrs.map(player => {
                if (player.gamesPlayed <= 2) {
                    // Cap their avg points at 7.9 (just below Low WR2/Flex threshold of 8)
                    return {
                        ...player,
                        avgPoints: Math.min(player.avgPoints, 7.9),
                        lowSampleSize: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);

            // Calculate top 24 averages
            const top24 = wrs.slice(0, 24);
            const top24AvgPoints = top24.reduce((sum, p) => sum + p.avgPoints, 0) / top24.length;
            const top24AvgTargets = top24.reduce((sum, p) => sum + (p.totalTargets / p.gamesPlayed), 0) / top24.length;

            // Track ranking for top 50 determination
            let overallRank = 0;

            // Define tiers - top two are rank-based (max 4 players each), then point-based
            const tiers = [
                { name: 'Elite WR1', class: 'elite', type: 'rank', maxPlayers: 4, color: '#30d158', showCharts: true },
                { name: 'High-End WR1', class: 'elite', type: 'rank', maxPlayers: 4, color: '#30d158', showCharts: true },
                { name: 'Solid WR1', class: 'elite', type: 'points', min: 17, max: 999, color: '#30d158', showCharts: true }, // Remaining WR1s (17+ ppg)
                { name: 'High Upside WR2', class: 'wr2', type: 'points', min: 14.5, max: 17, color: '#0a84ff', showCharts: true },
                { name: 'Solid WR2', class: 'wr2', type: 'points', min: 12, max: 14.5, color: '#0a84ff', showCharts: true },
                { name: 'Mid WR2', class: 'wr2', type: 'points', min: 10, max: 12, color: '#0a84ff', showCharts: true },
                { name: 'Low WR2/Flex', class: 'flex', type: 'points', min: 8, max: 10, color: '#FFD60A', showCharts: false },
                { name: 'WR3/Flex', class: 'flex', type: 'points', min: 5, max: 8, color: '#FFD60A', showCharts: false },
                { name: 'Depth/Streaming', class: 'depth', type: 'points', min: 0, max: 5, color: '#8e8e93', showCharts: false }
            ];

            let html = '';
            let chartIndex = 0;
            let rankIndex = 0; // Track position for rank-based tiers

            tiers.forEach(tier => {
                let tierPlayers = [];

                if (tier.type === 'rank') {
                    // Rank-based tier: take next N players in order
                    tierPlayers = wrs.slice(rankIndex, rankIndex + tier.maxPlayers);
                    rankIndex += tierPlayers.length;
                } else {
                    // Point-based tier: filter by point threshold from remaining players
                    const remainingPlayers = wrs.slice(rankIndex);
                    tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                    // Update rankIndex to skip these players for next tier
                    rankIndex += tierPlayers.length;
                }

                if (tierPlayers.length === 0) return;

                html += `
                    <div class="tier-section">
                        <div class="tier-header" onclick="toggleTierCollapse(this)">
                            <div class="tier-badge ${tier.class}">${tier.name}</div>
                            <div class="tier-count">Avg: ${(tierPlayers.reduce((sum, p) => sum + p.avgPoints, 0) / tierPlayers.length).toFixed(1)} pts/game</div>
                            <span class="tier-collapse-icon">▼</span>
                        </div>
                        <div class="tier-cards-container">
                            <div class="cards-grid">
                `;

                tierPlayers.forEach(player => {
                    overallRank++;
                    const chartId = `wr-player-chart-${chartIndex++}`;
                    const escapedId = player.id.replace(/'/g, "\\'");
                    const sentiment = getSentimentScore(player.name);
                    const buyPct = sentiment.total > 0 ? (sentiment.buy / sentiment.total * 100) : 0;

                    // Use original avg points for display (not demoted value)
                    const displayAvgPoints = player.inactive ? player.avgPoints * 2 : player.avgPoints;

                    // Calculate comparisons to top 24
                    const targetsPerGame = player.totalTargets / player.gamesPlayed;
                    const pointsDiff = displayAvgPoints - top24AvgPoints;
                    const targetsDiff = targetsPerGame - top24AvgTargets;

                    const pointsClass = pointsDiff >= 0 ? 'comparison-up' : 'comparison-down';
                    const pointsIcon = pointsDiff >= 0 ? '▲' : '▼';
                    const targetsClass = targetsDiff >= 0 ? 'comparison-up' : 'comparison-down';
                    const targetsIcon = targetsDiff >= 0 ? '▲' : '▼';

                    // Include chart based on tier setting
                    const includeChart = tier.showCharts;

                    // Get tags for this player
                    const tags = playerTags[player.id] || [];

                    // Build tags HTML (momentum badge moved to card root)
                    let tagElements = tags.map(tag => {
                        if (tag === 'rz_trend_up') return '<span class="player-tag rz-up" data-tooltip="Red Zone opportunities trending up - TD upside">RZ↑</span>';
                        return '';
                    }).filter(t => t);

                    const tagsHTML = tagElements.length > 0 ? `
                        <div class="player-tags">
                            ${tagElements.join('')}
                        </div>
                    ` : '';

                    html += `
                        <div class="player-card" onclick="openPlayerModal('${escapedId}')" ${player.inactive ? 'style="opacity: 0.6; border-left: 3px solid #ff453a;"' : ''}>
                            <div class="player-card-header">
                                <div class="player-card-badge" style="background: ${teamColors[player.team] || '#666'}">${player.team}</div>
                                <div style="flex: 1;">
                                    <div class="player-card-name">
                                        ${player.name}${player.inactive ? ' <span style="color: #ff453a; font-size: 11px;">⚠ INACTIVE</span>' : ''}
                                    </div>
                                    <div class="player-card-team">WR · ${player.team}${(() => {
                                        let badges = '';
                                        
                                        // Add injury badge if present
                                        const injury = getPlayerInjuryStatus(player.name);
                                        if (injury) {
                                            const statusInfo = formatInjuryStatus(injury.status);
                                            const injuryDetails = `${statusInfo.fullText} - ${injury.injuryBody}`;
                                            badges += ` <span class="injury-badge ${statusInfo.class}" data-injury-details="${injuryDetails}">${statusInfo.badge}</span>`;
                                        }
                                        
                                        // Add momentum badge if present
                                        if (player.momentum && player.momentum.isValid && player.momentum.direction !== 'neutral') {
                                            // Suppress negative momentum for high scorers unless decline is severe (>15%)
                                            let showBadge = true;
                                            if (player.momentum.direction === 'down') {
                                                const highScorerThreshold = currentScoringFormat === 'ppr' ? 20 : 
                                                                          currentScoringFormat === 'half' ? 17 : 14.5;
                                                if (player.avgPoints >= highScorerThreshold && player.momentum.score > -15) {
                                                    showBadge = false;
                                                }
                                            }
                                            if (showBadge) {
                                                badges += ` <span class="momentum-badge ${player.momentum.direction}" data-tooltip="Momentum: ${player.momentum.score > 0 ? '+' : ''}${player.momentum.score.toFixed(1)}% (last 3 vs prev 3 weeks)">${player.momentum.direction === 'up' ? '↑' : '↓'}</span>`;
                                            }
                                        }
                                        
                                        return badges;
                                    })()}</div>
                                    ${tagsHTML}
                                </div>
                            </div>
                            <div class="player-card-stats">
                                <div class="player-stat">
                                    <span class="player-stat-label">Avg Points</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="player-stat-value">${displayAvgPoints.toFixed(1)}</span>
                                        <span class="player-comparison ${pointsClass}">
                                            <span class="comparison-icon">${pointsIcon}</span>
                                            ${Math.abs(pointsDiff).toFixed(1)}
                                        </span>
                                        <div class="comparison-tooltip">
                                            <div class="tooltip-label">vs Top 24 WR Avg</div>
                                            <div class="tooltip-data">${displayAvgPoints.toFixed(1)} vs ${top24AvgPoints.toFixed(1)}</div>
                                            <div class="tooltip-data">${pointsDiff >= 0 ? '+' : ''}${pointsDiff.toFixed(1)} pts</div>
                                        </div>
                                    </div>
                                    <div class="stat-tooltip">Average fantasy points per game over ${player.gamesPlayed} games</div>
                                </div>
                                <div class="player-stat">
                                    <span class="player-stat-label">Targets/Game</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="player-stat-value">${targetsPerGame.toFixed(1)}</span>
                                        <span class="player-comparison ${targetsClass}">
                                            <span class="comparison-icon">${targetsIcon}</span>
                                            ${Math.abs(targetsDiff).toFixed(1)}
                                        </span>
                                        <div class="comparison-tooltip">
                                            <div class="tooltip-label">vs Top 24 WR Avg</div>
                                            <div class="tooltip-data">${targetsPerGame.toFixed(1)} vs ${top24AvgTargets.toFixed(1)}</div>
                                            <div class="tooltip-data">${targetsDiff >= 0 ? '+' : ''}${targetsDiff.toFixed(1)} tgt/g</div>
                                        </div>
                                    </div>
                                    <div class="stat-tooltip">Average targets per game (${player.totalTargets} total targets)</div>
                                </div>
                                <div class="player-stat" style="grid-column: 1 / -1;">
                                    <span class="player-stat-label">Community Sentiment</span>
                                    <div style="margin-top: 4px;">
                                        ${sentiment.total > 0 ? (() => {
                                            const totalVotes = sentiment.total;
                                            const buyPct = Math.round((sentiment.buy / totalVotes) * 100);
                                            const holdPct = Math.round((sentiment.hold / totalVotes) * 100);
                                            const sellPct = Math.round((sentiment.sell / totalVotes) * 100);

                                            const max = Math.max(buyPct, holdPct, sellPct);
                                            let label, color, bgColor, icon;
                                            if (buyPct === max) {
                                                label = 'BUY';
                                                color = 'var(--positive)';
                                                bgColor = 'rgba(48, 209, 88, 0.15)';
                                                icon = '▲';
                                            } else if (sellPct === max) {
                                                label = 'SELL';
                                                color = 'var(--negative)';
                                                bgColor = 'rgba(255, 69, 58, 0.15)';
                                                icon = '▼';
                                            } else {
                                                label = 'HOLD';
                                                color = 'var(--text-secondary)';
                                                bgColor = 'rgba(142, 142, 147, 0.15)';
                                                icon = '—';
                                            }

                                            return '<span style="padding: 3px 6px; background: ' + bgColor + '; color: ' + color + '; border-radius: 5px; font-size: 10px; font-weight: 600; display: inline-block;">' + icon + ' ' + max + '% ' + label + '</span>';
                                        })() : '<span style="padding: 3px 6px; background: rgba(142, 142, 147, 0.15); color: var(--text-secondary); border-radius: 5px; font-size: 10px; font-weight: 600; display: inline-block;">No Votes</span>'}
                                    </div>
                                    <div class="stat-tooltip">${sentiment.total > 0 ? `Community voting: ${sentiment.total} total votes` : 'Be the first to vote! Open player modal to cast your vote.'}</div>
                                </div>
                            </div>
                            ${includeChart ? `<div class="player-card-chart">
                                <canvas id="${chartId}"></canvas>
                            </div>` : ''}
                        </div>
                    `;
                });

                html += `
                            </div>
                        </div>
                    </div>
                `;
            });

            grid.innerHTML = html;

            // Render mini charts only for tiers with showCharts: true
            chartIndex = 0;
            rankIndex = 0; // Reset rank index for chart rendering

            tiers.forEach(tier => {
                if (!tier.showCharts) {
                    // Skip chart rendering for this tier, but still count the players
                    let tierPlayers = [];
                    if (tier.type === 'rank') {
                        tierPlayers = wrs.slice(rankIndex, rankIndex + tier.maxPlayers);
                        rankIndex += tierPlayers.length;
                    } else {
                        const remainingPlayers = wrs.slice(rankIndex);
                        tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                        rankIndex += tierPlayers.length;
                    }
                    chartIndex += tierPlayers.length;
                    return;
                }

                let tierPlayers = [];
                if (tier.type === 'rank') {
                    tierPlayers = wrs.slice(rankIndex, rankIndex + tier.maxPlayers);
                    rankIndex += tierPlayers.length;
                } else {
                    const remainingPlayers = wrs.slice(rankIndex);
                    tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                    rankIndex += tierPlayers.length;
                }

                tierPlayers.forEach(player => {
                    renderPlayerCardChart(`wr-player-chart-${chartIndex}`, player, 'WR');
                    chartIndex++;
                });
            });

            // Apply two-or-less class and add spacer for single cards
            document.querySelectorAll('#wr-players-grid .cards-grid').forEach(cardsGrid => {
                const playerCards = cardsGrid.querySelectorAll('.player-card');
                if (playerCards.length === 1) {
                    cardsGrid.classList.add('two-or-less');
                    // Add invisible spacer div to maintain 2-column layout
                    const spacer = document.createElement('div');
                    spacer.className = 'grid-spacer';
                    cardsGrid.appendChild(spacer);
                } else if (playerCards.length === 2) {
                    cardsGrid.classList.add('two-or-less');
                }
            });
        }

        function renderRBPlayerCards() {
            const grid = document.getElementById('rb-players-grid');
            let rbs = Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints);

            // Calculate tags for RBs
            const playerTags = calculatePlayerTags('RB');

            // FILTER: Mark Cam Skattebo as inactive
            rbs = rbs.map(player => {
                if (player.name === 'Cam Skattebo') {
                    return {
                        ...player,
                        latestWeek: 0, // Force inactive status
                        inactive: true
                    };
                }
                return player;
            });

            // DEMOTE: Players with no stats since Week 4
            rbs = rbs.map(player => {
                if (player.latestWeek && player.latestWeek < 5) {
                    // Apply penalty to move them down tiers (reduce avg points by 50%)
                    return {
                        ...player,
                        avgPoints: player.avgPoints * 0.5,
                        inactive: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);


            // DEMOTE: Players with only 1 game should max out at Deep Flex tier
            rbs = rbs.map(player => {
                if (player.gamesPlayed === 1) {
                    // Cap their avg points at 7.9 (just below RB3/Flex threshold of 8)
                    return {
                        ...player,
                        avgPoints: Math.min(player.avgPoints, 7.9),
                        lowSampleSize: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);
            // Calculate top 24 averages
            const top24 = rbs.slice(0, 24);
            const top24AvgPoints = top24.reduce((sum, p) => sum + p.avgPoints, 0) / top24.length;
            const top24AvgOpps = top24.reduce((sum, p) => sum + (p.totalOpportunities / p.gamesPlayed), 0) / top24.length;

            // Track ranking for top 50 determination
            let overallRank = 0;

            // Define tiers based on avg points thresholds (performance-based)
            const tiers = [
                { name: 'Elite RB1', class: 'elite', min: 22, max: 999, color: '#30d158', showCharts: true },
                { name: 'High-End RB1', class: 'elite', min: 20, max: 22, color: '#30d158', showCharts: true },
                { name: 'Solid RB1', class: 'elite', min: 18, max: 20, color: '#30d158', showCharts: true },
                { name: 'Low RB1/High RB2', class: 'wr2', min: 15, max: 18, color: '#0a84ff', showCharts: true },
                { name: 'Mid RB2', class: 'wr2', min: 13, max: 15, color: '#0a84ff', showCharts: true },
                { name: 'Low RB2/Flex', class: 'flex', min: 10, max: 13, color: '#FFD60A', showCharts: true },
                { name: 'RB3/Flex', class: 'flex', min: 8, max: 10, color: '#FFD60A', showCharts: true },
                { name: 'Deep Flex', class: 'depth', min: 5, max: 8, color: '#8e8e93', showCharts: false },
                { name: 'Depth/Streaming', class: 'depth', min: 0, max: 5, color: '#8e8e93', showCharts: false }
            ];

            let html = '';
            let chartIndex = 0;

            tiers.forEach(tier => {
                const tierPlayers = rbs.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                if (tierPlayers.length === 0) return;

                html += `
                    <div class="tier-section">
                        <div class="tier-header" onclick="toggleTierCollapse(this)">
                            <div class="tier-badge ${tier.class}">${tier.name}</div>
                            <div class="tier-count">Avg: ${(tierPlayers.reduce((sum, p) => sum + p.avgPoints, 0) / tierPlayers.length).toFixed(1)} pts/game</div>
                            <span class="tier-collapse-icon">▼</span>
                        </div>
                        <div class="tier-cards-container">
                            <div class="cards-grid">
                `;

                tierPlayers.forEach(player => {
                    overallRank++;
                    const chartId = `rb-player-chart-${chartIndex++}`;
                    const escapedId = player.id.replace(/'/g, "\\'");
                    const sentiment = getSentimentScore(player.name);
                    const buyPct = sentiment.total > 0 ? (sentiment.buy / sentiment.total * 100) : 0;

                    // Use original avg points for display (not demoted value)
                    const displayAvgPoints = player.inactive ? player.avgPoints * 2 : player.avgPoints;

                    // Calculate comparisons to top 24
                    const oppsPerGame = player.totalOpportunities / player.gamesPlayed;
                    const pointsDiff = displayAvgPoints - top24AvgPoints;
                    const oppsDiff = oppsPerGame - top24AvgOpps;

                    const pointsClass = pointsDiff >= 0 ? 'comparison-up' : 'comparison-down';
                    const pointsIcon = pointsDiff >= 0 ? '▲' : '▼';
                    const oppsClass = oppsDiff >= 0 ? 'comparison-up' : 'comparison-down';
                    const oppsIcon = oppsDiff >= 0 ? '▲' : '▼';

                    // Include chart based on tier setting
                    const includeChart = tier.showCharts;

                    // Get tags for this player (RB specific)
                    const tags = playerTags[player.id] || [];

                    // Build tags HTML (momentum badge moved to card root)
                    let tagElements = tags.map(tag => {
                        if (tag === 'rz_trend_up') return '<span class="player-tag rz-up" data-tooltip="Red Zone opportunities trending up - TD upside">RZ↑</span>';
                        return '';
                    }).filter(t => t);

                    const tagsHTML = tagElements.length > 0 ? `
                        <div class="player-tags">
                            ${tagElements.join('')}
                        </div>
                    ` : '';

                    html += `
                        <div class="player-card" onclick="openPlayerModal('${escapedId}')" ${player.inactive ? 'style="opacity: 0.6; border-left: 3px solid #ff453a;"' : ''}>
                            <div class="player-card-header">
                                <div class="player-card-badge" style="background: ${teamColors[player.team] || '#666'}">${player.team}</div>
                                <div style="flex: 1;">
                                    <div class="player-card-name">
                                        ${player.name}${player.inactive ? ' <span style="color: #ff453a; font-size: 11px;">⚠ INACTIVE</span>' : ''}
                                    </div>
                                    <div class="player-card-team">RB · ${player.team}${(() => {
                                        let badges = '';
                                        
                                        // Add injury badge if present
                                        const injury = getPlayerInjuryStatus(player.name);
                                        if (injury) {
                                            const statusInfo = formatInjuryStatus(injury.status);
                                            const injuryDetails = `${statusInfo.fullText} - ${injury.injuryBody}`;
                                            badges += ` <span class="injury-badge ${statusInfo.class}" data-injury-details="${injuryDetails}">${statusInfo.badge}</span>`;
                                        }
                                        
                                        // Add momentum badge if present
                                        if (player.momentum && player.momentum.isValid && player.momentum.direction !== 'neutral') {
                                            // Suppress negative momentum for high scorers unless decline is severe (>15%)
                                            let showBadge = true;
                                            if (player.momentum.direction === 'down') {
                                                const highScorerThreshold = currentScoringFormat === 'ppr' ? 20 : 
                                                                          currentScoringFormat === 'half' ? 17 : 14.5;
                                                if (player.avgPoints >= highScorerThreshold && player.momentum.score > -15) {
                                                    showBadge = false;
                                                }
                                            }
                                            if (showBadge) {
                                                badges += ` <span class="momentum-badge ${player.momentum.direction}" data-tooltip="Momentum: ${player.momentum.score > 0 ? '+' : ''}${player.momentum.score.toFixed(1)}% (last 3 vs prev 3 weeks)">${player.momentum.direction === 'up' ? '↑' : '↓'}</span>`;
                                            }
                                        }
                                        
                                        return badges;
                                    })()}</div>
                                    ${tagsHTML}
                                </div>
                            </div>
                            <div class="player-card-stats">
                                <div class="player-stat">
                                    <span class="player-stat-label">Avg Points</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="player-stat-value">${displayAvgPoints.toFixed(1)}</span>
                                        <span class="player-comparison ${pointsClass}">
                                            <span class="comparison-icon">${pointsIcon}</span>
                                            ${Math.abs(pointsDiff).toFixed(1)}
                                        </span>
                                        <div class="comparison-tooltip">
                                            <div class="tooltip-label">vs Top 24 RB Avg</div>
                                            <div class="tooltip-data">${displayAvgPoints.toFixed(1)} vs ${top24AvgPoints.toFixed(1)}</div>
                                            <div class="tooltip-data">${pointsDiff >= 0 ? '+' : ''}${pointsDiff.toFixed(1)} pts</div>
                                        </div>
                                    </div>
                                    <div class="stat-tooltip">Average fantasy points per game over ${player.gamesPlayed} games</div>
                                </div>
                                <div class="player-stat">
                                    <span class="player-stat-label">Opps/Game</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="player-stat-value">${oppsPerGame.toFixed(1)}</span>
                                        <span class="player-comparison ${oppsClass}">
                                            <span class="comparison-icon">${oppsIcon}</span>
                                            ${Math.abs(oppsDiff).toFixed(1)}
                                        </span>
                                        <div class="comparison-tooltip">
                                            <div class="tooltip-label">vs Top 24 RB Avg</div>
                                            <div class="tooltip-data">${oppsPerGame.toFixed(1)} vs ${top24AvgOpps.toFixed(1)}</div>
                                            <div class="tooltip-data">${oppsDiff >= 0 ? '+' : ''}${oppsDiff.toFixed(1)} opp/g</div>
                                        </div>
                                    </div>
                                    <div class="stat-tooltip">Average opportunities per game (${player.totalOpportunities} total opportunities)</div>
                                </div>
                                <div class="player-stat" style="grid-column: 1 / -1;">
                                    <span class="player-stat-label">Community Sentiment</span>
                                    <div style="margin-top: 4px;">
                                        ${sentiment.total > 0 ? (() => {
                                            const totalVotes = sentiment.total;
                                            const buyPct = Math.round((sentiment.buy / totalVotes) * 100);
                                            const holdPct = Math.round((sentiment.hold / totalVotes) * 100);
                                            const sellPct = Math.round((sentiment.sell / totalVotes) * 100);

                                            const max = Math.max(buyPct, holdPct, sellPct);
                                            let label, color, bgColor, icon;
                                            if (buyPct === max) {
                                                label = 'BUY';
                                                color = 'var(--positive)';
                                                bgColor = 'rgba(48, 209, 88, 0.15)';
                                                icon = '▲';
                                            } else if (sellPct === max) {
                                                label = 'SELL';
                                                color = 'var(--negative)';
                                                bgColor = 'rgba(255, 69, 58, 0.15)';
                                                icon = '▼';
                                            } else {
                                                label = 'HOLD';
                                                color = 'var(--text-secondary)';
                                                bgColor = 'rgba(142, 142, 147, 0.15)';
                                                icon = '—';
                                            }

                                            return '<span style="padding: 3px 6px; background: ' + bgColor + '; color: ' + color + '; border-radius: 5px; font-size: 10px; font-weight: 600; display: inline-block;">' + icon + ' ' + max + '% ' + label + '</span>';
                                        })() : '<span style="padding: 3px 6px; background: rgba(142, 142, 147, 0.15); color: var(--text-secondary); border-radius: 5px; font-size: 10px; font-weight: 600; display: inline-block;">No Votes</span>'}
                                    </div>
                                    <div class="stat-tooltip">${sentiment.total > 0 ? `Community voting: ${sentiment.total} total votes` : 'Be the first to vote! Open player modal to cast your vote.'}</div>
                                </div>
                            </div>
                            ${includeChart ? `<div class="player-card-chart">
                                <canvas id="${chartId}"></canvas>
                            </div>` : ''}
                        </div>
                    `;
                });

                html += `
                            </div>
                        </div>
                    </div>
                `;
            });

            grid.innerHTML = html;

            // Render mini charts ONLY for top 50 players
            chartIndex = 0;
            overallRank = 0;
            tiers.forEach(tier => {
                const tierPlayers = rbs.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                tierPlayers.forEach(player => {
                    overallRank++;
                    if (overallRank <= 50) {
                        renderPlayerCardChart(`rb-player-chart-${chartIndex}`, player, 'RB');
                    }
                    chartIndex++;
                });
            });

            // Apply two-or-less class and add spacer for single cards
            document.querySelectorAll('#rb-players-grid .cards-grid').forEach(cardsGrid => {
                const playerCards = cardsGrid.querySelectorAll('.player-card');
                if (playerCards.length === 1) {
                    cardsGrid.classList.add('two-or-less');
                    // Add invisible spacer div to maintain 2-column layout
                    const spacer = document.createElement('div');
                    spacer.className = 'grid-spacer';
                    cardsGrid.appendChild(spacer);
                } else if (playerCards.length === 2) {
                    cardsGrid.classList.add('two-or-less');
                }
            });
        }

        function renderTEPlayerCards() {
            const grid = document.getElementById('te-players-grid');
            let tes = Object.values(aggregatedTEs).sort((a, b) => b.avgPoints - a.avgPoints);

            // Calculate tags for TEs
            const playerTags = calculatePlayerTags('TE');

            // DEMOTE: Players with no stats since Week 4
            tes = tes.map(player => {
                if (player.latestWeek && player.latestWeek < 5) {
                    // Apply penalty to move them down tiers (reduce avg points by 50%)
                    return {
                        ...player,
                        avgPoints: player.avgPoints * 0.5,
                        inactive: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);

            // Find global max week (current week)
            let globalMaxWeek = 0;
            tes.forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });

            // DEMOTE: Players who haven't played in 2+ weeks - drop them 1 tier (~3.5 ppg)
            tes = tes.map(player => {
                if (player.latestWeek && globalMaxWeek - player.latestWeek >= 2) {
                    return {
                        ...player,
                        avgPoints: Math.max(0, player.avgPoints - 3.5),
                        recentlyInactive: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);

            // SPECIFIC: Move Darren Waller to TE2 tier max (6 ppg) until he plays again
            tes = tes.map(player => {
                if (player.name === 'Darren Waller') {
                    return {
                        ...player,
                        avgPoints: Math.min(player.avgPoints, 5.9), // Just below TE2 threshold
                        wallerException: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);

            // SPECIFIC: Tucker Kraft injured - mark inactive and keep below Bowers/McBride
            tes = tes.map(player => {
                if (player.name === 'Tucker Kraft') {
                    return {
                        ...player,
                        inactive: true,
                        kraftInjury: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);

            // ELITE TIER 0: Bowers and McBride are in their own tier
            // Everyone else must be within 1.5 ppg of them to join
            const eliteTwoAvg = tes.slice(0, 2).reduce((sum, p) => sum + p.avgPoints, 0) / 2;
            tes = tes.map((player, idx) => {
                // Skip the top 2 (Bowers and McBride)
                if (idx < 2) return player;

                // Everyone else must be within 1.5 ppg of the elite duo's average
                if (player.avgPoints < eliteTwoAvg - 1.5) {
                    return {
                        ...player,
                        avgPoints: Math.min(player.avgPoints, eliteTwoAvg - 1.6), // Push them down to next tier
                        notElite: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);

            // DEMOTE: Players with only 1 game should max out at tier 4 or 5 depending on points
            tes = tes.map(player => {
                if (player.gamesPlayed === 1) {
                    // If they scored 10+ points, cap at tier 4 (8 ppg)
                    // If they scored less, cap at tier 5 (6 ppg)
                    const maxPpg = player.avgPoints >= 10 ? 7.9 : 5.9;
                    return {
                        ...player,
                        avgPoints: Math.min(player.avgPoints, maxPpg),
                        lowSampleSize: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);

            // Calculate top 12 averages (not 24 like WR/RB)
            const top12 = tes.slice(0, 12);
            const top12AvgPoints = top12.reduce((sum, p) => sum + p.avgPoints, 0) / top12.length;
            const top12AvgTargets = top12.reduce((sum, p) => sum + (p.totalTargets / p.gamesPlayed), 0) / top12.length;

            // Track ranking for tier assignment
            let overallRank = 0;

            // Limit to top 50 TEs
            tes = tes.slice(0, 50);

            // Define 7 tiers with new naming
            const tiers = [
                { name: 'Elite', class: 'elite', type: 'rank', maxPlayers: 2, color: '#30d158', showCharts: true },
                { name: 'High-End TE1', class: 'elite', type: 'rank', maxPlayers: 3, color: '#30d158', showCharts: true },
                { name: 'Solid TE1', class: 'elite', type: 'rank', maxPlayers: 5, color: '#30d158', showCharts: true },
                { name: 'Low-End TE1/High-End TE2', class: 'wr2', type: 'rank', maxPlayers: 8, color: '#0a84ff', showCharts: true },
                { name: 'Solid TE2', class: 'wr2', type: 'points', min: 8, max: 999, color: '#0a84ff', showCharts: true },
                { name: 'Flex/Streamer', class: 'flex', type: 'points', min: 5.5, max: 8, color: '#FFD60A', showCharts: true },
                { name: 'Depth', class: 'depth', type: 'points', min: 0, max: 5.5, color: '#8e8e93', showCharts: false }
            ];

            let html = '';
            let chartIndex = 0;
            let rankIndex = 0; // Track position for rank-based tiers

            tiers.forEach(tier => {
                let tierPlayers = [];

                if (tier.type === 'rank') {
                    // Rank-based tier: take next N players in order
                    tierPlayers = tes.slice(rankIndex, rankIndex + tier.maxPlayers);
                    rankIndex += tierPlayers.length;
                } else {
                    // Point-based tier: filter by point threshold from remaining players
                    const remainingPlayers = tes.slice(rankIndex);
                    tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                    // Update rankIndex to skip these players for next tier
                    rankIndex += tierPlayers.length;
                }

                if (tierPlayers.length === 0) return;

                html += `
                    <div class="tier-section">
                        <div class="tier-header" onclick="toggleTierCollapse(this)">
                            <div class="tier-badge ${tier.class}">${tier.name}</div>
                            <div class="tier-count">Avg: ${(tierPlayers.reduce((sum, p) => sum + p.avgPoints, 0) / tierPlayers.length).toFixed(1)} pts/game</div>
                            <span class="tier-collapse-icon">▼</span>
                        </div>
                        <div class="tier-cards-container">
                            <div class="cards-grid">
                `;

                tierPlayers.forEach(player => {
                    overallRank++;
                    const chartId = `te-player-chart-${chartIndex++}`;
                    const escapedId = player.id.replace(/'/g, "\\'");
                    const sentiment = getSentimentScore(player.name);
                    const buyPct = sentiment.total > 0 ? (sentiment.buy / sentiment.total * 100) : 0;

                    // Use original avg points for display (not demoted value)
                    const displayAvgPoints = player.inactive ? player.avgPoints * 2 : player.avgPoints;

                    // Calculate comparisons to top 12
                    const targetsPerGame = player.totalTargets / player.gamesPlayed;
                    const pointsDiff = displayAvgPoints - top12AvgPoints;
                    const targetsDiff = targetsPerGame - top12AvgTargets;

                    const pointsClass = pointsDiff >= 0 ? 'comparison-up' : 'comparison-down';
                    const pointsIcon = pointsDiff >= 0 ? '▲' : '▼';
                    const targetsClass = targetsDiff >= 0 ? 'comparison-up' : 'comparison-down';
                    const targetsIcon = targetsDiff >= 0 ? '▲' : '▼';

                    // Include chart based on tier setting
                    const includeChart = tier.showCharts;

                    // Get tags for this player
                    const tags = playerTags[player.id] || [];

                    // Build tags HTML (momentum badge moved to card root)
                    let tagElements = tags.map(tag => {
                        if (tag === 'rz_trend_up') return '<span class="player-tag rz-up" data-tooltip="Red Zone opportunities trending up - TD upside">RZ↑</span>';
                        return '';
                    }).filter(t => t);

                    const tagsHTML = tagElements.length > 0 ? `
                        <div class="player-tags">
                            ${tagElements.join('')}
                        </div>
                    ` : '';

                    html += `
                        <div class="player-card" onclick="openPlayerModal('${escapedId}')" ${player.inactive ? 'style="opacity: 0.6; border-left: 3px solid #ff453a;"' : ''}>
                            <div class="player-card-header">
                                <div class="player-card-badge" style="background: ${teamColors[player.team] || '#666'}">${player.team}</div>
                                <div style="flex: 1;">
                                    <div class="player-card-name">
                                        ${player.name}${player.inactive ? ' <span style="color: #ff453a; font-size: 11px;">⚠ INACTIVE</span>' : ''}
                                    </div>
                                    <div class="player-card-team">TE · ${player.team}${(() => {
                                        let badges = '';
                                        
                                        // Add injury badge if present
                                        const injury = getPlayerInjuryStatus(player.name);
                                        if (injury) {
                                            const statusInfo = formatInjuryStatus(injury.status);
                                            const injuryDetails = `${statusInfo.fullText} - ${injury.injuryBody}`;
                                            badges += ` <span class="injury-badge ${statusInfo.class}" data-injury-details="${injuryDetails}">${statusInfo.badge}</span>`;
                                        }
                                        
                                        // Add momentum badge if present
                                        if (player.momentum && player.momentum.isValid && player.momentum.direction !== 'neutral') {
                                            // Suppress negative momentum for high scorers unless decline is severe (>15%)
                                            let showBadge = true;
                                            if (player.momentum.direction === 'down') {
                                                const highScorerThreshold = currentScoringFormat === 'ppr' ? 20 : 
                                                                          currentScoringFormat === 'half' ? 17 : 14.5;
                                                if (player.avgPoints >= highScorerThreshold && player.momentum.score > -15) {
                                                    showBadge = false;
                                                }
                                            }
                                            if (showBadge) {
                                                badges += ` <span class="momentum-badge ${player.momentum.direction}" data-tooltip="Momentum: ${player.momentum.score > 0 ? '+' : ''}${player.momentum.score.toFixed(1)}% (last 3 vs prev 3 weeks)">${player.momentum.direction === 'up' ? '↑' : '↓'}</span>`;
                                            }
                                        }
                                        
                                        return badges;
                                    })()}</div>
                                    ${tagsHTML}
                                </div>
                            </div>
                            <div class="player-card-stats">
                                <div class="player-stat">
                                    <span class="player-stat-label">Avg Points</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="player-stat-value">${displayAvgPoints.toFixed(1)}</span>
                                        <span class="player-comparison ${pointsClass}">
                                            <span class="comparison-icon">${pointsIcon}</span>
                                            ${Math.abs(pointsDiff).toFixed(1)}
                                        </span>
                                        <div class="comparison-tooltip">
                                            <div class="tooltip-label">vs Top 12 TE Avg</div>
                                            <div class="tooltip-data">${displayAvgPoints.toFixed(1)} vs ${top12AvgPoints.toFixed(1)}</div>
                                            <div class="tooltip-data">${pointsDiff >= 0 ? '+' : ''}${pointsDiff.toFixed(1)} pts</div>
                                        </div>
                                    </div>
                                    <div class="stat-tooltip">Average fantasy points per game over ${player.gamesPlayed} games</div>
                                </div>
                                <div class="player-stat">
                                    <span class="player-stat-label">Targets/Game</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="player-stat-value">${targetsPerGame.toFixed(1)}</span>
                                        <span class="player-comparison ${targetsClass}">
                                            <span class="comparison-icon">${targetsIcon}</span>
                                            ${Math.abs(targetsDiff).toFixed(1)}
                                        </span>
                                        <div class="comparison-tooltip">
                                            <div class="tooltip-label">vs Top 12 TE Avg</div>
                                            <div class="tooltip-data">${targetsPerGame.toFixed(1)} vs ${top12AvgTargets.toFixed(1)}</div>
                                            <div class="tooltip-data">${targetsDiff >= 0 ? '+' : ''}${targetsDiff.toFixed(1)} tgt/g</div>
                                        </div>
                                    </div>
                                    <div class="stat-tooltip">Average targets per game (${player.totalTargets} total targets)</div>
                                </div>
                                <div class="player-stat" style="grid-column: 1 / -1;">
                                    <span class="player-stat-label">Community Sentiment</span>
                                    <div style="margin-top: 4px;">
                                        ${sentiment.total > 0 ? (() => {
                                            const totalVotes = sentiment.total;
                                            const buyPct = Math.round((sentiment.buy / totalVotes) * 100);
                                            const holdPct = Math.round((sentiment.hold / totalVotes) * 100);
                                            const sellPct = Math.round((sentiment.sell / totalVotes) * 100);

                                            const max = Math.max(buyPct, holdPct, sellPct);
                                            let label, color, bgColor, icon;
                                            if (buyPct === max) {
                                                label = 'BUY';
                                                color = 'var(--positive)';
                                                bgColor = 'rgba(48, 209, 88, 0.15)';
                                                icon = '▲';
                                            } else if (sellPct === max) {
                                                label = 'SELL';
                                                color = 'var(--negative)';
                                                bgColor = 'rgba(255, 69, 58, 0.15)';
                                                icon = '▼';
                                            } else {
                                                label = 'HOLD';
                                                color = 'var(--text-secondary)';
                                                bgColor = 'rgba(142, 142, 147, 0.15)';
                                                icon = '—';
                                            }

                                            return '<span style="padding: 3px 6px; background: ' + bgColor + '; color: ' + color + '; border-radius: 5px; font-size: 10px; font-weight: 600; display: inline-block;">' + icon + ' ' + max + '% ' + label + '</span>';
                                        })() : '<span style="padding: 3px 6px; background: rgba(142, 142, 147, 0.15); color: var(--text-secondary); border-radius: 5px; font-size: 10px; font-weight: 600; display: inline-block;">No Votes</span>'}
                                    </div>
                                    <div class="stat-tooltip">${sentiment.total > 0 ? `Community voting: ${sentiment.total} total votes` : 'Be the first to vote! Open player modal to cast your vote.'}</div>
                                </div>
                            </div>
                            ${includeChart ? `<div class="player-card-chart">
                                <canvas id="${chartId}"></canvas>
                            </div>` : ''}
                        </div>
                    `;
                });

                html += `
                            </div>
                        </div>
                    </div>
                `;
            });

            grid.innerHTML = html;

            // Render mini charts only for tiers with showCharts: true
            chartIndex = 0;
            rankIndex = 0; // Reset rank index for chart rendering

            tiers.forEach(tier => {
                if (!tier.showCharts) {
                    rankIndex += tier.type === 'rank' ? tier.maxPlayers :
                                tes.slice(rankIndex).filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max).length;
                    return;
                }

                let tierPlayers = [];
                if (tier.type === 'rank') {
                    tierPlayers = tes.slice(rankIndex, rankIndex + tier.maxPlayers);
                    rankIndex += tierPlayers.length;
                } else {
                    const remainingPlayers = tes.slice(rankIndex);
                    tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                    rankIndex += tierPlayers.length;
                }

                // Render charts for this tier
                tierPlayers.forEach(player => {
                    renderPlayerCardChart(`te-player-chart-${chartIndex}`, player, 'TE');
                    chartIndex++;
                });
            });

            // Apply two-or-less class and add spacer for single cards
            document.querySelectorAll('#te-players-grid .cards-grid').forEach(cardsGrid => {
                const playerCards = cardsGrid.querySelectorAll('.player-card');
                if (playerCards.length === 1) {
                    cardsGrid.classList.add('two-or-less');
                    // Add invisible spacer div to maintain 2-column layout
                    const spacer = document.createElement('div');
                    spacer.className = 'grid-spacer';
                    cardsGrid.appendChild(spacer);
                } else if (playerCards.length === 2) {
                    cardsGrid.classList.add('two-or-less');
                }
            });
        }
        function renderTeamsPage() {
            const teamsGrid = document.getElementById('teams-grid');

            // Reset and recalculate global teamStats
            teamStats = {};

            // NFL Division mapping
            const divisions = {
                'AFC East': ['BUF', 'MIA', 'NE', 'NYJ'],
                'AFC North': ['BAL', 'CIN', 'CLE', 'PIT'],
                'AFC South': ['HOU', 'IND', 'JAC', 'TEN'],
                'AFC West': ['DEN', 'KC', 'LAC', 'LV'],
                'NFC East': ['DAL', 'NYG', 'PHI', 'WAS'],
                'NFC North': ['CHI', 'DET', 'GB', 'MIN'],
                'NFC South': ['ATL', 'CAR', 'NO', 'TB'],
                'NFC West': ['ARI', 'LAR', 'SF', 'SEA']
            };

            // Aggregate by team
            Object.values(allPlayers).forEach(player => {
                if (!teamStats[player.team]) {
                    teamStats[player.team] = {
                        team: player.team,
                        wrCount: 0,
                        rbCount: 0,
                        totalPoints: 0,
                        players: [],
                        totalTargets: 0,
                        totalRushAtts: 0,
                        totalGames: 0,
                        weeklyTargets: {}, // Track targets by week
                        weeklyRushAtts: {}, // Track rush attempts by week
                        weeklyRzOpps: {}, // Track RZ opportunities by week
                        totalRzOpps: 0
                    };
                }

                if (player.position === 'WR') {
                    teamStats[player.team].wrCount++;
                } else {
                    teamStats[player.team].rbCount++;
                }

                teamStats[player.team].totalPoints += player.totalPoints;
                teamStats[player.team].players.push(player);

                // Aggregate targets, rush attempts, and RZ opportunities by week
                player.weeks.forEach(week => {
                    const weekNum = week.week;

                    // Track targets (both WR and RB)
                    if (week.targets) {
                        if (!teamStats[player.team].weeklyTargets[weekNum]) {
                            teamStats[player.team].weeklyTargets[weekNum] = 0;
                        }
                        teamStats[player.team].weeklyTargets[weekNum] += week.targets;
                        teamStats[player.team].totalTargets += week.targets;
                    }

                    // Track rush attempts (RB only)
                    if (player.position === 'RB' && week.rushAttempts) {
                        if (!teamStats[player.team].weeklyRushAtts[weekNum]) {
                            teamStats[player.team].weeklyRushAtts[weekNum] = 0;
                        }
                        teamStats[player.team].weeklyRushAtts[weekNum] += week.rushAttempts;
                        teamStats[player.team].totalRushAtts += week.rushAttempts;
                    }

                    // Track RZ opportunities (use rzTargets for WR/TE, rzOpportunities for RB)
                    const rzField = player.position === 'RB' ? 'rzOpportunities' : 'rzTargets';
                    if (week[rzField]) {
                        if (!teamStats[player.team].weeklyRzOpps[weekNum]) {
                            teamStats[player.team].weeklyRzOpps[weekNum] = 0;
                        }
                        teamStats[player.team].weeklyRzOpps[weekNum] += week[rzField];
                        teamStats[player.team].totalRzOpps += week[rzField];
                    }
                });

                teamStats[player.team].totalGames = Math.max(
                    teamStats[player.team].totalGames,
                    player.weeks.length
                );
            });

            // Calculate averages and week-over-week changes for each team
            Object.values(teamStats).forEach(team => {
                // Find global max week
                let globalMaxWeek = 0;
                team.players.forEach(p => {
                    if (p.weeks && p.weeks.length > 0) {
                        const maxWeek = Math.max(...p.weeks.map(w => w.week));
                        if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                    }
                });

                // Calculate number of games (unique weeks with data)
                const uniqueWeeks = new Set();
                team.players.forEach(p => {
                    p.weeks.forEach(w => uniqueWeeks.add(w.week));
                });
                const numGames = uniqueWeeks.size;

                // Average targets per game
                team.avgTargetsPerGame = numGames > 0 ? team.totalTargets / numGames : 0;

                // Average rush attempts per game
                team.avgRushAttsPerGame = numGames > 0 ? team.totalRushAtts / numGames : 0;

                // Calculate week-over-week changes
                const lastWeek = globalMaxWeek;
                let prevWeek = globalMaxWeek - 1;

                // If team didn't play last week, look for the most recent week they did play
                let lastWeekTargets = team.weeklyTargets[lastWeek] || 0;
                let lastWeekRushAtts = team.weeklyRushAtts[lastWeek] || 0;

                // If no data for last week, find most recent week with data
                if (lastWeekTargets === 0 && lastWeekRushAtts === 0) {
                    for (let w = lastWeek - 1; w >= 1; w--) {
                        if (team.weeklyTargets[w] || team.weeklyRushAtts[w]) {
                            lastWeekTargets = team.weeklyTargets[w] || 0;
                            lastWeekRushAtts = team.weeklyRushAtts[w] || 0;
                            prevWeek = w - 1; // Compare to week before that
                            break;
                        }
                    }
                }

                const prevWeekTargets = team.weeklyTargets[prevWeek] || 0;
                const prevWeekRushAtts = team.weeklyRushAtts[prevWeek] || 0;

                team.targetsChange = prevWeekTargets > 0 ? lastWeekTargets - prevWeekTargets : 0;
                team.rushAttsChange = prevWeekRushAtts > 0 ? lastWeekRushAtts - prevWeekRushAtts : 0;

                // Calculate average points per game for Advanced Analytics
                team.avgPoints = numGames > 0 ? team.totalPoints / numGames : 0;
            });

            // Build HTML organized by division
            let html = '';
            let teamIndex = 0;

            Object.entries(divisions).forEach(([divisionName, teamCodes]) => {
                // Get teams in this division and sort by total points
                const divisionTeams = teamCodes
                    .map(code => teamStats[code])
                    .filter(team => team) // Filter out teams with no data
                    .sort((a, b) => b.totalPoints - a.totalPoints);

                if (divisionTeams.length === 0) return;

                // Division header
                html += `
                    <div style="grid-column: 1 / -1; margin-top: ${html ? '32px' : '0'};">
                        <h2 style="font-size: 18px; font-weight: 700; color: var(--text-primary); margin-bottom: 16px; padding-bottom: 8px; border-bottom: 2px solid var(--border-color);">
                            ${divisionName}
                        </h2>
                    </div>
                `;

                // Team cards for this division
                divisionTeams.forEach(team => {
                    const chartId = `team-chart-${teamIndex++}`;
                    html += `
                        <div class="team-card" onclick="openTeamModal('${team.team}')">
                            <div class="team-card-header">
                                <div class="team-card-badge" style="background: ${teamColors[team.team] || '#666'}">${team.team}</div>
                                <div class="team-card-name" style="font-weight: 700;">${team.team}</div>
                            </div>
                            <div class="team-card-stats">
                                <div class="team-stat">
                                    <span class="team-stat-label">Total Points</span>
                                    <span class="team-stat-value">${team.totalPoints.toFixed(1)}</span>
                                    <span class="stat-tooltip">Combined fantasy points from all WRs and RBs this season</span>
                                </div>
                                <div class="team-stat">
                                    <span class="team-stat-label">Avg Targets/Game</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="team-stat-value">${team.avgTargetsPerGame.toFixed(1)}</span>
                                        ${team.targetsChange !== 0 ? `
                                            <span class="player-comparison ${team.targetsChange > 0 ? 'comparison-up' : 'comparison-down'}">
                                                <span class="comparison-icon">${team.targetsChange > 0 ? '▲' : '▼'}</span>
                                                ${Math.abs(team.targetsChange).toFixed(1)}
                                            </span>
                                        ` : ''}
                                    </div>
                                    <span class="stat-tooltip">Average WR/RB targets per game (change vs last week)</span>
                                </div>
                                <div class="team-stat">
                                    <span class="team-stat-label">Avg Rush Atts/Game</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="team-stat-value">${team.avgRushAttsPerGame.toFixed(1)}</span>
                                        ${team.rushAttsChange !== 0 ? `
                                            <span class="player-comparison ${team.rushAttsChange > 0 ? 'comparison-up' : 'comparison-down'}">
                                                <span class="comparison-icon">${team.rushAttsChange > 0 ? '▲' : '▼'}</span>
                                                ${Math.abs(team.rushAttsChange).toFixed(1)}
                                            </span>
                                        ` : ''}
                                    </div>
                                    <span class="stat-tooltip">Average RB rush attempts per game (change vs last week)</span>
                                </div>
                            </div>
                            <div class="team-card-chart">
                                <canvas id="${chartId}"></canvas>
                            </div>
                        </div>
                    `;
                });
            });

            teamsGrid.innerHTML = html;

            // Now render charts for each team
            teamIndex = 0;
            Object.entries(divisions).forEach(([divisionName, teamCodes]) => {
                const divisionTeams = teamCodes
                    .map(code => teamStats[code])
                    .filter(team => team)
                    .sort((a, b) => b.totalPoints - a.totalPoints);

                divisionTeams.forEach(team => {
                    renderTeamCardChart(`team-chart-${teamIndex++}`, team);
                });
            });
        }

        function renderTeamCardChart(canvasId, team) {
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;

            // Get top 5 players by avg points
            const topPlayers = team.players
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 5);

            const labels = topPlayers.map(p => `${p.name} (${p.position})`);
            const data = topPlayers.map(p => p.avgPoints);

            // Generate color palette
            const teamColor = teamColors[team.team] || '#0a84ff';
            const colorPalette = getColorPalette(teamColor, topPlayers.length);

            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colorPalette,
                        borderColor: '#0a0a0a',
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => `${context.parsed.x.toFixed(1)} PPG`
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: false,
                            grid: { display: false }
                        },
                        y: {
                            ticks: {
                                color: '#8e8e93',
                                font: { size: 10 }
                            },
                            grid: { display: false }
                        }
                    }
                }
            });
        }

        function renderPlayerCardChart(canvasId, player, position) {
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;

            // Get weekly points data
            const weeks = player.weeks
                .sort((a, b) => a.week - b.week)
                .slice(-8); // Last 8 weeks

            const labels = weeks.map(w => `W${w.week}`);
            const actualData = weeks.map(w => w.fpts || 0);
            const expectedData = weeks.map(w => w.expectedFpts || 0);

            // Color based on team
            const teamColor = teamColors[player.team] || '#0a84ff';

            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Actual Points',
                            data: actualData,
                            borderColor: teamColor,
                            backgroundColor: teamColor + '33',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.3,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            pointBackgroundColor: teamColor,
                            pointBorderColor: '#fff',
                            pointBorderWidth: 1
                        },
                        {
                            label: 'Expected Points',
                            data: expectedData,
                            borderColor: '#8e8e93',
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false,
                            tension: 0.3,
                            pointRadius: 0,
                            pointHoverRadius: 4,
                            pointBackgroundColor: '#8e8e93',
                            pointBorderColor: '#fff',
                            pointBorderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: (context) => {
                                    const label = context.dataset.label || '';
                                    return `${label}: ${context.parsed.y.toFixed(1)} pts`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: '#8e8e93',
                                font: { size: 9 }
                            },
                            grid: { display: false }
                        },
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: '#8e8e93',
                                font: { size: 9 }
                            },
                            grid: {
                                color: '#1c1c1e'
                            }
                        }
                    }
                }
            });
        }

        function openTeamModal(teamCode) {
            const modal = document.getElementById('team-modal');
            modal.style.display = 'flex';

            // Get all players from this team
            const teamPlayers = Object.values(allPlayers).filter(p => p.team === teamCode);
            if (teamPlayers.length === 0) return;

            // Determine if WR or RB dominant team (or show both)
            const wrs = teamPlayers.filter(p => p.position === 'WR');
            const rbs = teamPlayers.filter(p => p.position === 'RB');
            const tes = teamPlayers.filter(p => p.position === 'TE');

            // Set header info
            document.getElementById('team-modal-badge').style.background = teamColors[teamCode] || '#666';
            document.getElementById('team-modal-badge').textContent = teamCode;
            document.getElementById('team-modal-name').textContent = `${teamCode} Team Analysis`;
            document.getElementById('team-modal-meta').textContent = `${wrs.length} WRs · ${rbs.length} RBs · ${tes.length} TEs`;

            // Calculate team stats
            const allTeamPlayers = [...wrs, ...rbs, ...tes];
            const totalPoints = allTeamPlayers.reduce((sum, p) => sum + (p.avgPoints * p.gamesPlayed), 0);
            const totalGames = allTeamPlayers.reduce((sum, p) => sum + p.gamesPlayed, 0);
            const avgPointsPerGame = totalGames > 0 ? totalPoints / totalGames : 0;

            const topPlayer = allTeamPlayers.sort((a, b) => b.avgPoints - a.avgPoints)[0];
            const topTargets = wrs.length > 0 ? Math.max(...wrs.map(w => w.totalTargets / w.gamesPlayed)) : 0;
            const topOpps = rbs.length > 0 ? Math.max(...rbs.map(r => r.totalOpportunities / r.gamesPlayed)) : 0;

            // Render team stats summary
            const statsHTML = `
                <div class="team-stat-card">
                    <div class="team-stat-value">${avgPointsPerGame.toFixed(1)}</div>
                    <div class="team-stat-label">Fantasy PPG</div>
                </div>
                <div class="team-stat-card">
                    <div class="team-stat-value">${topPlayer ? topPlayer.avgPoints.toFixed(1) : '0'}</div>
                    <div class="team-stat-label">Top Player PPG</div>
                </div>
                <div class="team-stat-card">
                    <div class="team-stat-value">${topTargets.toFixed(1)}</div>
                    <div class="team-stat-label">Top WR Targets</div>
                </div>
                <div class="team-stat-card">
                    <div class="team-stat-value">${topOpps.toFixed(1)}</div>
                    <div class="team-stat-label">Top RB Opps</div>
                </div>
            `;
            document.getElementById('team-stats-summary').innerHTML = statsHTML;

            // Render key players (top 4 by avg points)
            const keyPlayers = allTeamPlayers
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 4);

            const keyPlayersHTML = keyPlayers.map(player => {
                const posColor = getPositionColor(player.position);
                const statLabel = player.position === 'WR' || player.position === 'TE'
                    ? `${(player.totalTargets / player.gamesPlayed).toFixed(1)} tgts/g`
                    : `${(player.totalOpportunities / player.gamesPlayed).toFixed(1)} opps/g`;

                return `
                    <div class="key-player-card" onclick="openPlayerModal('${player.id.replace(/'/g, "\\'")}')">
                        <div class="key-player-position" style="background: ${posColor};">
                            ${player.position}
                        </div>
                        <div class="key-player-info">
                            <div class="key-player-name">${player.name}</div>
                            <div class="key-player-stat">${player.avgPoints.toFixed(1)} PPG · ${statLabel}</div>
                        </div>
                    </div>
                `;
            }).join('');

            document.getElementById('key-players-grid').innerHTML = keyPlayersHTML;

            // Store current team for chart updates
            window.currentTeamModalCode = teamCode;

            // Populate week selector
            const weeks = [...new Set([...wrData, ...rbData, ...(teData || [])].map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);
            const weekSelect = document.getElementById('team-modal-week');
            weekSelect.innerHTML = weeks.map(w => `<option value="${w}">Week ${w}</option>`).join('');
            if (weeks.length > 0) {
                weekSelect.value = weeks[weeks.length - 1]; // Default to latest week
            }

            // Set default timeframe to Season Long
            document.getElementById('team-modal-timeframe').value = 'season';

            // Render charts after modal is fully visible to ensure animations play
            // Using setTimeout ensures the browser has painted the modal and sized the canvas
            setTimeout(() => {
                updateTeamModalCharts();
            }, 50);

            // Reset key players to expanded state
            const playersSection = document.getElementById('key-players-section');
            const playersIcon = document.getElementById('team-players-collapse-icon');
            const playersText = document.getElementById('team-players-collapse-text');
            if (playersSection) {
                playersSection.style.display = '';
                playersIcon.textContent = '▼';
                playersText.textContent = 'Hide Players';
            }
        }

        function closeTeamModal() {
            document.getElementById('team-modal').style.display = 'none';
            if (window.teamModalPlayersChart) window.teamModalPlayersChart.destroy();
            if (window.teamModalPositionChart) window.teamModalPositionChart.destroy();
        }

        function updateTeamModalCharts() {
            const teamCode = window.currentTeamModalCode;
            if (!teamCode) return;

            const metric = document.getElementById('team-modal-metric').value;
            const timeframe = document.getElementById('team-modal-timeframe').value;
            const weekSelector = document.getElementById('team-modal-week-selector');
            const selectedWeek = parseInt(document.getElementById('team-modal-week').value);

            // Show/hide week selector based on timeframe
            if (timeframe === 'single') {
                weekSelector.style.display = 'block';
            } else {
                weekSelector.style.display = 'none';
            }

            // Get all weeks available
            const allWeeks = [...new Set([...wrData, ...rbData, ...(teData || [])].map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);
            const latestWeek = Math.max(...allWeeks);

            // Filter data based on timeframe
            let filteredWRData, filteredRBData, filteredTEData;

            if (timeframe === 'single') {
                filteredWRData = wrData.filter(row => row.Team === teamCode && parseInt(row.Week) === selectedWeek);
                filteredRBData = rbData.filter(row => row.Team === teamCode && parseInt(row.Week) === selectedWeek);
                filteredTEData = teData ? teData.filter(row => row.Team === teamCode && parseInt(row.Week) === selectedWeek) : [];
            } else if (timeframe === 'last3') {
                const startWeek = latestWeek - 2;
                filteredWRData = wrData.filter(row => row.Team === teamCode && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek);
                filteredRBData = rbData.filter(row => row.Team === teamCode && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek);
                filteredTEData = teData ? teData.filter(row => row.Team === teamCode && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek) : [];
            } else if (timeframe === 'last5') {
                const startWeek = latestWeek - 4;
                filteredWRData = wrData.filter(row => row.Team === teamCode && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek);
                filteredRBData = rbData.filter(row => row.Team === teamCode && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek);
                filteredTEData = teData ? teData.filter(row => row.Team === teamCode && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek) : [];
            } else { // season or season-avg
                filteredWRData = wrData.filter(row => row.Team === teamCode);
                filteredRBData = rbData.filter(row => row.Team === teamCode);
                filteredTEData = teData ? teData.filter(row => row.Team === teamCode) : [];
            }

            // Aggregate player data based on selected metric
            const playerData = {};

            // Process WRs
            filteredWRData.forEach(row => {
                const player = row.Player;
                if (!playerData[player]) {
                    playerData[player] = { name: player, position: 'WR', totalValue: 0, games: 0 };
                }

                let value = 0;
                if (metric === 'points') {
                    value = parseFloat(row.FPTS || row.Fpts) || 0;
                } else if (metric === 'targets') {
                    value = parseFloat(row.TGT) || 0;
                } else if (metric === 'redzone') {
                    const rzTargets = parseFloat(row.RZ_TGT || row['RZ TGT']) || 0;
                    value = rzTargets; // WRs only have RZ targets
                }

                playerData[player].totalValue += value;
                if (value > 0 || metric === 'points') playerData[player].games++;
            });

            // Process RBs
            filteredRBData.forEach(row => {
                const player = row.Player;
                if (!playerData[player]) {
                    playerData[player] = { name: player, position: 'RB', totalValue: 0, games: 0 };
                }

                let value = 0;
                if (metric === 'points') {
                    value = parseFloat(row.FPTS || row.Fpts) || 0;
                } else if (metric === 'targets') {
                    value = parseFloat(row.TGT) || 0;
                } else if (metric === 'redzone') {
                    const rzAtt = parseFloat(row.RZ_RUSH_ATT || row['RZ RUSH ATT']) || 0;
                    const rzTargets = parseFloat(row.RZ_TGT || row['RZ TGT']) || 0;
                    value = rzAtt + rzTargets;
                }

                playerData[player].totalValue += value;
                if (value > 0 || metric === 'points') playerData[player].games++;
            });

            // Process TEs
            filteredTEData.forEach(row => {
                const player = row.Player;
                if (!playerData[player]) {
                    playerData[player] = { name: player, position: 'TE', totalValue: 0, games: 0 };
                }

                let value = 0;
                if (metric === 'points') {
                    value = parseFloat(row.FPTS || row.Fpts) || 0;
                } else if (metric === 'targets') {
                    value = parseFloat(row.TGT) || 0;
                } else if (metric === 'redzone') {
                    const rzTargets = parseFloat(row.RZ_TGT || row['RZ TGT']) || 0;
                    value = rzTargets; // TEs only have RZ targets
                }

                playerData[player].totalValue += value;
                if (value > 0 || metric === 'points') playerData[player].games++;
            });

            // Convert to array and sort
            let players = Object.values(playerData);

            // If season-avg, calculate per game average
            if (timeframe === 'season-avg') {
                players = players.map(p => ({
                    ...p,
                    displayValue: p.games > 0 ? p.totalValue / p.games : 0
                }));
            } else {
                players = players.map(p => ({
                    ...p,
                    displayValue: p.totalValue
                }));
            }

            // Sort by displayValue and get top 6
            players.sort((a, b) => b.displayValue - a.displayValue);
            const top6Players = players.slice(0, 6);

            // Calculate position totals
            const positionTotals = {
                WR: 0,
                RB: 0,
                TE: 0
            };

            players.forEach(p => {
                if (timeframe === 'season-avg') {
                    positionTotals[p.position] += p.displayValue;
                } else {
                    positionTotals[p.position] += p.totalValue;
                }
            });

            // Update chart headers based on metric
            let metricLabel = '';
            if (metric === 'points') metricLabel = 'Points';
            else if (metric === 'targets') metricLabel = 'Targets';
            else if (metric === 'redzone') metricLabel = 'Red Zone Opps';

            document.getElementById('team-modal-players-chart-header').textContent = `Top 6 Players by ${metricLabel}`;
            document.getElementById('team-modal-position-chart-header').textContent = `${metricLabel} by Position`;

            // Render charts
            renderTeamModalPlayersChart(top6Players, teamCode, timeframe, metric);
            renderTeamModalPositionChart(positionTotals, teamCode, timeframe, metric);
        }

        function renderTeamModalPlayersChart(players, teamCode, timeframe, metric) {
            const ctx = document.getElementById('team-modal-players-chart');
            if (!ctx) return;

            // Destroy existing chart
            if (window.teamModalPlayersChart) {
                window.teamModalPlayersChart.destroy();
            }

            const teamColor = teamColors[teamCode] || '#0a84ff';
            const colorPalette = getColorPalette(teamColor, 6);

            const labels = players.map(p => p.name);
            const data = players.map(p => p.displayValue);
            const positions = players.map(p => p.position);

            const isAvg = timeframe === 'season-avg';
            const yAxisLabel = isAvg ? 'Points Per Game' : 'Total Points';

            window.teamModalPlayersChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colorPalette,
                        borderColor: colorPalette.map(c => c),
                        borderWidth: 0
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const pos = positions[context.dataIndex];
                                    const val = context.parsed.x.toFixed(1);
                                    return `${pos} - ${val} ${isAvg ? 'PPG' : 'pts'}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: yAxisLabel,
                                color: '#8e8e93',
                                font: { size: 11 }
                            },
                            ticks: {
                                color: '#8e8e93',
                                font: { size: 10 }
                            },
                            grid: {
                                color: '#1c1c1e'
                            }
                        },
                        y: {
                            ticks: {
                                color: '#ffffff',
                                font: { size: 11, weight: '600' }
                            },
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });
        }

        function renderTeamModalPositionChart(positionTotals, teamCode, timeframe, metric) {
            const ctx = document.getElementById('team-modal-position-chart');
            if (!ctx) return;

            // Destroy existing chart
            if (window.teamModalPositionChart) {
                window.teamModalPositionChart.destroy();
            }

            const positions = ['WR', 'RB', 'TE'];
            const data = positions.map(pos => positionTotals[pos]);
            const total = data.reduce((sum, val) => sum + val, 0);

            const colors = {
                WR: '#0a84ff',
                RB: '#30d158',
                TE: '#ff9500'
            };

            // Create transparent fills (45% opacity) and solid borders
            const backgroundColors = positions.map(pos => {
                const color = colors[pos];
                const r = parseInt(color.slice(1, 3), 16);
                const g = parseInt(color.slice(3, 5), 16);
                const b = parseInt(color.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, 0.45)`;
            });

            const borderColors = positions.map(pos => colors[pos]);

            const isAvg = timeframe === 'season-avg';

            window.teamModalPositionChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: positions,
                    datasets: [{
                        data: data,
                        backgroundColor: backgroundColors,
                        borderColor: borderColors,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        animateRotate: true,
                        animateScale: true,
                        duration: 1200,
                        easing: 'easeInOutQuart'
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: '#ffffff',
                                padding: 12,
                                font: { size: 12, weight: 'bold' },
                                generateLabels: (chart) => {
                                    const data = chart.data;
                                    return data.labels.map((label, i) => {
                                        const value = data.datasets[0].data[i];
                                        const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                        return {
                                            text: `${label}: ${value.toFixed(1)} ${isAvg ? 'PPG' : 'pts'} (${percentage}%)`,
                                            fillStyle: data.datasets[0].backgroundColor[i],
                                            fontColor: '#ffffff',
                                            hidden: false,
                                            index: i
                                        };
                                    });
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const value = context.parsed;
                                    const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                    return `${context.label}: ${value.toFixed(1)} ${isAvg ? 'PPG' : 'pts'} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        /* OLD TEAM MODAL CHART FUNCTIONS - NO LONGER USED
        function renderTeamModalShareChart(teamCode, position) {
            // Removed - replaced with renderTeamModalPlayersChart and renderTeamModalPositionChart
        }

        function renderTeamModalTrendsChart(teamCode, position) {
            // Removed - replaced with renderTeamModalPlayersChart and renderTeamModalPositionChart
        }
        */

        // 4. CHARTS

        function renderScatterPlots() {
            // Only render team scatter - WR/RB charts are lazy loaded
            renderTeamBalanceScatter();
            initializeTeamAnalysis();
        }

        // Matrix switching functions
        function switchMatrix(matrixType) {
            // Update button states
            document.querySelectorAll('.matrix-tab').forEach(btn => {
                btn.classList.remove('active');
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.color = 'var(--text-secondary)';
            });
            event.target.classList.add('active');
            event.target.style.background = 'var(--positive)';
            event.target.style.color = 'white';

            // Show correct section
            document.querySelectorAll('.matrix-section').forEach(section => {
                section.style.display = 'none';
            });
            document.getElementById(matrixType).style.display = 'block';
        }

        function switchWRMatrix(chartType) {
            // Update button states
            document.querySelectorAll('.wr-matrix-tab').forEach(btn => {
                btn.classList.remove('active');
                btn.style.color = 'var(--text-secondary)';
                btn.style.borderBottomColor = 'transparent';
            });
            event.target.classList.add('active');
            event.target.style.color = 'var(--text-primary)';
            event.target.style.borderBottomColor = 'var(--positive)';

            // Show correct chart with animation
            document.querySelectorAll('.wr-matrix-content').forEach(content => {
                content.style.display = 'none';
            });
            const targetChart = document.getElementById(`wr-matrix-${chartType}`);
            targetChart.style.display = 'block';
            targetChart.style.animation = 'fadeIn 0.3s ease';
        }

        function switchRBMatrix(chartType) {
            // Update button states
            document.querySelectorAll('.rb-matrix-tab').forEach(btn => {
                btn.classList.remove('active');
                btn.style.color = 'var(--text-secondary)';
                btn.style.borderBottomColor = 'transparent';
            });
            event.target.classList.add('active');
            event.target.style.color = 'var(--text-primary)';
            event.target.style.borderBottomColor = 'var(--positive)';

            // Show correct chart with animation
            document.querySelectorAll('.rb-matrix-content').forEach(content => {
                content.style.display = 'none';
            });
            const targetChart = document.getElementById(`rb-matrix-${chartType}`);
            targetChart.style.display = 'block';
            targetChart.style.animation = 'fadeIn 0.3s ease';
        }

        function switchMatrixChart(chartType) {
            // Update button states in current section
            const activeSection = document.querySelector('.matrix-section:not([style*="display: none"])');
            activeSection.querySelectorAll('.matrix-chart-tab').forEach(btn => {
                btn.classList.remove('active');
                btn.style.color = 'var(--text-secondary)';
                btn.style.borderBottomColor = 'transparent';
            });
            event.target.classList.add('active');
            event.target.style.color = 'var(--text-primary)';
            event.target.style.borderBottomColor = 'var(--positive)';

            // Show correct chart
            activeSection.querySelectorAll('.matrix-chart-content').forEach(content => {
                content.style.display = 'none';
            });
            activeSection.querySelector(`#matrix-${chartType}`).style.display = 'block';
        }

        function renderMatrices() {
            // WR Matrices
            renderEfficiencyMatrix('wr');
            renderShareMatrix('wr');
            renderFloorMatrix('wr');
            renderVolumeMonsterMatrix();
            renderCatchRateMatrix();
            renderRedzoneMatrix('wr');

            // RB Matrices
            renderEfficiencyMatrix('rb');
            renderTalentSituationMatrix();
            renderOpportunityEfficiencyMatrix();
            renderShareMatrix('rb');
            renderFloorMatrix('rb');
            renderRedzoneMatrix('rb');
        }

        // Matrix 1: Efficiency vs Volume
        function renderEfficiencyMatrix(position) {
            const canvasId = position === 'wr' ? 'wr-efficiency-matrix' : 'rb-efficiency-matrix';
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;

            const players = position === 'wr' ?
                Object.values(aggregatedWRs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50) :
                Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);

            const data = players.map(player => {
                const volume = position === 'wr' ? player.totalTargets : player.totalOpportunities;
                const efficiency = player.avgPoints / (volume / player.gamesPlayed); // Points per opportunity per game

                return {
                    x: volume,
                    y: efficiency,
                    label: player.name,
                    player: player
                };
            });

            // Calculate medians for quadrant lines
            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];

            const chartVar = position === 'wr' ? 'wrEfficiencyMatrix' : 'rbEfficiencyMatrix';
            if (window[chartVar]) {
                window[chartVar].destroy();
            }

            window[chartVar] = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: position.toUpperCase() + 's',
                            data: data,
                            backgroundColor: data.map(d => {
                                const color = teamColors[d.player.team] || '#666';
                                const r = parseInt(color.slice(1, 3), 16);
                                const g = parseInt(color.slice(3, 5), 16);
                                const b = parseInt(color.slice(5, 7), 16);
                                return `rgba(${r}, ${g}, ${b}, 0.6)`;
                            }),
                            borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                            borderWidth: 2,
                            pointRadius: 8,
                            pointHoverRadius: 10,
                            pointStyle: 'circle',
                            pointBorderWidth: 2,
                            shadowOffsetX: 0,
                            shadowOffsetY: 0,
                            shadowBlur: 12,
                            shadowColor: data.map(d => teamColors[d.player.team] || '#666')
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const player = data[elements[0].index].player;
                            openPlayerModal(player.id);
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const player = context.raw.player;
                                    return [
                                        player.name,
                                        `Volume: ${context.parsed.x.toFixed(0)}`,
                                        `Efficiency: ${context.parsed.y.toFixed(2)} pts/opp`,
                                        `AVG: ${player.avgPoints.toFixed(1)}`
                                    ];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                vLine: {
                                    type: 'line',
                                    xMin: medianX,
                                    xMax: medianX,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                hLine: {
                                    type: 'line',
                                    yMin: medianY,
                                    yMax: medianY,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                topRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: [position === 'wr' ? 'Safe Floor' : 'Volume RBs'],
                                    color: '#FFD60A',
                                    font: { size: 9, weight: 'bold' }
                                },
                                topLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: ['Efficient'],
                                    color: '#0a84ff',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: [''],
                                    color: '#FFD60A',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: [''],
                                    color: '#ff453a',
                                    font: { size: 9, weight: 'bold' }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: position === 'wr' ? 'Total Targets →' : 'Total Opportunities →',
                                color: '#8e8e93',
                                font: { weight: 'bold' }
                            },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianX) < 1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Efficiency (Points per Opportunity) →',
                                color: '#8e8e93',
                                font: { weight: 'bold' }
                            },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianY) < 0.1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }

        // Matrix 2: Share vs Team Strength
        function renderShareMatrix(position) {
            const canvasId = position === 'wr' ? 'wr-share-matrix' : 'rb-share-matrix';
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;

            const players = position === 'wr' ?
                Object.values(aggregatedWRs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50) :
                Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);

            // Calculate team total points
            const teamTotals = {};
            Object.values(allPlayers).forEach(p => {
                if (!teamTotals[p.team]) teamTotals[p.team] = 0;
                teamTotals[p.team] += p.totalPoints;
            });

            const data = players.map(player => ({
                x: player.latestWeekOppShare,
                y: teamTotals[player.team] || 0,
                label: player.name,
                player: player
            }));

            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];

            const chartVar = position === 'wr' ? 'wrShareMatrix' : 'rbShareMatrix';
            if (window[chartVar]) window[chartVar].destroy();

            window[chartVar] = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(d => {
                            const color = teamColors[d.player.team] || '#666';
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, 0.6)`;
                        }),
                        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            openPlayerModal(data[elements[0].index].player.id);
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    return [p.name, `Share: ${context.parsed.x.toFixed(1)}%`, `Team Total: ${context.parsed.y.toFixed(0)}`, `AVG: ${p.avgPoints.toFixed(1)}`];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                vLine: {
                                    type: 'line',
                                    xMin: medianX,
                                    xMax: medianX,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                hLine: {
                                    type: 'line',
                                    yMin: medianY,
                                    yMax: medianY,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                topRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: [position === 'rb' ? 'Elite RB1' : ''],
                                    color: '#30d158',
                                    font: { size: 9, weight: 'bold' }
                                },
                                topLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: [position === 'wr' ? 'Big piece of small pie' : 'Good offense low share'],
                                    color: position === 'wr' ? '#FFD60A' : '#0a84ff',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: [position === 'wr' ? 'Small piece of big pie' : 'Bellcow, bad offense'],
                                    color: position === 'wr' ? '#0a84ff' : '#FFD60A',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: [position === 'wr' ? 'Limited role on bad offense' : 'Avoid'],
                                    color: '#ff453a',
                                    font: { size: 9, weight: 'bold' }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Opportunity Share % →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianX) < 1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: { display: true, text: 'Team Total Points →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianY) < 1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }

        // Matrix 3: Floor vs Ceiling
        function renderFloorMatrix(position) {
            const canvasId = position === 'wr' ? 'wr-floor-matrix' : 'rb-floor-matrix';
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;

            const players = position === 'wr' ?
                Object.values(aggregatedWRs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50) :
                Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);

            const data = players.map(player => {
                const variances = player.weeks.map(w => w.variance);
                const stdDev = Math.sqrt(variances.reduce((sum, v) => sum + Math.pow(v, 2), 0) / variances.length);
                const consistency = 10 / (stdDev + 1); // Higher is more consistent

                return {
                    x: player.avgPoints,
                    y: consistency,
                    label: player.name,
                    player: player,
                    stdDev: stdDev
                };
            });

            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];

            const chartVar = position === 'wr' ? 'wrFloorMatrix' : 'rbFloorMatrix';
            if (window[chartVar]) window[chartVar].destroy();

            window[chartVar] = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(d => {
                            const color = teamColors[d.player.team] || '#666';
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, 0.6)`;
                        }),
                        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            openPlayerModal(data[elements[0].index].player.id);
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const d = data[context.dataIndex];
                                    return [d.player.name, `Ceiling: ${context.parsed.x.toFixed(1)}`, `Floor Score: ${context.parsed.y.toFixed(1)}`, `Std Dev: ${d.stdDev.toFixed(2)}`];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                vLine: {
                                    type: 'line',
                                    xMin: medianX,
                                    xMax: medianX,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                hLine: {
                                    type: 'line',
                                    yMin: medianY,
                                    yMax: medianY,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Average Points (Ceiling) →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianX) < 1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: { display: true, text: 'Consistency Score (Floor) →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianY) < 0.1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }

        // Matrix 4: Red Zone Usage vs Efficiency
        function renderRedzoneMatrix(position) {
            const canvasId = position === 'wr' ? 'wr-redzone-matrix' : 'rb-redzone-matrix';
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;

            const players = position === 'wr' ?
                Object.values(aggregatedWRs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50) :
                Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);

            const data = players.map(player => {
                let xValue, yValue;

                if (position === 'wr') {
                    // NEW: Total Targets (x) vs RZ Targets (y)
                    xValue = player.totalTargets;
                    yValue = player.rzOpportunities;
                } else {
                    // RB: Keep existing (RZ opps per game vs PPG)
                    xValue = player.rzOpportunities / player.gamesPlayed; // RZ opps per game
                    yValue = player.avgPoints / player.gamesPlayed; // Points per game
                }

                return {
                    x: xValue,
                    y: yValue,
                    label: player.name,
                    player: player
                };
            });

            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];

            const chartVar = position === 'wr' ? 'wrRedzoneMatrix' : 'rbRedzoneMatrix';
            if (window[chartVar]) window[chartVar].destroy();

            window[chartVar] = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(d => {
                            const color = teamColors[d.player.team] || '#666';
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, 0.6)`;
                        }),
                        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            openPlayerModal(data[elements[0].index].player.id);
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    if (position === 'wr') {
                                        return [p.name, `Total Targets: ${context.parsed.x}`, `RZ Targets: ${context.parsed.y}`, `AVG: ${p.avgPoints.toFixed(1)}`];
                                    } else {
                                        return [p.name, `RZ/Game: ${context.parsed.x.toFixed(1)}`, `PPG: ${context.parsed.y.toFixed(1)}`, `Total RZ: ${p.rzOpportunities}`];
                                    }
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                vLine: {
                                    type: 'line',
                                    xMin: medianX,
                                    xMax: medianX,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                hLine: {
                                    type: 'line',
                                    yMin: medianY,
                                    yMax: medianY,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                topRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: ['Elite RZ usage'],
                                    color: '#30d158',
                                    font: { size: 13, weight: 'bold' }
                                },
                                topLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.2,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: position === 'wr' ? ['High scoring low RZ'] : ['Efficient but no RZ'],
                                    color: '#0a84ff',
                                    font: { size: 13, weight: 'bold' }
                                },
                                bottomRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.min(...yValues) + (Math.max(...yValues) - Math.min(...yValues)) * 0.15,
                                    content: position === 'rb' ? ['Buy low candidates'] : [''],
                                    color: '#FFD60A',
                                    font: { size: 13, weight: 'bold' }
                                },
                                bottomLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.2,
                                    yValue: Math.min(...yValues) + (Math.max(...yValues) - Math.min(...yValues)) * 0.15,
                                    content: ['Low production'],
                                    color: '#ff453a',
                                    font: { size: 13, weight: 'bold' }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: position === 'wr' ? 'Total Targets →' : 'Red Zone Opportunities per Game →',
                                color: '#8e8e93',
                                font: { weight: 'bold' }
                            },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianX) < 0.1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: position === 'wr' ? 'Red Zone Targets →' : 'Total Fantasy Points per Game →',
                                color: '#8e8e93',
                                font: { weight: 'bold' }
                            },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianY) < 1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }

        // WR-Specific Matrix: Volume Monster (Target Share vs Targets per Game)
        function renderVolumeMonsterMatrix() {
            const ctx = document.getElementById('wr-volume-monster-matrix');
            if (!ctx) return;

            const wrs = Object.values(aggregatedWRs)
                .filter(p => p.gamesPlayed >= 3)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 50);

            const data = wrs.map(player => ({
                x: player.latestWeekOppShare,
                y: player.tgtPerGame,
                label: player.name,
                player: player
            }));

            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];

            if (wrVolumeMonsterMatrix) wrVolumeMonsterMatrix.destroy();

            wrVolumeMonsterMatrix = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(d => {
                            const color = teamColors[d.player.team] || '#666';
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, 0.6)`;
                        }),
                        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
                    onClick: (event, elements) => {
                        if (elements.length > 0) openPlayerModal(data[elements[0].index].player.id);
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    return [p.name, `Target Share: ${context.parsed.x.toFixed(1)}%`, `TGT/G: ${context.parsed.y.toFixed(1)}`, `AVG: ${p.avgPoints.toFixed(1)}`];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                vLine: {
                                    type: 'line',
                                    xMin: medianX,
                                    xMax: medianX,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                hLine: {
                                    type: 'line',
                                    yMin: medianY,
                                    yMax: medianY,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                topRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: ['Volume Monster'],
                                    color: '#30d158',
                                    font: { size: 9, weight: 'bold' }
                                },
                                topLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: ['High Volume, Low Share'],
                                    color: '#0a84ff',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: ['Concentrated Targets'],
                                    color: '#FFD60A',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: ['Limited Role'],
                                    color: '#ff453a',
                                    font: { size: 9, weight: 'bold' }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Target Share % (Latest Week) →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: { display: true, text: 'Targets per Game →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }

        // WR-Specific Matrix: Catch Rate (Air Yards per Game vs Catch Rate)
        function renderCatchRateMatrix() {
            const ctx = document.getElementById('wr-catch-rate-matrix');
            if (!ctx) return;

            const wrs = Object.values(aggregatedWRs)
                .filter(p => p.gamesPlayed >= 3)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 50);

            const data = wrs.map(player => ({
                x: player.airYardsPerGame,
                y: player.catchRate,
                label: player.name,
                player: player
            }));

            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];

            if (wrCatchRateMatrix) wrCatchRateMatrix.destroy();

            wrCatchRateMatrix = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(d => {
                            const color = teamColors[d.player.team] || '#666';
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, 0.6)`;
                        }),
                        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
                    onClick: (event, elements) => {
                        if (elements.length > 0) openPlayerModal(data[elements[0].index].player.id);
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    return [p.name, `Air Yds/G: ${context.parsed.x.toFixed(1)}`, `Catch Rate: ${context.parsed.y.toFixed(1)}%`, `AVG: ${p.avgPoints.toFixed(1)}`];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                vLine: {
                                    type: 'line',
                                    xMin: medianX,
                                    xMax: medianX,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                hLine: {
                                    type: 'line',
                                    yMin: medianY,
                                    yMax: medianY,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                topRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: ['Deep Threats'],
                                    color: '#30d158',
                                    font: { size: 9, weight: 'bold' }
                                },
                                topLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: ['Reliable Hands'],
                                    color: '#0a84ff',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: ['Contested Catches'],
                                    color: '#FFD60A',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: ['Drop Issues'],
                                    color: '#ff453a',
                                    font: { size: 9, weight: 'bold' }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Air Yards per Game →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: { display: true, text: 'Catch Rate % →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }

        // RB-Specific Matrix: Talent vs Situation (YBCON vs YACON)
        function renderTalentSituationMatrix() {
            const ctx = document.getElementById('rb-talent-matrix');
            if (!ctx) return;

            const rbs = Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);

            const data = rbs.map(player => {
                const playerRows = rbData.filter(row => row.Team === player.team && row.Player === player.name);
                let totalYBCON = 0, totalYACON = 0, totalATT = 0;
                playerRows.forEach(row => {
                    totalYBCON += parseFloat(row.YBCON) || 0;
                    totalYACON += parseFloat(row.YACON) || 0;
                    totalATT += parseFloat(row.ATT) || 0;
                });
                return {
                    x: totalATT > 0 ? totalYBCON / totalATT : 0,
                    y: totalATT > 0 ? totalYACON / totalATT : 0,
                    label: player.name,
                    player: player
                };
            });

            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];

            if (rbTalentMatrix) rbTalentMatrix.destroy();

            rbTalentMatrix = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(d => {
                            const color = teamColors[d.player.team] || '#666';
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, 0.6)`;
                        }),
                        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) openPlayerModal(data[elements[0].index].player.id);
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    return [p.name, `YBCON/ATT: ${context.parsed.x.toFixed(2)}`, `YACON/ATT: ${context.parsed.y.toFixed(2)}`, `AVG: ${p.avgPoints.toFixed(1)}`];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Yards Before Contact per Attempt (O-Line Quality) →', color: '#8e8e93' },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: { display: true, text: 'Yards After Contact per Attempt (RB Talent) →', color: '#8e8e93' },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                },
                plugins: [{
                    id: 'quadrantLabels',
                    afterDraw: (chart) => {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const xAxis = chart.scales.x;
                        const yAxis = chart.scales.y;
                        const xMid = xAxis.getPixelForValue(medianX);
                        const yMid = yAxis.getPixelForValue(medianY);

                        // Draw dotted median lines (2px thick)
                        ctx.strokeStyle = '#8e8e93';
                        ctx.setLineDash([5, 5]);
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(xMid, chartArea.top);
                        ctx.lineTo(xMid, chartArea.bottom);
                        ctx.moveTo(chartArea.left, yMid);
                        ctx.lineTo(chartArea.right, yMid);
                        ctx.stroke();
                        ctx.setLineDash([]);

                        // Add corner labels (9px font, colored)
                        ctx.font = 'bold 9px -apple-system, BlinkMacSystemFont, sans-serif';

                        // Top-right: Elite Situation + Talent (GREEN)
                        ctx.fillStyle = '#30d158';
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'top';
                        ctx.fillText('Elite', chartArea.right - 5, chartArea.top + 5);

                        // Top-left: Elite Talent (BLUE)
                        ctx.fillStyle = '#0a84ff';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        ctx.fillText('Elite Talent', chartArea.left + 5, chartArea.top + 5);

                        // Bottom-right: Elite Situation (YELLOW)
                        ctx.fillStyle = '#FFD60A';
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'bottom';
                        ctx.fillText('Elite Situation', chartArea.right - 5, chartArea.bottom - 5);

                        // Bottom-left: Avoid (RED)
                        ctx.fillStyle = '#ff453a';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'bottom';
                        ctx.fillText('Avoid', chartArea.left + 5, chartArea.bottom - 5);
                    }
                }]
            });
        }

        // RB-Specific Matrix: Opportunity vs Efficiency (Touch Share vs YAC)
        function renderOpportunityEfficiencyMatrix() {
            const ctx = document.getElementById('rb-opportunity-matrix');
            if (!ctx) return;

            const rbs = Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);

            const data = rbs.map(player => {
                const playerRows = rbData.filter(row => row.Team === player.team && row.Player === player.name);
                let totalYACON = 0, totalATT = 0;
                playerRows.forEach(row => {
                    totalYACON += parseFloat(row.YACON) || 0;
                    totalATT += parseFloat(row.ATT) || 0;
                });
                return {
                    x: player.latestWeekOppShare,
                    y: totalATT > 0 ? totalYACON / totalATT : 0,
                    label: player.name,
                    player: player
                };
            });

            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];

            if (rbOpportunityMatrix) rbOpportunityMatrix.destroy();

            rbOpportunityMatrix = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(d => {
                            const color = teamColors[d.player.team] || '#666';
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, 0.6)`;
                        }),
                        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) openPlayerModal(data[elements[0].index].player.id);
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    return [p.name, `Touch Share: ${context.parsed.x.toFixed(1)}%`, `YAC/ATT: ${context.parsed.y.toFixed(2)}`, `AVG: ${p.avgPoints.toFixed(1)}`];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Touch Share % →', color: '#8e8e93' },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: { display: true, text: 'Yards After Contact per Attempt →', color: '#8e8e93' },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                },
                plugins: [{
                    id: 'quadrantLabels',
                    afterDraw: (chart) => {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const xAxis = chart.scales.x;
                        const yAxis = chart.scales.y;
                        const xMid = xAxis.getPixelForValue(medianX);
                        const yMid = yAxis.getPixelForValue(medianY);

                        // Draw dotted median lines (2px thick)
                        ctx.strokeStyle = '#8e8e93';
                        ctx.setLineDash([5, 5]);
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(xMid, chartArea.top);
                        ctx.lineTo(xMid, chartArea.bottom);
                        ctx.moveTo(chartArea.left, yMid);
                        ctx.lineTo(chartArea.right, yMid);
                        ctx.stroke();
                        ctx.setLineDash([]);

                        // Add corner labels (9px font, colored)
                        ctx.font = 'bold 9px -apple-system, BlinkMacSystemFont, sans-serif';

                        // Top-right: Elite (GREEN)
                        ctx.fillStyle = '#30d158';
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'top';
                        ctx.fillText('Elite', chartArea.right - 5, chartArea.top + 5);

                        // Top-left: Inefficient Volume (BLUE)
                        ctx.fillStyle = '#0a84ff';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        ctx.fillText('Inefficient', chartArea.left + 5, chartArea.top + 5);

                        // Bottom-right: Boom-Bust (YELLOW)
                        ctx.fillStyle = '#FFD60A';
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'bottom';
                        ctx.fillText('Boom-Bust', chartArea.right - 5, chartArea.bottom - 5);

                        // Bottom-left: Fade (RED)
                        ctx.fillStyle = '#ff453a';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'bottom';
                        ctx.fillText('Fade', chartArea.left + 5, chartArea.bottom - 5);
                    }
                }]
            });
        }

        function renderWRScatter() {
            const ctx = document.getElementById('wr-scatter-chart');
            if (!ctx) return;

            // Get top 36 WRs by avg points
            const wrs = Object.values(aggregatedWRs)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 50);

            const data = wrs.map(player => ({
                x: player.totalTargets,
                y: player.rzOpportunities,
                label: player.name,
                player: player
            }));

            // Calculate linear regression for diagonal trendline
            const regression = calculateLinearRegression(data);
            const minX = Math.min(...data.map(d => d.x));
            const maxX = Math.max(...data.map(d => d.x));
            const trendlineData = [
                { x: minX, y: regression.slope * minX + regression.intercept },
                { x: maxX, y: regression.slope * maxX + regression.intercept }
            ];

            if (wrScatterChart) {
                wrScatterChart.destroy();
            }

            wrScatterChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Wide Receivers',
                            data: data,
                            backgroundColor: data.map(d => {
                                const color = teamColors[d.player.team] || '#666';
                                // Convert hex to rgba with 0.3 opacity
                                const r = parseInt(color.slice(1, 3), 16);
                                const g = parseInt(color.slice(3, 5), 16);
                                const b = parseInt(color.slice(5, 7), 16);
                                return `rgba(${r}, ${g}, ${b}, 0.6)`;
                            }),
                            borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                            borderWidth: 2,
                            pointRadius: 8,
                            pointHoverRadius: 10
                        },
                        {
                            label: 'Trendline',
                            type: 'line',
                            data: trendlineData,
                            borderColor: '#FFD60A',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0 && elements[0].datasetIndex === 0) {
                            const index = elements[0].index;
                            const player = data[index].player;
                            openPlayerModal(player.id);
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.datasetIndex === 1) return 'Trendline';
                                    const player = context.raw.player;
                                    return [
                                        player.name,
                                        `Targets: ${player.totalTargets}`,
                                        `RZ Targets: ${player.rzOpportunities}`,
                                        `AVG: ${player.avgPoints.toFixed(1)}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Total Season Targets',
                                color: '#8e8e93'
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Red Zone Targets',
                                color: '#8e8e93'
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });

            // Add labels for top 8 players
            const chartArea = wrScatterChart.chartArea;
            const ctx2d = wrScatterChart.ctx;

            wrs.slice(0, 8).forEach((player, idx) => {
                const meta = wrScatterChart.getDatasetMeta(0);
                const point = meta.data[idx];
                if (point && chartArea) {
                    ctx2d.save();
                    ctx2d.fillStyle = '#fff';
                    ctx2d.font = '11px -apple-system, sans-serif';
                    ctx2d.textAlign = 'center';
                    ctx2d.fillText(player.name.split(' ').pop(), point.x, point.y - 12);
                    ctx2d.restore();
                }
            });
        }

        function renderRBScatter() {
            const ctx = document.getElementById('rb-scatter-chart');
            if (!ctx) return;

            // Get top 36 RBs by avg points
            const rbs = Object.values(aggregatedRBs)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 50);

            const data = rbs.map(player => ({
                x: player.totalOpportunities,
                y: player.rzOpportunities,
                label: player.name,
                player: player
            }));

            // Calculate linear regression for diagonal trendline
            const regression = calculateLinearRegression(data);
            const minX = Math.min(...data.map(d => d.x));
            const maxX = Math.max(...data.map(d => d.x));
            const trendlineData = [
                { x: minX, y: regression.slope * minX + regression.intercept },
                { x: maxX, y: regression.slope * maxX + regression.intercept }
            ];

            if (rbScatterChart) {
                rbScatterChart.destroy();
            }

            rbScatterChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Running Backs',
                            data: data,
                            backgroundColor: data.map(d => {
                                const color = teamColors[d.player.team] || '#666';
                                // Convert hex to rgba with 0.3 opacity
                                const r = parseInt(color.slice(1, 3), 16);
                                const g = parseInt(color.slice(3, 5), 16);
                                const b = parseInt(color.slice(5, 7), 16);
                                return `rgba(${r}, ${g}, ${b}, 0.6)`;
                            }),
                            borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                            borderWidth: 2,
                            pointRadius: 8,
                            pointHoverRadius: 10
                        },
                        {
                            label: 'Trendline',
                            type: 'line',
                            data: trendlineData,
                            borderColor: '#FFD60A',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0 && elements[0].datasetIndex === 0) {
                            const index = elements[0].index;
                            const player = data[index].player;
                            openPlayerModal(player.id);
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.datasetIndex === 1) return 'Trendline';
                                    const player = context.raw.player;
                                    return [
                                        player.name,
                                        `Opportunities: ${player.totalOpportunities}`,
                                        `RZ Opportunities: ${player.rzOpportunities}`,
                                        `AVG: ${player.avgPoints.toFixed(1)}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Total Season Opportunities',
                                color: '#8e8e93'
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Red Zone Opportunities',
                                color: '#8e8e93'
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });

            // Add labels for top 8 players
            const chartArea = rbScatterChart.chartArea;
            const ctx2d = rbScatterChart.ctx;

            rbs.slice(0, 8).forEach((player, idx) => {
                const meta = rbScatterChart.getDatasetMeta(0);
                const point = meta.data[idx];
                if (point && chartArea) {
                    ctx2d.save();
                    ctx2d.fillStyle = '#fff';
                    ctx2d.font = '11px -apple-system, sans-serif';
                    ctx2d.textAlign = 'center';
                    ctx2d.fillText(player.name.split(' ').pop(), point.x, point.y - 12);
                    ctx2d.restore();
                }
            });
        }

        function renderTeamBalanceScatter(highlightTeam = null) {
            const ctx = document.getElementById('team-balance-scatter');
            if (!ctx) {                return;
            }
            if (!wrData || !rbData) {                return;
            }

            // Destroy existing chart if it exists
            const existingChart = Chart.getChart(ctx);
            if (existingChart) {
                existingChart.destroy();
            }

            // Aggregate team data (all weeks combined for season totals)
            const teamData = {};

            // Calculate total targets and points per team from WR data (exclude FA)
            wrData.forEach(row => {
                const team = row.Team;
                if (team === 'FA' || !team) return;
                if (!teamData[team]) {
                    teamData[team] = { team: team, targets: 0, rushOpps: 0, totalPoints: 0 };
                }
                teamData[team].targets += parseFloat(row.TGT) || 0;
                teamData[team].totalPoints += parseFloat(row.FPTS || row.Fpts) || 0; // Handle both cases
            });

            // Calculate total rush opportunities and points per team from RB data (exclude FA)
            rbData.forEach(row => {
                const team = row.Team;
                if (team === 'FA' || !team) return;
                if (!teamData[team]) {
                    teamData[team] = { team: team, targets: 0, rushOpps: 0, totalPoints: 0 };
                }
                teamData[team].rushOpps += parseFloat(row['RB Opp']) || 0;
                teamData[team].totalPoints += parseFloat(row.FPTS || row.Fpts) || 0; // Handle both cases
            });

            // Calculate total targets and points per team from TE data (exclude FA)
            if (teData) {
                teData.forEach(row => {
                    const team = row.Team;
                    if (team === 'FA' || !team) return;
                    if (!teamData[team]) {
                        teamData[team] = { team: team, targets: 0, rushOpps: 0, totalPoints: 0 };
                    }
                    teamData[team].targets += parseFloat(row.TGT) || 0;
                    teamData[team].totalPoints += parseFloat(row.FPTS || row.Fpts) || 0; // Handle both cases
                });
            }

            const teams = Object.values(teamData);
            // Find min and max points for scaling
            const allPoints = teams.map(t => t.totalPoints);
            const minPoints = Math.min(...allPoints);
            const maxPoints = Math.max(...allPoints);
            // Create scatter data with point-based radius
            const scatterData = teams.map(team => {
                // Scale radius from 8 to 20 based on total points
                const normalizedPoints = (team.totalPoints - minPoints) / (maxPoints - minPoints);
                const radius = 8 + (normalizedPoints * 12); // Range: 8-20

                return {
                    x: team.targets,
                    y: team.rushOpps,
                    r: radius, // For bubble chart
                    team: team.team,
                    totalPoints: team.totalPoints
                };
            });
            // Calculate medians
            const sortedTargets = teams.map(t => t.targets).sort((a, b) => a - b);
            const sortedOpps = teams.map(t => t.rushOpps).sort((a, b) => a - b);
            const medianTargets = sortedTargets[Math.floor(sortedTargets.length / 2)];
            const medianOpps = sortedOpps[Math.floor(sortedOpps.length / 2)];

            // Separate highlighted team from regular teams
            let datasets = [];

            if (highlightTeam) {
                // Regular teams (non-highlighted)
                const regularData = scatterData.filter(d => d.team !== highlightTeam);
                const highlightedData = scatterData.filter(d => d.team === highlightTeam);

                // Regular teams dataset
                datasets.push({
                    data: regularData,
                    backgroundColor: regularData.map(d => {
                        const color = teamColors[d.team] || '#0a84ff';
                        return color + '66'; // 40% opacity for non-highlighted
                    }),
                    borderColor: regularData.map(d => {
                        const color = teamColors[d.team] || '#0a84ff';
                        return color + '99'; // 60% opacity for border
                    }),
                    borderWidth: 2
                });

                // Highlighted team dataset (if found)
                if (highlightedData.length > 0) {
                    const highlightColor = teamColors[highlightTeam] || '#0a84ff';
                    datasets.push({
                        data: highlightedData,
                        backgroundColor: highlightColor,
                        borderColor: '#ffffff',
                        borderWidth: 4,
                        pointRadius: highlightedData.map(d => d.r * 1.3), // 30% larger
                        pointHoverRadius: highlightedData.map(d => d.r * 1.5)
                    });
                }
            } else {
                // No highlight - all teams same style
                datasets.push({
                    data: scatterData,
                    backgroundColor: scatterData.map(d => {
                        const color = teamColors[d.team] || '#0a84ff';
                        return color + '99'; // 60% opacity
                    }),
                    borderColor: scatterData.map(d => teamColors[d.team] || '#0a84ff'),
                    borderWidth: 2
                });
            }

            new Chart(ctx, {
                type: 'bubble',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                layout: {
                    padding: window.innerWidth <= 768
                        ? { left: 20, right: 20, top: 30, bottom: 30 }
                        : { left: 50, right: 50, top: 50, bottom: 50 }
                },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const data = context.raw;
                                    return [
                                        data.team,
                                        `Targets: ${data.x.toFixed(0)}`,
                                        `Rush Opps: ${data.y.toFixed(0)}`,
                                        `Total Points: ${data.totalPoints.toFixed(1)}`
                                    ];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                vLine: {
                                    type: 'line',
                                    xMin: medianTargets,
                                    xMax: medianTargets,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                hLine: {
                                    type: 'line',
                                    yMin: medianOpps,
                                    yMax: medianOpps,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                }
                            }
                        },
                        zoom: {
                            pan: {
                                enabled: window.innerWidth <= 768, // Enable pan on mobile only
                                mode: 'xy',
                                modifierKey: null
                            },
                            zoom: {
                                wheel: {
                                    enabled: false // Disable wheel zoom
                                },
                                pinch: {
                                    enabled: window.innerWidth <= 768 // Enable pinch zoom on mobile only
                                },
                                mode: 'xy'
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Total Pass Targets',
                                color: '#8e8e93',
                                font: {
                                    size: window.innerWidth <= 768 ? 10 : 12,
                                    weight: 'bold'
                                }
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: {
                                color: '#8e8e93',
                                font: { size: window.innerWidth <= 768 ? 9 : 11 }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Total Rush Opportunities',
                                color: '#8e8e93',
                                font: {
                                    size: window.innerWidth <= 768 ? 10 : 12,
                                    weight: 'bold'
                                }
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: {
                                color: '#8e8e93',
                                font: { size: window.innerWidth <= 768 ? 9 : 11 }
                            }
                        }
                    },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const dataIndex = elements[0].index;
                            const teamCode = scatterData[dataIndex].team;
                            openTeamModal(teamCode);
                        }
                    }
                }
            });
        }

        // TEAM ANALYSIS FUNCTIONS

        // Helper function to generate color variations from team palette
        function generateTeamColorVariations(team, count) {
            const primaryColor = teamColors[team];

            if (!primaryColor) {
                // Fallback for unknown teams - use gray shades
                return Array.from({length: count}, (_, i) => {
                    const lightness = 40 + (i * (70 / count));
                    return `hsl(0, 0%, ${lightness}%)`;
                });
            }

            // Special case: single player uses team primary color
            if (count === 1) {
                return [primaryColor];
            }

            // Convert hex to HSL
            const hexToHSL = (hex) => {
                hex = hex.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16) / 255;
                const g = parseInt(hex.substr(2, 2), 16) / 255;
                const b = parseInt(hex.substr(4, 2), 16) / 255;

                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

                    switch (max) {
                        case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                        case g: h = ((b - r) / d + 2) / 6; break;
                        case b: h = ((r - g) / d + 4) / 6; break;
                    }
                }

                return [h * 360, s * 100, l * 100];
            };

            const [baseHue, baseSat, baseLightness] = hexToHSL(primaryColor);

            // Generate count colors from primary to off-white
            // Start with primary color, progressively lighten and desaturate
            const colors = [];

            for (let i = 0; i < count; i++) {
                const progress = i / (count - 1); // 0 to 1

                // Keep hue constant
                const h = baseHue;

                // Gradually decrease saturation from base to ~20% (near gray)
                const s = baseSat * (1 - progress * 0.7); // Keep some saturation

                // Gradually increase lightness from base to ~85% (off-white)
                const targetLightness = 85;
                const l = baseLightness + (targetLightness - baseLightness) * progress;

                colors.push(`hsl(${h}, ${s}%, ${l}%)`);
            }

            return colors;
        }

        // Initialize Team Analysis
        function initializeTeamAnalysis() {
            if (!wrData || !rbData) return;

            // Populate team selector with placeholder
            const teams = [...new Set([...wrData, ...rbData].map(row => row.Team).filter(t => t && t !== 'FA'))].sort();
            const teamSelect = document.getElementById('team-select');
            teamSelect.innerHTML = '';

            // Add placeholder option
            const placeholderOption = document.createElement('option');
            placeholderOption.value = '';
            placeholderOption.textContent = '(Select a Team)';
            placeholderOption.selected = true;
            teamSelect.appendChild(placeholderOption);

            // Add team options (no pre-selection)
            teams.forEach(team => {
                const option = document.createElement('option');
                option.value = team;
                option.textContent = team;
                teamSelect.appendChild(option);
            });

            // No default team
            currentTeamAnalysisTeam = null;

            // Populate week selector
            const weeks = [...new Set([...wrData, ...rbData].map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);
            const weekSelect = document.getElementById('week-select');
            weekSelect.innerHTML = '';
            weeks.forEach(week => {
                const option = document.createElement('option');
                option.value = week;
                option.textContent = `Week ${week}`;
                weekSelect.appendChild(option);
            });

            // Set most recent week as default
            if (weeks.length > 0) {
                weekSelect.value = weeks[weeks.length - 1];
            }

            // Enable league comparison by default and render it
            leagueComparisonEnabled = true;
            const toggleBtn = document.getElementById('league-comparison-toggle');
            const icon = document.getElementById('league-comparison-icon');
            toggleBtn.style.background = 'var(--positive)';
            toggleBtn.style.borderColor = 'var(--positive)';
            toggleBtn.style.color = 'white';
            icon.textContent = '●';

            // Show placeholder for pie chart, but render league comparison
            updateTeamAnalysis();
        }

        // Toggle League Comparison
        function toggleLeagueComparison() {
            leagueComparisonEnabled = !leagueComparisonEnabled;

            const toggleBtn = document.getElementById('league-comparison-toggle');
            const icon = document.getElementById('league-comparison-icon');

            if (leagueComparisonEnabled) {
                toggleBtn.style.background = 'var(--positive)';
                toggleBtn.style.borderColor = 'var(--positive)';
                toggleBtn.style.color = 'white';
                icon.textContent = '●';
            } else {
                toggleBtn.style.background = 'var(--bg-tertiary)';
                toggleBtn.style.borderColor = 'var(--border-color)';
                toggleBtn.style.color = 'var(--text-secondary)';
                icon.textContent = '○';
            }

            updateTeamAnalysis();
        }

        // Update Team Analysis based on selections
        function updateTeamAnalysis() {
            const team = document.getElementById('team-select').value;
            const position = document.getElementById('position-group-select').value;
            const timeFrame = document.getElementById('time-frame-select').value;
            const week = parseInt(document.getElementById('week-select').value);

            // Get placeholder and chart elements
            const placeholder = document.getElementById('team-chart-placeholder');
            const pieChartWrapper = document.querySelector('#team-charts-container .chart-wrapper:nth-child(2)');
            const secondaryChartWrapper = document.getElementById('team-secondary-chart-wrapper');

            // Show/hide week selector based on time frame
            const weekContainer = document.getElementById('week-select-container');
            weekContainer.style.display = timeFrame === 'single' ? 'block' : 'none';

            // Disable/enable league comparison toggle for season long
            const leagueToggleBtn = document.getElementById('league-comparison-toggle');
            if (timeFrame === 'season') {
                leagueToggleBtn.disabled = true;
                leagueToggleBtn.style.opacity = '0.4';
                leagueToggleBtn.style.cursor = 'not-allowed';
            } else {
                leagueToggleBtn.disabled = false;
                leagueToggleBtn.style.opacity = '1';
                leagueToggleBtn.style.cursor = 'pointer';
            }

            // If no team selected
            if (!team || team === '') {
                // Show placeholder for pie chart area
                placeholder.style.display = 'flex';
                pieChartWrapper.style.display = 'none';
                
                // But still show league comparison if enabled
                if (leagueComparisonEnabled && timeFrame !== 'season') {
                    secondaryChartWrapper.style.display = 'block';
                    // Render league comparison with no specific team (shows league average only)
                    setTimeout(() => {
                        renderLeagueComparison(null, position, timeFrame, week, 0);
                    }, 50);
                } else {
                    secondaryChartWrapper.style.display = 'none';
                }
                return;
            }

            // Team selected - hide placeholder and show pie chart
            placeholder.style.display = 'none';
            pieChartWrapper.style.display = 'block';
            secondaryChartWrapper.style.display = 'block';

            currentTeamAnalysisTeam = team;

            // Update title
            const titleEl = document.getElementById('team-chart-title');
            const descEl = document.getElementById('team-chart-description');

            const positionLabel = (position === 'WR' || position === 'TE') ? 'Target' : 'Opportunity';
            let timeLabel = '';

            if (timeFrame === 'single') {
                timeLabel = `Week ${week}`;
            } else if (timeFrame === 'last3') {
                timeLabel = 'Last 3 Weeks';
            } else if (timeFrame === 'last5') {
                timeLabel = 'Last 5 Weeks';
            } else {
                timeLabel = 'Season Long';
            }

            titleEl.textContent = `${team} ${position} ${positionLabel} Distribution - ${timeLabel}`;

            // Add description based on position
            if (position === 'WR' || position === 'TE') {
                descEl.textContent = `Showing top 4 pass catchers (WR/RB/TE) by target share - all positions compete for targets`;
            } else {
                descEl.textContent = `Showing RB opportunity distribution (rush attempts + targets)`;
            }

            // Render appropriate charts with animation
            // Use setTimeout to ensure canvas elements are fully rendered and sized
            setTimeout(() => {
                if (timeFrame === 'season') {
                    renderSeasonLongChart(team, position);
                } else {
                    renderPieAndBarCharts(team, position, timeFrame, week);
                }
            }, 50);

            // Highlight the selected team on the scatter plot
            renderTeamBalanceScatter(team);
        }

        // Render Pie and Bar Charts (for single week, last3, last5)
        function renderPieAndBarCharts(team, position, timeFrame, week) {
            // Reset grid layout to 50/50 for dual charts
            const container = document.getElementById('team-charts-container');
            container.style.gridTemplateColumns = '1fr 1fr';
            document.getElementById('team-secondary-chart-wrapper').style.display = 'block';

            // For WR and TE charts, include ALL pass catchers (WR/RB/TE) for accurate target share
            // For RB charts, use only RB data for opportunities
            let combinedData;
            if (position === 'WR' || position === 'TE') {
                // Include all positions that receive targets
                combinedData = [...wrData, ...rbData];
                if (teData) {
                    combinedData = [...combinedData, ...teData];
                }
            } else {
                combinedData = rbData;
            }

            // Filter data based on time frame
            let filteredData;
            if (timeFrame === 'single') {
                filteredData = combinedData.filter(row => row.Team === team && parseInt(row.Week) === week);
            } else {
                const weeks = [...new Set(combinedData.map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);
                const latestWeek = Math.max(...weeks);
                const weeksToInclude = timeFrame === 'last3' ? 3 : 5;
                const startWeek = latestWeek - weeksToInclude + 1;
                filteredData = combinedData.filter(row => row.Team === team && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek);
            }

            // Calculate player shares
            const playerStats = {};
            filteredData.forEach(row => {
                const player = row.Player;
                if (!playerStats[player]) {
                    playerStats[player] = { targets: 0, opportunities: 0, position: row.Pos };
                }

                if (position === 'WR' || position === 'TE') {
                    // For WR/TE view, count targets for all pass catchers
                    playerStats[player].targets += parseFloat(row.TGT) || 0;
                } else {
                    playerStats[player].opportunities += parseFloat(row['RB Opp']) || 0;
                }
            });

            // Convert to array and sort
            const playerArray = Object.entries(playerStats).map(([name, stats]) => ({
                name,
                value: (position === 'WR' || position === 'TE') ? stats.targets : stats.opportunities,
                position: stats.position
            })).sort((a, b) => b.value - a.value);

            const totalValue = playerArray.reduce((sum, p) => sum + p.value, 0);

            // For WR/TE views (showing all pass catchers), take top 4 players
            // For RB views, take top 5 players
            const topCount = (position === 'WR' || position === 'TE') ? 4 : 5;
            const topPlayers = playerArray.slice(0, topCount);
            const otherValue = playerArray.slice(topCount).reduce((sum, p) => sum + p.value, 0);

            // Build chart data
            let chartData = [...topPlayers];
            if (otherValue > 0) {
                chartData.push({ name: 'Other', value: otherValue, position: 'Other' });
            }

            // Render pie chart
            renderTeamPieChart(chartData, totalValue, position);

            // Render bar chart or league comparison
            if (leagueComparisonEnabled) {
                renderLeagueComparison(team, position, timeFrame, week, totalValue);
            } else {
                renderTeamBarChart(chartData, position);
            }
        }

        // Render Pie Chart
        function renderTeamPieChart(chartData, totalValue, position) {
            const canvas = document.getElementById('team-pie-chart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Destroy existing chart
            if (teamAnalysisCharts.pie) {
                teamAnalysisCharts.pie.destroy();
            }

            const labels = chartData.map(d => d.name);
            const values = chartData.map(d => d.value);
            const percentages = chartData.map(d => ((d.value / totalValue) * 100).toFixed(1));

            // Generate color variations based on team color palette
            const playerCount = chartData.filter(d => d.name !== 'Other').length;
            const teamColorVariations = generateTeamColorVariations(currentTeamAnalysisTeam, playerCount);

            // Create colors with opacity for fills
            // Use higher opacity (85%) for single player so team color is clearly visible
            const opacity = playerCount === 1 ? 0.85 : 0.45;

            const fillColors = chartData.map((d, i) => {
                if (d.name === 'Other') return 'rgba(99, 99, 102, 0.45)';
                const baseColor = teamColorVariations[i];
                // Convert to rgba with appropriate opacity
                if (baseColor.startsWith('#')) {
                    const r = parseInt(baseColor.slice(1, 3), 16);
                    const g = parseInt(baseColor.slice(3, 5), 16);
                    const b = parseInt(baseColor.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                } else if (baseColor.startsWith('hsl')) {
                    return baseColor.replace('hsl', 'hsla').replace(')', `, ${opacity})`);
                }
                return baseColor;
            });

            // Solid colors for borders (same color, 100% opacity)
            const borderColors = chartData.map((d, i) => {
                if (d.name === 'Other') return '#636366';
                return teamColorVariations[i];
            });

            const metric = position === 'WR' ? 'Targets' : 'Opportunities';

            teamAnalysisCharts.pie = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: values,
                        backgroundColor: fillColors,
                        borderColor: borderColors,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        animateRotate: true,
                        animateScale: true,
                        duration: 1400,
                        easing: 'easeInOutQuart'
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `Total ${metric}: ${totalValue.toFixed(0)}`,
                            color: '#8e8e93',
                            font: { size: 13, weight: '600' },
                            padding: { top: 0, bottom: 10 }
                        },
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: '#ffffff',
                                padding: 15,
                                font: { size: 12, weight: 'bold' },
                                generateLabels: (chart) => {
                                    const data = chart.data;
                                    return data.labels.map((label, i) => ({
                                        text: `${label} (${percentages[i]}%)`,
                                        fillStyle: data.datasets[0].backgroundColor[i],
                                        fontColor: '#ffffff',
                                        hidden: false,
                                        index: i
                                    }));
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const label = context.label || '';
                                    const value = context.parsed;
                                    const percentage = ((value / totalValue) * 100).toFixed(1);
                                    return `${label}: ${value.toFixed(1)} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Render Bar Chart (when league comparison is off)
        function renderTeamBarChart(chartData, position) {
            const canvas = document.getElementById('team-secondary-chart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Destroy existing chart
            if (teamAnalysisCharts.secondary) {
                teamAnalysisCharts.secondary.destroy();
            }

            const labels = chartData.map(d => d.name);
            const values = chartData.map(d => d.value);

            // Generate color variations based on team color palette
            const playerCount = chartData.filter(d => d.name !== 'Other').length;
            const teamColorVariations = generateTeamColorVariations(currentTeamAnalysisTeam, playerCount);

            // Create colors with medium opacity for fills
            const fillColors = chartData.map((d, i) => {
                if (d.name === 'Other') return 'rgba(99, 99, 102, 0.45)';
                const baseColor = teamColorVariations[i];
                // Convert to rgba with 45% opacity
                if (baseColor.startsWith('#')) {
                    const r = parseInt(baseColor.slice(1, 3), 16);
                    const g = parseInt(baseColor.slice(3, 5), 16);
                    const b = parseInt(baseColor.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, 0.45)`;
                } else if (baseColor.startsWith('hsl')) {
                    return baseColor.replace('hsl', 'hsla').replace(')', ', 0.45)');
                }
                return baseColor;
            });

            // Solid colors for borders (same color, 100% opacity)
            const borderColors = chartData.map((d, i) => {
                if (d.name === 'Other') return '#636366';
                return teamColorVariations[i];
            });

            const totalValue = chartData.reduce((sum, d) => sum + d.value, 0);
            const metric = position === 'WR' ? 'Targets' : 'Opportunities';

            teamAnalysisCharts.secondary = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: metric,
                        data: values,
                        backgroundColor: fillColors,
                        borderColor: borderColors,
                        borderWidth: 2
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Total ${metric}: ${totalValue.toFixed(0)}`,
                            color: '#8e8e93',
                            font: { size: 13, weight: '600' },
                            padding: { top: 0, bottom: 10 }
                        },
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    return `${context.parsed.x.toFixed(1)} ${position === 'WR' ? 'targets' : 'opportunities'}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            grid: { display: false },
                            ticks: { color: '#fff' }
                        }
                    }
                }
            });
        }

        // Render League Comparison
        function renderLeagueComparison(team, position, timeFrame, week, teamTotal) {
            // For WR view, include RBs who receive targets; for RB view, use only RB data
            let data;
            if (position === 'WR') {
                data = [...wrData, ...rbData]; // Include RBs in WR league comparison
            } else {
                data = rbData;
            }

            // Calculate totals for all teams
            const teamTotals = {};

            if (timeFrame === 'single') {
                data.filter(row => parseInt(row.Week) === week).forEach(row => {
                    const t = row.Team;
                    if (t && t !== 'FA') {
                        if (!teamTotals[t]) teamTotals[t] = 0;
                        // For WR view, count targets for all positions
                        teamTotals[t] += position === 'WR' ? (parseFloat(row.TGT) || 0) : (parseFloat(row['RB Opp']) || 0);
                    }
                });
            } else {
                const weeks = [...new Set(data.map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);
                const latestWeek = Math.max(...weeks);
                const weeksToInclude = timeFrame === 'last3' ? 3 : 5;
                const startWeek = latestWeek - weeksToInclude + 1;

                data.filter(row => parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek).forEach(row => {
                    const t = row.Team;
                    if (t && t !== 'FA') {
                        if (!teamTotals[t]) teamTotals[t] = 0;
                        // For WR view, count targets for all positions
                        teamTotals[t] += position === 'WR' ? (parseFloat(row.TGT) || 0) : (parseFloat(row['RB Opp']) || 0);
                    }
                });
            }

            // Convert to array and sort
            const leagueData = Object.entries(teamTotals)
                .map(([t, total]) => ({ team: t, total }))
                .sort((a, b) => b.total - a.total);

            const canvas = document.getElementById('team-secondary-chart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Destroy existing chart
            if (teamAnalysisCharts.secondary) {
                teamAnalysisCharts.secondary.destroy();
            }

            const labels = leagueData.map(d => d.team);
            const values = leagueData.map(d => d.total);

            // Get selected team color (if team is provided)
            const selectedTeamColor = team ? (teamColors[team] || '#666') : '#666';
            let selectedBgColor, selectedBorderColor;
            if (selectedTeamColor.startsWith('#')) {
                const r = parseInt(selectedTeamColor.slice(1, 3), 16);
                const g = parseInt(selectedTeamColor.slice(3, 5), 16);
                const b = parseInt(selectedTeamColor.slice(5, 7), 16);
                selectedBgColor = `rgba(${r}, ${g}, ${b}, 0.6)`;
                selectedBorderColor = selectedTeamColor;
            }

            // Create colors arrays - different color for selected vs others
            const backgroundColors = leagueData.map(d => {
                if (team && d.team === team) {
                    return selectedBgColor;
                }
                const color = teamColors[d.team] || '#666';
                if (color.startsWith('#')) {
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, 0.45)`;
                }
                return color;
            });

            const borderColors = leagueData.map(d => {
                if (team && d.team === team) return selectedBorderColor;
                return teamColors[d.team] || '#666';
            });

            const borderWidths = leagueData.map(d => (team && d.team === team) ? 3 : 2);

            const metric = position === 'WR' ? 'Targets' : 'Opportunities';

            // Title text depends on whether team is selected
            const titleText = team 
                ? `${team} Total ${metric}: ${teamTotal.toFixed(0)}`
                : `League Comparison - Total ${metric}`;

            teamAnalysisCharts.secondary = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: `Total ${metric}`,
                            data: values,
                            backgroundColor: backgroundColors,
                            borderColor: borderColors,
                            borderWidth: borderWidths,
                            barThickness: 'flex',
                            maxBarThickness: 30
                        }
                    ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    aspectRatio: 0.8,
                    plugins: {
                        title: {
                            display: true,
                            text: titleText,
                            color: '#8e8e93',
                            font: { size: 13, weight: '600' },
                            padding: { top: 0, bottom: 10 }
                        },
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const value = context.parsed.x;
                                    if (value === null || value === 0) return null;
                                    return `${value.toFixed(1)} ${position === 'WR' ? 'targets' : 'opportunities'}`;
                                },
                                title: (context) => {
                                    return context[0].label;
                                }
                            },
                            filter: (tooltipItem) => {
                                return tooltipItem.parsed.x !== null && tooltipItem.parsed.x !== 0;
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            grid: { display: false },
                            ticks: {
                                autoSkip: false, // Show all team labels
                                maxRotation: 0,
                                minRotation: 0,
                                color: (context) => {
                                    // Much brighter white for selected team, dimmer for others
                                    return context.tick.label === team ? '#ffffff' : '#8e8e93';
                                },
                                font: (context) => {
                                    const isSelected = context.tick.label === team;

                                    if (isSelected) {
                                        // Selected team is bigger and bolder
                                        return { size: 13, weight: 'bold' };
                                    } else {
                                        // Normal size for others
                                        return { size: 10, weight: 'normal' };
                                    }
                                },
                                // Two-column staggered layout
                                align: (context) => {
                                    // Even indices right-aligned, odd indices left-aligned
                                    return context.index % 2 === 0 ? 'end' : 'start';
                                },
                                crossAlign: 'near',
                                padding: (context) => {
                                    // Add extra padding for odd indices to create column effect
                                    return context.index % 2 === 0 ? 4 : 12;
                                }
                            }
                        }
                    },
                    onClick: (event, elements) => {
                        // If clicked on a bar, open that team's modal
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const clickedTeam = labels[index];
                            openTeamModal(clickedTeam);
                        } else {
                            // If clicked elsewhere on chart, open current team's modal
                            openTeamModal(team);
                        }
                    }
                }
            });
        }

        // Render Season Long Chart
        function renderSeasonLongChart(team, position) {
            // For WR and TE charts, include ALL pass catchers (WR/RB/TE) for accurate target share
            // For RB charts, use only RB data for opportunities
            let data;
            if (position === 'WR' || position === 'TE') {
                data = [...wrData, ...rbData];
                if (teData) {
                    data = [...data, ...teData];
                }
            } else {
                data = rbData;
            }

            const filteredData = data.filter(row => row.Team === team);

            // Get all weeks
            const weeks = [...new Set(filteredData.map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);

            // Calculate total for the time period
            let seasonTotal = 0;

            // Calculate weekly totals for labels
            const weeklyTotals = {};

            // Calculate weekly shares
            const weeklyShares = {};
            weeks.forEach(week => {
                const weekData = filteredData.filter(row => parseInt(row.Week) === week);
                const totalValue = weekData.reduce((sum, row) => {
                    const val = (position === 'WR' || position === 'TE') ? (parseFloat(row.TGT) || 0) : (parseFloat(row['RB Opp']) || 0);
                    return sum + val;
                }, 0);

                weeklyTotals[week] = totalValue;
                seasonTotal += totalValue;

                weekData.forEach(row => {
                    const player = row.Player;
                    const value = (position === 'WR' || position === 'TE') ? (parseFloat(row.TGT) || 0) : (parseFloat(row['RB Opp']) || 0);
                    const share = totalValue > 0 ? (value / totalValue) * 100 : 0;

                    if (!weeklyShares[player]) {
                        weeklyShares[player] = [];
                    }
                    weeklyShares[player].push({ week, share, value });
                });
            });

            // Get top players by average share
            const playerAverages = Object.entries(weeklyShares).map(([player, shares]) => {
                const avgShare = shares.reduce((sum, s) => sum + s.share, 0) / shares.length;
                return { player, avgShare, shares };
            }).sort((a, b) => b.avgShare - a.avgShare);

            // Take top 4 players (regardless of position for WR/TE views)
            const topPlayers = playerAverages.slice(0, 4);

            // Hide secondary chart wrapper, show full width for season long
            const container = document.getElementById('team-charts-container');
            container.style.gridTemplateColumns = '1fr';
            document.getElementById('team-secondary-chart-wrapper').style.display = 'none';

            const canvas = document.getElementById('team-pie-chart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Destroy existing chart
            if (teamAnalysisCharts.pie) {
                teamAnalysisCharts.pie.destroy();
            }

            const metric = (position === 'WR' || position === 'TE') ? 'Targets' : 'Opportunities';

            if (position === 'WR' || position === 'TE') {
                // Stacked bar chart for WR/TE (showing top 4 pass catchers)
                const teamPalette = teamColorPalettes[team] || ['#666', '#888', '#aaa', '#ccc'];
                const teamColorVariations = generateTeamColorVariations(team, topPlayers.length);

                const datasets = topPlayers.map((p, i) => {
                    const baseColor = teamColorVariations[i];
                    // Convert to rgba with 45% opacity for fills
                    let fillColor = baseColor;
                    if (baseColor.startsWith('#')) {
                        const r = parseInt(baseColor.slice(1, 3), 16);
                        const g = parseInt(baseColor.slice(3, 5), 16);
                        const b = parseInt(baseColor.slice(5, 7), 16);
                        fillColor = `rgba(${r}, ${g}, ${b}, 0.45)`;
                    } else if (baseColor.startsWith('hsl')) {
                        fillColor = baseColor.replace('hsl', 'hsla').replace(')', ', 0.45)');
                    }

                    return {
                        label: p.player,
                        data: weeks.map(week => {
                            const weekShare = p.shares.find(s => s.week === week);
                            return weekShare ? weekShare.share : 0;
                        }),
                        backgroundColor: fillColor,
                        borderColor: baseColor,
                        borderWidth: 2
                    };
                });

                // Add "Other" category
                const otherData = weeks.map(week => {
                    const weekTotal = 100;
                    const topTotal = topPlayers.reduce((sum, p) => {
                        const weekShare = p.shares.find(s => s.week === week);
                        return sum + (weekShare ? weekShare.share : 0);
                    }, 0);
                    return Math.max(0, weekTotal - topTotal);
                });

                datasets.push({
                    label: 'Other',
                    data: otherData,
                    backgroundColor: 'rgba(99, 99, 102, 0.45)',
                    borderColor: '#636366',
                    borderWidth: 2
                });

                teamAnalysisCharts.pie = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: weeks.map(w => `Week ${w} (${Math.round(weeklyTotals[w])})`),
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        aspectRatio: 2.5,
                        animation: {
                            duration: 1400,
                            easing: 'easeInOutQuart'
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `Total ${metric} (Season): ${seasonTotal.toFixed(0)}`,
                                color: '#8e8e93',
                                font: { size: 13, weight: '600' },
                                padding: { top: 5, bottom: 15 }
                            },
                            legend: {
                                position: 'bottom',
                                labels: { color: '#fff', padding: 10, font: { size: 11 } }
                            },
                            tooltip: {
                                mode: 'point',
                                intersect: true,
                                callbacks: {
                                    label: (context) => {
                                        return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                stacked: true,
                                grid: { color: '#2c2c2e' },
                                ticks: { color: '#8e8e93', font: { size: 10 } }
                            },
                            y: {
                                stacked: true,
                                max: 100,
                                grid: { color: '#2c2c2e' },
                                ticks: { color: '#8e8e93' },
                                title: {
                                    display: true,
                                    text: 'Target Share %',
                                    color: '#8e8e93'
                                }
                            }
                        },
                        onClick: (event, elements) => {
                            // Open team modal when clicking anywhere on the chart
                            openTeamModal(team);
                        }
                    }
                });
            } else {
                // Line chart for RBs
                const teamColorVariations = generateTeamColorVariations(team, topPlayers.length);

                const datasets = topPlayers.map((p, i) => {
                    const baseColor = teamColorVariations[i];
                    // Convert to rgba with 45% opacity for fills
                    let fillColor = baseColor + '45';
                    if (baseColor.startsWith('#')) {
                        const r = parseInt(baseColor.slice(1, 3), 16);
                        const g = parseInt(baseColor.slice(3, 5), 16);
                        const b = parseInt(baseColor.slice(5, 7), 16);
                        fillColor = `rgba(${r}, ${g}, ${b}, 0.45)`;
                    } else if (baseColor.startsWith('hsl')) {
                        fillColor = baseColor.replace('hsl', 'hsla').replace(')', ', 0.45)');
                    }

                    return {
                        label: p.player,
                        data: weeks.map(week => {
                            const weekShare = p.shares.find(s => s.week === week);
                            return weekShare ? weekShare.share : null;
                        }),
                        borderColor: baseColor,
                        backgroundColor: fillColor,
                        borderWidth: 3,
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        pointBackgroundColor: fillColor,
                        pointBorderColor: baseColor,
                        pointBorderWidth: 2,
                        tension: 0.3
                    };
                });

                teamAnalysisCharts.pie = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: weeks.map(w => `Week ${w} (${Math.round(weeklyTotals[w])})`),
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        aspectRatio: 2.5,
                        animation: {
                            duration: 1400,
                            easing: 'easeInOutQuart'
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `Total ${metric} (Season): ${seasonTotal.toFixed(0)}`,
                                color: '#8e8e93',
                                font: { size: 13, weight: '600' },
                                padding: { top: 5, bottom: 15 }
                            },
                            legend: {
                                position: 'bottom',
                                labels: { color: '#fff', padding: 10, font: { size: 11 } }
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    label: (context) => {
                                        return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                grid: { color: '#2c2c2e' },
                                ticks: { color: '#8e8e93' }
                            },
                            y: {
                                grid: { color: '#2c2c2e' },
                                ticks: { color: '#8e8e93' },
                                title: {
                                    display: true,
                                    text: 'Opportunity Share %',
                                    color: '#8e8e93'
                                }
                            }
                        },
                        onClick: (event, elements) => {
                            // Open team modal when clicking anywhere on the chart
                            openTeamModal(team);
                        }
                    }
                });
            }
        }

        // Render Collapsible Divisions
        function renderCollapsibleDivisions() {
            if (!wrData || !rbData) return;

            const divisionsContainer = document.getElementById('divisions-grid');
            divisionsContainer.innerHTML = '';

            // Calculate team stats for display
            const teamStatsMap = {};
            const allData = [...wrData, ...rbData];
            allData.forEach(row => {
                const team = row.Team;
                if (team && team !== 'FA') {
                    if (!teamStatsMap[team]) {
                        teamStatsMap[team] = { totalPoints: 0, games: 0 };
                    }
                    teamStatsMap[team].totalPoints += parseFloat(row.FPTS || row.Fpts) || 0;
                }
            });

            // Count games per team
            const uniqueTeamWeeks = {};
            allData.forEach(row => {
                const team = row.Team;
                const week = row.Week;
                if (team && team !== 'FA' && week) {
                    const key = `${team}-${week}`;
                    uniqueTeamWeeks[key] = true;
                }
            });

            Object.keys(uniqueTeamWeeks).forEach(key => {
                const team = key.split('-')[0];
                if (teamStatsMap[team]) {
                    teamStatsMap[team].games++;
                }
            });

            // Render each division
            Object.entries(nflDivisions).forEach(([divisionName, teams]) => {
                const divSection = document.createElement('div');
                divSection.className = 'division-section';

                const header = document.createElement('div');
                header.className = 'division-header';
                header.onclick = () => toggleDivision(divisionName);

                const title = document.createElement('div');
                title.className = 'division-title';
                title.textContent = divisionName;

                const arrow = document.createElement('div');
                arrow.className = 'division-arrow';
                arrow.id = `arrow-${divisionName.replace(/\s+/g, '-')}`;
                arrow.textContent = '▼';

                header.appendChild(title);
                header.appendChild(arrow);

                const content = document.createElement('div');
                content.className = 'division-content';
                content.id = `content-${divisionName.replace(/\s+/g, '-')}`;

                const teamsGrid = document.createElement('div');
                teamsGrid.className = 'division-teams-grid';

                // Add team cards
                teams.forEach(team => {
                    const stats = teamStatsMap[team] || { totalPoints: 0, games: 1 };
                    const ppg = stats.games > 0 ? (stats.totalPoints / stats.games).toFixed(1) : '0.0';

                    const teamCard = document.createElement('div');
                    teamCard.className = 'division-team-card';
                    teamCard.onclick = () => selectTeamFromDivision(team);

                    const logo = document.createElement('div');
                    logo.className = 'division-team-logo';
                    logo.style.background = teamColors[team] || '#666';
                    logo.textContent = team;

                    const info = document.createElement('div');
                    info.className = 'division-team-info';

                    const name = document.createElement('div');
                    name.className = 'division-team-name';
                    name.textContent = team;

                    const statsDiv = document.createElement('div');
                    statsDiv.className = 'division-team-stats';
                    statsDiv.textContent = `${ppg} PPG · ${stats.games} games`;

                    info.appendChild(name);
                    info.appendChild(statsDiv);

                    teamCard.appendChild(logo);
                    teamCard.appendChild(info);

                    teamsGrid.appendChild(teamCard);
                });

                content.appendChild(teamsGrid);

                divSection.appendChild(header);
                divSection.appendChild(content);

                divisionsContainer.appendChild(divSection);
            });
        }

        // Toggle Division Collapse/Expand
        function toggleDivision(divisionName) {
            const contentId = `content-${divisionName.replace(/\s+/g, '-')}`;
            const arrowId = `arrow-${divisionName.replace(/\s+/g, '-')}`;

            const content = document.getElementById(contentId);
            const arrow = document.getElementById(arrowId);

            if (content && arrow) {
                content.classList.toggle('expanded');
                arrow.classList.toggle('expanded');
            }
        }

        // Select Team from Division
        function selectTeamFromDivision(team) {
            const teamSelect = document.getElementById('team-select');
            teamSelect.value = team;
            currentTeamAnalysisTeam = team;
            updateTeamAnalysis();

            // Scroll to Team Analysis section
            document.querySelector('.advanced-analytics-container').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        // 5. INTERACTIONS

        // Sub-Tab Navigation (Rankings vs Advanced Analytics)
        let wrAnalyticsRendered = false;
        let rbAnalyticsRendered = false;

        function switchWRSubTab(tab) {
            // Update button styles
            const tabs = document.querySelectorAll('#wide-receivers .sub-nav-tab');
            tabs.forEach(t => {
                t.style.color = 'var(--text-secondary)';
                t.style.borderBottomColor = 'transparent';
                t.classList.remove('active');
            });

            event.target.classList.add('active');
            event.target.style.color = 'var(--text-primary)';
            event.target.style.borderBottomColor = 'var(--positive)';

            // Show/hide content
            if (tab === 'rankings') {
                document.getElementById('wr-rankings-content').style.display = 'block';
                document.getElementById('wr-analytics-content').style.display = 'none';
            } else if (tab === 'analytics') {
                document.getElementById('wr-rankings-content').style.display = 'none';
                document.getElementById('wr-analytics-content').style.display = 'block';

                // Lazy load charts on first view
                if (!wrAnalyticsRendered) {
                    renderWRScatter();
                    renderMatrices(); // This will render WR matrices

                    // Initialize trend animations for WR eval charts
                    if (Object.keys(evaluationDataWR).length > 0) {
                        initSmoothTrendAnimation('wr-eval-volume-efficiency');
                        initSmoothTrendAnimation('wr-eval-share-rz');
                        initSmoothTrendAnimation('wr-eval-production-volume');
                    }

                    wrAnalyticsRendered = true;
                }
            }
        }

        function switchRBSubTab(tab) {
            // Update button styles
            const tabs = document.querySelectorAll('#running-backs .sub-nav-tab');
            tabs.forEach(t => {
                t.style.color = 'var(--text-secondary)';
                t.style.borderBottomColor = 'transparent';
                t.classList.remove('active');
            });

            event.target.classList.add('active');
            event.target.style.color = 'var(--text-primary)';
            event.target.style.borderBottomColor = 'var(--positive)';

            // Show/hide content
            if (tab === 'rankings') {
                document.getElementById('rb-rankings-content').style.display = 'block';
                document.getElementById('rb-analytics-content').style.display = 'none';
            } else if (tab === 'analytics') {
                document.getElementById('rb-rankings-content').style.display = 'none';
                document.getElementById('rb-analytics-content').style.display = 'block';

                // Lazy load charts on first view
                if (!rbAnalyticsRendered) {
                    renderRBScatter();
                    renderMatrices(); // This will render RB matrices

                    // Initialize trend animations for RB eval charts
                    if (Object.keys(evaluationDataRB).length > 0) {
                        initSmoothTrendAnimation('rb-eval-total-rz');
                        initSmoothTrendAnimation('rb-eval-volume-efficiency');
                        initSmoothTrendAnimation('rb-eval-production-volume');
                    }

                    rbAnalyticsRendered = true;
                }
            }
        }

        // Navigation
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const pageName = this.getAttribute('data-page');

                // Update active tab
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');

                // Show page
                document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
                document.getElementById(pageName).classList.add('active');

                // Render dashboard categories if on dashboard page
                if (pageName === 'top-movers') {
                    setTimeout(() => {
                        renderDashboardCategories();
                        setTimeout(renderMiniScatterPlots, 100);
                    }, 100);
                }

                // Scroll to top of page
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        });

        // Modal Functions
        let currentModalPlayer = null;

        // Open modal with category context
        function openPlayerModalWithCategory(playerId, categoryTitle, explanation, rank, metricLabel, metricValue) {
            // First open the modal normally
            openPlayerModal(playerId);

            // Then add category context
            const contextDiv = document.getElementById('modal-category-context');
            if (contextDiv && categoryTitle) {
                contextDiv.style.display = 'block';
                document.getElementById('modal-category-title').textContent = categoryTitle;
                document.getElementById('modal-category-rank').textContent = `#${rank}`;
                document.getElementById('modal-category-explanation').textContent = explanation;
                document.getElementById('modal-category-metric-label').textContent = metricLabel;
                document.getElementById('modal-category-metric-value').textContent = metricValue;
            }
        }

        function openPlayerModal(playerId) {
            const player = allPlayers[playerId];
            if (!player) return;

            // Hide category context by default
            const contextDiv = document.getElementById('modal-category-context');
            if (contextDiv) {
                contextDiv.style.display = 'none';
            }

            currentModalPlayer = player;

            // Set player info with momentum badge
            const modalNameEl = document.getElementById('modal-player-name');
            modalNameEl.textContent = player.name;
            
            // Set player name to white
            modalNameEl.style.color = '#ffffff';

            // Build meta line with injury and momentum badges inline
            const injury = getPlayerInjuryStatus(player.name);
            let metaHTML = `${player.position} · ${player.team} · Rank #${player.rosRank}`;
            
            if (injury) {
                const statusInfo = formatInjuryStatus(injury.status);
                const injuryDetails = `${statusInfo.fullText} - ${injury.injuryBody}`;
                metaHTML += ` <span class="injury-badge ${statusInfo.class}" data-injury-details="${injuryDetails}" style="font-size: 13px; padding: 3px 8px;">${statusInfo.fullText}</span>`;
            }
            
            // Add momentum badge inline if valid
            if (player.momentum && player.momentum.isValid && player.momentum.direction !== 'neutral') {
                // Suppress negative momentum for high scorers unless decline is severe (>15%)
                let showBadge = true;
                if (player.momentum.direction === 'down') {
                    const highScorerThreshold = currentScoringFormat === 'ppr' ? 20 : 
                                              currentScoringFormat === 'half' ? 17 : 14.5;
                    if (player.avgPoints >= highScorerThreshold && player.momentum.score > -15) {
                        showBadge = false;
                    }
                }
                if (showBadge) {
                    metaHTML += ` <span class="momentum-badge ${player.momentum.direction}" data-tooltip="Momentum: ${player.momentum.score > 0 ? '+' : ''}${player.momentum.score.toFixed(1)}% (last 3 vs prev 3 weeks)" style="font-size: 13px; padding: 3px 8px;">${player.momentum.direction === 'up' ? '↑' : '↓'}</span>`;
                }
            }
            
            document.getElementById('modal-player-meta').innerHTML = metaHTML;
            document.getElementById('modal-team-badge').textContent = player.team;
            document.getElementById('modal-team-badge').style.background = teamColors[player.team] || '#666';

            // Get latest week data
            const latestWeek = player.weeks[player.weeks.length - 1];
            const latestWeekNum = latestWeek.week;
            const actualPts = latestWeek.fpts;
            const expectedPts = latestWeek.expectedFpts;
            const diffPct = expectedPts > 0 ? ((actualPts - expectedPts) / expectedPts) * 100 : 0;

            // Get previous week data for comparison
            const prevWeek = player.weeks.length > 1 ? player.weeks[player.weeks.length - 2] : null;

            // Calculate top 24 averages for this position
            let allPositionPlayers, top24Players;
            if (player.position === 'WR') {
                allPositionPlayers = Object.values(aggregatedWRs);
            } else if (player.position === 'RB') {
                allPositionPlayers = Object.values(aggregatedRBs);
            } else {
                allPositionPlayers = Object.values(aggregatedTEs);
            }
            
            top24Players = allPositionPlayers
                .filter(p => p.gamesPlayed >= 3)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 24);

            const top24AvgPts = top24Players.reduce((sum, p) => sum + p.avgPoints, 0) / top24Players.length;

            // ============================================
            // STAT 1: FPTS/G
            // ============================================
            document.getElementById('modal-avg-pts').textContent = player.avgPoints.toFixed(1);
            const ptsDiff = player.avgPoints - top24AvgPts;
            const ptsColor = ptsDiff >= 0 ? '#30d158' : '#ff453a';
            const ptsSymbol = ptsDiff >= 0 ? '▲' : '▼';
            document.getElementById('modal-avg-pts-comparison').innerHTML = 
                `<span style="color: ${ptsColor};">${ptsSymbol} ${Math.abs(ptsDiff).toFixed(1)} pts</span>`;

            // ============================================
            // STAT 2: Actual Scored (Last Week)  
            // ============================================
            document.getElementById('modal-actual-pts-label').textContent = `Actual Pts (W${latestWeekNum})`;
            document.getElementById('modal-actual-pts').textContent = actualPts.toFixed(1);
            
            // Compare to previous week if available
            if (prevWeek) {
                const prevWeekPts = prevWeek.fpts;
                const weekOverWeekDiff = actualPts - prevWeekPts;
                const actualDiffColor = weekOverWeekDiff >= 0 ? '#30d158' : '#ff453a';
                const actualDiffSymbol = weekOverWeekDiff >= 0 ? '▲' : '▼';
                document.getElementById('modal-actual-comparison').innerHTML = 
                    `<span style="color: ${actualDiffColor};">${actualDiffSymbol} ${Math.abs(weekOverWeekDiff).toFixed(1)} vs W${prevWeek.week}</span>`;
            } else {
                document.getElementById('modal-actual-comparison').innerHTML = '';
            }

            // ============================================
            // STAT 3: Momentum
            // ============================================
            if (player.momentum && player.momentum.isValid) {
                let momentumIcon = '';
                let momentumColor = '';
                if (player.momentum.direction === 'up') {
                    momentumIcon = '↑ Hot';
                    momentumColor = '#30d158';
                } else if (player.momentum.direction === 'down') {
                    momentumIcon = '↓ Cold';
                    momentumColor = '#ff453a';
                } else {
                    momentumIcon = '→ Steady';
                    momentumColor = 'rgba(235, 235, 245, 0.6)';
                }
                
                document.getElementById('modal-momentum').textContent = momentumIcon;
                document.getElementById('modal-momentum').style.color = momentumColor;
                
                const momentumScore = player.momentum.score;
                const momentumScoreColor = momentumScore >= 0 ? '#30d158' : '#ff453a';
                const momentumSymbol = momentumScore >= 0 ? '▲' : '▼';
                document.getElementById('modal-momentum-comparison').innerHTML = 
                    `<span style="color: ${momentumScoreColor};">${momentumSymbol} ${Math.abs(momentumScore).toFixed(1)}%</span>`;
            } else {
                document.getElementById('modal-momentum').textContent = '→ Steady';
                document.getElementById('modal-momentum').style.color = 'rgba(235, 235, 245, 0.6)';
                document.getElementById('modal-momentum-comparison').innerHTML = 
                    `<span style="color: rgba(235, 235, 245, 0.6);">Insufficient data</span>`;
            }

            // ============================================
            // STAT 4: PPG vs Expected
            // ============================================
            // Calculate season-long actual vs expected
            const totalActual = player.weeks.reduce((sum, w) => sum + w.fpts, 0);
            const totalExpected = player.weeks.reduce((sum, w) => sum + (w.expectedFpts || w.fpts), 0);
            const avgActual = totalActual / player.gamesPlayed;
            const avgExpected = totalExpected / player.gamesPlayed;
            const ppgDiff = avgActual - avgExpected;
            const ppgDiffPct = avgExpected > 0 ? (ppgDiff / avgExpected) * 100 : 0;
            
            document.getElementById('modal-ppg-expected').textContent = avgActual.toFixed(1);
            
            const ppgColor = ppgDiff >= 0 ? '#30d158' : '#ff453a';
            const ppgSymbol = ppgDiff >= 0 ? '▲' : '▼';
            document.getElementById('modal-ppg-expected-comparison').innerHTML = 
                `<span style="color: ${ppgColor};">${ppgSymbol} ${Math.abs(ppgDiffPct).toFixed(1)}% vs exp</span>`;

            // ============================================
            // STAT 5: Tgt/Opp Share (Last Week)
            // ============================================
            if (player.position === 'WR' || player.position === 'TE') {
                const thisWeekShare = latestWeek.teamShare || 0;
                const lastWeekShare = prevWeek ? (prevWeek.teamShare || 0) : 0;
                const shareChange = thisWeekShare - lastWeekShare;
                
                document.getElementById('modal-opp-share-label').textContent = `Tgt Share (W${latestWeekNum})`;
                document.getElementById('modal-opp-share').textContent = thisWeekShare.toFixed(1) + '%';
                
                if (prevWeek) {
                    const shareColor = shareChange >= 0 ? '#30d158' : '#ff453a';
                    const shareSymbol = shareChange >= 0 ? '▲' : '▼';
                    document.getElementById('modal-opp-share-comparison').innerHTML = 
                        `<span style="color: ${shareColor};">${shareSymbol} ${Math.abs(shareChange).toFixed(1)}% vs W${prevWeek.week}</span>`;
                } else {
                    document.getElementById('modal-opp-share-comparison').innerHTML = '';
                }
                
                document.getElementById('modal-opp-share-tooltip').textContent = 
                    'Player\'s share of team targets in the most recent week';
            } else {
                // RB - use opportunity share
                const thisWeekOpp = latestWeek.opportunities || 0;
                const thisWeekTeamOpp = latestWeek.teamOpportunities || 1;
                const thisWeekShare = (thisWeekOpp / thisWeekTeamOpp) * 100;
                
                const lastWeekOpp = prevWeek ? (prevWeek.opportunities || 0) : 0;
                const lastWeekTeamOpp = prevWeek ? (prevWeek.teamOpportunities || 1) : 1;
                const lastWeekShare = prevWeek ? (lastWeekOpp / lastWeekTeamOpp) * 100 : 0;
                const shareChange = thisWeekShare - lastWeekShare;
                
                document.getElementById('modal-opp-share-label').textContent = `Opp Share (W${latestWeekNum})`;
                document.getElementById('modal-opp-share').textContent = thisWeekShare.toFixed(1) + '%';
                
                if (prevWeek) {
                    const shareColor = shareChange >= 0 ? '#30d158' : '#ff453a';
                    const shareSymbol = shareChange >= 0 ? '▲' : '▼';
                    document.getElementById('modal-opp-share-comparison').innerHTML = 
                        `<span style="color: ${shareColor};">${shareSymbol} ${Math.abs(shareChange).toFixed(1)}% vs W${prevWeek.week}</span>`;
                } else {
                    document.getElementById('modal-opp-share-comparison').innerHTML = '';
                }
                
                document.getElementById('modal-opp-share-tooltip').textContent = 
                    'Player\'s share of team opportunities (carries + targets) in the most recent week';
            }

            // ============================================
            // STAT 6: Avg Tgt/Opp vs Top 24
            // ============================================
            if (player.position === 'WR' || player.position === 'TE') {
                const avgTargets = player.totalTargets / player.gamesPlayed;
                const top24AvgTargets = top24Players.reduce((sum, p) => 
                    sum + (p.totalTargets / p.gamesPlayed), 0) / top24Players.length;
                const targetsDiff = avgTargets - top24AvgTargets;
                
                document.getElementById('modal-avg-volume-label').textContent = 
                    `Avg Tgt vs Top ${player.position === 'TE' ? '12' : '24'}`;
                document.getElementById('modal-avg-volume').textContent = avgTargets.toFixed(1);
                
                const targetsColor = targetsDiff >= 0 ? '#30d158' : '#ff453a';
                const targetsSymbol = targetsDiff >= 0 ? '▲' : '▼';
                document.getElementById('modal-avg-volume-comparison').innerHTML = 
                    `<span style="color: ${targetsColor};">${targetsSymbol} ${Math.abs(targetsDiff).toFixed(1)} vs avg</span>`;
                
                document.getElementById('modal-avg-volume-tooltip').textContent = 
                    `Average targets per game compared to Top ${player.position === 'TE' ? '12' : '24'} ${player.position} average`;
            } else {
                // RB - use opportunities
                const avgOpps = player.totalOpportunities / player.gamesPlayed;
                const top24AvgOpps = top24Players.reduce((sum, p) => 
                    sum + (p.totalOpportunities / p.gamesPlayed), 0) / top24Players.length;
                const oppsDiff = avgOpps - top24AvgOpps;
                
                document.getElementById('modal-avg-volume-label').textContent = 'Avg Opp vs Top 24';
                document.getElementById('modal-avg-volume').textContent = avgOpps.toFixed(1);
                
                const oppsColor = oppsDiff >= 0 ? '#30d158' : '#ff453a';
                const oppsSymbol = oppsDiff >= 0 ? '▲' : '▼';
                document.getElementById('modal-avg-volume-comparison').innerHTML = 
                    `<span style="color: ${oppsColor};">${oppsSymbol} ${Math.abs(oppsDiff).toFixed(1)} vs avg</span>`;
                
                document.getElementById('modal-avg-volume-tooltip').textContent = 
                    'Average opportunities (carries + targets) per game compared to Top 24 RB average';
            }

            // ============================================
            // STAT 7: RZ Opp Share
            // ============================================
            const rzShare = (player.rzOpportunities / player.teamRzOpportunities) * 100 || 0;
            document.getElementById('modal-rz-share').textContent = rzShare.toFixed(1) + '%';
            
            // Calculate average RZ share for top 24
            const top24AvgRzShare = top24Players.reduce((sum, p) => 
                sum + ((p.rzOpportunities / p.teamRzOpportunities) * 100 || 0), 0) / top24Players.length;
            const rzShareDiff = rzShare - top24AvgRzShare;
            
            const rzShareColor = rzShareDiff >= 0 ? '#30d158' : '#ff453a';
            const rzShareSymbol = rzShareDiff >= 0 ? '▲' : '▼';
            document.getElementById('modal-rz-share-comparison').innerHTML = 
                `<span style="color: ${rzShareColor};">${rzShareSymbol} ${Math.abs(rzShareDiff).toFixed(1)}% vs avg</span>`;

            // ============================================
            // STAT 8: RZ Opp Avg vs Top 24
            // ============================================
            const rzOppsPerGame = player.rzOpportunities / player.gamesPlayed;
            const top24AvgRzOpps = top24Players.reduce((sum, p) => 
                sum + (p.rzOpportunities / p.gamesPlayed), 0) / top24Players.length;
            const rzOppsDiff = rzOppsPerGame - top24AvgRzOpps;
            
            document.getElementById('modal-rz-avg-label').textContent = 
                `RZ Avg vs Top ${player.position === 'TE' ? '12' : '24'}`;
            document.getElementById('modal-rz-avg').textContent = rzOppsPerGame.toFixed(1);
            
            const rzOppsColor = rzOppsDiff >= 0 ? '#30d158' : '#ff453a';
            const rzOppsSymbol = rzOppsDiff >= 0 ? '▲' : '▼';
            document.getElementById('modal-rz-avg-comparison').innerHTML = 
                `<span style="color: ${rzOppsColor};">${rzOppsSymbol} ${Math.abs(rzOppsDiff).toFixed(1)} vs avg</span>`;
            
            document.getElementById('modal-rz-avg-tooltip').textContent = 
                `Average red zone opportunities per game compared to Top ${player.position === 'TE' ? '12' : '24'} ${player.position} average`;


            // Update sentiment display
            updateModalSentiment(player.name);

            // Load comments
            loadComments(player.name);
            
            // Load schedule data
            loadPlayerSchedule(player.team, player.position);

            // Show modal first (important for chart rendering)
            document.getElementById('player-modal').classList.add('active');

            // Initialize swipeable stats for mobile
            if (window.innerWidth <= 768) {
                statsCurrentPage = 0;
                setTimeout(() => {
                    initStatsSwipe();
                    updateStatsPage();
                }, 100);
            }

            // Render charts - outcomes chart needs to wait for modal to be visible
            renderModalVarianceChart(player);
            renderModalSpiderChart(player);
            renderModalPRSChart(player);
            renderFloorMetricsChart(player);
            renderModalCandlesChart(player);

            // Delay outcomes chart rendering to ensure modal is fully visible
            setTimeout(() => {
                renderModalOutcomesChart(player);
            }, 50);

            // Reset to Reliability tab
            document.querySelectorAll('.chart-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.chart-content').forEach(content => content.classList.remove('active'));
            document.querySelector('.chart-tab[onclick*="reliability"]').classList.add('active');
            document.getElementById('modal-chart-reliability').classList.add('active');

            // Reset stats to expanded state
            const statsContainer = document.getElementById('modal-stats-container');
            const statsIcon = document.getElementById('stats-collapse-icon');
            const statsText = document.getElementById('stats-collapse-text');
            if (statsContainer) {
                statsContainer.style.display = '';
                statsIcon.textContent = '▼';
                statsText.textContent = 'Hide Stats';
            }

            // Setup spider explanation section
            const explanation = document.getElementById('spider-explanation');
            const icon = document.getElementById('spider-explanation-icon');
            if (explanation) {
                explanation.style.display = 'none'; // Collapsed by default
                icon.textContent = 'ℹ️';

                // Show correct metrics section based on position
                const wrMetrics = document.getElementById('spider-wr-metrics');
                const rbMetrics = document.getElementById('spider-rb-metrics');
                const teMetrics = document.getElementById('spider-te-metrics');
                if (player.position === 'WR') {
                    wrMetrics.style.display = 'block';
                    rbMetrics.style.display = 'none';
                    teMetrics.style.display = 'none';
                } else if (player.position === 'RB') {
                    wrMetrics.style.display = 'none';
                    rbMetrics.style.display = 'block';
                    teMetrics.style.display = 'none';
                } else if (player.position === 'TE') {
                    wrMetrics.style.display = 'none';
                    rbMetrics.style.display = 'none';
                    teMetrics.style.display = 'block';
                }
            }

            // Scroll modal to top
            setTimeout(() => {
                const modalBody = document.querySelector('#player-modal .modal');
                if (modalBody) {
                    modalBody.scrollTop = 0;
                }
            }, 100);
        }

        function updateModalSentiment(playerName) {
            const sentiment = getSentimentScore(playerName);
            const total = sentiment.total;
            const buyPct = total > 0 ? (sentiment.buy / total * 100) : 0;
            const sellPct = total > 0 ? (sentiment.sell / total * 100) : 0;
            const holdPct = total > 0 ? (sentiment.hold / total * 100) : 0;

            // Update 3-section bar widths
            const buySegment = document.getElementById('modal-sentiment-segment-buy');
            const holdSegment = document.getElementById('modal-sentiment-segment-hold');
            const sellSegment = document.getElementById('modal-sentiment-segment-sell');

            if (total > 0) {
                // Set segment widths based on vote percentages
                buySegment.style.width = buyPct + '%';
                holdSegment.style.width = holdPct + '%';
                sellSegment.style.width = sellPct + '%';
            } else {
                // No votes - show grey bar
                buySegment.style.width = '0%';
                holdSegment.style.width = '100%';
                sellSegment.style.width = '0%';
            }

            // Update vote count
            const voteCountEl = document.getElementById('modal-sentiment-vote-count');
            voteCountEl.textContent = total === 1 ? '1 vote' : `${total} votes`;

            // Highlight user's vote if exists
            document.querySelectorAll('.vote-btn').forEach(btn => btn.classList.remove('active'));
            const userVote = localStorage.getItem(`ffse_user_vote_${playerName}`);
            if (userVote) {
                document.querySelector(`.vote-btn.${userVote}-btn`)?.classList.add('active');
            }
        }

        function castVote(voteType) {
            if (!currentModalPlayer) return;

            const playerName = currentModalPlayer.name;

            // Check if user is clicking the same vote (undo)
            const previousVote = localStorage.getItem(`ffse_user_vote_${playerName}`);
            if (previousVote === voteType) {
                // User is undoing their vote
                if (!playerVotes[playerName]) {
                    playerVotes[playerName] = { buy: 0, sell: 0, hold: 0, lastVote: Date.now() };
                }
                playerVotes[playerName][previousVote] = Math.max(0, playerVotes[playerName][previousVote] - 1);

                // Remove user's vote from localStorage
                localStorage.removeItem(`ffse_user_vote_${playerName}`);

                // Save to localStorage
                saveSentimentData();

                // Update display
                updateModalSentiment(playerName);

                // Refresh player cards to show updated sentiment
                if (currentModalPlayer.position === 'WR') {
                    renderWRPlayerCards();
                } else if (currentModalPlayer.position === 'RB') {
                    renderRBPlayerCards();
                } else if (currentModalPlayer.position === 'TE') {
                    renderTEPlayerCards();
                }
                return; // Exit early - vote has been removed
            }

            // User is changing their vote or voting for first time
            // Remove previous vote if exists
            if (previousVote) {
                if (!playerVotes[playerName]) {
                    playerVotes[playerName] = { buy: 0, sell: 0, hold: 0, lastVote: Date.now() };
                }
                playerVotes[playerName][previousVote] = Math.max(0, playerVotes[playerName][previousVote] - 1);
            }

            // Add new vote
            if (!playerVotes[playerName]) {
                playerVotes[playerName] = { buy: 0, sell: 0, hold: 0, lastVote: Date.now() };
            }
            playerVotes[playerName][voteType]++;
            playerVotes[playerName].lastVote = Date.now();

            // Store user's vote
            localStorage.setItem(`ffse_user_vote_${playerName}`, voteType);

            // Save to localStorage
            saveSentimentData();

            // Update display
            updateModalSentiment(playerName);

            // Refresh player cards to show updated sentiment
            if (currentModalPlayer.position === 'WR') {
                renderWRPlayerCards();
            } else if (currentModalPlayer.position === 'RB') {
                renderRBPlayerCards();
            } else if (currentModalPlayer.position === 'TE') {
                renderTEPlayerCards();
            }
        }

        function loadComments(playerName) {
            if (!playerComments[playerName]) {
                playerComments[playerName] = [];
            }

            const commentList = document.getElementById('comment-list');
            const comments = playerComments[playerName].sort((a, b) => b.timestamp - a.timestamp);

            if (comments.length === 0) {
                commentList.innerHTML = '<div style="color: var(--text-secondary); font-size: 13px; text-align: center; padding: 20px;">No comments yet. Be the first!</div>';
                return;
            }

            commentList.innerHTML = comments.slice(0, 10).map(comment => {
                const timeAgo = getTimeAgo(comment.timestamp);
                return `
                    <div class="comment-item">
                        <div>${comment.text}</div>
                        <div class="comment-meta">${timeAgo}</div>
                    </div>
                `;
            }).join('');

            // Add Enter key listener
            const input = document.getElementById('comment-input');
            input.onkeypress = function(e) {
                if (e.key === 'Enter') {
                    submitComment();
                }
            };
        }

        function submitComment() {
            if (!currentModalPlayer) return;

            const input = document.getElementById('comment-input');
            const text = input.value.trim();

            if (!text) return;

            const playerName = currentModalPlayer.name;

            if (!playerComments[playerName]) {
                playerComments[playerName] = [];
            }

            playerComments[playerName].push({
                text: text,
                timestamp: Date.now(),
                user: 'Anonymous' // Could be enhanced with user system
            });

            // Save to localStorage
            localStorage.setItem('ffse_player_comments', JSON.stringify(playerComments));

            // Clear input
            input.value = '';

            // Reload comments
            loadComments(playerName);
        }

        function getTimeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);

            if (seconds < 60) return 'Just now';
            if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
            if (seconds < 86400) return Math.floor(seconds / 3600) + 'h ago';
            return Math.floor(seconds / 86400) + 'd ago';
        }

        function closeModal() {
            document.getElementById('player-modal').classList.remove('active');

            // Destroy charts
            if (modalVarianceChart) modalVarianceChart.destroy();
            if (modalOutcomesChart) modalOutcomesChart.destroy();
            if (modalSpiderChart) modalSpiderChart.destroy();
            if (modalShareChart) modalShareChart.destroy();
            if (modalTrendsChart) modalTrendsChart.destroy();
            
            // Reset stats page to first page
            if (window.innerWidth <= 768) {
                statsCurrentPage = 0;
                updateStatsPage();
            }
        }

        // Swipeable Stats Grid (Mobile Only)
        let statsCurrentPage = 0;
        let statsStartX = 0;
        let statsCurrentX = 0;
        let statsStartY = 0;
        let statsDragging = false;

        function initStatsSwipe() {
            const wrapper = document.getElementById('modal-stats-wrapper');
            if (!wrapper || window.innerWidth > 768) return; // Desktop - no swipe

            // Touch events
            wrapper.addEventListener('touchstart', handleStatsStart, { passive: true });
            wrapper.addEventListener('touchmove', handleStatsMove, { passive: false });
            wrapper.addEventListener('touchend', handleStatsEnd, { passive: true });

            // Mouse events (for testing)
            wrapper.addEventListener('mousedown', handleStatsStart);
            wrapper.addEventListener('mousemove', handleStatsMove);
            wrapper.addEventListener('mouseup', handleStatsEnd);
            wrapper.addEventListener('mouseleave', handleStatsEnd);

            // Dot click events
            document.querySelectorAll('.stats-dot').forEach(dot => {
                dot.addEventListener('click', () => {
                    statsCurrentPage = parseInt(dot.dataset.page);
                    updateStatsPage();
                });
            });
        }

        function handleStatsStart(e) {
            if (window.innerWidth > 768) return;
            statsDragging = true;
            statsStartX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
            statsStartY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
            statsCurrentX = statsStartX;
        }

        function handleStatsMove(e) {
            if (!statsDragging || window.innerWidth > 768) return;
            
            const currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
            const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
            
            const diffX = Math.abs(currentX - statsStartX);
            const diffY = Math.abs(currentY - statsStartY);
            
            // Only prevent default if horizontal swipe is dominant
            if (diffX > diffY && diffX > 10) {
                e.preventDefault();
                statsCurrentX = currentX;
                
                const diff = statsCurrentX - statsStartX;
                const wrapper = document.getElementById('modal-stats-wrapper');
                const currentTranslate = -statsCurrentPage * 100;
                const dragPercent = (diff / wrapper.offsetWidth) * 100;
                
                wrapper.style.transform = `translateX(${currentTranslate + dragPercent}%)`;
            } else if (diffY > 10) {
                // Vertical scroll - cancel drag
                statsDragging = false;
            }
        }

        function handleStatsEnd(e) {
            if (!statsDragging || window.innerWidth > 768) return;
            statsDragging = false;
            
            const diff = statsCurrentX - statsStartX;
            const threshold = 50; // pixels
            
            if (diff > threshold && statsCurrentPage > 0) {
                statsCurrentPage--;
            } else if (diff < -threshold && statsCurrentPage < 1) {
                statsCurrentPage++;
            }
            
            updateStatsPage();
        }

        function updateStatsPage() {
            const wrapper = document.getElementById('modal-stats-wrapper');
            if (!wrapper) return;
            
            wrapper.style.transform = `translateX(-${statsCurrentPage * 100}%)`;
            
            // Update dots
            document.querySelectorAll('.stats-dot').forEach((dot, index) => {
                dot.classList.toggle('active', index === statsCurrentPage);
            });
        }


        function switchModalChart(chartName) {
            // Update tabs
            document.querySelectorAll('.chart-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');

            // Update content
            document.querySelectorAll('.chart-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`modal-chart-${chartName}`).classList.add('active');

            // Charts are now fully loaded on modal open (no re-rendering needed)
        }

        function toggleSpiderExplanation() {
            const explanation = document.getElementById('spider-explanation');
            const icon = document.getElementById('spider-explanation-icon');

            if (explanation.style.display === 'none') {
                explanation.style.display = 'block';
                icon.textContent = '▼';
            } else {
                explanation.style.display = 'none';
                icon.textContent = 'ℹ️';
            }
        }

        function toggleStatsCollapse() {
            const container = document.getElementById('modal-stats-container');
            const icon = document.getElementById('stats-collapse-icon');
            const text = document.getElementById('stats-collapse-text');
            
            if (container.style.display === 'none') {
                container.style.display = '';
                icon.textContent = '▼';
                text.textContent = 'Hide Stats';
            } else {
                container.style.display = 'none';
                icon.textContent = '▶';
                text.textContent = 'Show Stats';
            }
        }

        function toggleTeamPlayers() {
            const container = document.getElementById('key-players-section');
            const icon = document.getElementById('team-players-collapse-icon');
            const text = document.getElementById('team-players-collapse-text');
            
            if (container.style.display === 'none') {
                container.style.display = '';
                icon.textContent = '▼';
                text.textContent = 'Hide Players';
            } else {
                container.style.display = 'none';
                icon.textContent = '▶';
                text.textContent = 'Show Players';
            }
        }

        function renderModalVarianceChart(player) {
            const ctx = document.getElementById('modal-variance-chart');

            if (modalVarianceChart) {
                modalVarianceChart.destroy();
            }

            const weeks = player.weeks.map(w => `W${w.week}`);
            const actuals = player.weeks.map(w => w.fpts);
            const expected = player.weeks.map(w => w.expectedFpts);
            const variance = player.weeks.map(w => w.variance);

            modalVarianceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: weeks,
                    datasets: [
                        {
                            type: 'line',
                            label: 'Actual',
                            data: actuals,
                            borderColor: '#fff',
                            borderWidth: 2,
                            fill: false,
                            pointRadius: 4,
                            pointBackgroundColor: '#fff',
                            yAxisID: 'y'
                        },
                        {
                            type: 'line',
                            label: 'Expected',
                            data: expected,
                            borderColor: '#8e8e93',
                            borderDash: [5, 5],
                            borderWidth: 2,
                            fill: false,
                            pointRadius: 4,
                            pointBackgroundColor: '#8e8e93',
                            yAxisID: 'y'
                        },
                        {
                            type: 'bar',
                            label: 'Variance',
                            data: variance,
                            backgroundColor: variance.map(v =>
                                v >= 0 ? 'rgba(48, 209, 88, 0.6)' : 'rgba(255, 69, 58, 0.6)'
                            ),
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            labels: { color: '#8e8e93' }
                        }
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Fantasy Points',
                                color: '#8e8e93'
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Variance',
                                color: '#8e8e93'
                            },
                            grid: { display: false },
                            ticks: { color: '#8e8e93' }
                        },
                        x: {
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }

        function renderModalOutcomesChart(player) {
            const ctx = document.getElementById('modal-outcomes-chart');

            if (modalOutcomesChart) {
                modalOutcomesChart.destroy();
            }

            // Get team color
            const teamColor = teamColors[player.team] || '#0a84ff';
            const teamColorRgba = hexToRgba(teamColor, 0.1);

            // Calculate average variance (how much they beat or miss expectations)
            const variances = player.weeks.map(w => w.variance);
            const avgVariance = variances.reduce((sum, v) => sum + v, 0) / variances.length;
            const weeksOverExpected = variances.filter(v => v > 0).length;
            const consistency = (weeksOverExpected / variances.length * 100).toFixed(0);

            const weeks = player.weeks.map(w => `W${w.week}`);
            const actuals = player.weeks.map(w => w.fpts);
            const expected = player.weeks.map(w => w.expectedFpts);

            modalOutcomesChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: weeks,
                    datasets: [
                        {
                            label: 'Actual',
                            data: actuals,
                            borderColor: teamColor,
                            backgroundColor: teamColorRgba,
                            borderWidth: 3,
                            fill: true,
                            tension: 0.3,
                            pointRadius: 5,
                            pointBackgroundColor: teamColor,
                            pointBorderColor: '#fff',
                            pointBorderWidth: 2
                        },
                        {
                            label: 'Expected',
                            data: expected,
                            borderColor: '#8e8e93',
                            borderDash: [5, 5],
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                            pointRadius: 4,
                            pointBackgroundColor: '#8e8e93'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                color: '#8e8e93',
                                font: { size: 12 },
                                usePointStyle: true,
                                pointStyle: 'line'
                            }
                        },
                        title: {
                            display: true,
                            text: [
                                `Avg ${avgVariance >= 0 ? '+' : ''}${avgVariance.toFixed(1)} vs Expected`,
                                `Beats Expectations: ${consistency}% of weeks (${weeksOverExpected}/${variances.length})`
                            ],
                            color: avgVariance >= 0 ? '#30d158' : '#ff453a',
                            padding: { bottom: 15 },
                            font: { size: 13, weight: '600' }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(1) + ' pts';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Fantasy Points',
                                color: '#8e8e93'
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        x: {
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }

        // Helper function to convert hex to rgba
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function renderModalSpiderChart(player) {
            const ctx = document.getElementById('modal-spider-chart');

            if (modalSpiderChart) {
                modalSpiderChart.destroy();
                modalSpiderChart = null;
            }

            // Get team color
            const teamColor = teamColors[player.team] || '#0a84ff';
            const teamColorRgba = hexToRgba(teamColor, 0.2);

            // Get all players for ranking
            const allPlayers = player.position === 'WR' ?
                Object.values(aggregatedWRs).filter(p => p.gamesPlayed >= 3) :
                player.position === 'RB' ?
                Object.values(aggregatedRBs).filter(p => p.gamesPlayed >= 3) :
                Object.values(aggregatedTEs).filter(p => p.gamesPlayed >= 3);

            // Calculate rankings for each metric (lower rank = better)
            let metrics = {};
            let rankings = {};

            if (player.position === 'WR') {
                // WR: Volume (targets/game), Efficiency (pts/target), Red Zone, Consistency
                const targetsPerGameData = allPlayers.map(p => ({
                    player: p,
                    value: p.totalTargets / p.gamesPlayed
                })).sort((a, b) => b.value - a.value);

                const efficiencyData = allPlayers.map(p => ({
                    player: p,
                    value: p.avgPoints / (p.totalTargets / p.gamesPlayed) // pts per target
                })).sort((a, b) => b.value - a.value);

                const redZoneData = allPlayers.map(p => ({
                    player: p,
                    value: p.rzOpportunities / p.gamesPlayed
                })).sort((a, b) => b.value - a.value);

                const teamShareData = allPlayers.map(p => ({
                    player: p,
                    value: p.latestWeekOppShare || 0
                })).sort((a, b) => b.value - a.value);

                // Catch Rate: Receptions / Targets (%)
                const catchRateData = allPlayers.map(p => {
                    // Calculate from raw data
                    const playerRows = wrData.filter(row => row.Team === p.team && row.Player === p.name);
                    let totalReceptions = 0;
                    let totalTargets = 0;
                    playerRows.forEach(row => {
                        totalReceptions += parseFloat(row.REC) || 0;
                        totalTargets += parseFloat(row.TGT) || 0;
                    });
                    const catchRate = totalTargets > 0 ? (totalReceptions / totalTargets) * 100 : 0;
                    return { player: p, value: catchRate };
                }).sort((a, b) => b.value - a.value);

                // Find player's rank in each category
                rankings = {
                    'Volume': targetsPerGameData.findIndex(p => p.player.id === player.id) + 1,
                    'Efficiency': efficiencyData.findIndex(p => p.player.id === player.id) + 1,
                    'Red Zone': redZoneData.findIndex(p => p.player.id === player.id) + 1,
                    'Team Share': teamShareData.findIndex(p => p.player.id === player.id) + 1,
                    'Catch Rate': catchRateData.findIndex(p => p.player.id === player.id) + 1
                };

            } else if (player.position === 'RB') {
                // RB: Volume (opps/game), Efficiency (pts/opp), Red Zone, Consistency
                const oppsPerGameData = allPlayers.map(p => ({
                    player: p,
                    value: p.totalOpportunities / p.gamesPlayed
                })).sort((a, b) => b.value - a.value);

                const efficiencyData = allPlayers.map(p => ({
                    player: p,
                    value: p.avgPoints / (p.totalOpportunities / p.gamesPlayed) // pts per opp
                })).sort((a, b) => b.value - a.value);

                const redZoneData = allPlayers.map(p => ({
                    player: p,
                    value: p.rzOpportunities / p.gamesPlayed
                })).sort((a, b) => b.value - a.value);

                const teamShareData = allPlayers.map(p => ({
                    player: p,
                    value: p.latestWeekOppShare || 0
                })).sort((a, b) => b.value - a.value);

                // Yards After Contact: YACON per attempt
                const yacData = allPlayers.map(p => {
                    // Calculate from raw data
                    const playerRows = rbData.filter(row => row.Team === p.team && row.Player === p.name);
                    let totalYACON = 0;
                    let totalATT = 0;
                    playerRows.forEach(row => {
                        totalYACON += parseFloat(row.YACON) || 0;
                        totalATT += parseFloat(row.ATT) || 0;
                    });
                    const yacPerAtt = totalATT > 0 ? totalYACON / totalATT : 0;
                    return { player: p, value: yacPerAtt };
                }).sort((a, b) => b.value - a.value);

                // Find player's rank in each category
                rankings = {
                    'Volume': oppsPerGameData.findIndex(p => p.player.id === player.id) + 1,
                    'Efficiency': efficiencyData.findIndex(p => p.player.id === player.id) + 1,
                    'Red Zone': redZoneData.findIndex(p => p.player.id === player.id) + 1,
                    'Team Share': teamShareData.findIndex(p => p.player.id === player.id) + 1,
                    'Yards After Contact': yacData.findIndex(p => p.player.id === player.id) + 1
                };
            } else if (player.position === 'TE') {
                // TE: Volume (targets/game), Efficiency (pts/target), Red Zone, Catch Rate, Team Share
                const targetsPerGameData = allPlayers.map(p => ({
                    player: p,
                    value: p.totalTargets / p.gamesPlayed
                })).sort((a, b) => b.value - a.value);

                const efficiencyData = allPlayers.map(p => ({
                    player: p,
                    value: p.avgPoints / (p.totalTargets / p.gamesPlayed) // pts per target
                })).sort((a, b) => b.value - a.value);

                const redZoneData = allPlayers.map(p => ({
                    player: p,
                    value: p.rzOpportunities / p.gamesPlayed
                })).sort((a, b) => b.value - a.value);

                const teamShareData = allPlayers.map(p => ({
                    player: p,
                    value: p.latestWeekOppShare || 0
                })).sort((a, b) => b.value - a.value);

                // Catch Rate: Receptions / Targets (%)
                const catchRateData = allPlayers.map(p => {
                    // Calculate from raw data
                    const playerRows = teData.filter(row => row.Team === p.team && row.Player === p.name);
                    let totalReceptions = 0;
                    let totalTargets = 0;
                    playerRows.forEach(row => {
                        totalReceptions += parseFloat(row.REC) || 0;
                        totalTargets += parseFloat(row.TGT) || 0;
                    });
                    const catchRate = totalTargets > 0 ? (totalReceptions / totalTargets) * 100 : 0;
                    return { player: p, value: catchRate };
                }).sort((a, b) => b.value - a.value);

                // Find player's rank in each category
                rankings = {
                    'Volume': targetsPerGameData.findIndex(p => p.player.id === player.id) + 1,
                    'Efficiency': efficiencyData.findIndex(p => p.player.id === player.id) + 1,
                    'Red Zone': redZoneData.findIndex(p => p.player.id === player.id) + 1,
                    'Team Share': teamShareData.findIndex(p => p.player.id === player.id) + 1,
                    'Catch Rate': catchRateData.findIndex(p => p.player.id === player.id) + 1
                };
            }

            // Check if player is in top 200 for all metrics
            const isTop200 = Object.values(rankings).every(rank => rank <= 200);

            if (!isTop200) {
                // Don't render chart for players outside top 200
                // Clear the canvas properly
                if (ctx) {
                    const context = ctx.getContext('2d');
                    if (context) {
                        context.clearRect(0, 0, ctx.width, ctx.height);
                        context.fillStyle = '#8e8e93';
                        context.font = '14px -apple-system, BlinkMacSystemFont, SF Pro Display';
                        context.textAlign = 'center';
                        context.fillText('Player Profile Not Available', ctx.width / 2, ctx.height / 2 - 10);
                        context.fillText('Rankings shown for Top 200 players only', ctx.width / 2, ctx.height / 2 + 10);
                    }
                }
                return;
            }

            // Convert rankings to scores (rank 1 = 100, rank 200 = 0.5)
            const labels = Object.keys(rankings);
            const data = labels.map(label => {
                const rank = rankings[label];
                // Linear scale: rank 1 gets 100, rank 200 gets 0.5
                // Formula: 100 - ((rank - 1) / 199 * 99.5)
                return Math.max(0.5, 100 - ((rank - 1) / 199 * 99.5));
            });

            modalSpiderChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: player.name,
                        data: data,
                        backgroundColor: teamColorRgba,
                        borderColor: teamColor,
                        borderWidth: 3,
                        pointBackgroundColor: teamColor,
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: teamColor,
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        pointBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: {
                        legend: { display: false },
                        title: {
                            display: true,
                            text: 'Rankings vs Top 200 (Higher = Better Rank)',
                            color: '#8e8e93',
                            font: { size: 12 }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const rank = rankings[context.label];
                                    const score = context.parsed.r.toFixed(0);
                                    return `${context.label}: #${rank} (Score: ${score}/100)`;
                                }
                            }
                        }
                    },
                    scales: {
                        r: {
                            beginAtZero: true,
                            min: 0,
                            max: 100,
                            ticks: {
                                stepSize: 20,
                                color: '#8e8e93',
                                backdropColor: 'transparent',
                                font: { size: 10 }
                            },
                            grid: {
                                color: '#1c1c1e'
                            },
                            pointLabels: {
                                color: '#fff',
                                font: {
                                    size: 12,
                                    weight: 'bold'
                                }
                            },
                            angleLines: {
                                color: '#1c1c1e'
                            }
                        }
                    }
                }
            });
        }

        function renderModalPRSChart(player) {
            const ctx = document.getElementById('prs-gauge-chart');
            if (!ctx) return;

            // Get all players of same position for normalization
            const positionPlayers = Object.values(allPlayers).filter(p => 
                p.position === player.position && p.gamesPlayed >= 3 && p.weeks && p.weeks.length > 0
            );

            // Defensive check: ensure we have enough players for comparison
            if (positionPlayers.length < 2) {
                console.warn(`Not enough ${player.position} players with valid data for PRS calculation`);
                // Set default values
                document.getElementById('prs-usage-value').textContent = '--';
                document.getElementById('prs-rz-value').textContent = '--';
                document.getElementById('prs-consistency-value').textContent = '--';
                document.getElementById('prs-games-value').textContent = '--';
                document.getElementById('prs-score-value').textContent = '--';
                return;
            }

            // Defensive check: ensure player has valid week data
            if (!player.weeks || player.weeks.length === 0) {
                console.warn(`No week data available for ${player.name} - cannot calculate PRS`);
                // Set default values
                document.getElementById('prs-usage-value').textContent = '--';
                document.getElementById('prs-rz-value').textContent = '--';
                document.getElementById('prs-consistency-value').textContent = '--';
                document.getElementById('prs-games-value').textContent = '--';
                document.getElementById('prs-score-value').textContent = '--';
                return;
            }

            // Calculate average usage share across all weeks (now using Usage_Share from CSV)
            const usageShare = player.weeks.reduce((sum, w) => sum + (w.usageShare || 0), 0) / player.weeks.length;
            
            // Calculate RZ share (now using RZ_Share from CSV)
            const rzShare = player.weeks.reduce((sum, w) => sum + (w.rzShare || 0), 0) / player.weeks.length;
            
            // Calculate average FP variance from CSV (lower is better = more consistent)
            const fpVariance = player.weeks.reduce((sum, w) => sum + (w.variance || 0), 0) / player.weeks.length;
            
            // Debug logging
            console.log(`PRS Debug for ${player.name}:`, {
                position: player.position,
                avgPoints: player.avgPoints,
                usageShare: usageShare,
                usageScore: usageShare * player.avgPoints,
                rzShare: rzShare,
                rzScore: rzShare * player.avgPoints,
                fpVariance: fpVariance
            });

            // Get max games in dataset
            const maxGames = Math.max(...positionPlayers.map(p => p.gamesPlayed));
            const gamesPlayedPct = player.gamesPlayed / maxGames;

            // Normalize components using min-max within position
            // USAGE: Use production-weighted opportunity score (usage × avg points)
            // This rewards players whose usage translates to actual fantasy production
            const usageValues = positionPlayers.map(p => {
                const avgUsage = p.weeks.reduce((sum, w) => sum + (w.usageShare || 0), 0) / p.weeks.length;
                return avgUsage * p.avgPoints; // Weight usage by production
            });
            const minUsage = Math.min(...usageValues);
            const maxUsage = Math.max(...usageValues);
            const playerUsageScore = usageShare * player.avgPoints;
            const usageNorm = maxUsage > minUsage ? (playerUsageScore - minUsage) / (maxUsage - minUsage) : 0;

            // RZ ROLE: Also weight by production for same reason
            const rzValues = positionPlayers.map(p => {
                const avgRZ = p.weeks.reduce((sum, w) => sum + (w.rzShare || 0), 0) / p.weeks.length;
                return avgRZ * p.avgPoints; // Weight RZ share by production
            });
            const minRZ = Math.min(...rzValues);
            const maxRZ = Math.max(...rzValues);
            const playerRZScore = rzShare * player.avgPoints;
            const rzNorm = maxRZ > minRZ ? (playerRZScore - minRZ) / (maxRZ - minRZ) : 0;

            // FLOOR RELIABILITY: How often do they meet/beat expectations, and by how much?
            // Calculate hit rate and average performance vs expected
            const floorReliabilityValues = positionPlayers.map(p => {
                let hitCount = 0;
                let totalDiff = 0;
                let validWeeks = 0;
                
                p.weeks.forEach(w => {
                    if (w.expectedFpts > 0 && w.fpts !== undefined) {
                        const diff = w.fpts - w.expectedFpts;
                        const diffPct = diff / w.expectedFpts;
                        
                        // Dynamic threshold: high scorers (14+) get 15% leeway, others get 10%
                        const threshold = p.avgPoints >= 14 ? -0.15 : -0.10;
                        
                        // Count as "hit" if within threshold or better
                        if (diffPct >= threshold) {
                            hitCount++;
                        }
                        
                        // Track performance differential
                        totalDiff += diffPct;
                        validWeeks++;
                    }
                });
                
                if (validWeeks === 0) return 0;
                
                const hitRate = hitCount / validWeeks;
                const avgDiffPct = totalDiff / validWeeks;
                
                // Composite score: 60% hit rate + 40% avg differential (capped)
                // Cap differential component at 0.50 (max contribution 0.20) to prevent outliers
                // Higher expected scorers (14+) get bonus for maintaining floor
                const expectedBonus = p.avgPoints >= 14 ? 0.15 : 0;
                const diffComponent = Math.min(0.50, Math.max(0, avgDiffPct + 0.25));
                return (0.60 * hitRate) + (0.40 * diffComponent) + expectedBonus;
            });
            
            const minFloor = Math.min(...floorReliabilityValues);
            const maxFloor = Math.max(...floorReliabilityValues);
            
            // Calculate this player's floor reliability
            let playerHitCount = 0;
            let playerTotalDiff = 0;
            let playerValidWeeks = 0;
            
            // Dynamic threshold for this player
            const playerThreshold = player.avgPoints >= 14 ? -0.15 : -0.10;
            
            player.weeks.forEach(w => {
                if (w.expectedFpts > 0 && w.fpts !== undefined) {
                    const diff = w.fpts - w.expectedFpts;
                    const diffPct = diff / w.expectedFpts;
                    
                    if (diffPct >= playerThreshold) {
                        playerHitCount++;
                    }
                    
                    playerTotalDiff += diffPct;
                    playerValidWeeks++;
                }
            });
            
            let consistencyNorm = 0;
            if (playerValidWeeks > 0) {
                const playerHitRate = playerHitCount / playerValidWeeks;
                const playerAvgDiffPct = playerTotalDiff / playerValidWeeks;
                const playerExpectedBonus = player.avgPoints >= 14 ? 0.15 : 0;
                
                // Cap differential component at 0.50 to prevent outliers from skewing normalization
                const playerDiffComponent = Math.min(0.50, Math.max(0, playerAvgDiffPct + 0.25));
                const playerFloorScore = (0.60 * playerHitRate) + (0.40 * playerDiffComponent) + playerExpectedBonus;
                
                consistencyNorm = maxFloor > minFloor ? (playerFloorScore - minFloor) / (maxFloor - minFloor) : 0;
                
                // Detailed debug logging
                console.log(`PRS Debug for ${player.name}:`, {
                    position: player.position,
                    avgPoints: player.avgPoints,
                    validWeeks: playerValidWeeks,
                    hitCount: playerHitCount,
                    hitRate: (playerHitRate * 100).toFixed(1) + '%',
                    avgDiffPct: (playerAvgDiffPct * 100).toFixed(1) + '%',
                    expectedBonus: playerExpectedBonus,
                    rawFloorScore: playerFloorScore.toFixed(3),
                    minFloorInPosition: minFloor.toFixed(3),
                    maxFloorInPosition: maxFloor.toFixed(3),
                    normalizedScore: consistencyNorm.toFixed(3),
                    finalScore: Math.round(consistencyNorm * 100)
                });
            } else {
                console.log(`PRS Debug for ${player.name}:`, {
                    position: player.position,
                    avgPoints: player.avgPoints,
                    validWeeks: 0,
                    floorReliabilityScore: 'N/A - no valid weeks'
                });
            }
            // Calculate PRS with position-specific weights
            let prsRaw;
            if (player.position === 'WR') {
                // WR weights: Opportunity Value 40%, Scoring Role 20%, Floor Reliability 30%, Games 10%
                prsRaw = (0.40 * usageNorm) + (0.20 * rzNorm) + (0.30 * consistencyNorm) + (0.10 * gamesPlayedPct);
            } else {
                // RB/TE weights: Opportunity Value 40%, Scoring Role 30%, Floor Reliability 20%, Games 10%
                prsRaw = (0.40 * usageNorm) + (0.30 * rzNorm) + (0.20 * consistencyNorm) + (0.10 * gamesPlayedPct);
            }
            const prs = Math.round(prsRaw * 100);

            // Update weight labels based on position
            if (player.position === 'WR') {
                document.getElementById('prs-usage-weight').textContent = '40%';
                document.getElementById('prs-rz-weight').textContent = '20%';
                document.getElementById('prs-consistency-weight').textContent = '30%';
                document.getElementById('prs-games-weight').textContent = '10%';
            } else {
                document.getElementById('prs-usage-weight').textContent = '40%';
                document.getElementById('prs-rz-weight').textContent = '30%';
                document.getElementById('prs-consistency-weight').textContent = '20%';
                document.getElementById('prs-games-weight').textContent = '10%';
            }

            // Function to get color based on score (0-100)
            function getScoreColor(score) {
                if (score >= 80) return '#30d158'; // Green (high)
                if (score >= 60) return '#0a84ff'; // Blue (high-middle)
                if (score >= 40) return '#ffd60a'; // Yellow (low-middle)
                return '#ff453a'; // Red (low)
            }

            // Calculate score values
            const usageScore = Math.round(usageNorm * 100);
            const rzScore = Math.round(rzNorm * 100);
            const consistencyScore = Math.round(consistencyNorm * 100);
            const gamesScore = Math.round(gamesPlayedPct * 100);

            // Update component bars and values in "X/100" format with color coding
            const usageColor = getScoreColor(usageScore);
            document.getElementById('prs-usage-value').textContent = usageScore + '/100';
            document.getElementById('prs-usage-value').style.color = usageColor;
            document.getElementById('prs-usage-bar').style.background = usageColor;
            document.getElementById('prs-usage-bar').style.width = usageScore + '%';

            const rzColor = getScoreColor(rzScore);
            document.getElementById('prs-rz-value').textContent = rzScore + '/100';
            document.getElementById('prs-rz-value').style.color = rzColor;
            document.getElementById('prs-rz-bar').style.background = rzColor;
            document.getElementById('prs-rz-bar').style.width = rzScore + '%';

            const consistencyColor = getScoreColor(consistencyScore);
            document.getElementById('prs-consistency-value').textContent = consistencyScore + '/100';
            document.getElementById('prs-consistency-value').style.color = consistencyColor;
            document.getElementById('prs-consistency-bar').style.background = consistencyColor;
            document.getElementById('prs-consistency-bar').style.width = consistencyScore + '%';

            const gamesColor = getScoreColor(gamesScore);
            document.getElementById('prs-games-value').textContent = gamesScore + '/100';
            document.getElementById('prs-games-value').style.color = gamesColor;
            document.getElementById('prs-games-bar').style.background = gamesColor;
            document.getElementById('prs-games-bar').style.width = gamesScore + '%';

            // Destroy existing chart
            if (window.modalPRSGauge) {
                window.modalPRSGauge.destroy();
            }

            // Determine color based on PRS score
            let gaugeColor = '#30d158'; // Green
            if (prs < 40) {
                gaugeColor = '#ff453a'; // Red
            } else if (prs < 70) {
                gaugeColor = '#ffd60a'; // Yellow
            }

            // Create doughnut gauge chart
            window.modalPRSGauge = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    datasets: [{
                        data: [prs, 100 - prs],
                        backgroundColor: [gaugeColor, '#1c1c1e'],
                        borderWidth: 0,
                        circumference: 270,
                        rotation: 225
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    cutout: '75%',
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    }
                },
                plugins: [{
                    id: 'centerText',
                    afterDraw: (chart) => {
                        const ctx = chart.ctx;
                        const centerX = chart.chartArea.left + (chart.chartArea.right - chart.chartArea.left) / 2;
                        const centerY = chart.chartArea.top + (chart.chartArea.bottom - chart.chartArea.top) / 2;
                        
                        // Responsive font sizes
                        const isMobile = window.innerWidth <= 768;
                        const scoreFontSize = isMobile ? 32 : 48;
                        const labelFontSize = isMobile ? 11 : 14;
                        const scoreOffset = isMobile ? -6 : -10;
                        const labelOffset = isMobile ? 18 : 25;
                        
                        ctx.save();
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        // Draw PRS score
                        ctx.fillStyle = '#fff';
                        ctx.font = `700 ${scoreFontSize}px -apple-system, BlinkMacSystemFont, SF Pro Display`;
                        ctx.fillText(prs, centerX, centerY + scoreOffset);
                        
                        // Draw "PRS" label
                        ctx.fillStyle = '#8e8e93';
                        ctx.font = `600 ${labelFontSize}px -apple-system, BlinkMacSystemFont, SF Pro Display`;
                        ctx.fillText('PRS', centerX, centerY + labelOffset);
                        
                        ctx.restore();
                    }
                }]
            });
        }

        function renderFloorMetricsChart(player) {
            // Calculate fragility score components
            const totalTDs = player.weeks.reduce((sum, w) => sum + (w.tds || 0), 0);
            const tdPoints = totalTDs * 6;
            const totalPoints = player.avgPoints * player.gamesPlayed;
            const tdDependency = (tdPoints / totalPoints) * 100;
            
            const points = player.weeks.map(w => w.fpts);
            const mean = points.reduce((sum, p) => sum + p, 0) / points.length;
            const variance = points.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / points.length;
            const stdDev = Math.sqrt(variance);
            const coefficientOfVariation = (stdDev / mean) * 100;
            
            let volumeMetric;
            if (player.position === 'WR' || player.position === 'TE') {
                volumeMetric = player.totalTargets / player.gamesPlayed;
            } else {
                volumeMetric = player.totalOpportunities / player.gamesPlayed;
            }
            const volumePenalty = volumeMetric < (player.position === 'RB' ? 12 : 5) ? 20 : 0;
            const fragilityScore = Math.min(100, (tdDependency * 0.5) + (coefficientOfVariation * 0.3) + volumePenalty);
            
            // Calculate ghost rate components
            const playableGames = player.weeks.filter(w => w.fpts >= 8).length;
            const boomGames = player.weeks.filter(w => w.fpts >= 15).length;
            const bustGames = player.weeks.filter(w => w.fpts < 8).length;
            const ghostRate = (bustGames / player.gamesPlayed) * 100;
            
            // Update Fragility Score
            const fragilityValue = Math.round(fragilityScore);
            
            // Color code based on score (negative framing - lower is better)
            let fragilityColor, fragilityLabel;
            if (fragilityValue < 33) {
                fragilityColor = '#30d158'; // Green - LOW fragility = GOOD
                fragilityLabel = ''; // No label for low risk
            } else if (fragilityValue < 67) {
                fragilityColor = '#FFD60A'; // Yellow - MEDIUM fragility
                fragilityLabel = 'MEDIUM RISK';
            } else {
                fragilityColor = '#ff453a'; // Red - HIGH fragility = BAD
                fragilityLabel = 'HIGH RISK';
            }
            
            // Update fragility display
            document.getElementById('floor-fragility-value').innerHTML = 
                `<span style="color: ${fragilityColor};">${fragilityValue}</span><span style="font-size: 16px; color: rgba(235, 235, 245, 0.5);">/100</span>`;
            
            // Only show pill if there's a label
            const fragilityPill = document.getElementById('floor-fragility-pill');
            if (fragilityLabel) {
                fragilityPill.textContent = fragilityLabel;
                fragilityPill.style.display = '';
            } else {
                fragilityPill.style.display = 'none';
            }
            
            // Animate bar
            const fragilityBar = document.getElementById('floor-fragility-bar');
            fragilityBar.style.background = fragilityColor;
            fragilityBar.style.width = fragilityValue + '%';
            
            // Update breakdown
            document.getElementById('floor-fragility-td').textContent = `TD Dependency: ${tdDependency.toFixed(1)}%`;
            document.getElementById('floor-fragility-var').textContent = `Variance: ${coefficientOfVariation.toFixed(1)}%`;
            document.getElementById('floor-fragility-vol').textContent = `Volume Penalty: ${volumePenalty}`;
            
            // Update Ghost Rate
            const ghostValue = Math.round(ghostRate);
            
            // Color code based on rate (negative framing - lower is better)
            let ghostColor, ghostLabel;
            if (ghostValue < 25) {
                ghostColor = '#30d158'; // Green - LOW ghost rate = GOOD
                ghostLabel = 'LOW RISK';
            } else if (ghostValue < 50) {
                ghostColor = '#FFD60A'; // Yellow - MEDIUM ghost rate
                ghostLabel = 'MEDIUM RISK';
            } else {
                ghostColor = '#ff453a'; // Red - HIGH ghost rate = BAD
                ghostLabel = 'HIGH RISK';
            }
            
            // Update ghost display
            document.getElementById('floor-ghost-value').innerHTML = 
                `<span style="color: ${ghostColor};">${ghostValue}</span><span style="font-size: 16px; color: rgba(235, 235, 245, 0.5);">%</span>`;
            document.getElementById('floor-ghost-pill').textContent = ghostLabel;
            
            // Animate bar
            const ghostBar = document.getElementById('floor-ghost-bar');
            ghostBar.style.background = ghostColor;
            ghostBar.style.width = ghostValue + '%';
            
            // Update breakdown
            document.getElementById('floor-ghost-playable').textContent = `Playable: ${playableGames} games`;
            document.getElementById('floor-ghost-boom').textContent = `Boom: ${boomGames} games`;
            document.getElementById('floor-ghost-bust').textContent = `Bust: ${bustGames} games`;
        }

        function renderModalCandlesChart(player) {
            const ctx = document.getElementById('modal-candles-chart');
            
            if (window.modalCandlesChart) {
                window.modalCandlesChart.destroy();
            }

            // Update scoring format label
            document.getElementById('candles-scoring-format').textContent = currentScoringFormat.toUpperCase();

            // Prepare data for candles
            const weeks = player.weeks.map(w => `Week ${w.week}`);
            const variance = player.weeks.map(w => w.variance || 0);
            const actuals = player.weeks.map(w => w.fpts || 0);
            const expected = player.weeks.map(w => w.expectedFpts || 0);

            // Create candlestick data using floating bars
            const candleData = player.weeks.map((w, i) => {
                const actual = w.fpts || 0;
                const exp = w.expectedFpts || 0;
                return [Math.min(exp, actual), Math.max(exp, actual)];
            });

            window.modalCandlesChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: weeks,
                    datasets: [
                        {
                            label: 'Expected Baseline',
                            data: expected,
                            type: 'line',
                            borderColor: '#636366',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            order: 1
                        },
                        {
                            label: 'Performance Range',
                            data: candleData,
                            backgroundColor: function(context) {
                                const index = context.dataIndex;
                                const actual = actuals[index];
                                const exp = expected[index];
                                return actual >= exp ? 'rgba(48, 209, 88, 0.25)' : 'rgba(255, 69, 58, 0.25)';
                            },
                            borderColor: function(context) {
                                const index = context.dataIndex;
                                const actual = actuals[index];
                                const exp = expected[index];
                                return actual >= exp ? 'rgba(48, 209, 88, 1)' : 'rgba(255, 69, 58, 1)';
                            },
                            borderWidth: 2,
                            borderRadius: 2,
                            barPercentage: 0.6,
                            categoryPercentage: 0.85,
                            order: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: window.innerWidth <= 768 ? 1.5 : 2.5,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: window.innerWidth > 768,
                            position: 'top',
                            align: 'end',
                            labels: {
                                color: '#8e8e93',
                                font: {
                                    size: 11
                                },
                                padding: 12,
                                usePointStyle: true,
                                filter: function(item) {
                                    return item.text !== 'Expected Baseline';
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#fff',
                            bodyColor: '#8e8e93',
                            padding: 12,
                            displayColors: false,
                            callbacks: {
                                title: function(context) {
                                    return weeks[context[0].dataIndex];
                                },
                                label: function(context) {
                                    const index = context.dataIndex;
                                    const actual = actuals[index];
                                    const exp = expected[index];
                                    const diff = actual - exp;
                                    const pct = exp > 0 ? ((diff / exp) * 100).toFixed(1) : '0.0';
                                    
                                    return [
                                        `Actual: ${actual.toFixed(1)} pts`,
                                        `Expected: ${exp.toFixed(1)} pts`,
                                        `Variance: ${diff >= 0 ? '+' : ''}${diff.toFixed(1)} (${diff >= 0 ? '+' : ''}${pct}%)`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)',
                                drawBorder: false
                            },
                            ticks: {
                                color: '#8e8e93',
                                font: {
                                    size: window.innerWidth <= 768 ? 9 : 11
                                },
                                maxRotation: 45,
                                minRotation: 0
                            }
                        },
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)',
                                drawBorder: false
                            },
                            ticks: {
                                color: '#8e8e93',
                                font: {
                                    size: window.innerWidth <= 768 ? 9 : 11
                                },
                                callback: function(value) {
                                    return value.toFixed(1);
                                }
                            },
                            title: {
                                display: window.innerWidth > 768,
                                text: 'Fantasy Points',
                                color: '#8e8e93',
                                font: {
                                    size: 12,
                                    weight: '600'
                                }
                            }
                        }
                    }
                }
            });

            // Generate summary statistics
            const aboveCount = variance.filter(v => v > 0).length;
            const belowCount = variance.filter(v => v < 0).length;
            const avgVariance = variance.reduce((sum, v) => sum + v, 0) / variance.length;
            const hitRate = ((aboveCount / variance.length) * 100).toFixed(0);

            const summaryHTML = `
                <div style="background: var(--bg-elevated); border-radius: 8px; padding: 16px; text-align: center;">
                    <div style="font-size: 28px; font-weight: 700; color: var(--positive); margin-bottom: 4px;">${aboveCount}</div>
                    <div style="font-size: 12px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px;">Weeks Above Expected</div>
                </div>
                <div style="background: var(--bg-elevated); border-radius: 8px; padding: 16px; text-align: center;">
                    <div style="font-size: 28px; font-weight: 700; color: var(--negative); margin-bottom: 4px;">${belowCount}</div>
                    <div style="font-size: 12px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px;">Weeks Below Expected</div>
                </div>
                <div style="background: var(--bg-elevated); border-radius: 8px; padding: 16px; text-align: center;">
                    <div style="font-size: 28px; font-weight: 700; color: ${avgVariance >= 0 ? 'var(--positive)' : 'var(--negative)'}; margin-bottom: 4px;">
                        ${avgVariance >= 0 ? '+' : ''}${avgVariance.toFixed(1)}
                    </div>
                    <div style="font-size: 12px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px;">Avg Weekly Variance</div>
                </div>
                <div style="background: var(--bg-elevated); border-radius: 8px; padding: 16px; text-align: center;">
                    <div style="font-size: 28px; font-weight: 700; color: ${hitRate >= 50 ? 'var(--positive)' : 'var(--text-primary)'}; margin-bottom: 4px;">
                        ${hitRate}%
                    </div>
                    <div style="font-size: 12px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px;">Hit Rate</div>
                </div>
            `;
            
            document.getElementById('candles-summary').innerHTML = summaryHTML;
        }

        function renderModalShareChart(player) {
            const ctx = document.getElementById('modal-share-chart');

            if (modalShareChart) {
                modalShareChart.destroy();
                modalShareChart = null;
            }

            // Get team data from latest week
            const latestWeek = player.latestWeek;
            let teamData = [];

            if (player.position === 'WR') {
                teamData = wrData.filter(row =>
                    row.Team === player.team &&
                    parseInt(row.Week) === latestWeek &&
                    row.Player &&
                    parseFloat(row.TGT) > 0
                );
            } else {
                teamData = rbData.filter(row =>
                    row.Team === player.team &&
                    parseInt(row.Week) === latestWeek &&
                    row.Player &&
                    parseFloat(row['RB Opp']) > 0
                );
            }

            // Calculate shares for each player
            const playerShares = teamData.map(row => {
                let share = 0;
                if (player.position === 'WR') {
                    share = parseFloat(row['% TM']) || 0;
                } else {
                    // Calculate RB share
                    const playerOpp = parseFloat(row['RB Opp']) || 0;
                    const teamTotal = teamData.reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);
                    share = teamTotal > 0 ? (playerOpp / teamTotal) * 100 : 0;
                }

                return {
                    name: row.Player,
                    share: share,
                    isTarget: row.Player === player.name
                };
            });

            // Sort by share
            playerShares.sort((a, b) => b.share - a.share);

            // Get top 3 (including our player) + everyone else
            const top3 = playerShares.slice(0, 3);
            const others = playerShares.slice(3);
            const othersTotal = others.reduce((sum, p) => sum + p.share, 0);

            const labels = top3.map(p => p.name);
            const data = top3.map(p => p.share);

            // Generate color palette from team color
            const teamColor = teamColors[player.team] || '#0a84ff';
            const colorPalette = getColorPalette(teamColor, 3);
            const colors = colorPalette.slice(0, top3.length);

            if (othersTotal > 0) {
                labels.push('Everyone Else');
                data.push(othersTotal);
                colors.push('#1c1c1e');
            }

            modalShareChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colors,
                        borderColor: '#0a0a0a',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        animateRotate: true,
                        animateScale: true,
                        duration: 1200,
                        easing: 'easeInOutQuart'
                    },
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                color: '#8e8e93',
                                font: { weight: 'bold' }
                            },
                            position: 'bottom'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.label}: ${context.parsed.toFixed(1)}%`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function renderModalTrendsChart(player) {
            const ctx = document.getElementById('modal-trends-chart');

            if (modalTrendsChart) {
                modalTrendsChart.destroy();
            }

            if (player.position === 'RB') {
                // For RBs: Show line chart with all team RBs' opportunity shares

                // Get all RBs from this team
                const teamRBs = Object.values(aggregatedRBs).filter(rb => rb.team === player.team);

                // Get all weeks that have been played
                const allWeeks = [...new Set(player.weeks.map(w => w.week))].sort((a, b) => a - b);

                // Calculate total opportunities per week
                const weekTotals = {};
                allWeeks.forEach(weekNum => {
                    const weekData = rbData.filter(row =>
                        row.Team === player.team &&
                        parseInt(row.Week) === weekNum &&
                        parseFloat(row['RB Opp']) > 0
                    );
                    weekTotals[weekNum] = weekData.reduce((sum, row) => sum + (parseFloat(row['RB Opp']) || 0), 0);
                });

                // Calculate total opportunity share for each RB across all weeks to rank them
                const rbTotalShares = teamRBs.map(rb => {
                    const totalShare = allWeeks.reduce((sum, weekNum) => {
                        const weekData = rbData.filter(row =>
                            row.Team === rb.team &&
                            parseInt(row.Week) === weekNum &&
                            parseFloat(row['RB Opp']) > 0
                        );
                        const rbWeek = weekData.find(row => row.Player === rb.name);
                        const totalOpp = weekData.reduce((sum, row) => sum + (parseFloat(row['RB Opp']) || 0), 0);
                        const weekShare = rbWeek && totalOpp > 0 ? (parseFloat(rbWeek['RB Opp']) / totalOpp * 100) : 0;
                        return sum + weekShare;
                    }, 0);
                    return { rb, totalShare };
                });

                // Sort by total share and get top 3
                rbTotalShares.sort((a, b) => b.totalShare - a.totalShare);
                const top3RBs = rbTotalShares.slice(0, 3).map(item => item.rb);

                // Generate color palette from team color for top 3
                const teamColor = teamColors[player.team] || '#0a84ff';
                const colorPalette = getColorPalette(teamColor, 3);

                // Create datasets for top 3 RBs
                const datasets = top3RBs.map((rb, index) => {
                    const rbColor = colorPalette[index];

                    // Calculate opportunity share for each week
                    const shareData = allWeeks.map(weekNum => {
                        const weekData = rbData.filter(row =>
                            row.Team === rb.team &&
                            parseInt(row.Week) === weekNum &&
                            parseFloat(row['RB Opp']) > 0
                        );
                        const rbWeek = weekData.find(row => row.Player === rb.name);
                        const totalOpp = weekData.reduce((sum, row) => sum + (parseFloat(row['RB Opp']) || 0), 0);
                        return rbWeek && totalOpp > 0 ? (parseFloat(rbWeek['RB Opp']) / totalOpp * 100) : null;
                    });

                    return {
                        label: rb.name,
                        data: shareData,
                        borderColor: rbColor,  // Use full color for all top 3
                        backgroundColor: 'transparent',
                        borderWidth: rb.id === player.id ? 4 : 2,  // Only thickness varies
                        tension: 0.3,
                        pointRadius: rb.id === player.id ? 6 : 3,  // Point size varies
                        pointBackgroundColor: rbColor,
                        pointBorderColor: '#0a0a0a',
                        pointBorderWidth: 2,
                        spanGaps: true
                    };
                });

                // Add "Everyone Else" line if there are more than 3 RBs
                if (teamRBs.length > 3) {
                    const everyoneElseData = allWeeks.map(weekNum => {
                        // Calculate share for everyone else
                        const weekData = rbData.filter(row =>
                            row.Team === player.team &&
                            parseInt(row.Week) === weekNum &&
                            parseFloat(row['RB Opp']) > 0
                        );
                        const totalOpp = weekData.reduce((sum, row) => sum + (parseFloat(row['RB Opp']) || 0), 0);

                        // Calculate top 3 share
                        const top3Share = top3RBs.reduce((sum, rb) => {
                            const rbWeek = weekData.find(row => row.Player === rb.name);
                            const rbOpp = rbWeek ? parseFloat(rbWeek['RB Opp']) || 0 : 0;
                            return sum + (totalOpp > 0 ? (rbOpp / totalOpp * 100) : 0);
                        }, 0);

                        return totalOpp > 0 ? Math.max(0, 100 - top3Share) : null;
                    });

                    datasets.push({
                        label: 'Everyone Else',
                        data: everyoneElseData,
                        borderColor: '#1c1c1e',
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 2,
                        pointBackgroundColor: '#1c1c1e',
                        pointBorderColor: '#0a0a0a',
                        pointBorderWidth: 2,
                        spanGaps: true,
                        borderDash: [5, 5]
                    });
                }

                modalTrendsChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: allWeeks.map(w => `Week ${w}`),
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'bottom',
                                labels: {
                                    color: '#8e8e93',
                                    font: { size: 12 },
                                    boxWidth: 15,
                                    padding: 10
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    title: (context) => {
                                        const weekNum = allWeeks[context[0].dataIndex];
                                        const totalOpps = weekTotals[weekNum];
                                        return `Week ${weekNum} (${totalOpps.toFixed(0)} Total RB Opps)`;
                                    },
                                    label: (context) => `${context.dataset.label}: ${context.parsed.y ? context.parsed.y.toFixed(1) : '0'}% share`
                                }
                            }
                        },
                        scales: {
                            x: {
                                grid: { color: '#2c2c2e' },
                                ticks: { color: '#8e8e93' }
                            },
                            y: {
                                beginAtZero: true,
                                max: 100,
                                title: {
                                    display: true,
                                    text: 'Opportunity Share %',
                                    color: '#8e8e93'
                                },
                                grid: { color: '#2c2c2e' },
                                ticks: {
                                    color: '#8e8e93',
                                    callback: (value) => value + '%'
                                }
                            }
                        }
                    }
                });
            } else {
                // For WRs: Keep stacked bar chart

                // Get all weeks that player played
                const weeks = player.weeks.map(w => w.week);

                // For each week, get team data and calculate shares
                const weeklyShares = {};
                const weekTotals = {};

                weeks.forEach(weekNum => {
                    const teamData = wrData.filter(row =>
                        row.Team === player.team &&
                        parseInt(row.Week) === weekNum &&
                        row.Player &&
                        parseFloat(row.TGT) > 0
                    );

                    // Calculate total targets for this week
                    weekTotals[weekNum] = teamData.reduce((sum, row) => sum + (parseFloat(row.TGT) || 0), 0);

                    // Calculate shares for this week
                    const playerShares = teamData.map(row => {
                        const share = parseFloat(row['% TM']) || 0;
                        return {
                            name: row.Player,
                            share: share
                        };
                    });

                    // Sort by share
                    playerShares.sort((a, b) => b.share - a.share);

                    weeklyShares[weekNum] = playerShares;
                });

                // Identify consistent top 3 players across all weeks
                const allPlayers = new Map();
                Object.values(weeklyShares).forEach(weekData => {
                    weekData.forEach(p => {
                        if (!allPlayers.has(p.name)) {
                            allPlayers.set(p.name, 0);
                        }
                        allPlayers.set(p.name, allPlayers.get(p.name) + p.share);
                    });
                });

                // Get top 3 by total share across all weeks
                const sortedPlayers = Array.from(allPlayers.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3)
                    .map(entry => entry[0]);

                // Build datasets for stacked bar chart
                const labels = weeks.map(w => `W${w}`);
                const datasets = [];

                // Generate color palette from team color
                const teamColor = teamColors[player.team] || '#0a84ff';
                const colorPalette = getColorPalette(teamColor, 3);

                // Use color palette for each player
                sortedPlayers.forEach((playerName, idx) => {
                    const color = colorPalette[idx];

                    const weeklyData = weeks.map(weekNum => {
                        const weekData = weeklyShares[weekNum];
                        const playerWeekData = weekData.find(p => p.name === playerName);
                        return playerWeekData ? playerWeekData.share : 0;
                    });

                    datasets.push({
                        label: playerName,
                        data: weeklyData,
                        backgroundColor: color,
                        borderColor: '#0a0a0a',
                        borderWidth: 1
                    });
                });

                // Everyone else
                const othersData = weeks.map(weekNum => {
                    const weekData = weeklyShares[weekNum];
                    const top3Total = weekData
                        .filter(p => sortedPlayers.includes(p.name))
                        .reduce((sum, p) => sum + p.share, 0);
                    return Math.max(0, 100 - top3Total);
                });

                datasets.push({
                    label: 'Everyone Else',
                    data: othersData,
                    backgroundColor: '#1c1c1e',
                    borderColor: '#0a0a0a',
                    borderWidth: 1
                });

                modalTrendsChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                labels: { color: '#8e8e93' },
                                position: 'bottom'
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(context) {
                                        const weekNum = weeks[context[0].dataIndex];
                                        const totalTargets = weekTotals[weekNum];
                                        return `W${weekNum} (${totalTargets.toFixed(0)} Total Targets)`;
                                    },
                                    label: function(context) {
                                        return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                stacked: true,
                                grid: { color: '#2c2c2e' },
                                ticks: { color: '#8e8e93' }
                            },
                            y: {
                                stacked: true,
                                beginAtZero: true,
                                max: 100,
                                title: {
                                    display: true,
                                    text: 'Opportunity Share %',
                                    color: '#8e8e93'
                                },
                                grid: { color: '#2c2c2e' },
                                ticks: { color: '#8e8e93' }
                            }
                        }
                    }
                });
            }
        }

        /* ============================================
           New: Evaluation Chart Rendering + Trend Animation
           ============================================ */
        /**
 * Render WR Evaluation Chart 1: Volume vs Efficiency
 * X = Targets per Game, Y = Fantasy Points per Target
 */
function renderWREvalVolumeEfficiency(week = null) {
    const ctx = document.getElementById('wr-eval-volume-efficiency');
    if (!ctx) return;

    const weekData = getEvaluationWeekData(evaluationDataWR, week);

    // Filter by total fantasy points
    const topPlayers = weekData
        .filter(p => p.aggregate.gamesPlayed >= 3)
        .sort((a, b) => b.aggregate.totalFpts - a.aggregate.totalFpts)
        .slice(0, 50);

    const data = topPlayers.map(player => ({
        x: player.targetsPerGame || player.targets || 0,
        y: player.fptsPerTarget || 0,
        label: player.player,
        player: player
    }));

    // Calculate medians for quadrant lines
    const xValues = data.map(d => d.x).filter(x => x > 0).sort((a, b) => a - b);
    const yValues = data.map(d => d.y).filter(y => y > 0).sort((a, b) => a - b);
    const medianX = xValues[Math.floor(xValues.length / 2)] || 5;
    const medianY = yValues[Math.floor(yValues.length / 2)] || 1.5;

    if (wrEvalVolumeEfficiencyChart) wrEvalVolumeEfficiencyChart.destroy();

    wrEvalVolumeEfficiencyChart = new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: [{
                data: data,
                backgroundColor: data.map(d => {
                    const color = teamColors[d.player.team] || '#666';
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, 0.7)`;
                }),
                borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                borderWidth: 2,
                pointRadius: 8,
                pointHoverRadius: 12
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: (context) => {
                            const p = context.raw.player;
                            return [
                                p.player,
                                `Tgts/G: ${context.parsed.x.toFixed(1)}`,
                                `Pts/Tgt: ${context.parsed.y.toFixed(2)}`,
                                `Total: ${p.aggregate.totalFpts.toFixed(1)} pts`
                            ];
                        }
                    }
                },
                annotation: {
                    annotations: {
                        vLine: {
                            type: 'line',
                            xMin: medianX,
                            xMax: medianX,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        hLine: {
                            type: 'line',
                            yMin: medianY,
                            yMax: medianY,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        topRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['Reliable Studs', '(Hold)'],
                            color: '#30d158',
                            font: { size: 13, weight: 'bold' }
                        },
                        topLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.5,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['Efficient Sleepers', '(Buy Low)'],
                            color: '#0a84ff',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.min(...yValues) * 2.0,
                            content: ['Volume, Poor Efficiency', '(Sell Window)'],
                            color: '#FFD60A',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.5,
                            yValue: Math.min(...yValues) * 2.0,
                            content: ['Bench Fodder'],
                            color: '#ff453a',
                            font: { size: 13, weight: 'bold' }
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: 'Targets per Game →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' }
                },
                y: {
                    title: { display: true, text: 'Fantasy Points per Target →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' }
                }
            }
        }
    });
}

/**
 * Render WR Evaluation Chart 2: Target Share vs RZ Share
 * X = Target Share %, Y = Red Zone Target Share %
 */
function renderWREvalShareRZ(week = null) {
    const ctx = document.getElementById('wr-eval-share-rz');
    if (!ctx) return;

    const weekData = getEvaluationWeekData(evaluationDataWR, week);

    // Filter by total fantasy points
    const topPlayers = weekData
        .filter(p => p.aggregate.gamesPlayed >= 3)
        .sort((a, b) => b.aggregate.totalFpts - a.aggregate.totalFpts)
        .slice(0, 50);

    const data = topPlayers.map(player => ({
        x: player.targetShare || 0,
        y: player.rzTargetShare || 0,
        label: player.player,
        player: player
    }));

    // Calculate medians
    const xValues = data.map(d => d.x).filter(x => x > 0).sort((a, b) => a - b);
    const yValues = data.map(d => d.y).filter(y => y > 0).sort((a, b) => a - b);
    const medianX = xValues[Math.floor(xValues.length / 2)] || 20;
    const medianY = yValues[Math.floor(yValues.length / 2)] || 20;

    if (wrEvalShareRZChart) wrEvalShareRZChart.destroy();

    wrEvalShareRZChart = new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: [{
                data: data,
                backgroundColor: data.map(d => {
                    const color = teamColors[d.player.team] || '#666';
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, 0.7)`;
                }),
                borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                borderWidth: 2,
                pointRadius: 8,
                pointHoverRadius: 12
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: (context) => {
                            const p = context.raw.player;
                            return [
                                p.player,
                                `Tgt Share: ${context.parsed.x.toFixed(1)}%`,
                                `RZ Share: ${context.parsed.y.toFixed(1)}%`,
                                `Total: ${p.aggregate.totalFpts.toFixed(1)} pts`
                            ];
                        }
                    }
                },
                annotation: {
                    annotations: {
                        vLine: {
                            type: 'line',
                            xMin: medianX,
                            xMax: medianX,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        hLine: {
                            type: 'line',
                            yMin: medianY,
                            yMax: medianY,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        topRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['Alpha WR1s'],
                            color: '#30d158',
                            font: { size: 13, weight: 'bold' }
                        },
                        topLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.3,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['TD-Dependent', 'Boom/Busts'],
                            color: '#FFD60A',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.min(...yValues) * 2.0,
                            content: ['Chain Movers'],
                            color: '#0a84ff',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.3,
                            yValue: Math.min(...yValues) * 2.0,
                            content: ['Background Noise'],
                            color: '#ff453a',
                            font: { size: 13, weight: 'bold' }
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: 'Target Share (% of Team) →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93', callback: (value) => value + '%' }
                },
                y: {
                    title: { display: true, text: 'Red Zone Target Share (% of Team) →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93', callback: (value) => value + '%' }
                }
            }
        }
    });
}

/**
 * Render RB Evaluation Chart 1: Total vs Red Zone Opportunities
 * X = Opportunities per Game, Y = RZ Opportunities per Game
 */
function renderRBEvalTotalRZ(week = null) {
    const ctx = document.getElementById('rb-eval-total-rz');
    if (!ctx) return;

    const weekData = getEvaluationWeekData(evaluationDataRB, week);

    // Filter by total fantasy points
    const topPlayers = weekData
        .filter(p => p.aggregate.gamesPlayed >= 3)
        .sort((a, b) => b.aggregate.totalFpts - a.aggregate.totalFpts)
        .slice(0, 50);

    const data = topPlayers.map(player => ({
        x: player.opportunitiesPerGame || 0,
        y: player.rzOpportunitiesPerGame || 0,
        label: player.player,
        player: player
    }));

    // Calculate medians
    const xValues = data.map(d => d.x).filter(x => x > 0).sort((a, b) => a - b);
    const yValues = data.map(d => d.y).filter(y => y > 0).sort((a, b) => a - b);
    const medianX = xValues[Math.floor(xValues.length / 2)] || 12;
    const medianY = yValues[Math.floor(yValues.length / 2)] || 2;

    if (rbEvalTotalRZChart) rbEvalTotalRZChart.destroy();

    rbEvalTotalRZChart = new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: [{
                data: data,
                backgroundColor: data.map(d => {
                    const color = teamColors[d.player.team] || '#666';
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, 0.7)`;
                }),
                borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                borderWidth: 2,
                pointRadius: 8,
                pointHoverRadius: 12
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: (context) => {
                            const p = context.raw.player;
                            return [
                                p.player,
                                `Opps/G: ${context.parsed.x.toFixed(1)}`,
                                `RZ Opps/G: ${context.parsed.y.toFixed(1)}`,
                                `Total: ${p.aggregate.totalFpts.toFixed(1)} pts`
                            ];
                        }
                    }
                },
                annotation: {
                    annotations: {
                        vLine: {
                            type: 'line',
                            xMin: medianX,
                            xMax: medianX,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        hLine: {
                            type: 'line',
                            yMin: medianY,
                            yMax: medianY,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        topRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['True Workhorses', '(Buy/Hold)'],
                            color: '#30d158',
                            font: { size: 13, weight: 'bold' }
                        },
                        topLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.2,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['TD Vultures', '(Sell High)'],
                            color: '#FFD60A',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.min(...yValues) * 1.5,
                            content: ['Between-the-20s Backs', '(Neutral)'],
                            color: '#0a84ff',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.2,
                            yValue: Math.min(...yValues) * 1.5,
                            content: ['Irrelevant Depth'],
                            color: '#ff453a',
                            font: { size: 13, weight: 'bold' }
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: 'Opportunities per Game (Rush + Targets) →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' }
                },
                y: {
                    title: { display: true, text: 'Red Zone Opportunities per Game →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' }
                }
            }
        }
    });
}

/**
 * Render RB Evaluation Chart 2: Volume vs Efficiency
 * X = Opportunities per Game, Y = Efficiency (Pts per Opp)
 */
function renderRBEvalVolumeEfficiency(week = null) {
    const ctx = document.getElementById('rb-eval-volume-efficiency');
    if (!ctx) return;

    const weekData = getEvaluationWeekData(evaluationDataRB, week);

    // Filter by total fantasy points
    const topPlayers = weekData
        .filter(p => p.aggregate.gamesPlayed >= 3)
        .sort((a, b) => b.aggregate.totalFpts - a.aggregate.totalFpts)
        .slice(0, 50);

    const data = topPlayers.map(player => ({
        x: player.opportunitiesPerGame || 0,
        y: player.efficiency || 0,
        label: player.player,
        player: player
    }));

    // Calculate medians
    const xValues = data.map(d => d.x).filter(x => x > 0).sort((a, b) => a - b);
    const yValues = data.map(d => d.y).filter(y => y > 0).sort((a, b) => a - b);
    const medianX = xValues[Math.floor(xValues.length / 2)] || 12;
    const medianY = yValues[Math.floor(yValues.length / 2)] || 1;

    if (rbEvalVolumeEfficiencyChart) rbEvalVolumeEfficiencyChart.destroy();

    rbEvalVolumeEfficiencyChart = new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: [{
                data: data,
                backgroundColor: data.map(d => {
                    const color = teamColors[d.player.team] || '#666';
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, 0.7)`;
                }),
                borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                borderWidth: 2,
                pointRadius: 8,
                pointHoverRadius: 12
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: (context) => {
                            const p = context.raw.player;
                            return [
                                p.player,
                                `Opps/G: ${context.parsed.x.toFixed(1)}`,
                                `Efficiency: ${context.parsed.y.toFixed(2)} pts/opp`,
                                `Total: ${p.aggregate.totalFpts.toFixed(1)} pts`
                            ];
                        }
                    }
                },
                annotation: {
                    annotations: {
                        vLine: {
                            type: 'line',
                            xMin: medianX,
                            xMax: medianX,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        hLine: {
                            type: 'line',
                            yMin: medianY,
                            yMax: medianY,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        topRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['Elite Dual Threats'],
                            color: '#30d158',
                            font: { size: 13, weight: 'bold' }
                        },
                        topLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.2,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['Breakout Candidates'],
                            color: '#0a84ff',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.min(...yValues) * 2.0,
                            content: ['Inefficient', 'Workhorses'],
                            color: '#FFD60A',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.2,
                            yValue: Math.min(...yValues) * 2.0,
                            content: ['Bench Fodder'],
                            color: '#ff453a',
                            font: { size: 13, weight: 'bold' }
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: 'Opportunities per Game (Rush + Targets) →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' }
                },
                y: {
                    title: { display: true, text: 'Efficiency (Fantasy Points per Opportunity) →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' }
                }
            }
        }
    });
}
/* ============================================
   Player Evaluation Matrix | Smooth Trend Animation + Week Scrubber
   Features: Linear interpolation, fading trails, interactive scrubber
   ============================================ */

// Smooth animation state
let smoothTrendState = {};
let smoothTrendAnimationFrames = {};
let smoothTrendPlayerTrails = {};
let smoothTrendMoversFilter = {};  // Track movers filter state for each chart

/**
 * Initialize smooth trend animation for a chart
 */
/**
 * Initialize smooth trend animation for a chart (v7: SEGMENT VERSION)
 */
function initSmoothTrendAnimation(chartId) {
    const isWR = chartId.includes('wr-eval');
    const segmentData = isWR ? segmentDataWR : segmentDataRB;  // v7: use segmentData
    const segments = getAvailableSegments(segmentData);         // v7: use segments

    if (segments.length === 0) return;

    // Initialize state
    smoothTrendState[chartId] = {
        isPlaying: false,
        currentSegmentFloat: segments[segments.length - 1],    // v7: segment instead of week
        segments: segments,                                    // v7: segments instead of weeks
        fps: 30,
        speedMultiplier: 0.01,  // Segments per frame (500% slower - was 0.05)
        maxTrailLength: 20      // Longer trail (was 5)
    };

    // Initialize trail data
    smoothTrendPlayerTrails[chartId] = {};

    // Setup scrubber
    const scrubber = document.getElementById(`${chartId}-scrubber`);
    if (scrubber) {
        scrubber.min = segments[0];
        scrubber.max = segments[segments.length - 1];
        scrubber.value = segments[segments.length - 1];

        // Scrubber input handler
        scrubber.addEventListener('input', (e) => {
            const segmentFloat = parseFloat(e.target.value);   // v7: segment naming
            smoothTrendState[chartId].currentSegmentFloat = segmentFloat;
            smoothTrendState[chartId].isPlaying = false;
            updatePlayButton(chartId, false);
            renderSmoothTrendFrame(chartId, segmentFloat);     // v7: pass segment
            updateSegmentLabel(chartId, segmentFloat);         // v7: update segment label
        });
    }

    // Render initial frame (latest segment)
    renderSmoothTrendFrame(chartId, smoothTrendState[chartId].currentSegmentFloat);
    updateSegmentLabel(chartId, smoothTrendState[chartId].currentSegmentFloat);
}

/**
 * Toggle playback for smooth trend animation
 */
function toggleSmoothTrendPlayback(chartId) {
    if (!smoothTrendState[chartId]) {
        initSmoothTrendAnimation(chartId);
    }

    const state = smoothTrendState[chartId];
    state.isPlaying = !state.isPlaying;

    updatePlayButton(chartId, state.isPlaying);

    if (state.isPlaying) {
        startSmoothAnimation(chartId);
    } else {
        stopSmoothAnimation(chartId);
    }
}

/**
 * Toggle movers filter for a chart
 * @param {string} chartId - Chart identifier
 * @param {string} mode - 'all' or 'movers'
 */
/**
 * Toggle movers filter for a chart
 * @param {string} chartId - Chart identifier
 * @param {string} mode - 'all', 'positive', or 'negative'
 */
function toggleMoversFilter(chartId, mode) {
    // Update filter state
    smoothTrendMoversFilter[chartId] = mode;

    // Update button styles
    const allBtn = document.getElementById(`${chartId}-filter-all`);
    const positiveBtn = document.getElementById(`${chartId}-filter-positive`);
    const negativeBtn = document.getElementById(`${chartId}-filter-negative`);

    // Reset all buttons to inactive style
    [allBtn, positiveBtn, negativeBtn].forEach(btn => {
        if (btn) {
            btn.style.background = 'var(--bg-elevated)';
            btn.style.color = 'var(--text-primary)';
            btn.style.border = '1px solid var(--border-color)';
        }
    });

    // Set active button to active style
    let activeBtn;
    if (mode === 'all') activeBtn = allBtn;
    else if (mode === 'positive') activeBtn = positiveBtn;
    else if (mode === 'negative') activeBtn = negativeBtn;

    if (activeBtn) {
        activeBtn.style.background = 'var(--positive)';
        activeBtn.style.color = '#000';
        activeBtn.style.border = 'none';
    }

    // Re-render current frame
    if (smoothTrendState[chartId]) {
        renderSmoothTrendFrame(chartId, smoothTrendState[chartId].currentSegmentFloat);
    }
}

/**
 * Calculate top movers between first and last segment
 * @param {Array} allPlayers - All players with data
 * @param {Object} segmentData - Segment data
 * @param {Array} segments - Available segment indices
 * @param {string} chartId - Chart ID to determine axes
 * @returns {Object} Object with topPositive and topNegative movers
 */
function calculateTopMovers(allPlayers, segmentData, segments, chartId) {
    if (segments.length < 2) return { topPositive: [], topNegative: [] };

    const firstSegment = segments[0];
    const lastSegment = segments[segments.length - 1];

    const firstData = getEvaluationSegmentData(segmentData, firstSegment);
    const lastData = getEvaluationSegmentData(segmentData, lastSegment);

    // Calculate movement for each player
    const movements = [];

    allPlayers.forEach(player => {
        const playerFirst = firstData.find(p => p.player === player.player);
        const playerLast = lastData.find(p => p.player === player.player);

        if (!playerFirst || !playerLast) return;

        // Calculate movement based on chart type
        let xFirst, yFirst, xLast, yLast;

        if (chartId === 'wr-eval-volume-efficiency') {
            xFirst = playerFirst.targets || 0;
            yFirst = playerFirst.fptsPerTarget || 0;
            xLast = playerLast.targets || 0;
            yLast = playerLast.fptsPerTarget || 0;
        } else if (chartId === 'wr-eval-share-rz') {
            xFirst = playerFirst.targetShare || 0;
            yFirst = playerFirst.rzTargetShare || 0;
            xLast = playerLast.targetShare || 0;
            yLast = playerLast.rzTargetShare || 0;
        } else if (chartId === 'rb-eval-total-rz') {
            xFirst = playerFirst.opportunities || 0;
            yFirst = playerFirst.rzOpportunities || 0;
            xLast = playerLast.opportunities || 0;
            yLast = playerLast.rzOpportunities || 0;
        } else if (chartId === 'rb-eval-volume-efficiency') {
            xFirst = playerFirst.opportunities || 0;
            yFirst = playerFirst.efficiency || 0;
            xLast = playerLast.opportunities || 0;
            yLast = playerLast.efficiency || 0;
        } else if (chartId === 'wr-eval-production-volume') {
            xFirst = (playerFirst.targets || 0) / (playerFirst.weeksInSegment || 1);
            yFirst = (playerFirst.fpts || 0) / (playerFirst.weeksInSegment || 1);
            xLast = (playerLast.targets || 0) / (playerLast.weeksInSegment || 1);
            yLast = (playerLast.fpts || 0) / (playerLast.weeksInSegment || 1);
        } else if (chartId === 'rb-eval-production-volume') {
            xFirst = (playerFirst.opportunities || 0) / (playerFirst.weeksInSegment || 1);
            yFirst = (playerFirst.fpts || 0) / (playerFirst.weeksInSegment || 1);
            xLast = (playerLast.opportunities || 0) / (playerLast.weeksInSegment || 1);
            yLast = (playerLast.fpts || 0) / (playerLast.weeksInSegment || 1);
        }

        // Calculate Euclidean distance moved (with Y weighted 2x)
        const xChange = xLast - xFirst;
        const yChange = yLast - yFirst;
        const distance = Math.sqrt(xChange * xChange + (yChange * yChange * 4)); // Y weighted more

        // Determine if positive or negative mover (upward/rightward = positive)
        const direction = (xChange + yChange * 2) >= 0 ? 1 : -1;
        const signedDistance = distance * direction;

        movements.push({
            player: player.player,
            distance: signedDistance,
            absDistance: Math.abs(signedDistance)
        });
    });

    // Sort and get top 5 positive and top 5 negative
    movements.sort((a, b) => b.distance - a.distance);

    const topPositive = movements.slice(0, 5).map(m => m.player);
    const topNegative = movements.slice(-5).reverse().map(m => m.player);

    return { topPositive, topNegative };
}

/**
 * Start smooth animation loop (v7: SEGMENT VERSION)
 */
function startSmoothAnimation(chartId) {
    const state = smoothTrendState[chartId];

    // If at end, restart from beginning and clear trails
    if (state.currentSegmentFloat >= state.segments[state.segments.length - 1]) {
        state.currentSegmentFloat = state.segments[0];
        smoothTrendPlayerTrails[chartId] = {};  // Clear trails on restart
    }

    // Animation loop using requestAnimationFrame
    function animationLoop() {
        if (!state.isPlaying) return;

        // Increment segment position
        state.currentSegmentFloat += state.speedMultiplier;

        // Stop at end (don't loop automatically)
        if (state.currentSegmentFloat >= state.segments[state.segments.length - 1]) {
            state.currentSegmentFloat = state.segments[state.segments.length - 1];
            state.isPlaying = false;
            updatePlayButton(chartId, false);

            // Render final frame with full trails
            renderSmoothTrendFrame(chartId, state.currentSegmentFloat, true);  // Pass showFullTrail flag
            updateSegmentLabel(chartId, state.currentSegmentFloat);
            updateScrubberPosition(chartId, state.currentSegmentFloat);
            return;  // Stop animation
        }

        // Render frame
        renderSmoothTrendFrame(chartId, state.currentSegmentFloat);

        // Update UI
        updateSegmentLabel(chartId, state.currentSegmentFloat);
        updateScrubberPosition(chartId, state.currentSegmentFloat);

        // Continue loop
        smoothTrendAnimationFrames[chartId] = requestAnimationFrame(animationLoop);
    }

    smoothTrendAnimationFrames[chartId] = requestAnimationFrame(animationLoop);
}

/**
 * Stop smooth animation
 */
function stopSmoothAnimation(chartId) {
    const state = smoothTrendState[chartId];
    state.isPlaying = false;

    if (smoothTrendAnimationFrames[chartId]) {
        cancelAnimationFrame(smoothTrendAnimationFrames[chartId]);
        delete smoothTrendAnimationFrames[chartId];
    }
}

/**
/**
 * Render a single frame with interpolation (v7: SEGMENT VERSION)
 * segmentFloat can be a decimal (e.g., 3.5 for halfway between segment 3 and 4)
 * @param {string} chartId - Chart identifier
 * @param {number} segmentFloat - Current segment position (can be fractional)
 * @param {boolean} showFullTrail - If true, show full trail from start to finish
 */
function renderSmoothTrendFrame(chartId, segmentFloat, showFullTrail = false) {
    const isWR = chartId.includes('wr-eval');
    const segmentData = isWR ? segmentDataWR : segmentDataRB;  // v7: use segmentData
    const state = smoothTrendState[chartId];

    // Determine which segments to interpolate between
    const segmentBefore = Math.floor(segmentFloat);
    const segmentAfter = Math.ceil(segmentFloat);
    const interpolationFactor = segmentFloat - segmentBefore;

    // Get data for both segments
    const dataBefore = getEvaluationSegmentData(segmentData, segmentBefore);  // v7: use segment function
    const dataAfter = segmentBefore !== segmentAfter ?
                     getEvaluationSegmentData(segmentData, segmentAfter) :
                     dataBefore;

    // Collect all unique players from both segments
    const playerSet = new Set();
    dataBefore.forEach(p => playerSet.add(p.player));
    dataAfter.forEach(p => playerSet.add(p.player));

    const allPlayers = Array.from(playerSet).map(playerName => {
        const pBefore = dataBefore.find(p => p.player === playerName);
        const pAfter = dataAfter.find(p => p.player === playerName);
        return pBefore || pAfter;
    });

    // Filter by total fantasy points OR top 5 positive/negative movers if filter is active
    let topPlayers;

    if (smoothTrendMoversFilter[chartId] === 'positive' || smoothTrendMoversFilter[chartId] === 'negative') {
        // Calculate top movers
        const segments = getAvailableSegments(segmentData);
        const movers = calculateTopMovers(allPlayers, segmentData, segments, chartId);

        // Get the appropriate set of movers
        let moverNames;
        if (smoothTrendMoversFilter[chartId] === 'positive') {
            moverNames = movers.topPositive;  // Top 5 positive movers
        } else {
            moverNames = movers.topNegative;  // Top 5 negative movers
        }

        // Filter to only selected movers
        topPlayers = allPlayers.filter(p =>
            p && p.aggregate && p.aggregate.gamesPlayed >= 3 && moverNames.includes(p.player)
        );
    } else {
        // Default: filter by fantasy points
        topPlayers = allPlayers
            .filter(p => p && p.aggregate && p.aggregate.gamesPlayed >= 3)
            .sort((a, b) => b.aggregate.totalFpts - a.aggregate.totalFpts)
            .slice(0, 50);
    }

    // Build interpolated data points with trails
    const interpolatedData = topPlayers.map(player => {
        const pBefore = dataBefore.find(p => p.player === player.player);
        const pAfter = dataAfter.find(p => p.player === player.player);

        // Get coordinates for interpolation
        let xBefore, yBefore, xAfter, yAfter;

        // Determine axes based on chart type
        if (chartId === 'wr-eval-volume-efficiency') {
            xBefore = pBefore ? (pBefore.targets || 0) : 0;
            yBefore = pBefore ? (pBefore.fptsPerTarget || 0) : 0;
            xAfter = pAfter ? (pAfter.targets || 0) : xBefore;
            yAfter = pAfter ? (pAfter.fptsPerTarget || 0) : yBefore;
        } else if (chartId === 'wr-eval-share-rz') {
            xBefore = pBefore ? (pBefore.targetShare || 0) : 0;
            yBefore = pBefore ? (pBefore.rzTargetShare || 0) : 0;
            xAfter = pAfter ? (pAfter.targetShare || 0) : xBefore;
            yAfter = pAfter ? (pAfter.rzTargetShare || 0) : yBefore;
        } else if (chartId === 'rb-eval-total-rz') {
            xBefore = pBefore ? (pBefore.opportunities || 0) : 0;
            yBefore = pBefore ? (pBefore.rzOpportunities || 0) : 0;
            xAfter = pAfter ? (pAfter.opportunities || 0) : xBefore;
            yAfter = pAfter ? (pAfter.rzOpportunities || 0) : yBefore;
        } else if (chartId === 'rb-eval-volume-efficiency') {
            xBefore = pBefore ? (pBefore.opportunities || 0) : 0;
            yBefore = pBefore ? (pBefore.efficiency || 0) : 0;
            xAfter = pAfter ? (pAfter.opportunities || 0) : xBefore;
            yAfter = pAfter ? (pAfter.efficiency || 0) : yBefore;
        } else if (chartId === 'wr-eval-production-volume') {
            xBefore = pBefore ? ((pBefore.targets || 0) / (pBefore.weeksInSegment || 1)) : 0;
            yBefore = pBefore ? ((pBefore.fpts || 0) / (pBefore.weeksInSegment || 1)) : 0;
            xAfter = pAfter ? ((pAfter.targets || 0) / (pAfter.weeksInSegment || 1)) : xBefore;
            yAfter = pAfter ? ((pAfter.fpts || 0) / (pAfter.weeksInSegment || 1)) : yBefore;
        } else if (chartId === 'rb-eval-production-volume') {
            xBefore = pBefore ? ((pBefore.opportunities || 0) / (pBefore.weeksInSegment || 1)) : 0;
            yBefore = pBefore ? ((pBefore.fpts || 0) / (pBefore.weeksInSegment || 1)) : 0;
            xAfter = pAfter ? ((pAfter.opportunities || 0) / (pAfter.weeksInSegment || 1)) : xBefore;
            yAfter = pAfter ? ((pAfter.fpts || 0) / (pAfter.weeksInSegment || 1)) : yBefore;
        }

        // Linear interpolation (lerp)
        const x = xBefore + (xAfter - xBefore) * interpolationFactor;
        const y = yBefore + (yAfter - yBefore) * interpolationFactor;

        // Store trail data
        if (!smoothTrendPlayerTrails[chartId][player.player]) {
            smoothTrendPlayerTrails[chartId][player.player] = [];
        }
        const trail = smoothTrendPlayerTrails[chartId][player.player];
        trail.push({ x, y, segment: segmentFloat });  // v7: segment instead of week

        // Keep only last N positions (unless showing full trail at end)
        if (!showFullTrail && trail.length > state.maxTrailLength) {
            trail.shift();
        }

        return {
            x: x,
            y: y,
            label: player.player,
            player: player,
            trail: [...trail] // Copy trail for rendering
        };
    });

    // Render the chart with trails
    renderSmoothTrendChart(chartId, interpolatedData);
}

/**
 * Render chart with smooth data and trails
 */
function renderSmoothTrendChart(chartId, data) {
    const ctx = document.getElementById(chartId);
    if (!ctx) return;

    // v7: Calculate fixed axis ranges from ALL segments (not just current frame)
    const isWR = chartId.includes('wr-eval');
    const segmentData = isWR ? segmentDataWR : segmentDataRB;  // v7: use segmentData
    const segments = getAvailableSegments(segmentData);         // v7: use segments

    let allXValues = [];
    let allYValues = [];

    segments.forEach(segment => {                               // v7: iterate segments
        const segmentPlayers = getEvaluationSegmentData(segmentData, segment);  // v7: get segment data
        segmentPlayers.forEach(player => {
            if (chartId === 'wr-eval-volume-efficiency') {
                allXValues.push(player.targets || 0);
                allYValues.push(player.fptsPerTarget || 0);
            } else if (chartId === 'wr-eval-share-rz') {
                allXValues.push(player.targetShare || 0);
                allYValues.push(player.rzTargetShare || 0);
            } else if (chartId === 'rb-eval-total-rz') {
                allXValues.push(player.opportunities || 0);
                allYValues.push(player.rzOpportunities || 0);
            } else if (chartId === 'rb-eval-volume-efficiency') {
                allXValues.push(player.opportunities || 0);
                allYValues.push(player.efficiency || 0);
            } else if (chartId === 'wr-eval-production-volume') {
                allXValues.push((player.targets || 0) / (player.weeksInSegment || 1));
                allYValues.push((player.fpts || 0) / (player.weeksInSegment || 1));
            } else if (chartId === 'rb-eval-production-volume') {
                allXValues.push((player.opportunities || 0) / (player.weeksInSegment || 1));
                allYValues.push((player.fpts || 0) / (player.weeksInSegment || 1));
            }
        });
    });

    const xMin = Math.min(...allXValues.filter(v => v > 0));
    const xMax = Math.max(...allXValues);
    const yMin = Math.min(...allYValues.filter(v => v > 0));
    const yMax = Math.max(...allYValues);

    // Calculate medians for quadrant lines
    const xValues = allXValues.filter(v => v > 0).sort((a, b) => a - b);
    const yValues = allYValues.filter(v => v > 0).sort((a, b) => a - b);
    const medianX = xValues[Math.floor(xValues.length / 2)] || 5;
    const medianY = yValues[Math.floor(yValues.length / 2)] || 1.5;

    // Get existing chart
    let chart = window[`${chartId}Chart`];

    if (!chart) {
        // Create new chart with fixed axes
        chart = createSmoothTrendChart(ctx, chartId, medianX, medianY, xMin, xMax, yMin, yMax);
        window[`${chartId}Chart`] = chart;
    }

    // Update chart data (points + trails)
    const datasets = [];

    // Add trail datasets (one per player with trail)
    data.forEach(point => {
        if (point.trail && point.trail.length > 1) {
            const trailData = point.trail.map((t, idx) => ({
                x: t.x,
                y: t.y
            }));

            const teamColor = teamColors[point.player.team] || '#666';
            const r = parseInt(teamColor.slice(1, 3), 16);
            const g = parseInt(teamColor.slice(3, 5), 16);
            const b = parseInt(teamColor.slice(5, 7), 16);

            datasets.push({
                type: 'line',
                data: trailData,
                borderColor: `rgba(${r}, ${g}, ${b}, 0.6)`,  // More opaque (was 0.4)
                backgroundColor: 'transparent',
                borderWidth: 4,  // Thicker trail (was 2)
                pointRadius: 0,
                showLine: true,
                tension: 0.4
            });
        }
    });

    // Add main data points (current positions)
    datasets.push({
        type: 'scatter',
        data: data.map(d => ({ x: d.x, y: d.y, label: d.label, player: d.player })),
        backgroundColor: data.map(d => {
            const color = teamColors[d.player.team] || '#666';
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, 0.85)`;
        }),
        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
        borderWidth: 2,
        pointRadius: 8,
        pointHoverRadius: 12
    });

    chart.data.datasets = datasets;
    chart.update('none'); // No animation for smooth movement
}

/**
 * Create a new chart with fixed configuration
 */
function createSmoothTrendChart(ctx, chartId, medianX, medianY, xMin, xMax, yMin, yMax) {
    // Determine labels based on chart type
    let xLabel, yLabel, quadrantLabels;

    if (chartId === 'wr-eval-volume-efficiency') {
        xLabel = 'Targets per Game →';
        yLabel = 'Fantasy Points per Target →';
        quadrantLabels = {
            topRight: ['Reliable Studs', '(Hold)'],
            topLeft: ['Efficient Sleepers', '(Buy Low)'],
            bottomRight: ['Volume, Poor Efficiency', '(Sell Window)'],
            bottomLeft: ['Bench Fodder']
        };
    } else if (chartId === 'wr-eval-share-rz') {
        xLabel = 'Target Share (% of Team) →';
        yLabel = 'Red Zone Target Share (% of Team) →';
        quadrantLabels = {
            topRight: ['Alpha WR1s'],
            topLeft: ['TD-Dependent', 'Boom/Busts'],
            bottomRight: ['Chain Movers'],
            bottomLeft: ['Background Noise']
        };
    } else if (chartId === 'rb-eval-total-rz') {
        xLabel = 'Opportunities per Game (Rush + Targets) →';
        yLabel = 'Red Zone Opportunities per Game →';
        quadrantLabels = {
            topRight: ['True Workhorses', '(Buy/Hold)'],
            topLeft: ['TD Vultures', '(Sell High)'],
            bottomRight: ['Between-the-20s Backs', '(Neutral)'],
            bottomLeft: ['Irrelevant Depth']
        };
    } else if (chartId === 'rb-eval-volume-efficiency') {
        xLabel = 'Opportunities per Game (Rush + Targets) →';
        yLabel = 'Efficiency (Fantasy Points per Opportunity) →';
        quadrantLabels = {
            topRight: ['Elite Dual Threats'],
            topLeft: ['Breakout Candidates'],
            bottomRight: ['Inefficient', 'Workhorses'],
            bottomLeft: ['Bench Fodder']
        };
    } else if (chartId === 'wr-eval-production-volume') {
        xLabel = 'Targets per Game →';
        yLabel = 'Fantasy Points per Game (FPPG) →';
        quadrantLabels = {
            topRight: ['Elite WR1s'],
            topLeft: ['Efficient Sleepers'],
            bottomRight: ['Volume Drags'],
            bottomLeft: ['Irrelevant']
        };
    } else if (chartId === 'rb-eval-production-volume') {
        xLabel = 'Opportunities per Game →';
        yLabel = 'Fantasy Points per Game (FPPG) →';
        quadrantLabels = {
            topRight: ['Elite Bellcows'],
            topLeft: ['Efficient Backups'],
            bottomRight: ['Plodding Workhorses'],
            bottomLeft: ['Irrelevant']
        };
    }

    return new Chart(ctx, {
        type: 'scatter',
        data: { datasets: [] },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false, // Disable default animations
            layout: {
                padding: {
                    left: 50,
                    right: 50,
                    top: 50,
                    bottom: 50
                }
            },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: (context) => {
                            const p = context.raw.player;
                            if (!p) return '';
                            return [
                                p.player,
                                `X: ${context.parsed.x.toFixed(1)}`,
                                `Y: ${context.parsed.y.toFixed(2)}`,
                                `Total: ${p.aggregate.totalFpts.toFixed(1)} pts`
                            ];
                        }
                    }
                },
                annotation: {
                    annotations: {
                        vLine: {
                            type: 'line',
                            xMin: medianX,
                            xMax: medianX,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        hLine: {
                            type: 'line',
                            yMin: medianY,
                            yMax: medianY,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        topRight: {
                            type: 'label',
                            xValue: xMax * 0.70,  // Much closer to center (was 0.82)
                            yValue: yMax * 0.70,  // Much closer to center (was 0.82)
                            content: quadrantLabels.topRight,
                            color: '#30d158',
                            font: { size: 13, weight: 'bold' }  // Larger (was 10)
                        },
                        topLeft: {
                            type: 'label',
                            xValue: xMin * 1.5,   // Much closer to center (was 1.3)
                            yValue: yMax * 0.70,  // Much closer to center (was 0.82)
                            content: quadrantLabels.topLeft,
                            color: '#0a84ff',
                            font: { size: 13, weight: 'bold' }  // Larger (was 10)
                        },
                        bottomRight: {
                            type: 'label',
                            xValue: xMax * 0.70,  // Much closer to center (was 0.82)
                            yValue: yMin * 2.0,   // Much closer to center (was 1.5)
                            content: quadrantLabels.bottomRight,
                            color: '#FFD60A',
                            font: { size: 13, weight: 'bold' }  // Larger (was 10)
                        },
                        bottomLeft: {
                            type: 'label',
                            xValue: xMin * 1.5,   // Much closer to center (was 1.3)
                            yValue: yMin * 2.0,   // Much closer to center (was 1.5)
                            content: quadrantLabels.bottomLeft,
                            color: '#ff453a',
                            font: { size: 13, weight: 'bold' }  // Larger (was 10)
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: xLabel, color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' },
                    min: xMin * 0.9,
                    max: xMax * 1.1
                },
                y: {
                    title: { display: true, text: yLabel, color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' },
                    min: yMin * 0.9,
                    max: chartId === 'wr-eval-share-rz' ? 110 : yMax * 1.1  // Special case for WR RZ Share
                }
            }
        }
    });
}

/**
 * Update UI helpers
 */
function updatePlayButton(chartId, isPlaying) {
    const btn = document.getElementById(`${chartId}-play-btn`);
    if (btn) {
        if (isPlaying) {
            btn.classList.add('playing');
            btn.querySelector('.play-icon').textContent = '⏸';
        } else {
            btn.classList.remove('playing');
            btn.querySelector('.play-icon').textContent = '▶';
        }
    }
}

/**
 * Update segment label display (v7: NEW FUNCTION)
 */
function updateSegmentLabel(chartId, segmentFloat) {
    const label = document.getElementById(`${chartId}-week-label`);
    if (label && smoothTrendState[chartId]) {
        const isWR = chartId.includes('wr-eval');
        const segmentData = isWR ? segmentDataWR : segmentDataRB;

        // Format the segment label
        const segmentIndex = Math.floor(segmentFloat);
        const weeks = getSegmentWeekRange(segmentData, segmentIndex);

        if (weeks.length > 0) {
            const firstWeek = weeks[0];
            const lastWeek = weeks[weeks.length - 1];
            label.textContent = `Segments ${firstWeek}-${lastWeek}`;
        } else {
            label.textContent = `Segment ${segmentIndex}`;
        }
    }
}

/**
 * Legacy week label function (kept for compatibility)
 */
function updateWeekLabel(chartId, weekFloat) {
    // Redirect to segment label
    updateSegmentLabel(chartId, weekFloat);
}

function updateScrubberPosition(chartId, segmentFloat) {
    const scrubber = document.getElementById(`${chartId}-scrubber`);
    if (scrubber) {
        scrubber.value = segmentFloat;
    }
}



                // Sort table function (now re-renders card tiers)
        function sortTable(position, column) {
            // Re-render player cards (tiers are always sorted by avg points)
            if (position === 'wr') {
                renderWRPlayerCards();
            } else {
                renderRBPlayerCards();
            }
        }

        // Close modal on click outside
        document.getElementById('player-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeModal();
            }
        });

        document.getElementById('team-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeTeamModal();
            }
        });

        // Close modal on ESC key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeModal();
                closeTeamModal();
            }
        });

        // 6. INITIALIZATION


        // Fetch betting odds data from GitHub
        window.addEventListener('DOMContentLoaded', function() {
            // Load sentiment data
            loadSentimentData();

            // Load comments
            const storedComments = localStorage.getItem('ffse_player_comments');
            if (storedComments) {
                playerComments = JSON.parse(storedComments);
            }

            // Check if localStorage has data
            const hasLocalData = localStorage.getItem('wrData') &&
                                 localStorage.getItem('rbData') &&
                                 localStorage.getItem('teData');

            if (hasLocalData) {
                // Load from localStorage first (instant load)
                loadStoredData();

                // Render dashboard if it's the active page
                setTimeout(() => {
                    const dashboardPage = document.getElementById('top-movers');
                    if (dashboardPage && dashboardPage.classList.contains('active')) {
                        renderDashboardCategories();
                        setTimeout(renderMiniScatterPlots, 100);
                    }
                }, 200);

                // Silently fetch updates in background (user can keep using the app)
                fetchDataFromGitHub().catch(err => {                });
            } else {
                // No local data - show loading and fetch from GitHub
                showLoadingIndicator();
                fetchDataFromGitHub();
            }
        });

        // PAGE VISIBILITY API - Pause Animations
        document.addEventListener('visibilitychange', function() {
            // Only run if animationStates is defined (for WR/RB analytics pages)
            if (typeof animationStates === 'undefined') return;

            if (document.hidden) {
                // Page is hidden - pause all animations
                Object.keys(animationStates).forEach(chartId => {
                    if (animationStates[chartId].isPlaying) {
                        // Store that it was playing
                        animationStates[chartId].wasPlayingBeforeHidden = true;
                        // Pause the animation
                        pauseSmoothTrendAnimation(chartId);
                    }
                });
            } else {
                // Page is visible again - resume animations that were playing
                Object.keys(animationStates).forEach(chartId => {
                    if (animationStates[chartId].wasPlayingBeforeHidden) {
                        // Resume the animation
                        playSmoothTrendAnimation(chartId);
                        animationStates[chartId].wasPlayingBeforeHidden = false;
                    }
                });
            }
        });

        // ============================================
        // ANALYTICS DASHBOARD
        // ============================================
        
        // Analytics Dashboard State
        let heatmapState = {
            position: 'WR',
            period: 'last3',
            metric: 'actual-vs-expected',
            display: '24'
        };

        // Initialize Analytics Dashboard
        function initializeAnalyticsDashboard() {
            // Check if data is loaded
            if (!aggregatedWRs || Object.keys(aggregatedWRs).length === 0) {
                console.log('Analytics Dashboard: Data not yet loaded');
                return;
            }
            
            console.log('Analytics Dashboard: Initializing with data', {
                WRs: Object.keys(aggregatedWRs).length,
                RBs: Object.keys(aggregatedRBs).length,
                TEs: Object.keys(aggregatedTEs).length
            });
            
            updateHeatmap();
            updateMarketOpportunities();
            initializeMetricTooltip();
        }

        // Initialize metric tooltip
        function initializeMetricTooltip() {
            const infoIcon = document.getElementById('metric-info-icon');
            const tooltip = document.getElementById('metric-tooltip');
            const metricSelect = document.getElementById('heatmap-metric-select');
            
            if (!infoIcon || !tooltip || !metricSelect) {
                console.log('Metric tooltip elements not found, will retry when page is shown');
                return false;
            }
            
            // Remove any existing listeners first
            const newInfoIcon = infoIcon.cloneNode(true);
            infoIcon.parentNode.replaceChild(newInfoIcon, infoIcon);
            
            // Toggle tooltip on info icon click
            newInfoIcon.addEventListener('click', (e) => {
                e.stopPropagation();
                const currentTooltip = document.getElementById('metric-tooltip');
                if (!currentTooltip) return;
                
                const isVisible = currentTooltip.style.display === 'block';
                currentTooltip.style.display = isVisible ? 'none' : 'block';
                if (!isVisible) {
                    const currentSelect = document.getElementById('heatmap-metric-select');
                    if (currentSelect) {
                        updateMetricTooltipContent(currentSelect.value);
                    }
                }
            });
            
            // Update tooltip when metric changes
            metricSelect.addEventListener('change', () => {
                const currentTooltip = document.getElementById('metric-tooltip');
                if (currentTooltip && currentTooltip.style.display === 'block') {
                    updateMetricTooltipContent(metricSelect.value);
                }
            });
            
            // Close tooltip when clicking outside
            document.addEventListener('click', (e) => {
                const currentTooltip = document.getElementById('metric-tooltip');
                const currentInfoIcon = document.getElementById('metric-info-icon');
                if (currentTooltip && !currentTooltip.contains(e.target) && e.target !== currentInfoIcon) {
                    currentTooltip.style.display = 'none';
                }
            });
            
            console.log('Metric tooltip initialized successfully');
            return true;
        }

        // Update metric tooltip content based on selected metric
        function updateMetricTooltipContent(metric) {
            const content = document.getElementById('metric-tooltip-content');
            if (!content) return;
            
            const tooltips = {
                'actual-vs-expected': `
                    <strong>Actual vs Expected Points</strong>
                    <div class="tooltip-section">
                        <div class="tooltip-label">The Number (e.g., "15.2 pts")</div>
                        Player's average fantasy points per game for the selected time period (Last 3 or Last 5 weeks).
                    </div>
                    <div class="tooltip-section">
                        <div class="tooltip-label">The Delta & Color (e.g., "+12%" = Green)</div>
                        <strong>Period vs Season comparison:</strong> How much better (green) or worse (red) the player is performing in this period compared to their season average vs expected.
                        <br><br>
                        <strong>Example Calculation:</strong><br>
                        • Last 3 weeks: Player averaged 15 pts vs 12 expected = +25% over expected<br>
                        • Season average: Player averaged 14 pts vs 13 expected = +7.7% over expected<br>
                        • <strong>Delta: +25% - 7.7% = +17.3%</strong> (Strong positive = green card)<br>
                        <br>
                        <strong>Color Thresholds:</strong><br>
                        • Dark Green: +20% or more<br>
                        • Light Green: +10% to +15%<br>
                        • Gray: ±5% (on target)<br>
                        • Light Red: -10% to -15%<br>
                        • Dark Red: -20% or worse
                    </div>
                    <div class="tooltip-section">
                        <div class="tooltip-label">What It Means</div>
                        • Positive (+) = Recently performing BETTER vs expectations than season average<br>
                        • Negative (-) = Recently performing WORSE vs expectations than season average<br>
                        • Shows if player is heating up or cooling down relative to projections
                    </div>
                `,
                'target-share': `
                    <strong>Target/Opportunity Share</strong>
                    <div class="tooltip-section">
                        <div class="tooltip-label">The Number (e.g., "22.5%")</div>
                        Average usage share for the selected time period (Last 3 or Last 5 weeks):
                        <br>
                        • <strong>WR/TE:</strong> Target share (% of team's targets)
                        <br>
                        • <strong>RB:</strong> Opportunity share (% of team's touches)
                    </div>
                    <div class="tooltip-section">
                        <div class="tooltip-label">The Delta & Color (e.g., "+4.5%" = Green)</div>
                        <strong>Period vs Season comparison:</strong> Difference between recent usage and season average usage (in percentage points).
                        <br><br>
                        <strong>Example Calculation:</strong><br>
                        • Last 3 weeks: Player averaged 28% target share<br>
                        • Season average: Player averaged 22% target share<br>
                        • <strong>Delta: 28% - 22% = +6%</strong> (Strong positive = green card)<br>
                        <br>
                        <strong>Color Thresholds:</strong><br>
                        • Dark Green: +8% or more<br>
                        • Light Green: +3% to +5%<br>
                        • Gray: ±1.5% (stable)<br>
                        • Light Red: -3% to -5%<br>
                        • Dark Red: -8% or worse
                    </div>
                    <div class="tooltip-section">
                        <div class="tooltip-label">What It Means</div>
                        • 20%+ with positive delta = Elite usage trending up<br>
                        • Rising usage = Role expanding, buy candidate<br>
                        • Falling usage from high level = Monitor closely
                    </div>
                `,
                'rz-opp-share': `
                    <strong>RZ Opportunity Share</strong>
                    <div class="tooltip-section">
                        <div class="tooltip-label">The Number (e.g., "35.2%")</div>
                        Player's share of their team's red zone opportunities for the selected time period (Last 3 or Last 5 weeks).
                        <br>
                        • <strong>WR/TE:</strong> % of team's RZ targets
                        <br>
                        • <strong>RB:</strong> % of team's RZ carries + targets
                    </div>
                    <div class="tooltip-section">
                        <div class="tooltip-label">The Delta & Color (e.g., "+5%" = Green)</div>
                        <strong>Period vs Season comparison:</strong> Difference between recent RZ share and season average RZ share (in percentage points).
                        <br><br>
                        <strong>Example Calculation:</strong><br>
                        • Last 3 weeks: Player got 7 RZ targets, team had 18 total = 38.9% RZ share<br>
                        • Season average: Player got 22 RZ targets, team had 68 total = 32.4% RZ share<br>
                        • <strong>Delta: 38.9% - 32.4% = +6.5%</strong> (Extreme positive = dark green card)<br>
                        <br>
                        <strong>Color Thresholds:</strong><br>
                        • Dark Green: +6% or more<br>
                        • Light Green: +2.5% to +4%<br>
                        • Gray: ±1.5% (stable)<br>
                        • Light Red: -2.5% to -4%<br>
                        • Dark Red: -6% or worse
                    </div>
                    <div class="tooltip-section">
                        <div class="tooltip-label">What It Means</div>
                        • 30%+ with positive delta = Dominating team's RZ, high TD upside<br>
                        • Rising RZ share = Increasing TD opportunity, buy candidate<br>
                        • Falling RZ share = TD upside declining, potential concern
                    </div>
                `,
                'points-per-touch': `
                    <strong>Points per Touch Efficiency</strong>
                    <div class="tooltip-section">
                        <div class="tooltip-label">The Number (e.g., "1.45")</div>
                        Average fantasy points per touch for the selected time period.
                        <br>
                        • <strong>WR/TE:</strong> Points per target
                        <br>
                        • <strong>RB:</strong> Points per opportunity (carry + target)
                    </div>
                    <div class="tooltip-section">
                        <div class="tooltip-label">The Delta & Color (e.g., "+0.15" = Green)</div>
                        <strong>Period vs Season comparison:</strong> Difference in efficiency (recent vs season average).
                        <br><br>
                        <strong>Example Calculation:</strong><br>
                        • Last 3 weeks: Player scored 45 pts on 28 targets = 1.61 pts/target<br>
                        • Season average: Player scored 112 pts on 78 targets = 1.44 pts/target<br>
                        • <strong>Delta: 1.61 - 1.44 = +0.17</strong> (Moderate positive = green card)<br>
                        <br>
                        <strong>Color Thresholds:</strong><br>
                        • Dark Green: +0.40 or more<br>
                        • Light Green: +0.15 to +0.25<br>
                        • Gray: ±0.08 (stable)<br>
                        • Light Red: -0.15 to -0.25<br>
                        • Dark Red: -0.40 or worse
                    </div>
                    <div class="tooltip-section">
                        <div class="tooltip-label">What It Means</div>
                        • Higher efficiency + steady volume = Elite player<br>
                        • Rising efficiency = Buy candidate<br>
                        • Falling efficiency with high volume = Positive regression likely
                    </div>
                `,
                'consistency': `
                    <strong>Consistency Score</strong>
                    <div class="tooltip-section">
                        <div class="tooltip-label">The Number (e.g., "75")</div>
                        Consistency score (0-100) for the selected time period. Higher = more consistent.
                        <br><br>
                        Formula: 100 - (Coefficient of Variation)
                    </div>
                    <div class="tooltip-section">
                        <div class="tooltip-label">The Delta (e.g., "+8")</div>
                        <strong>Period vs Season comparison:</strong> Difference in consistency score.
                        <br><br>
                        • Positive (+) = MORE consistent recently<br>
                        • Negative (-) = LESS consistent recently (boom/bust)
                    </div>
                    <div class="tooltip-section">
                        <div class="tooltip-label">What It Means</div>
                        • 75+ = Very consistent (safe floor)<br>
                        • 50-75 = Moderate consistency<br>
                        • <50 = Boom/bust player
                    </div>
                `,
                'ceiling': `
                    <strong>Ceiling (90th Percentile)</strong>
                    <div class="tooltip-section">
                        <div class="tooltip-label">The Number (e.g., "24.5")</div>
                        90th percentile fantasy score for the selected time period. Represents weekly upside.
                    </div>
                    <div class="tooltip-section">
                        <div class="tooltip-label">The Delta (e.g., "+3.2")</div>
                        <strong>Period vs Season comparison:</strong> Difference in ceiling.
                        <br><br>
                        • Positive (+) = Higher ceiling recently<br>
                        • Negative (-) = Lower ceiling recently
                    </div>
                    <div class="tooltip-section">
                        <div class="tooltip-label">What It Means</div>
                        • 25+ ceiling = League-winning upside<br>
                        • Rising ceiling = Player breaking out<br>
                        • High ceiling + low floor = Boom/bust
                    </div>
                `,
                'floor': `
                    <strong>Floor (10th Percentile)</strong>
                    <div class="tooltip-section">
                        <div class="tooltip-label">The Number (e.g., "8.5")</div>
                        10th percentile fantasy score for the selected time period. Represents weekly safety.
                    </div>
                    <div class="tooltip-section">
                        <div class="tooltip-label">The Delta (e.g., "+2.1")</div>
                        <strong>Period vs Season comparison:</strong> Difference in floor.
                        <br><br>
                        • Positive (+) = Higher floor recently (safer)<br>
                        • Negative (-) = Lower floor recently (riskier)
                    </div>
                    <div class="tooltip-section">
                        <div class="tooltip-label">What It Means</div>
                        • 10+ floor = Very safe weekly play<br>
                        • Rising floor = Role solidifying<br>
                        • Low floor = Risky start
                    </div>
                `
            };
            
            content.innerHTML = tooltips[metric] || '<strong>Select a metric to see details</strong>';
        }

        // Set heatmap period
        function setHeatmapPeriod(period) {
            heatmapState.period = period;
            
            // Update button states
            document.querySelectorAll('.heatmap-toggle-btn[data-period]').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`.heatmap-toggle-btn[data-period="${period}"]`).classList.add('active');
            
            updateHeatmap();
        }

        // Set heatmap display
        function setHeatmapDisplay(display) {
            heatmapState.display = display;
            
            // Update button states
            document.querySelectorAll('.heatmap-toggle-btn[data-display]').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`.heatmap-toggle-btn[data-display="${display}"]`).classList.add('active');
            
            updateHeatmap();
        }

        // Update heatmap
        function updateHeatmap() {
            const position = document.getElementById('heatmap-position-select').value;
            const metric = document.getElementById('heatmap-metric-select').value;
            
            console.log(`===== HEATMAP UPDATE =====`);
            console.log(`Position: ${position}, Metric: ${metric}, Period: ${heatmapState.period}`);
            console.log(`Current scoring format: ${currentScoringFormat}`);
            
            heatmapState.position = position;
            heatmapState.metric = metric;
            
            // Update legend for the selected metric
            updateHeatmapLegend(metric);
            
            // Get player data for the position
            let players = getPlayersForPosition(position);
            console.log(`Players loaded for ${position}: ${players.length}`);
            
            // Sample first player to check data
            if (players.length > 0 && metric === 'actual-vs-expected') {
                const sample = players[0];
                console.log(`Sample ${position}: ${sample.name}`);
                console.log(`  - avgPoints: ${sample.avgPoints.toFixed(2)}`);
                console.log(`  - pctOverExpected: ${sample.pctOverExpected.toFixed(2)}%`);
                if (sample.weeks && sample.weeks.length > 0) {
                    const recentWeek = sample.weeks[sample.weeks.length - 1];
                    console.log(`  - Recent week fpts: ${recentWeek.fpts.toFixed(2)}`);
                    console.log(`  - Recent week expectedFpts: ${recentWeek.expectedFpts.toFixed(2)}`);
                }
            }
            
            // Calculate the selected metric for each player
            players = players.map(player => {
                const metricData = calculatePlayerMetric(player, metric, heatmapState.period);
                return {
                    ...player,
                    metricValue: metricData.value,
                    metricDelta: metricData.delta,
                    metricDisplay: metricData.display
                };
            }).filter(p => p.metricValue !== null);
            
            console.log(`Players after metric calculation: ${players.length}`);
            
            // Sort by metric value
            players.sort((a, b) => b.metricValue - a.metricValue);
            
            // Filter based on display setting
            if (heatmapState.display !== 'all') {
                const displayLimit = parseInt(heatmapState.display);
                if (displayLimit > 0) {
                    players = players.slice(0, displayLimit);
                }
            }
            
            console.log(`Players to display: ${players.length}`);
            
            // Update position stats
            updatePositionStats(players, position);
            
            // Render player cards
            renderHeatmapCards(players, position);
        }

        // Get players for position
        function getPlayersForPosition(position) {
            if (position === 'WR') {
                if (!aggregatedWRs) return [];
                return Object.values(aggregatedWRs).filter(p => p.gamesPlayed >= 3);
            } else if (position === 'RB') {
                if (!aggregatedRBs) return [];
                return Object.values(aggregatedRBs).filter(p => p.gamesPlayed >= 3);
            } else if (position === 'TE') {
                if (!aggregatedTEs) return [];
                return Object.values(aggregatedTEs).filter(p => p.gamesPlayed >= 3);
            }
            return [];
        }

        // Calculate player metric with time period support
        function calculatePlayerMetric(player, metric, period) {
            // Get data for the specified time period (last3 or last5)
            const periodData = getPlayerDataForPeriod(player, period);
            if (!periodData) return { value: null, delta: 0, display: 'N/A' };
            
            // Get season data for comparison
            const seasonData = getPlayerDataForPeriod(player, 'season');
            if (!seasonData) return { value: null, delta: 0, display: 'N/A' };
            
            const avgPoints = periodData.avgPoints;
            const avgExpected = periodData.avgExpected;
            const weeks = periodData.weeks;
            const seasonWeeks = seasonData.weeks;
            
            switch (metric) {
                case 'actual-vs-expected': {
                    if (avgExpected === 0 || weeks.length === 0) return { value: null, delta: 0, display: '0.0' };
                    
                    // Calculate period pctOverExpected
                    const periodOverExpected = avgExpected > 0 ? ((avgPoints - avgExpected) / avgExpected) * 100 : 0;
                    
                    // Delta = period vs season pctOverExpected
                    const seasonOverExpected = player.pctOverExpected || 0;
                    const delta = periodOverExpected - seasonOverExpected;
                    
                    return {
                        value: avgPoints,
                        delta: delta,
                        display: avgPoints.toFixed(1)
                    };
                }
                    
                case 'target-share': {
                    // Calculate average usage share for the period
                    if (weeks.length === 0) return { value: null, delta: 0, display: '0.0%' };
                    const periodUsageShare = weeks.reduce((sum, w) => sum + (w.usageShare || 0), 0) / weeks.length;
                    
                    // Calculate season average usage share
                    const seasonUsageShare = seasonWeeks.reduce((sum, w) => sum + (w.usageShare || 0), 0) / seasonWeeks.length;
                    
                    // Delta = period vs season (percentage point change)
                    const usageDelta = periodUsageShare - seasonUsageShare;
                    
                    return {
                        value: periodUsageShare,
                        delta: usageDelta,
                        display: periodUsageShare.toFixed(1) + '%'
                    };
                }
                    
                case 'rz-opp-share': {
                    // Calculate RZ Opp Share: player's RZ opps as % of team's total RZ opps
                    if (weeks.length === 0) return { value: null, delta: 0, display: '0.0%' };
                    
                    // For WR/TE use rzTargets, for RB use rzOpportunities
                    const rzField = player.position === 'RB' ? 'rzOpportunities' : 'rzTargets';
                    
                    // Get team stats
                    const team = teamStats[player.team];
                    if (!team || !team.weeklyRzOpps) return { value: null, delta: 0, display: '0.0%' };
                    
                    // Calculate period RZ share
                    let periodPlayerRzOpps = 0;
                    let periodTeamRzOpps = 0;
                    weeks.forEach(w => {
                        periodPlayerRzOpps += (w[rzField] || 0);
                        periodTeamRzOpps += (team.weeklyRzOpps[w.week] || 0);
                    });
                    const periodRzShare = periodTeamRzOpps > 0 ? (periodPlayerRzOpps / periodTeamRzOpps) * 100 : 0;
                    
                    // Calculate season RZ share
                    let seasonPlayerRzOpps = 0;
                    let seasonTeamRzOpps = 0;
                    seasonWeeks.forEach(w => {
                        seasonPlayerRzOpps += (w[rzField] || 0);
                        seasonTeamRzOpps += (team.weeklyRzOpps[w.week] || 0);
                    });
                    const seasonRzShare = seasonTeamRzOpps > 0 ? (seasonPlayerRzOpps / seasonTeamRzOpps) * 100 : 0;
                    
                    // Delta = period vs season (percentage point change)
                    const rzDelta = periodRzShare - seasonRzShare;
                    
                    return {
                        value: periodRzShare,
                        delta: rzDelta,
                        display: periodRzShare.toFixed(1) + '%'
                    };
                }
                    
                case 'points-per-touch': {
                    // Calculate points per touch for period
                    if (weeks.length === 0) return { value: null, delta: 0, display: '0.00' };
                    
                    // Period calculation
                    let periodTotalTouches = 0;
                    weeks.forEach(w => {
                        if (player.position === 'RB') {
                            periodTotalTouches += (w.rushAttempts || 0) + (w.targets || 0);
                        } else {
                            periodTotalTouches += (w.targets || 0);
                        }
                    });
                    const periodPpTouch = periodTotalTouches > 0 ? (avgPoints * weeks.length) / periodTotalTouches : 0;
                    
                    // Season calculation
                    let seasonTotalTouches = 0;
                    seasonWeeks.forEach(w => {
                        if (player.position === 'RB') {
                            seasonTotalTouches += (w.rushAttempts || 0) + (w.targets || 0);
                        } else {
                            seasonTotalTouches += (w.targets || 0);
                        }
                    });
                    const seasonPpTouch = seasonTotalTouches > 0 ? (seasonData.avgPoints * seasonWeeks.length) / seasonTotalTouches : 0;
                    
                    // Delta = period vs season efficiency
                    const touchDelta = periodPpTouch - seasonPpTouch;
                    
                    return {
                        value: periodPpTouch,
                        delta: touchDelta,
                        display: periodPpTouch.toFixed(2)
                    };
                }
                    
                case 'usage-trend': {
                    // Calculate usage trend comparing period to season
                    if (weeks.length === 0) return { value: null, delta: 0, display: '0.0%' };
                    
                    // Calculate average usage for the period
                    const periodUsageShare = weeks.reduce((sum, w) => sum + (w.usageShare || w.teamShare || 0), 0) / weeks.length;
                    
                    // Calculate season average usage
                    const seasonUsageShare = seasonWeeks.reduce((sum, w) => sum + (w.usageShare || w.teamShare || 0), 0) / seasonWeeks.length;
                    
                    // Delta = period vs season
                    const trendDelta = periodUsageShare - seasonUsageShare;
                    
                    return {
                        value: periodUsageShare,
                        delta: trendDelta,
                        display: periodUsageShare.toFixed(1) + '%'
                    };
                }
                    
                case 'consistency': {
                    // Calculate consistency score (100 - coefficient of variation) for period
                    if (weeks.length < 2) return { value: null, delta: 0, display: '0' };
                    
                    // Period consistency
                    const periodPoints = weeks.map(w => w.fpts);
                    const periodMean = periodPoints.reduce((sum, p) => sum + p, 0) / periodPoints.length;
                    const periodVariance = periodPoints.reduce((sum, p) => sum + Math.pow(p - periodMean, 2), 0) / periodPoints.length;
                    const periodStdDev = Math.sqrt(periodVariance);
                    const periodCv = periodMean > 0 ? (periodStdDev / periodMean) * 100 : 0;
                    const periodConsistency = Math.max(0, 100 - periodCv);
                    
                    // Season consistency
                    const seasonPoints = seasonWeeks.map(w => w.fpts);
                    const seasonMean = seasonPoints.reduce((sum, p) => sum + p, 0) / seasonPoints.length;
                    const seasonVariance = seasonPoints.reduce((sum, p) => sum + Math.pow(p - seasonMean, 2), 0) / seasonPoints.length;
                    const seasonStdDev = Math.sqrt(seasonVariance);
                    const seasonCv = seasonMean > 0 ? (seasonStdDev / seasonMean) * 100 : 0;
                    const seasonConsistency = Math.max(0, 100 - seasonCv);
                    
                    // Delta = period vs season consistency
                    const consistencyDelta = periodConsistency - seasonConsistency;
                    
                    return {
                        value: periodConsistency,
                        delta: consistencyDelta,
                        display: periodConsistency.toFixed(0)
                    };
                }
                    
                case 'ceiling': {
                    // Calculate 90th percentile score for period
                    if (weeks.length < 3) return { value: null, delta: 0, display: '0.0' };
                    
                    // Period ceiling
                    const periodSortedPoints = weeks.map(w => w.fpts).sort((a, b) => b - a);
                    const periodCeilingIndex = Math.floor(periodSortedPoints.length * 0.1);
                    const periodCeiling = periodSortedPoints[periodCeilingIndex] || periodSortedPoints[0];
                    
                    // Season ceiling
                    const seasonSortedPoints = seasonWeeks.map(w => w.fpts).sort((a, b) => b - a);
                    const seasonCeilingIndex = Math.floor(seasonSortedPoints.length * 0.1);
                    const seasonCeiling = seasonSortedPoints[seasonCeilingIndex] || seasonSortedPoints[0];
                    
                    // Delta = period vs season ceiling
                    const ceilingDelta = periodCeiling - seasonCeiling;
                    
                    return {
                        value: periodCeiling,
                        delta: ceilingDelta,
                        display: periodCeiling.toFixed(1)
                    };
                }
                    
                case 'floor': {
                    // Calculate 10th percentile score for period
                    if (weeks.length < 3) return { value: null, delta: 0, display: '0.0' };
                    
                    // Period floor
                    const periodFloorPoints = weeks.map(w => w.fpts).sort((a, b) => a - b);
                    const periodFloorIndex = Math.floor(periodFloorPoints.length * 0.1);
                    const periodFloor = periodFloorPoints[periodFloorIndex] || periodFloorPoints[0];
                    
                    // Season floor
                    const seasonFloorPoints = seasonWeeks.map(w => w.fpts).sort((a, b) => a - b);
                    const seasonFloorIndex = Math.floor(seasonFloorPoints.length * 0.1);
                    const seasonFloor = seasonFloorPoints[seasonFloorIndex] || seasonFloorPoints[0];
                    
                    // Delta = period vs season floor
                    const floorDelta = periodFloor - seasonFloor;
                    
                    return {
                        value: periodFloor,
                        delta: floorDelta,
                        display: periodFloor.toFixed(1)
                    };
                }
                    
                default: {
                    return { value: avgPoints, delta: player.pctOverExpected || 0, display: avgPoints.toFixed(1) };
                }
            }
        }
        
        // Get player data for specified time period
        function getPlayerDataForPeriod(player, period) {
            const weeks = player.weeks || [];
            if (weeks.length === 0) return null;
            
            let relevantWeeks;
            
            switch(period) {
                case 'week':
                    // Last week only
                    relevantWeeks = weeks.slice(-1);
                    break;
                case 'last3':
                    // Last 3 weeks (or fewer if not available)
                    relevantWeeks = weeks.slice(-3);
                    break;
                case 'last5':
                    // Last 5 weeks (or fewer if not available)
                    relevantWeeks = weeks.slice(-5);
                    break;
                case 'season':
                default:
                    // All weeks
                    relevantWeeks = weeks;
                    break;
            }
            
            if (relevantWeeks.length === 0) return null;
            
            // Calculate averages for this period
            const totalPoints = relevantWeeks.reduce((sum, w) => sum + (parseFloat(w.fpts) || 0), 0);
            const totalExpected = relevantWeeks.reduce((sum, w) => sum + (parseFloat(w.expectedFpts) || 0), 0);
            const avgPoints = totalPoints / relevantWeeks.length;
            const avgExpected = totalExpected / relevantWeeks.length;
            
            return { 
                avgPoints, 
                avgExpected,
                weeks: relevantWeeks,
                weeksAvailable: relevantWeeks.length
            };
        }

        // Update position stats
        function updatePositionStats(players, position) {
            if (players.length === 0) {
                console.log('No players to display stats for');
                return;
            }
            
            // Determine top N based on display filter
            const displayFilter = heatmapState.display;
            let topN = 24; // default
            if (displayFilter === '36') topN = 36;
            else if (displayFilter === '50') topN = 50;
            else if (displayFilter === 'all') topN = players.length;
            
            // Get current metric
            const metric = heatmapState.metric;
            
            // Get all players for this position (not just displayed)
            let allPlayers = getPlayersForPosition(position);
            
            // Calculate metric for all players
            allPlayers = allPlayers.map(player => {
                const metricData = calculatePlayerMetric(player, metric, heatmapState.period);
                return {
                    ...player,
                    metricValue: metricData.value,
                    metricDisplay: metricData.display
                };
            }).filter(p => p.metricValue !== null);
            
            // Sort by metric value
            allPlayers.sort((a, b) => b.metricValue - a.metricValue);
            
            // Take top N players
            const topPlayers = allPlayers.slice(0, Math.min(topN, allPlayers.length));
            
            // Calculate average based on metric type
            let avgValue = 0;
            let unit = '';
            let label = '';
            
            if (metric === 'actual-vs-expected') {
                // Points per game
                const totalPoints = topPlayers.reduce((sum, p) => sum + p.metricValue, 0);
                avgValue = topPlayers.length > 0 ? totalPoints / topPlayers.length : 0;
                unit = ' PPG';
                label = 'Top ' + topN + ' Avg';
            } else if (metric === 'target-share') {
                // Usage share as percentage
                const totalShare = topPlayers.reduce((sum, p) => sum + p.metricValue, 0);
                avgValue = topPlayers.length > 0 ? totalShare / topPlayers.length : 0;
                unit = '%';
                label = 'Top ' + topN + ' Avg';
            } else if (metric === 'rz-opportunity') {
                // Red zone opportunities (raw count)
                const totalRZ = topPlayers.reduce((sum, p) => sum + p.metricValue, 0);
                avgValue = topPlayers.length > 0 ? totalRZ / topPlayers.length : 0;
                unit = ' RZ Opp';
                label = 'Top ' + topN + ' Avg';
            } else if (metric === 'floor-consistency') {
                // Floor score
                const totalFloor = topPlayers.reduce((sum, p) => sum + p.metricValue, 0);
                avgValue = topPlayers.length > 0 ? totalFloor / topPlayers.length : 0;
                unit = '';
                label = 'Top ' + topN + ' Avg';
            }
            
            const positionBadgeClass = position === 'WR' ? 'wr-badge' : position === 'RB' ? 'rb-badge' : 'te-badge';
            const positionName = position === 'WR' ? 'Wide Receivers' : position === 'RB' ? 'Running Backs' : 'Tight Ends';
            
            document.getElementById('heatmap-position-stats').innerHTML = `
                <div class="position-info">
                    <span class="position-badge ${positionBadgeClass}">${position}</span>
                    <span class="position-title">${positionName}</span>
                </div>
                <div class="position-stats">
                    <div class="position-stat">
                        <div class="position-stat-label">${label}</div>
                        <div class="position-stat-value">${avgValue.toFixed(1)}${unit}</div>
                    </div>
                </div>
            `;
        }

        // Get color class based on delta percentage - METRIC-SPECIFIC THRESHOLDS
        function getHeatmapColorClass(delta, metric) {
            // Different metrics need different scales
            if (metric === 'actual-vs-expected') {
                // Actual vs Expected: use percentage-based thresholds
                if (delta >= 20) return 'extreme-positive';
                if (delta >= 15) return 'strong-positive';
                if (delta >= 10) return 'moderate-positive';
                if (delta >= 5) return 'slight-positive';
                if (delta >= -5) return 'neutral';
                if (delta >= -10) return 'slight-negative';
                if (delta >= -15) return 'moderate-negative';
                if (delta >= -20) return 'strong-negative';
                return 'extreme-negative';
            } else if (metric === 'target-share' || metric === 'usage-trend') {
                // Target/Usage Share: use percentage point thresholds (smaller scale)
                if (delta >= 8) return 'extreme-positive';
                if (delta >= 5) return 'strong-positive';
                if (delta >= 3) return 'moderate-positive';
                if (delta >= 1.5) return 'slight-positive';
                if (delta >= -1.5) return 'neutral';
                if (delta >= -3) return 'slight-negative';
                if (delta >= -5) return 'moderate-negative';
                if (delta >= -8) return 'strong-negative';
                return 'extreme-negative';
            } else if (metric === 'rz-opp-share') {
                // RZ Opp Share: percentage point thresholds (similar to target-share but slightly more sensitive)
                if (delta >= 6) return 'extreme-positive';
                if (delta >= 4) return 'strong-positive';
                if (delta >= 2.5) return 'moderate-positive';
                if (delta >= 1.5) return 'slight-positive';
                if (delta >= -1.5) return 'neutral';
                if (delta >= -2.5) return 'slight-negative';
                if (delta >= -4) return 'moderate-negative';
                if (delta >= -6) return 'strong-negative';
                return 'extreme-negative';
            } else if (metric === 'points-per-touch') {
                // PPT Efficiency: moderate sensitivity
                if (delta >= 0.4) return 'extreme-positive';
                if (delta >= 0.25) return 'strong-positive';
                if (delta >= 0.15) return 'moderate-positive';
                if (delta >= 0.08) return 'slight-positive';
                if (delta >= -0.08) return 'neutral';
                if (delta >= -0.15) return 'slight-negative';
                if (delta >= -0.25) return 'moderate-negative';
                if (delta >= -0.4) return 'strong-negative';
                return 'extreme-negative';
            } else if (metric === 'consistency') {
                // Consistency: moderate scale (0-100 score)
                if (delta >= 15) return 'extreme-positive';
                if (delta >= 10) return 'strong-positive';
                if (delta >= 6) return 'moderate-positive';
                if (delta >= 3) return 'slight-positive';
                if (delta >= -3) return 'neutral';
                if (delta >= -6) return 'slight-negative';
                if (delta >= -10) return 'moderate-negative';
                if (delta >= -15) return 'strong-negative';
                return 'extreme-negative';
            } else if (metric === 'ceiling' || metric === 'floor') {
                // Ceiling/Floor: points difference
                if (delta >= 6) return 'extreme-positive';
                if (delta >= 4) return 'strong-positive';
                if (delta >= 2.5) return 'moderate-positive';
                if (delta >= 1.5) return 'slight-positive';
                if (delta >= -1.5) return 'neutral';
                if (delta >= -2.5) return 'slight-negative';
                if (delta >= -4) return 'moderate-negative';
                if (delta >= -6) return 'strong-negative';
                return 'extreme-negative';
            } else {
                // Default: use percentage-based thresholds
                if (delta >= 20) return 'extreme-positive';
                if (delta >= 15) return 'strong-positive';
                if (delta >= 10) return 'moderate-positive';
                if (delta >= 5) return 'slight-positive';
                if (delta >= -5) return 'neutral';
                if (delta >= -10) return 'slight-negative';
                if (delta >= -15) return 'moderate-negative';
                if (delta >= -20) return 'strong-negative';
                return 'extreme-negative';
            }
        }

        // Update heatmap legend based on selected metric
        function updateHeatmapLegend(metric) {
            const titleEl = document.getElementById('heatmap-legend-title');
            const labels = [
                document.getElementById('legend-label-0'),
                document.getElementById('legend-label-1'),
                document.getElementById('legend-label-2'),
                document.getElementById('legend-label-3'),
                document.getElementById('legend-label-4'),
                document.getElementById('legend-label-5'),
                document.getElementById('legend-label-6'),
                document.getElementById('legend-label-7'),
                document.getElementById('legend-label-8')
            ];
            
            // Define legend configurations for each metric
            const legendConfigs = {
                'actual-vs-expected': {
                    title: 'Performance vs Expected',
                    labels: [
                        '-20%+<br>Extreme Under',
                        '-15 to -20%<br>Strong Under',
                        '-10 to -15%<br>Moderate Under',
                        '-5 to -10%<br>Slight Under',
                        '±5%<br>On Target',
                        '+5 to +10%<br>Slight Over',
                        '+10 to +15%<br>Moderate Over',
                        '+15 to +20%<br>Strong Over',
                        '+20%+<br>Extreme Over'
                    ]
                },
                'target-share': {
                    title: 'Target/Opportunity Share',
                    labels: [
                        '-8%+<br>Extreme Low',
                        '-5 to -8%<br>Strong Low',
                        '-3 to -5%<br>Moderate Low',
                        '-1.5 to -3%<br>Slight Low',
                        '±1.5%<br>Average',
                        '+1.5 to +3%<br>Slight High',
                        '+3 to +5%<br>Moderate High',
                        '+5 to +8%<br>Strong High',
                        '+8%+<br>Extreme High'
                    ]
                },
                'rz-opp-share': {
                    title: 'RZ Opportunity Share',
                    labels: [
                        '-6%+<br>Extreme Low',
                        '-4 to -6%<br>Strong Low',
                        '-2.5 to -4%<br>Moderate Low',
                        '-1.5 to -2.5%<br>Slight Low',
                        '±1.5%<br>Average',
                        '+1.5 to +2.5%<br>Slight High',
                        '+2.5 to +4%<br>Moderate High',
                        '+4 to +6%<br>Strong High',
                        '+6%+<br>Extreme High'
                    ]
                },
                'points-per-touch': {
                    title: 'Points Per Touch Efficiency',
                    labels: [
                        '-0.4+<br>Very Poor',
                        '-0.25 to -0.4<br>Poor',
                        '-0.15 to -0.25<br>Below Avg',
                        '-0.08 to -0.15<br>Slight Low',
                        '±0.08<br>Average',
                        '+0.08 to +0.15<br>Slight High',
                        '+0.15 to +0.25<br>Above Avg',
                        '+0.25 to +0.4<br>Strong',
                        '+0.4+<br>Elite'
                    ]
                }
            };
            
            // Get config for current metric (fallback to actual-vs-expected)
            const config = legendConfigs[metric] || legendConfigs['actual-vs-expected'];
            
            // Update title
            titleEl.textContent = config.title;
            
            // Update labels
            labels.forEach((label, idx) => {
                label.innerHTML = config.labels[idx];
            });
        }

        // Get arrow based on delta
        function getHeatmapArrow(delta) {
            if (delta >= 10) return '↑';
            if (delta >= 5) return '↗';
            if (delta >= -5) return '→';
            if (delta >= -10) return '↘';
            return '↓';
        }

        // Get arrow color class
        function getArrowColorClass(delta) {
            if (delta >= 5) return 'positive-delta';
            if (delta <= -5) return 'negative-delta';
            return '';
        }

        // Render heatmap cards
        function renderHeatmapCards(players, position) {
            const grid = document.getElementById('heatmap-player-grid');
            const metric = heatmapState.metric; // Get current metric
            
            grid.innerHTML = players.map(player => {
                const colorClass = getHeatmapColorClass(player.metricDelta, metric);
                const arrow = getHeatmapArrow(player.metricDelta);
                const arrowColorClass = getArrowColorClass(player.metricDelta);
                const deltaSign = player.metricDelta >= 0 ? '+' : '';
                
                return `
                    <div class="heatmap-player-card ${colorClass}" onclick="openPlayerModal('${player.id}')">
                        <div class="heatmap-player-name">${player.name}</div>
                        <div class="heatmap-player-team">${player.team}</div>
                        <div class="heatmap-bottom-row">
                            <div class="heatmap-value">${player.metricDisplay}</div>
                            <div class="heatmap-delta-group ${arrowColorClass}">
                                <div class="heatmap-arrow">${arrow}</div>
                                <div class="heatmap-delta-value">${deltaSign}${player.metricDelta.toFixed(0)}%</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Update Market Opportunities
        function updateMarketOpportunities() {
            // Check if data is loaded
            if (!aggregatedWRs || !aggregatedRBs || !aggregatedTEs) {
                console.log('Market Opportunities: Data not yet loaded');
                return;
            }
            
            // If injury data isn't loaded yet, wait for it
            if (!injuryData || Object.keys(injuryData).length === 0) {
                console.log('Market Opportunities: Waiting for injury data...');
                // Try to fetch from cache first
                const cachedData = localStorage.getItem('injuryData');
                if (cachedData) {
                    try {
                        const parsedCache = JSON.parse(cachedData);
                        const cacheAge = Date.now() - (parsedCache.timestamp || 0);
                        // Use cache if less than 1 hour old
                        if (cacheAge < 3600000) {
                            injuryData = parsedCache.data;
                            console.log('Market Opportunities: Loaded injury data from cache');
                        }
                    } catch (e) {
                        console.error('Failed to parse cached injury data:', e);
                    }
                }
                
                // If still no injury data, schedule retry or continue without it
                if (!injuryData || Object.keys(injuryData).length === 0) {
                    console.log('Market Opportunities: Proceeding without injury data (will retry in 2s)');
                    setTimeout(updateMarketOpportunities, 2000);
                    // Continue with current call but log warning
                }
            }
            
            // Get all players
            const allPlayers = [
                ...Object.values(aggregatedWRs).filter(p => p.gamesPlayed >= 3),
                ...Object.values(aggregatedRBs).filter(p => p.gamesPlayed >= 3),
                ...Object.values(aggregatedTEs).filter(p => p.gamesPlayed >= 3)
            ];
            
            console.log('Market Opportunities: Analyzing', allPlayers.length, 'players');
            
            // Identify buy low candidates
            const buyLow = identifyBuyLowCandidates(allPlayers);
            
            // Identify sell high candidates
            const sellHigh = identifySellHighCandidates(allPlayers);
            
            console.log('Market Opportunities:', { buyLow: buyLow.length, sellHigh: sellHigh.length });
            
            // Render opportunities
            renderMarketOpportunities(buyLow, sellHigh);
        }

        // Identify buy low candidates
        function identifyBuyLowCandidates(players) {
            console.log('Market Opportunities: Analyzing', players.length, 'players for Buy Low');
            
            const usedNarratives = {}; // Track narrative usage
            
            const candidates = players
                .map(player => {
                    const avgPoints = player.avgPoints || 0;
                    const weeks = player.weeks || [];
                    if (weeks.length < 3) return null;
                    
                    // Filter out recent breakout games (20+ in last game = no longer buy low)
                    const lastGame = weeks[weeks.length - 1];
                    const lastGamePoints = lastGame ? parseFloat(lastGame.fpts) || 0 : 0;
                    if (lastGamePoints >= 20) return null;
                    
                    // Check for established role (3+ weeks of 10+ points)
                    const recentWeeks = weeks.slice(-4); // Last 4 weeks
                    const solidWeeks = recentWeeks.filter(w => parseFloat(w.fpts) >= 10).length;
                    const hasEstablishedRole = solidWeeks >= 3;
                    
                    // Get opportunity metrics
                    const oppShare = player.latestWeekOppShare || 0;
                    const teamPts = player.latestWeekTeamPoints || 0;
                    
                    // Calculate average usage share from weeks
                    let avgUsageShare = 0;
                    if (weeks.length > 0) {
                        avgUsageShare = weeks.reduce((sum, w) => sum + (w.usageShare || 0), 0) / weeks.length;
                    }
                    
                    // Use pctOverExpected which is already calculated
                    const underPerforming = player.pctOverExpected || 0;
                    
                    // Check momentum
                    const hasNegMomentum = player.momentum && player.momentum.isValid && player.momentum.score < -5;
                    
                    // Good offense = team scoring 24+ PPG
                    const goodOffense = teamPts > 24;
                    
                    // High volume = 18%+ usage share OR 15+ opportunities
                    const highVolume = avgUsageShare > 18 || oppShare > 15;
                    
                    // Buy low criteria
                    const isUnderperforming = underPerforming < -8;
                    const hasGoodSituation = (goodOffense && (avgUsageShare > 12 || oppShare > 10));
                    const meetsMinimum = avgPoints > 8;
                    
                    if ((isUnderperforming && hasGoodSituation && meetsMinimum) || (hasEstablishedRole && underPerforming < -5 && meetsMinimum)) {
                        // Generate list of applicable narratives in priority order
                        const narrativeOptions = [];
                        
                        if (hasEstablishedRole && goodOffense) {
                            narrativeOptions.push('Established role on elite offense - buy the consistency');
                        }
                        if (hasEstablishedRole) {
                            narrativeOptions.push('Consistent 10+ point weeks - emerging reliable option');
                        }
                        if (oppShare > 20 && teamPts > 24) {
                            narrativeOptions.push('Elite offense role + volume - production should rebound');
                        }
                        if (hasNegMomentum && avgUsageShare > 15) {
                            narrativeOptions.push('Strong usage despite slump - buy the dip');
                        }
                        if (goodOffense && avgUsageShare > 18) {
                            narrativeOptions.push('High-powered offense role - volume should translate');
                        }
                        if (goodOffense && avgUsageShare > 12) {
                            narrativeOptions.push('Good situation + volume, recent production should improve');
                        }
                        if (avgUsageShare > 20) {
                            narrativeOptions.push(`High usage (${avgUsageShare.toFixed(0)}% share) but TD-luck drought`);
                        }
                        if (oppShare > 15) {
                            narrativeOptions.push('Strong opportunity share - usage should convert to points');
                        }
                        narrativeOptions.push(`Solid usage (${avgUsageShare.toFixed(0)}% share) but underperforming expected`);
                        
                        // Select first narrative that hasn't been used twice
                        let selectedNarrative = narrativeOptions[0];
                        for (const narrative of narrativeOptions) {
                            const normalizedNarrative = narrative.replace(/\d+%/g, 'X%'); // Normalize percentages for tracking
                            if (!usedNarratives[normalizedNarrative] || usedNarratives[normalizedNarrative] < 2) {
                                selectedNarrative = narrative;
                                usedNarratives[normalizedNarrative] = (usedNarratives[normalizedNarrative] || 0) + 1;
                                break;
                            }
                        }
                        
                        console.log('Buy Low candidate:', player.name, {
                            reason: selectedNarrative,
                            narrativeOptions: narrativeOptions.length
                        });
                        
                        // Calculate upside score
                        let upsideScore = Math.abs(underPerforming);
                        if (hasEstablishedRole) upsideScore += 10;
                        if (goodOffense && highVolume) upsideScore += 5;
                        
                        return {
                            player: player,
                            upside: upsideScore,
                            usageShare: avgUsageShare,
                            reason: selectedNarrative
                        };
                    }
                    return null;
                })
                .filter(x => x !== null)
                .sort((a, b) => b.upside - a.upside)
                .slice(0, 5);
            
            return candidates;
        }

        // Identify sell high candidates
        function identifySellHighCandidates(players) {
            console.log('Market Opportunities: Analyzing', players.length, 'players for Sell High');
            
            // Debug: Check injury data availability
            console.log('Injury Data Check:', {
                injuryDataExists: !!injuryData,
                injuryDataKeys: injuryData ? Object.keys(injuryData).length : 0,
                sampleKeys: injuryData ? Object.keys(injuryData).slice(0, 5) : []
            });
            
            // Calculate top 10 at each position by avgPoints
            const positionRanks = {};
            ['WR', 'RB', 'TE'].forEach(pos => {
                const posPlayers = players.filter(p => p.position === pos);
                const sorted = [...posPlayers].sort((a, b) => b.avgPoints - a.avgPoints);
                sorted.forEach((p, idx) => {
                    positionRanks[p.id] = idx + 1;
                });
            });
            
            let irFilteredCount = 0;
            let top10FilteredCount = 0;
            const usedNarratives = {}; // Track narrative usage
            
            const candidates = players
                .map(player => {
                    const avgPoints = player.avgPoints || 0;
                    const weeks = player.weeks || [];
                    if (weeks.length < 3) return null;
                    
                    // Exclude top 10 players at their position
                    const posRank = positionRanks[player.id] || 999;
                    if (posRank <= 10) {
                        top10FilteredCount++;
                        console.log(`✓ Filtered out ${player.name} - Top 10 at ${player.position} (rank #${posRank})`);
                        return null;
                    }
                    
                    // Must be scoring reasonably well to be worth selling (8-18 PPG range)
                    if (avgPoints < 8 || avgPoints > 18) return null;
                    
                    // Filter out injured reserve players
                    const injury = getPlayerInjuryStatus(player.name);
                    if (injury && (injury.status === 'IR' || injury.status === 'PUP')) {
                        irFilteredCount++;
                        console.log(`✓ Filtered out ${player.name} - ${injury.status}`);
                        return null;
                    }
                    
                    // Get last 3 weeks for recent performance
                    const last3Weeks = weeks.slice(-3);
                    const last3Points = last3Weeks.map(w => parseFloat(w.fpts) || 0);
                    const last3Avg = last3Points.reduce((sum, pts) => sum + pts, 0) / last3Points.length;
                    
                    // Calculate variance
                    const variances = last3Points.map(pts => Math.pow(pts - last3Avg, 2));
                    const variance = variances.reduce((sum, v) => sum + v, 0) / variances.length;
                    const stdDev = Math.sqrt(variance);
                    
                    // TD dependency calculation
                    const last3TDs = last3Weeks.reduce((sum, w) => {
                        return sum + (parseFloat(w.rec_td) || 0) + (parseFloat(w.rush_td) || 0);
                    }, 0);
                    const tdPoints = last3TDs * 6;
                    const tdDependency = last3Avg > 0 ? (tdPoints / (last3Avg * 3)) * 100 : 0;
                    
                    // Volume metrics
                    const totalUsageShare = weeks.reduce((sum, w) => sum + (w.usageShare || 0), 0);
                    const avgUsageShare = totalUsageShare / weeks.length;
                    const volumeScore = avgUsageShare < 12 ? 1.5 : avgUsageShare < 18 ? 1.2 : 1.0;
                    
                    // Check momentum
                    const hasSolidMomentum = player.momentum && player.momentum.isValid && player.momentum.score > 10;
                    if (hasSolidMomentum) return null;
                    
                    // Calculate sell high score
                    const sellHighScore = (stdDev * volumeScore) + (tdDependency * 0.5);
                    
                    const isInconsistent = stdDev > 5;
                    const isTDDependent = tdDependency > 35;
                    const recentlyHot = last3Avg > 12;
                    
                    if ((isInconsistent || isTDDependent) && recentlyHot) {
                        // Generate list of applicable narratives in priority order
                        const narrativeOptions = [];
                        
                        if (tdDependency > 45 && volumeScore > 1.1) {
                            narrativeOptions.push(`${last3TDs} TDs on limited volume - unsustainable production`);
                        }
                        if (tdDependency > 40) {
                            narrativeOptions.push(`Heavy TD reliance (${tdDependency.toFixed(0)}%) - regression likely`);
                        }
                        if (tdDependency > 30 && volumeScore > 1.1) {
                            narrativeOptions.push(`TD-dependent (${tdDependency.toFixed(0)}%) on low volume - sell high`);
                        }
                        if (volumeScore > 1.3) {
                            narrativeOptions.push('Low-volume boom/bust profile - volatile week-to-week');
                        }
                        if (volumeScore > 1.1 && stdDev > 6) {
                            narrativeOptions.push('Limited role + inconsistent - sell while value is up');
                        }
                        if (stdDev > 7) {
                            narrativeOptions.push('Extreme variance recently - cash in while hot');
                        }
                        if (stdDev > 5) {
                            narrativeOptions.push(`Boom/bust scoring pattern (±${stdDev.toFixed(1)} pts) - sell at peak`);
                        }
                        narrativeOptions.push('Inconsistent scoring pattern - sell at peak value');
                        
                        // Select first narrative that hasn't been used twice
                        let selectedNarrative = narrativeOptions[0];
                        for (const narrative of narrativeOptions) {
                            const normalizedNarrative = narrative.replace(/\d+%?/g, 'X').replace(/±\d+\.\d+/g, '±X'); // Normalize numbers
                            if (!usedNarratives[normalizedNarrative] || usedNarratives[normalizedNarrative] < 2) {
                                selectedNarrative = narrative;
                                usedNarratives[normalizedNarrative] = (usedNarratives[normalizedNarrative] || 0) + 1;
                                break;
                            }
                        }
                        
                        console.log('Sell High candidate:', player.name, {
                            reason: selectedNarrative,
                            narrativeOptions: narrativeOptions.length
                        });
                        
                        return {
                            player: player,
                            downside: sellHighScore,
                            tdRate: last3TDs / 3,
                            tdDependency: tdDependency,
                            usage: avgUsageShare,
                            reason: selectedNarrative
                        };
                    }
                    return null;
                })
                .filter(x => x !== null)
                .sort((a, b) => b.downside - a.downside)
                .slice(0, 5);
            
            // Debug: Report filtering results
            console.log(`Top 10 Filter: Removed ${top10FilteredCount} players in top 10 at position`);
            console.log(`IR Filter: Removed ${irFilteredCount} players on IR/PUP`);
            
            return candidates;
        }

        // Generate buy low reason
        function generateBuyLowReason(player, underPerforming, usageShare) {
            const reasons = [];
            if (usageShare > 20) reasons.push(`High usage (${usageShare.toFixed(0)}% share)`);
            else if (usageShare > 15) reasons.push(`Solid usage (${usageShare.toFixed(0)}% share)`);
            else reasons.push(`Decent usage (${usageShare.toFixed(0)}% share)`);
            
            if (underPerforming < -15) reasons.push('TD-luck drought');
            else reasons.push('underperforming expected');
            
            return reasons.join(' but ');
        }

        // Generate sell high reason
        function generateSellHighReason(player, overPerforming, tdDependent, tdRate) {
            const reasons = [];
            
            if (tdDependent) reasons.push(`TD rate unsustainable (${tdRate.toFixed(1)}/game)`);
            if (overPerforming > 20) reasons.push('extreme outperformance');
            else if (overPerforming > 12) reasons.push('significant overperformance');
            
            if (reasons.length === 0) reasons.push('regression likely');
            
            return reasons.join(', ');
        }

        // Render market opportunities
        function renderMarketOpportunities(buyLow, sellHigh) {
            const grid = document.getElementById('market-opportunities-grid');
            
            const buyLowHTML = `
                <div class="market-column">
                    <div class="market-column-header">
                        <div class="market-column-title buy-low">Buy Low</div>
                        <div class="market-column-count">(${buyLow.length} players)</div>
                    </div>
                    ${buyLow.map(opp => `
                        <div class="opportunity-card" onclick="openPlayerModal('${opp.player.id}')">
                            <div class="opportunity-badge buy">BUY</div>
                            <div class="opportunity-info">
                                <div class="opportunity-name">${opp.player.name}</div>
                                <div class="opportunity-reason">${opp.reason}</div>
                            </div>
                            <div class="opportunity-percentage positive">+${opp.upside.toFixed(0)}%</div>
                        </div>
                    `).join('')}
                </div>
            `;
            
            const sellHighHTML = `
                <div class="market-column">
                    <div class="market-column-header">
                        <div class="market-column-title sell-high">Sell High</div>
                        <div class="market-column-count">(${sellHigh.length} players)</div>
                    </div>
                    ${sellHigh.map(opp => `
                        <div class="opportunity-card" onclick="openPlayerModal('${opp.player.id}')">
                            <div class="opportunity-badge sell">SELL</div>
                            <div class="opportunity-info">
                                <div class="opportunity-name">${opp.player.name}</div>
                                <div class="opportunity-reason">${opp.reason}</div>
                            </div>
                            <div class="opportunity-percentage negative">-${opp.downside.toFixed(0)}%</div>
                        </div>
                    `).join('')}
                </div>
            `;
            
            grid.innerHTML = buyLowHTML + sellHighHTML;
        }

        // DASHBOARD CATEGORIES SYSTEM

        // Helper: Calculate averages for last 3 games
        function getLast3GamesAvg(player) {
            if (!player.weeks || player.weeks.length === 0) return null;

            // Find the global maximum week across ALL WRs, RBs, and TEs (the current week of the season)
            let globalMaxWeek = 0;

            // Check all WRs
            Object.values(aggregatedWRs).forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });

            // Check all RBs
            Object.values(aggregatedRBs).forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });

            // Check all TEs
            Object.values(aggregatedTEs).forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });

            if (globalMaxWeek === 0) return null;

            // The last 3 weeks are based on the GLOBAL max week (current week of season)
            const last3ActualWeeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
            const prior3ActualWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];

            // Filter to only games within the last 3 actual weeks where player had fantasy points
            let last3WeeksGames = player.weeks.filter(w =>
                last3ActualWeeks.includes(w.week) && w.fpts > 0
            );

            // NEW LOGIC: If player only has 1 game in last 3 weeks (e.g., injured/bye most recent week)
            // but has 2+ games in weeks 2-3 of the window, use those 2 weeks
            let usedAlternateWeeks = false;
            if (last3WeeksGames.length === 1) {
                // Check if they have data from weeks globalMaxWeek-1 and globalMaxWeek-2
                const weeks2and3 = player.weeks.filter(w =>
                    [globalMaxWeek - 1, globalMaxWeek - 2].includes(w.week) && w.fpts > 0
                );

                if (weeks2and3.length >= 2) {
                    // Use these 2 weeks for "last 3"
                    last3WeeksGames = weeks2and3;
                    usedAlternateWeeks = true;
                }
            }

            // If still less than 2 games, try getting most recent games regardless of week
            if (last3WeeksGames.length < 2) {
                // Get all games with points, sorted by week descending
                const allGamesWithPoints = player.weeks
                    .filter(w => w.fpts > 0)
                    .sort((a, b) => b.week - a.week);

                if (allGamesWithPoints.length >= 2) {
                    last3WeeksGames = allGamesWithPoints.slice(0, Math.min(3, allGamesWithPoints.length));
                    usedAlternateWeeks = true;
                }
            }

            // Filter for prior 3 weeks
            let prior3WeeksGames = player.weeks.filter(w =>
                prior3ActualWeeks.includes(w.week) && w.fpts > 0
            );

            // If we used alternate weeks for last 3, adjust prior weeks accordingly
            if (usedAlternateWeeks && last3WeeksGames.length > 0) {
                const oldestRecentWeek = Math.min(...last3WeeksGames.map(w => w.week));
                // Get 3 games before the oldest recent week
                prior3WeeksGames = player.weeks
                    .filter(w => w.week < oldestRecentWeek && w.fpts > 0)
                    .sort((a, b) => b.week - a.week)
                    .slice(0, 3);
            }

            // Count how many of the last 3 weeks the player actually played with points
            const gamesPlayed = last3WeeksGames.length;

            // Player must have played at least 2 games
            if (gamesPlayed < 2) return null;

            const totalPoints = last3WeeksGames.reduce((sum, w) => sum + w.fpts, 0);
            const avgPoints = totalPoints / gamesPlayed;

            let avgVolume = 0;
            if (player.position === 'WR' || player.position === 'TE') {
                avgVolume = last3WeeksGames.reduce((sum, w) => sum + (w.targets || 0), 0) / gamesPlayed;
            } else {
                avgVolume = last3WeeksGames.reduce((sum, w) => sum + (w.opportunities || 0), 0) / gamesPlayed;
            }

            const efficiency = avgVolume > 0 ? avgPoints / avgVolume : 0;

            // Calculate prior 3 weeks metrics for comparison
            let priorAvgVolume = 0;
            let priorEfficiency = 0;
            let priorRzOppsPerGame = 0;

            if (prior3WeeksGames.length >= 2) {
                if (player.position === 'WR' || player.position === 'TE') {
                    priorAvgVolume = prior3WeeksGames.reduce((sum, w) => sum + (w.targets || 0), 0) / prior3WeeksGames.length;
                } else {
                    priorAvgVolume = prior3WeeksGames.reduce((sum, w) => sum + (w.opportunities || 0), 0) / prior3WeeksGames.length;
                }
                priorEfficiency = priorAvgVolume > 0 ? prior3WeeksGames.reduce((sum, w) => sum + w.fpts, 0) / prior3WeeksGames.length / priorAvgVolume : 0;

                // Calculate prior RZ opps
                const rawData = player.position === 'WR' ? wrData : (player.position === 'TE' ? teData : rbData);
                if (rawData) {
                    let priorTotalRzOpps = 0;
                    prior3WeeksGames.forEach(weekData => {
                        const weekNum = weekData.week;
                        const weekRow = rawData.find(row =>
                            row.Team === player.team &&
                            row.Player === player.name &&
                            parseInt(row.Week) === weekNum
                        );
                        if (weekRow) {
                            if (player.position === 'WR' || player.position === 'TE') {
                                priorTotalRzOpps += parseFloat(weekRow.RZTGT) ||
                                                  parseFloat(weekRow['RZ TGT']) ||
                                                  parseFloat(weekRow.RZ_TGT) ||
                                                  parseFloat(weekRow['Red Zone Targets']) ||
                                                  0;
                            } else {
                                const rzAtt = parseFloat(weekRow.RZ_RUSH_ATT) ||
                                             parseFloat(weekRow['RZ_RUSH_ATT']) ||
                                             parseFloat(weekRow.RZATT) ||
                                             parseFloat(weekRow['RZ ATT']) ||
                                             parseFloat(weekRow.RZ_ATT) ||
                                             0;
                                const rzTgt = parseFloat(weekRow['RZ TGT']) ||
                                             parseFloat(weekRow.RZ_TGT) ||
                                             parseFloat(weekRow.RZTGT) ||
                                             0;
                                priorTotalRzOpps += rzAtt + rzTgt;
                            }
                        }
                    });
                    priorRzOppsPerGame = priorTotalRzOpps / prior3WeeksGames.length;
                }
            }

            // Calculate RZ opportunities from last 3 weeks
            let totalRzOpps = 0;
            const rawData = player.position === 'WR' ? wrData : (player.position === 'TE' ? teData : rbData);
            if (rawData) {
                last3WeeksGames.forEach(weekData => {
                    const weekNum = weekData.week;
                    const weekRow = rawData.find(row =>
                        row.Team === player.team &&
                        row.Player === player.name &&
                        parseInt(row.Week) === weekNum
                    );
                    if (weekRow) {
                        if (player.position === 'WR' || player.position === 'TE') {
                            // Try multiple column name variations for WR/TE red zone targets
                            totalRzOpps += parseFloat(weekRow.RZTGT) ||
                                          parseFloat(weekRow['RZ TGT']) ||
                                          parseFloat(weekRow.RZ_TGT) ||
                                          parseFloat(weekRow['Red Zone Targets']) ||
                                          0;
                        } else {
                            // For RBs: Red zone attempts + red zone targets
                            const rzAtt = parseFloat(weekRow.RZ_RUSH_ATT) ||
                                         parseFloat(weekRow['RZ_RUSH_ATT']) ||
                                         parseFloat(weekRow.RZATT) ||
                                         parseFloat(weekRow['RZ ATT']) ||
                                         parseFloat(weekRow.RZ_ATT) ||
                                         0;
                            const rzTgt = parseFloat(weekRow['RZ TGT']) ||
                                         parseFloat(weekRow.RZ_TGT) ||
                                         parseFloat(weekRow.RZTGT) ||
                                         0;
                            totalRzOpps += rzAtt + rzTgt;
                        }
                    }
                });
            }

            return {
                avgPoints,
                avgVolume,
                efficiency,
                gamesPlayed,
                rzOppsPerGame: totalRzOpps / gamesPlayed,
                globalMaxWeek,  // Include for debugging if needed
                // Prior 3 weeks for comparison
                priorAvgVolume,
                priorEfficiency,
                priorRzOppsPerGame
            };
        }

        function calculateDashboardCategories() {
            // Combine WR, RB, and TE players with minimum 3 games played
            const allEligiblePlayers = [
                ...Object.values(aggregatedWRs).filter(p => p.gamesPlayed >= 3),
                ...Object.values(aggregatedRBs).filter(p => p.gamesPlayed >= 3),
                ...Object.values(aggregatedTEs).filter(p => p.gamesPlayed >= 3)
            ];

            if (allEligiblePlayers.length === 0) return null;

            // Helper function: Check if player should be excluded due to inactivity
            // Returns true if player should be EXCLUDED (hasn't played in 3+ weeks without 2 games back)
            function shouldExcludePlayerForInactivity(player) {
                if (!player.weeks || player.weeks.length === 0) return true;

                // Find global max week (current week)
                let globalMaxWeek = 0;
                [...Object.values(aggregatedWRs), ...Object.values(aggregatedRBs), ...Object.values(aggregatedTEs)].forEach(p => {
                    if (p.weeks && p.weeks.length > 0) {
                        const maxWeek = Math.max(...p.weeks.map(w => w.week));
                        if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                    }
                });

                // Get player's games with points
                const gamesWithPoints = player.weeks.filter(w => w.fpts > 0).sort((a, b) => b.week - a.week);
                if (gamesWithPoints.length === 0) return true;

                const mostRecentGame = gamesWithPoints[0];
                const weeksAgo = globalMaxWeek - mostRecentGame.week;

                // If player's last game was 3+ weeks ago
                if (weeksAgo >= 3) {
                    // Check if they have 2+ games since coming back
                    // "Coming back" means any games after a 3+ week absence
                    // Count games in the last 3 weeks
                    const recentGames = player.weeks.filter(w =>
                        w.week >= (globalMaxWeek - 2) && w.fpts > 0
                    );

                    // If they don't have at least 2 recent games, exclude them
                    if (recentGames.length < 2) {
                        return true; // EXCLUDE
                    }
                }

                return false; // INCLUDE
            }

            // Add last 3 games data to each player and filter by 7+ PPG and activity
            const playersWithLast3 = allEligiblePlayers
                .filter(p => !shouldExcludePlayerForInactivity(p)) // NEW: Filter out inactive players
                .map(p => {
                    const last3 = getLast3GamesAvg(p);
                    return { ...p, last3 };
                })
                .filter(p => {
                    // getLast3GamesAvg returns null if player hasn't played 2 of last 3 weeks
                    if (!p.last3) return false;
                    // MIN 7 PPG filter
                    return p.last3.avgPoints >= 7.0;
                });

            const categories = {
                volumeMonsters: calculateVolumeMonsters(playersWithLast3),
                efficiencyElites: calculateEfficiencyElites(playersWithLast3),
                redZoneKingsWR: calculateRedZoneKingsWR(playersWithLast3),
                redZoneBacks: calculateRedZoneBacks(playersWithLast3),
                rbEfficiency: calculateRBEfficiency(playersWithLast3),
                consistentFloor: calculateConsistentFloor(playersWithLast3),
                airYardsLeaders: calculateAirYardsLeaders(playersWithLast3),
                passCatchingBacks: calculatePassCatchingBacks(playersWithLast3),
                targetLeadersTE: calculateTargetLeadersTE(playersWithLast3),
                redZoneDominanceTE: calculateRedZoneDominanceTE(playersWithLast3),
                totalTouchdownLeadersWR: calculateTotalTouchdownLeadersWR(playersWithLast3)
            };

            return categories;
        }

        // Category 1: Volume Monsters (Last 3 Games) - RBs Only
        function calculateVolumeMonsters(players) {
            // Filter to only RBs
            const rbPlayers = players.filter(p => p.position === 'RB');

            const volumeData = rbPlayers.map(p => {
                const volume = p.last3.avgVolume; // Use last 3 games average
                const priorVolume = p.last3.priorAvgVolume || 0;
                const change = priorVolume > 0 ? volume - priorVolume : 0;
                return { player: p, value: volume, change: change };
            }).sort((a, b) => b.value - a.value);

            // Get 75th percentile threshold
            const threshold = volumeData[Math.floor(volumeData.length * 0.25)]?.value || 0;

            return volumeData
                .filter(d => d.value >= threshold)
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'Opps/Game (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'High touch volume (last 3 games) - workhouse usage',
                    scatterKey: 'volume-efficiency'
                }));
        }

        // Category 2: Efficiency Elites (Last 3 Games)
        function calculateEfficiencyElites(players) {
            const efficiencyData = players
                .filter(p => p.avgPoints >= 7) // Only players with 7+ PPG
                .map(p => {
                    const efficiency = p.last3.efficiency; // Use last 3 games efficiency
                    const priorEfficiency = p.last3.priorEfficiency || 0;
                    const change = priorEfficiency > 0 ? efficiency - priorEfficiency : 0;
                    return { player: p, value: efficiency, change: change };
                }).sort((a, b) => b.value - a.value);

            // Top 20%
            return efficiencyData
                .slice(0, Math.ceil(efficiencyData.length * 0.2))
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(2),
                    metricLabel: d.player.position === 'WR' ? 'Pts/Tgt (L3)' : 'Pts/Opp (L3)',
                    change: d.change.toFixed(2),
                    explanation: 'Elite production per touch (last 3 games) - league winner upside if volume increases',
                    scatterKey: 'volume-efficiency'
                }));
        }

        // Category 3: Red Zone Kings WR (Last 3 Games) - WRs Only
        function calculateRedZoneKingsWR(players) {
            // Filter to only WRs
            const wrPlayers = players.filter(p => p.position === 'WR');

            const redZoneData = wrPlayers.map(p => {
                const rzPerGame = p.last3.rzOppsPerGame; // Use last 3 games RZ opps
                const priorRzPerGame = p.last3.priorRzOppsPerGame || 0;
                const change = priorRzPerGame > 0 ? rzPerGame - priorRzPerGame : 0;
                return { player: p, value: rzPerGame, change: change };
            })
            .filter(d => d.value > 0) // Only players with RZ opportunities
            .sort((a, b) => b.value - a.value);

            // Take top 8 WRs
            return redZoneData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'RZ Tgt/G (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'WRs with highest red zone target rate (last 3 games) - weekly TD upside',
                    scatterKey: 'redzone'
                }));
        }

        // Category 4: Red Zone Backs (Last 3 Games) - RBs Only
        function calculateRedZoneBacks(players) {
            // Filter to only RBs
            const rbPlayers = players.filter(p => p.position === 'RB');

            const redZoneData = rbPlayers.map(p => {
                const rzPerGame = p.last3.rzOppsPerGame; // Use last 3 games RZ opps (rush + targets)
                const priorRzPerGame = p.last3.priorRzOppsPerGame || 0;
                const change = priorRzPerGame > 0 ? rzPerGame - priorRzPerGame : 0;
                return { player: p, value: rzPerGame, change: change };
            })
            .filter(d => d.value > 0) // Only players with RZ opportunities
            .sort((a, b) => b.value - a.value);

            // Take top 8 RBs
            return redZoneData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'RZ Opps/G (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'RBs with highest red zone usage (last 3 games) - carries + targets in scoring position',
                    scatterKey: 'redzone'
                }));
        }

        // Category 5: RB Efficiency (Last 3 Games) - Rushing Yards Per Attempt
        function calculateRBEfficiency(players) {
            // Filter to only RBs
            const rbPlayers = players.filter(p => p.position === 'RB');

            const efficiencyData = rbPlayers.map(p => {
                // Calculate yards per attempt from last 3 games
                let totalYards = 0;
                let totalAttempts = 0;
                let priorTotalYards = 0;
                let priorTotalAttempts = 0;

                if (p.weeks && p.weeks.length > 0) {
                    // Get the global max week
                    let globalMaxWeek = 0;
                    Object.values(aggregatedRBs).forEach(rb => {
                        if (rb.weeks && rb.weeks.length > 0) {
                            const maxWeek = Math.max(...rb.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });

                    const last3Weeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
                    const prior3Weeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];

                    // Sum yards and attempts from last 3 weeks
                    p.weeks.forEach(w => {
                        if (last3Weeks.includes(w.week)) {
                            // Get raw data for this week
                            const weekRow = rbData.find(row =>
                                row.Player === p.name &&
                                row.Team === p.team &&
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow) {
                                totalYards += parseFloat(weekRow.YDS) || 0;
                                totalAttempts += parseFloat(weekRow.ATT) || 0;
                            }
                        }
                        // Calculate prior 3 weeks for comparison
                        if (prior3Weeks.includes(w.week)) {
                            const weekRow = rbData.find(row =>
                                row.Player === p.name &&
                                row.Team === p.team &&
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow) {
                                priorTotalYards += parseFloat(weekRow.YDS) || 0;
                                priorTotalAttempts += parseFloat(weekRow.ATT) || 0;
                            }
                        }
                    });
                }

                const yardsPerAttempt = totalAttempts > 0 ? totalYards / totalAttempts : 0;
                const priorYardsPerAttempt = priorTotalAttempts > 0 ? priorTotalYards / priorTotalAttempts : 0;
                const change = priorYardsPerAttempt > 0 ? yardsPerAttempt - priorYardsPerAttempt : 0;

                return {
                    player: p,
                    value: yardsPerAttempt,
                    totalAttempts: totalAttempts,
                    change: change
                };
            })
            .filter(d => d.totalAttempts >= 20) // Minimum 20 attempts over last 3 games
            .sort((a, b) => b.value - a.value);

            // Take top 8 RBs
            return efficiencyData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(2),
                    metricLabel: 'Yds/Att (L3)',
                    change: d.change,
                    explanation: 'RBs with highest yards per carry (last 3 games) - explosive rushing efficiency',
                    scatterKey: 'volume-efficiency'
                }));
        }

        // Category 4: Buy Low Gems (Last 3 Games Performance)
        function calculateBuyLowGems(players) {
            const buyLowData = players.map(p => {
                // High opportunity share on good offense, but underperforming recently
                const oppShare = p.latestWeekOppShare || 0;
                const teamPts = p.latestWeekTeamPoints || 0;
                const situationScore = oppShare * (teamPts / 30); // Normalize team points
                const actualPPG = p.last3.avgPoints; // Use last 3 games average
                const expectedPPG = situationScore * 2; // Rough expected
                const underperformance = expectedPPG - actualPPG;
                
                // Check if they have negative momentum (trending down)
                const hasNegMomentum = p.momentum && p.momentum.isValid && p.momentum.score < -5;

                return {
                    player: p,
                    value: underperformance,
                    situationScore: situationScore,
                    actualPPG: actualPPG,
                    oppShare: oppShare,
                    teamPts: teamPts,
                    hasNegMomentum: hasNegMomentum
                };
            })
            .filter(d => d.underperformance > 0 && d.situationScore > 15)
            .sort((a, b) => b.value - a.value);

            return buyLowData
                .slice(0, 8)
                .map((d, idx) => {
                    // Generate varied explanations based on player characteristics
                    let explanation;
                    if (d.oppShare > 25 && d.teamPts > 25) {
                        explanation = 'Elite offense role + volume - production should rebound';
                    } else if (d.hasNegMomentum && d.oppShare > 20) {
                        explanation = 'Strong usage despite slump - buy the dip';
                    } else if (d.situationScore > 25) {
                        explanation = 'Premium situation, underperforming - positive regression due';
                    } else if (d.teamPts > 27) {
                        explanation = 'High-powered offense role - volume should translate';
                    } else {
                        explanation = 'Good situation + volume, recent production should improve';
                    }
                    
                    return {
                        player: d.player,
                        rank: idx + 1,
                        metric: d.actualPPG.toFixed(1),
                        metricLabel: 'PPG (L3)',
                        score: d.situationScore.toFixed(0),
                        explanation: explanation,
                        scatterKey: 'opportunity-share'
                    };
                });
        }

        // Category 5: Sell High Alerts (Last 3 Games Variance)
        function calculateSellHighAlerts(players) {
            const sellHighData = players.map(p => {
                // Calculate variance from last 3 games
                const last3Weeks = [...p.weeks].sort((a, b) => b.week - a.week).slice(0, 3);
                const variances = last3Weeks.map(w => {
                    const weekAvg = w.fpts;
                    return Math.pow(weekAvg - p.last3.avgPoints, 2);
                });
                const variance = variances.reduce((sum, v) => sum + v, 0) / variances.length;
                const stdDev = Math.sqrt(variance);
                const consistency = 10 / (stdDev + 1);

                const ppg = p.last3.avgPoints; // Use last 3 games average
                
                // TD dependency calculation
                const last3TDs = last3Weeks.reduce((sum, w) => sum + (parseFloat(w.rec_td) || 0) + (parseFloat(w.rush_td) || 0), 0);
                const tdPoints = last3TDs * 6; // 6 points per TD
                const tdDependency = ppg > 0 ? (tdPoints / (ppg * 3)) * 100 : 0; // % of points from TDs
                
                // Volume metrics (lower = sell high concern)
                const avgOpportunities = p.last3.avgOpportunities || p.latestWeekOppShare || 0;
                const volumeScore = avgOpportunities < 10 ? 1.5 : avgOpportunities < 15 ? 1.2 : 1.0; // Penalty multiplier for low volume
                
                // Momentum check - exclude strong positive momentum players (>10%)
                const hasSolidMomentum = p.momentum && p.momentum.isValid && p.momentum.score > 10;
                
                // Calculate sell high score: high variance + TD dependent + low volume = sell high
                const sellHighScore = (stdDev * volumeScore) + (tdDependency * 0.5);

                return {
                    player: p,
                    value: ppg,
                    consistency: consistency,
                    stdDev: stdDev,
                    tdDependency: tdDependency,
                    volumeScore: volumeScore,
                    last3TDs: last3TDs,
                    sellHighScore: sellHighScore,
                    hasSolidMomentum: hasSolidMomentum
                };
            })
            .filter(d => {
                // Filter criteria: high PPG, low consistency OR high TD dependency, and not solid momentum
                return d.value > 12 && 
                       (d.consistency < 5 || d.tdDependency > 35) && 
                       !d.hasSolidMomentum;
            })
            .sort((a, b) => b.sellHighScore - a.sellHighScore); // Sort by sell high score

            return sellHighData
                .slice(0, 8)
                .map((d, idx) => {
                    // Generate varied explanations based on player characteristics
                    let explanation;
                    if (d.tdDependency > 50 && d.volumeScore > 1.2) {
                        explanation = `${d.last3TDs} TDs on limited volume - unsustainable production`;
                    } else if (d.tdDependency > 40) {
                        explanation = `Heavy TD reliance (${d.tdDependency.toFixed(0)}%) - regression likely`;
                    } else if (d.volumeScore > 1.3) {
                        explanation = 'Low-volume boom/bust profile - volatile week-to-week';
                    } else if (d.stdDev > 8) {
                        explanation = 'Extreme variance recently - cash in while hot';
                    } else {
                        explanation = 'Inconsistent scoring pattern - sell at peak value';
                    }
                    
                    return {
                        player: d.player,
                        rank: idx + 1,
                        metric: d.value.toFixed(1),
                        metricLabel: 'PPG (L3)',
                        score: d.consistency.toFixed(1),
                        explanation: explanation,
                        scatterKey: 'floor-ceiling'
                    };
                });
        }

        // Category 6: Bellcows / Target Hogs (Recent Performance)
        function calculateBellcowsTargetHogs(players) {
            const bellcowData = players.map(p => {
                // Calculate average opportunity share over last 3 weeks
                const last3Weeks = [...p.weeks].sort((a, b) => b.week - a.week).slice(0, 3);
                let totalShare = 0;
                let weekCount = 0;

                last3Weeks.forEach(weekData => {
                    const rawData = p.position === 'WR' ? wrData : rbData;
                    if (rawData) {
                        const weekRow = rawData.find(row =>
                            row.Team === p.team &&
                            row.Player === p.name &&
                            parseInt(row.Week) === weekData.week
                        );
                        if (weekRow && weekRow['Opp Share']) {
                            totalShare += parseFloat(weekRow['Opp Share']) || 0;
                            weekCount++;
                        }
                    }
                });

                const avgShare = weekCount > 0 ? totalShare / weekCount : 0;
                const threshold = p.position === 'WR' ? 28 : 70; // WR: 28% target share, RB: 70% opp share

                return { player: p, value: avgShare, threshold: threshold };
            })
            .filter(d => d.value >= d.threshold)
            .sort((a, b) => b.value - a.value);

            return bellcowData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1) + '%',
                    metricLabel: d.player.position === 'WR' ? 'Tgt Share (L3)' : 'Opp Share (L3)',
                    score: d.player.last3.avgPoints.toFixed(1),
                    explanation: d.player.position === 'WR' ?
                        'Target hog over last 3 games - will get volume in any game script' :
                        'Bellcow back over last 3 games - elite workload share',
                    scatterKey: 'opportunity-share'
                }));
        }

        // Category 7: High-Volume Alphas (Last 3 Games) - WRs Only, Based on Targets
        function calculateConsistentFloor(players) {
            // Filter to only WRs
            const wrPlayers = players.filter(p => p.position === 'WR');

            const consistentData = wrPlayers.map(p => {
                // Use targets per game as the consistency metric for WRs
                const targetsPerGame = p.last3.avgVolume; // For WRs, avgVolume is targets
                const ppg = p.last3.avgPoints;
                const priorTargetsPerGame = p.last3.priorAvgVolume || 0;
                const change = priorTargetsPerGame > 0 ? targetsPerGame - priorTargetsPerGame : 0;

                return {
                    player: p,
                    value: targetsPerGame,
                    ppg: ppg,
                    change: change
                };
            })
            .filter(d => d.ppg > 8 && d.value >= 6) // Decent production and minimum target volume
            .sort((a, b) => b.value - a.value); // Sort by targets per game

            return consistentData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'Tgt/Game (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'Consistent target volume recently - reliable PPR floor',
                    scatterKey: 'volume-efficiency'
                }));
        }

        // Category 8: Air Yards Leaders (Last 3 Games) - WRs Only
        function calculateAirYardsLeaders(players) {
            // Filter to only WRs
            const wrPlayers = players.filter(p => p.position === 'WR');

            const airYardsData = wrPlayers.map(p => {
                // Calculate air yards per game from last 3 games
                let totalAirYards = 0;
                let gameCount = 0;

                if (p.weeks && p.weeks.length > 0) {
                    // Get the global max week
                    let globalMaxWeek = 0;
                    Object.values(aggregatedWRs).forEach(wr => {
                        if (wr.weeks && wr.weeks.length > 0) {
                            const maxWeek = Math.max(...wr.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });

                    const last3Weeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];

                    // Sum air yards from last 3 weeks
                    p.weeks.forEach(w => {
                        if (last3Weeks.includes(w.week)) {
                            // Get raw data for this week
                            const weekRow = wrData.find(row =>
                                row.Team === p.team &&
                                row.Player === p.name &&
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow && weekRow['Air Yards']) {
                                totalAirYards += parseFloat(weekRow['Air Yards']) || 0;
                                gameCount++;
                            }
                        }
                    });
                }

                const airYardsPerGame = gameCount > 0 ? totalAirYards / gameCount : 0;

                // Calculate prior weeks for change
                let priorAirYards = 0;
                let priorGameCount = 0;

                if (p.weeks && p.weeks.length > 0) {
                    let globalMaxWeek = 0;
                    Object.values(aggregatedWRs).forEach(wr => {
                        if (wr.weeks && wr.weeks.length > 0) {
                            const maxWeek = Math.max(...wr.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });

                    const priorWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];

                    p.weeks.forEach(w => {
                        if (priorWeeks.includes(w.week)) {
                            const weekRow = wrData.find(row =>
                                row.Team === p.team &&
                                row.Player === p.name &&
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow && weekRow['Air Yards']) {
                                priorAirYards += parseFloat(weekRow['Air Yards']) || 0;
                                priorGameCount++;
                            }
                        }
                    });
                }

                const priorAirYardsPerGame = priorGameCount > 0 ? priorAirYards / priorGameCount : 0;
                const change = priorAirYardsPerGame > 0 ? airYardsPerGame - priorAirYardsPerGame : 0;

                return { player: p, value: airYardsPerGame, change: change };
            })
            .filter(d => d.value > 0)
            .sort((a, b) => b.value - a.value);

            return airYardsData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'Air Yds/G (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'Deep threat potential - high air yards signal downfield usage',
                    scatterKey: 'volume-efficiency'
                }));
        }

        // Category 9: Pass-Catching Backs (Last 3 Games) - RBs Only
        function calculatePassCatchingBacks(players) {
            // Filter to only RBs
            const rbPlayers = players.filter(p => p.position === 'RB');

            const receivingData = rbPlayers.map(p => {
                // Calculate targets per game from last 3 games
                let totalTargets = 0;
                let gameCount = 0;

                if (p.weeks && p.weeks.length > 0) {
                    // Get the global max week
                    let globalMaxWeek = 0;
                    Object.values(aggregatedRBs).forEach(rb => {
                        if (rb.weeks && rb.weeks.length > 0) {
                            const maxWeek = Math.max(...rb.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });

                    const last3Weeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];

                    // Sum targets from last 3 weeks
                    p.weeks.forEach(w => {
                        if (last3Weeks.includes(w.week)) {
                            // Get raw data for this week
                            const weekRow = rbData.find(row =>
                                row.Team === p.team &&
                                row.Player === p.name &&
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow && weekRow.TGT) {
                                totalTargets += parseFloat(weekRow.TGT) || 0;
                                gameCount++;
                            }
                        }
                    });
                }

                const targetsPerGame = gameCount > 0 ? totalTargets / gameCount : 0;

                // Calculate prior weeks for change
                let priorTargets = 0;
                let priorGameCount = 0;

                if (p.weeks && p.weeks.length > 0) {
                    let globalMaxWeek = 0;
                    Object.values(aggregatedRBs).forEach(rb => {
                        if (rb.weeks && rb.weeks.length > 0) {
                            const maxWeek = Math.max(...rb.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });

                    const priorWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];

                    p.weeks.forEach(w => {
                        if (priorWeeks.includes(w.week)) {
                            const weekRow = rbData.find(row =>
                                row.Team === p.team &&
                                row.Player === p.name &&
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow && weekRow.TGT) {
                                priorTargets += parseFloat(weekRow.TGT) || 0;
                                priorGameCount++;
                            }
                        }
                    });
                }

                const priorTargetsPerGame = priorGameCount > 0 ? priorTargets / priorGameCount : 0;
                const change = priorTargetsPerGame > 0 ? targetsPerGame - priorTargetsPerGame : 0;

                return { player: p, value: targetsPerGame, change: change };
            })
            .filter(d => d.value >= 2.0) // Minimum 2 targets per game
            .sort((a, b) => b.value - a.value);

            return receivingData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'Tgt/Game (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'Pass-catching backs - PPR gold with receiving volume',
                    scatterKey: 'volume-efficiency'
                }));
        }

        // NEW Category 9: TE Target Leaders (Last 3 Games) - TEs Only
        function calculateTargetLeadersTE(players) {
            // Filter to only TEs
            const tePlayers = players.filter(p => p.position === 'TE');

            const targetData = tePlayers.map(p => {
                const targetsPerGame = p.last3.avgVolume; // For TEs, avgVolume is targets per game
                const priorTargetsPerGame = p.last3.priorAvgVolume || 0;
                const change = priorTargetsPerGame > 0 ? targetsPerGame - priorTargetsPerGame : 0;
                return { player: p, value: targetsPerGame, change: change };
            })
            .filter(d => d.value > 0) // Only TEs with targets
            .sort((a, b) => b.value - a.value);

            // Take top 8 TEs
            return targetData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'Tgt/Game (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'TEs with highest target volume (last 3 games) - consistent fantasy floor',
                    scatterKey: 'volume-efficiency'
                }));
        }

        // NEW Category 10: TE Red Zone Dominance (Last 3 Games) - TEs Only
        function calculateRedZoneDominanceTE(players) {
            // Filter to only TEs
            const tePlayers = players.filter(p => p.position === 'TE');

            const redZoneData = tePlayers.map(p => {
                // Calculate combined RZ targets and TDs per game from last 3 games
                let rzTargets = 0;
                let rzTDs = 0;
                let gameCount = 0;

                if (p.weeks && p.weeks.length > 0) {
                    // Get the global max week
                    let globalMaxWeek = 0;
                    Object.values(aggregatedTEs).forEach(te => {
                        if (te.weeks && te.weeks.length > 0) {
                            const maxWeek = Math.max(...te.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });

                    const last3Weeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];

                    // Sum RZ data from last 3 weeks
                    p.weeks.forEach(w => {
                        if (last3Weeks.includes(w.week)) {
                            const weekRow = teData.find(row =>
                                row.Player === p.name &&
                                row.Team === p.team &&
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow) {
                                rzTargets += parseFloat(weekRow.RZ_TGT) || 0;
                                rzTDs += parseFloat(weekRow.RZ_TD) || 0;
                                gameCount++;
                            }
                        }
                    });
                }

                // Weight: RZ targets + (RZ TDs * 3) - TDs are more valuable
                const rzScore = gameCount > 0 ? (rzTargets + (rzTDs * 3)) / gameCount : 0;

                // Calculate prior weeks for change
                let priorRzTargets = 0;
                let priorRzTDs = 0;
                let priorGameCount = 0;

                if (p.weeks && p.weeks.length > 0) {
                    let globalMaxWeek = 0;
                    Object.values(aggregatedTEs).forEach(te => {
                        if (te.weeks && te.weeks.length > 0) {
                            const maxWeek = Math.max(...te.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });

                    const priorWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];

                    p.weeks.forEach(w => {
                        if (priorWeeks.includes(w.week)) {
                            const weekRow = teData.find(row =>
                                row.Player === p.name &&
                                row.Team === p.team &&
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow) {
                                priorRzTargets += parseFloat(weekRow.RZ_TGT) || 0;
                                priorRzTDs += parseFloat(weekRow.RZ_TD) || 0;
                                priorGameCount++;
                            }
                        }
                    });
                }

                const priorRzScore = priorGameCount > 0 ? (priorRzTargets + (priorRzTDs * 3)) / priorGameCount : 0;
                const change = priorRzScore > 0 ? rzScore - priorRzScore : 0;

                return { player: p, value: rzScore, change: change, rzTargets: rzTargets, rzTDs: rzTDs, gameCount: gameCount };
            })
            .filter(d => d.value > 0) // Only TEs with RZ involvement
            .sort((a, b) => b.value - a.value);

            return redZoneData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'RZ Score (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'TEs with most RZ targets + TDs (last 3 games) - weekly TD upside',
                    scatterKey: 'redzone'
                }));
        }

        // NEW Category 11: WR Total Touchdown Leaders (Last 3 Games) - WRs Only
        function calculateTotalTouchdownLeadersWR(players) {
            // Filter to only WRs
            const wrPlayers = players.filter(p => p.position === 'WR');

            const tdData = wrPlayers.map(p => {
                // Calculate total TDs per game from last 3 games (receiving + rushing)
                let recTDs = 0;
                let rushTDs = 0;
                let gameCount = 0;

                if (p.weeks && p.weeks.length > 0) {
                    // Get the global max week
                    let globalMaxWeek = 0;
                    Object.values(aggregatedWRs).forEach(wr => {
                        if (wr.weeks && wr.weeks.length > 0) {
                            const maxWeek = Math.max(...wr.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });

                    const last3Weeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];

                    // Sum TDs from last 3 weeks
                    p.weeks.forEach(w => {
                        if (last3Weeks.includes(w.week)) {
                            const weekRow = wrData.find(row =>
                                row.Player === p.name &&
                                row.Team === p.team &&
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow) {
                                recTDs += parseFloat(weekRow.REC_TD) || 0;
                                rushTDs += parseFloat(weekRow.RUSH_TD) || 0;
                                gameCount++;
                            }
                        }
                    });
                }

                const totalTDs = recTDs + rushTDs;
                const tdsPerGame = gameCount > 0 ? totalTDs / gameCount : 0;

                // Calculate prior weeks for change
                let priorRecTDs = 0;
                let priorRushTDs = 0;
                let priorGameCount = 0;

                if (p.weeks && p.weeks.length > 0) {
                    let globalMaxWeek = 0;
                    Object.values(aggregatedWRs).forEach(wr => {
                        if (wr.weeks && wr.weeks.length > 0) {
                            const maxWeek = Math.max(...wr.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });

                    const priorWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];

                    p.weeks.forEach(w => {
                        if (priorWeeks.includes(w.week)) {
                            const weekRow = wrData.find(row =>
                                row.Player === p.name &&
                                row.Team === p.team &&
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow) {
                                priorRecTDs += parseFloat(weekRow.REC_TD) || 0;
                                priorRushTDs += parseFloat(weekRow.RUSH_TD) || 0;
                                priorGameCount++;
                            }
                        }
                    });
                }

                const priorTotalTDs = priorRecTDs + priorRushTDs;
                const priorTdsPerGame = priorGameCount > 0 ? priorTotalTDs / priorGameCount : 0;
                const change = priorTdsPerGame > 0 ? tdsPerGame - priorTdsPerGame : 0;

                return { player: p, value: tdsPerGame, change: change, recTDs: recTDs, rushTDs: rushTDs, totalTDs: totalTDs };
            })
            .filter(d => d.totalTDs > 0) // Only WRs who scored TDs
            .sort((a, b) => b.value - a.value);

            return tdData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(2),
                    metricLabel: 'TDs/Game (L3)',
                    change: d.change.toFixed(2),
                    explanation: 'WRs scoring the most TDs (receiving + rushing) in last 3 games',
                    scatterKey: 'redzone'
                }));
        }

        // Category 8: Boom/Bust DFS (Last 3 Games Volatility)
        function calculateBoomBustDFS(players) {
            const boomBustData = players.map(p => {
                // High ceiling, low floor based on last 3 games
                const last3Weeks = [...p.weeks].sort((a, b) => b.week - a.week).slice(0, 3);
                const variances = last3Weeks.map(w => {
                    const weekAvg = w.fpts;
                    return Math.pow(weekAvg - p.last3.avgPoints, 2);
                });
                const variance = variances.reduce((sum, v) => sum + v, 0) / variances.length;
                const stdDev = Math.sqrt(variance);
                const consistency = 10 / (stdDev + 1);

                const ppg = p.last3.avgPoints; // Use last 3 games average
                const ceiling = ppg; // Simplified ceiling

                return {
                    player: p,
                    value: ceiling,
                    consistency: consistency,
                    stdDev: stdDev
                };
            })
            .filter(d => d.value > 10) // Decent recent ceiling
            .sort((a, b) => a.consistency - b.consistency) // Low consistency (high variance)
            .slice(0, 8);

            return boomBustData
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'PPG (L3)',
                    score: d.stdDev.toFixed(1),
                    explanation: 'High recent variance - tournament play, avoid cash games',
                    scatterKey: 'floor-ceiling'
                }));
        }

        // Key Insights state management
        let keyInsightsState = {
            currentIndex: 0,
            insights: [],
            autoRotateInterval: null
        };

        // Render Key Insights widget with dynamic data
        function renderStatOfTheWeek() {
            const statContainer = document.getElementById('stat-of-week');
            const analyticsStatContainer = document.getElementById('analytics-stat-of-week');
            if (!statContainer && !analyticsStatContainer) return;

            const allWRs = Object.values(aggregatedWRs).filter(p => p.gamesPlayed >= 3);
            const allRBs = Object.values(aggregatedRBs).filter(p => p.gamesPlayed >= 3);

            if (allWRs.length === 0 && allRBs.length === 0) return;

            // Create 4 insights - one for each leaderboard category
            const stats = [];

            // Insight 1: High-Volume Alphas (WR) - Tied to leaderboard
            const highTargetWRs = allWRs
                .map(p => ({
                    player: p,
                    targetsPerGame: p.totalTargets / p.gamesPlayed
                }))
                .filter(d => d.targetsPerGame >= 8)
                .sort((a, b) => b.targetsPerGame - a.targetsPerGame);

            if (highTargetWRs.length > 0) {
                const avgHighTarget = highTargetWRs.reduce((sum, p) => sum + p.player.avgPoints, 0) / highTargetWRs.length;
                const avgAllWRs = allWRs.reduce((sum, p) => sum + p.avgPoints, 0) / allWRs.length;
                const difference = avgHighTarget - avgAllWRs;

                stats.push({
                    value: '8+',
                    label: `High-Volume Alphas (${highTargetWRs.length} WRs)`,
                    text: `WRs commanding <strong>8+ targets/game</strong> are averaging <strong>+${difference.toFixed(1)} PPG</strong> over the field. Target these alpha receivers dominating their team's passing offense.`,
                    category: 'High-Volume Alphas'
                });
            }

            // Insight 2: Volume Monsters (RB) - Tied to leaderboard
            const volumeRBs = allRBs
                .map(p => ({
                    player: p,
                    oppsPerGame: p.totalOpportunities / p.gamesPlayed
                }))
                .filter(d => d.oppsPerGame >= 18)
                .sort((a, b) => b.oppsPerGame - a.oppsPerGame);

            if (volumeRBs.length > 0) {
                const avgVolRBPts = volumeRBs.reduce((sum, p) => sum + p.player.avgPoints, 0) / volumeRBs.length;
                const avgAllRBs = allRBs.reduce((sum, p) => sum + p.avgPoints, 0) / allRBs.length;
                const rbDiff = avgVolRBPts - avgAllRBs;

                stats.push({
                    value: '18+',
                    label: `Volume Monsters (${volumeRBs.length} RBs)`,
                    text: `RBs seeing <strong>18+ opportunities/game</strong> average <strong>+${rbDiff.toFixed(1)} PPG</strong> vs the field. Bell-cow backs deliver consistent RB1 production—prioritize workload.`,
                    category: 'Volume Monsters'
                });
            }

            // Insight 3: Efficiency Elites - Players with 2.76+ PPT
            const allPlayers = [...allWRs, ...allRBs];
            const efficiencyThreshold = 2.76;
            const efficiencyPlayers = allPlayers
                .map(p => {
                    const touches = p.position === 'WR'
                        ? p.totalTargets
                        : (p.totalRushAttempts || 0) + (p.totalTargets || 0);
                    const ppt = touches > 0 ? p.totalPoints / touches : 0;
                    return { player: p, ppt: ppt, touches: touches };
                })
                .filter(d => d.ppt >= efficiencyThreshold && d.touches >= 30)
                .sort((a, b) => b.ppt - a.ppt);

            if (efficiencyPlayers.length > 0) {
                const avgEfficientPPG = efficiencyPlayers.reduce((sum, p) => sum + p.player.avgPoints, 0) / efficiencyPlayers.length;
                const count = efficiencyPlayers.length;

                stats.push({
                    value: efficiencyThreshold.toFixed(2),
                    label: `Efficiency Elites (${count} players)`,
                    text: `Players with <strong>${efficiencyThreshold.toFixed(2)}+ points per touch</strong> average <strong>${avgEfficientPPG.toFixed(1)} PPG</strong>. Elite efficiency often signals quality over quantity—target these players in trades.`,
                    category: 'Efficiency Elites'
                });
            }

            // Insight 4: Red Zone Kings - Players with 2+ RZ opps/game
            const rzThresholdPerGame = 2.0;
            const rzPlayers = allPlayers
                .map(p => ({
                    player: p,
                    rzOppsPerGame: p.rzOpportunities / p.gamesPlayed
                }))
                .filter(d => d.rzOppsPerGame >= rzThresholdPerGame)
                .sort((a, b) => b.rzOppsPerGame - a.rzOppsPerGame);

            if (rzPlayers.length > 0) {
                const avgRZPlayerPPG = rzPlayers.reduce((sum, p) => sum + p.player.avgPoints, 0) / rzPlayers.length;
                const avgAllPlayersPPG = allPlayers.reduce((sum, p) => sum + p.avgPoints, 0) / allPlayers.length;
                const rzAdvantage = avgRZPlayerPPG - avgAllPlayersPPG;
                const count = rzPlayers.length;

                stats.push({
                    value: `${rzThresholdPerGame.toFixed(1)}+`,
                    label: `Red Zone Kings (${count} players)`,
                    text: `Players averaging <strong>${rzThresholdPerGame.toFixed(1)}+ red zone opportunities/game</strong> score <strong>+${rzAdvantage.toFixed(1)} PPG</strong> more than the field. RZ usage = TD equity—target these scoring threats.`,
                    category: 'Red Zone Kings'
                });
            }

            // Store insights and initialize
            keyInsightsState.insights = stats;
            keyInsightsState.currentIndex = 0;

            // Display first insight
            displayInsight(0);

            // Start auto-rotation (15 seconds)
            startInsightRotation();
        }

        // Display a specific insight with fade effect
        function displayInsight(index) {
            const statContainer = document.getElementById('stat-of-week');
            const analyticsStatContainer = document.getElementById('analytics-stat-of-week');
            const indicator = document.getElementById('insight-indicator');
            const analyticsIndicator = document.getElementById('analytics-insight-indicator');

            if (!statContainer && !analyticsStatContainer) return;
            if (keyInsightsState.insights.length === 0) return;

            // Ensure index is within bounds
            index = ((index % keyInsightsState.insights.length) + keyInsightsState.insights.length) % keyInsightsState.insights.length;
            keyInsightsState.currentIndex = index;

            const insight = keyInsightsState.insights[index];

            // Fade out both containers
            if (statContainer) statContainer.style.opacity = '0';
            if (analyticsStatContainer) analyticsStatContainer.style.opacity = '0';

            setTimeout(() => {
                const content = `
                    <div class="stat-highlight-value">${insight.value}</div>
                    <div class="stat-highlight-content">
                        <div class="stat-highlight-label">${insight.label}</div>
                        <div class="stat-highlight-text">
                            ${insight.text}
                        </div>
                    </div>
                `;

                // Update content
                if (statContainer) statContainer.innerHTML = content;
                if (analyticsStatContainer) analyticsStatContainer.innerHTML = content;

                // Update indicators
                if (indicator) {
                    indicator.textContent = `${index + 1}/${keyInsightsState.insights.length}`;
                }
                if (analyticsIndicator) {
                    analyticsIndicator.textContent = `${index + 1}/${keyInsightsState.insights.length}`;
                }

                // Fade in both
                if (statContainer) statContainer.style.opacity = '1';
                if (analyticsStatContainer) analyticsStatContainer.style.opacity = '1';
            }, 300);
        }

        // Navigate to next insight
        function nextInsight() {
            stopInsightRotation();
            displayInsight(keyInsightsState.currentIndex + 1);
            startInsightRotation();
        }

        // Navigate to previous insight
        function previousInsight() {
            stopInsightRotation();
            displayInsight(keyInsightsState.currentIndex - 1);
            startInsightRotation();
        }

        // Start auto-rotation every 15 seconds
        function startInsightRotation() {
            stopInsightRotation(); // Clear any existing interval
            keyInsightsState.autoRotateInterval = setInterval(() => {
                displayInsight(keyInsightsState.currentIndex + 1);
            }, 15000); // 15 seconds
        }

        // Stop auto-rotation
        function stopInsightRotation() {
            if (keyInsightsState.autoRotateInterval) {
                clearInterval(keyInsightsState.autoRotateInterval);
                keyInsightsState.autoRotateInterval = null;
            }
        }

        // DASHBOARD TREND CHARTS

        let dashboardTrendState = {
            wr: {
                isPlaying: false,
                currentTranche: 3,  // Start at final position
                chart: null,
                trails: {},
                fixedAxes: null,
                medianX: null,
                medianY: null,
                filter: 'all'  // 'all', 'positive', 'negative'
            },
            rb: {
                isPlaying: false,
                currentTranche: 3,  // Start at final position
                chart: null,
                trails: {},
                fixedAxes: null,
                medianX: null,
                medianY: null,
                filter: 'all'  // 'all', 'positive', 'negative'
            }
        };

        // Toggle chart expand/collapse
        function toggleChartExpand(position) {
            const wrWidget = document.getElementById('wr-trend-widget');
            const rbWidget = document.getElementById('rb-trend-widget');
            const wrBtn = document.getElementById('wr-expand-btn');
            const rbBtn = document.getElementById('rb-expand-btn');

            if (position === 'wr') {
                if (wrWidget.classList.contains('expanded')) {
                    // Collapse - show both
                    wrWidget.classList.remove('expanded');
                    rbWidget.classList.remove('collapsed');
                    wrBtn.textContent = '⛶';
                    wrBtn.title = 'Expand';
                } else {
                    // Expand WR, hide RB
                    wrWidget.classList.add('expanded');
                    rbWidget.classList.add('collapsed');
                    wrBtn.textContent = '⛶';
                    wrBtn.title = 'Collapse';
                }
            } else {
                if (rbWidget.classList.contains('expanded')) {
                    // Collapse - show both
                    rbWidget.classList.remove('expanded');
                    wrWidget.classList.remove('collapsed');
                    rbBtn.textContent = '⛶';
                    rbBtn.title = 'Expand';
                } else {
                    // Expand RB, hide WR
                    rbWidget.classList.add('expanded');
                    wrWidget.classList.add('collapsed');
                    rbBtn.textContent = '⛶';
                    rbBtn.title = 'Collapse';
                }
            }

            // Re-render charts after expansion animation
            setTimeout(() => {
                if (position === 'wr' || !wrWidget.classList.contains('collapsed')) {
                    renderDashboardWRTrend();
                }
                if (position === 'rb' || !rbWidget.classList.contains('collapsed')) {
                    renderDashboardRBTrend();
                }
            }, 100);
        }

        // Set dashboard filter for movers
        function setDashboardFilter(position, filter) {
            dashboardTrendState[position].filter = filter;

            // Update button states for this position's filter buttons
            ['all', 'positive', 'negative'].forEach(f => {
                const btn = document.getElementById(`${position}-filter-${f}`);
                if (btn) {
                    if (f === filter) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
            });

            // Re-render the chart for this position
            if (position === 'wr') {
                renderDashboardWRTrend();
            } else {
                renderDashboardRBTrend();
            }
        }

        // Calculate 3-week tranche averages and total movement
        function calculateTrancheData(players, position) {
            // Find the global maximum week across all players
            let globalMaxWeek = 0;
            players.forEach(player => {
                if (player.weeks && player.weeks.length > 0) {
                    const maxWeek = Math.max(...player.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });

            // Dynamically create tranches based on current max week
            // Tranche 1: Weeks 1-3
            // Tranche 2: Weeks 4-6
            // Tranche 3: Latest weeks (will be 7-8 for Week 8 data, 7-9 for Week 9 data, etc.)
            const tranche3Start = 7;
            const tranche3Weeks = [];
            for (let w = tranche3Start; w <= globalMaxWeek; w++) {
                tranche3Weeks.push(w);
            }

            const tranches = [
                { name: 'Weeks 1-3', weeks: [1, 2, 3] },
                { name: 'Weeks 4-6', weeks: [4, 5, 6] },
                { name: `Weeks ${tranche3Start}-${globalMaxWeek}`, weeks: tranche3Weeks }
            ];

            return players.map(player => {
                const trancheData = tranches.map((tranche, idx) => {
                    const weeksInTranche = player.weeks.filter(w => tranche.weeks.includes(w.week));

                    if (weeksInTranche.length === 0) return null;

                    let volume, efficiency;

                    if (position === 'WR') {
                        // Volume = avg targets per game in tranche
                        volume = weeksInTranche.reduce((sum, w) => sum + (w.targets || 0), 0) / weeksInTranche.length;
                        // Efficiency = points per target
                        const totalTargets = weeksInTranche.reduce((sum, w) => sum + (w.targets || 0), 0);
                        const totalPoints = weeksInTranche.reduce((sum, w) => sum + w.fpts, 0);
                        efficiency = totalTargets > 0 ? totalPoints / totalTargets : 0;
                    } else {
                        // RB: Volume = avg RB opportunities (rush att + targets) per game
                        volume = weeksInTranche.reduce((sum, w) => sum + ((w.rushAttempts || 0) + (w.targets || 0)), 0) / weeksInTranche.length;
                        // Efficiency = points per RB opportunity
                        const totalOpps = weeksInTranche.reduce((sum, w) => sum + ((w.rushAttempts || 0) + (w.targets || 0)), 0);
                        const totalPoints = weeksInTranche.reduce((sum, w) => sum + w.fpts, 0);
                        efficiency = totalOpps > 0 ? totalPoints / totalOpps : 0;
                    }

                    return {
                        tranche: idx + 1,
                        trancheName: tranche.name,
                        volume: volume,
                        efficiency: efficiency,
                        gamesPlayed: weeksInTranche.length
                    };
                }).filter(t => t !== null);

                // Calculate total distance traveled
                let totalDistance = 0;
                if (trancheData.length >= 2) {
                    for (let i = 1; i < trancheData.length; i++) {
                        const dx = trancheData[i].volume - trancheData[i-1].volume;
                        const dy = trancheData[i].efficiency - trancheData[i-1].efficiency;
                        totalDistance += Math.sqrt(dx*dx + dy*dy);
                    }
                }

                return {
                    player: player,
                    tranches: trancheData,
                    totalDistance: totalDistance
                };
            }).filter(p => p.tranches.length > 0);
        }

        // Calculate fixed axis ranges for locked axes and median values
        function calculateFixedAxesAndMedian(trancheData) {
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let allX = [], allY = [];

            // Also collect current week (tranche 3) data separately
            let currentWeekX = [], currentWeekY = [];

            trancheData.forEach(playerData => {
                playerData.tranches.forEach(t => {
                    minX = Math.min(minX, t.volume);
                    maxX = Math.max(maxX, t.volume);
                    minY = Math.min(minY, t.efficiency);
                    maxY = Math.max(maxY, t.efficiency);
                    allX.push(t.volume);
                    allY.push(t.efficiency);

                    // Collect tranche 3 (current week) data
                    if (t.tranche === 3) {
                        currentWeekX.push(t.volume);
                        currentWeekY.push(t.efficiency);
                    }
                });
            });

            // Calculate CURRENT WEEK medians (tranche 3) - this is what we'll use for the lines
            currentWeekX.sort((a, b) => a - b);
            currentWeekY.sort((a, b) => a - b);
            const currentMedianX = currentWeekX.length > 0 ? currentWeekX[Math.floor(currentWeekX.length / 2)] : 0;
            const currentMedianY = currentWeekY.length > 0 ? currentWeekY[Math.floor(currentWeekY.length / 2)] : 0;

            // Calculate overall medians for axis centering
            allX.sort((a, b) => a - b);
            allY.sort((a, b) => a - b);
            const medianX = allX[Math.floor(allX.length / 2)];
            const medianY = allY[Math.floor(allY.length / 2)];
            // Zoom in: center on overall median, show ±60% of range on each side
            const rangeX = maxX - minX;
            const rangeY = maxY - minY;
            const zoomedMinX = medianX - (rangeX * 0.6);
            const zoomedMaxX = medianX + (rangeX * 0.6);
            const zoomedMinY = medianY - (rangeY * 0.6);
            const zoomedMaxY = medianY + (rangeY * 0.6);

            return {
                axes: {
                    x: { min: zoomedMinX, max: zoomedMaxX },
                    y: { min: zoomedMinY, max: zoomedMaxY }
                },
                median: { x: currentMedianX, y: currentMedianY } // Return CURRENT week median
            };
        }

        // Render the combined dashboard trend chart (routes to WR or RB based on currentPosition)
        function renderDashboardCombinedTrend() {
            // Render both charts independently
            renderDashboardWRTrend();
            renderDashboardRBTrend();
        }

        // Render dashboard WR trend chart
        function renderDashboardWRTrend() {
            const canvas = document.getElementById('wr-trend-chart');
            if (!canvas) {                return;
            }

            // Check if we have data
            if (!aggregatedWRs || Object.keys(aggregatedWRs).length === 0) {                return;
            }

            const wrs = Object.values(aggregatedWRs)
                .filter(p => p.gamesPlayed >= 3)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 36);

            const trancheData = calculateTrancheData(wrs, 'WR');

            // Update tranche label based on current position (not last tranche)
            updateTrancheLabel('wr', dashboardTrendState.wr.currentTranche);

            // Calculate fixed axes and median if not set
            if (!dashboardTrendState.wr.fixedAxes) {
                const result = calculateFixedAxesAndMedian(trancheData);
                dashboardTrendState.wr.fixedAxes = result.axes;
                dashboardTrendState.wr.medianX = result.median.x;
                dashboardTrendState.wr.medianY = result.median.y;
            }

            // Find top movers (by distance traveled)
            const sortedByDistance = [...trancheData].sort((a, b) => b.totalDistance - a.totalDistance);
            const topMovers = new Set(sortedByDistance.slice(0, 5).map(d => d.player.id));

            // Calculate movement direction (efficiency change from tranche 2 to 3 - previous to current)
            const movementData = trancheData.map(pd => {
                const effT2 = pd.tranches.find(t => t.tranche === 2)?.efficiency || 0;
                const effT3 = pd.tranches.find(t => t.tranche === 3)?.efficiency || 0;
                const volT2 = pd.tranches.find(t => t.tranche === 2)?.volume || 0;
                const volT3 = pd.tranches.find(t => t.tranche === 3)?.volume || 0;

                // Calculate combined movement (efficiency change + volume change normalized)
                const effChange = effT3 - effT2;
                const volChange = (volT3 - volT2) / 10; // Normalize volume change
                const movement = effChange + volChange;

                return { playerId: pd.player.id, movement };
            });

            // Apply filter based on selection
            const filter = dashboardTrendState.wr.filter;
            let filteredPlayerIds = new Set(trancheData.map(d => d.player.id));

            if (filter === 'positive') {
                // Top 10 positive movers
                const topPositive = movementData
                    .filter(m => m.movement > 0)
                    .sort((a, b) => b.movement - a.movement)
                    .slice(0, 10)
                    .map(m => m.playerId);
                filteredPlayerIds = new Set(topPositive);
            } else if (filter === 'negative') {
                // Top 10 negative movers
                const topNegative = movementData
                    .filter(m => m.movement < 0)
                    .sort((a, b) => a.movement - b.movement)
                    .slice(0, 10)
                    .map(m => m.playerId);
                filteredPlayerIds = new Set(topNegative);
            }

            // Destroy existing chart
            if (dashboardTrendState.wr.chart) {
                dashboardTrendState.wr.chart.destroy();
            }

            // Get current tranche (interpolated)
            const currentTranche = dashboardTrendState.wr.currentTranche;
            let currentData = interpolateTranchePlayers(trancheData, currentTranche, 'wr');

            // Filter data based on selection
            currentData = currentData.filter(d => filteredPlayerIds.has(d.player.id));

            // Build trail data with gradient fade - optimized for performance
            const trailDatasets = [];
            if (currentTranche > 0) {
                // Track current phase (0-1, 1-2, 2-3) and clear trails when phase changes
                const currentPhase = Math.floor(currentTranche);
                if (!dashboardTrendState.wr.lastPhase) {
                    dashboardTrendState.wr.lastPhase = 0;
                }

                // Clear trails when entering a new phase
                if (currentPhase > dashboardTrendState.wr.lastPhase) {
                    dashboardTrendState.wr.trails = {};
                    dashboardTrendState.wr.lastPhase = currentPhase;
                }

                currentData.forEach(point => {
                    const playerId = point.player.id;

                    // Add to trail history
                    if (!dashboardTrendState.wr.trails[playerId]) {
                        dashboardTrendState.wr.trails[playerId] = [];
                    }
                    dashboardTrendState.wr.trails[playerId].push({ x: point.x, y: point.y });

                    // Keep trail length reasonable (max 30 points for better performance)
                    if (dashboardTrendState.wr.trails[playerId].length > 30) {
                        dashboardTrendState.wr.trails[playerId].shift();
                    }

                    // Create trail as a single line dataset with gradient effect
                    const trail = dashboardTrendState.wr.trails[playerId];
                    if (trail.length > 2) {
                        const teamColor = teamColors[point.player.team] || '#666';
                        const r = parseInt(teamColor.slice(1, 3), 16);
                        const g = parseInt(teamColor.slice(3, 5), 16);
                        const b = parseInt(teamColor.slice(5, 7), 16);

                        // Create a single line dataset with all trail points
                        trailDatasets.push({
                            type: 'line',
                            data: trail,
                            borderColor: `rgba(${r}, ${g}, ${b}, 0.3)`,
                            borderWidth: 2.5, // Thicker trail for better visibility
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            tension: 0.4, // Smooth curve
                            segment: {
                                borderColor: ctx => {
                                    // Gradient along the line - fade from transparent to more visible
                                    const progress = ctx.p0DataIndex / (trail.length - 1);
                                    const opacity = 0.1 + (progress * 0.3);
                                    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                                }
                            }
                        });
                    }
                });
            }

            const ctx = canvas.getContext('2d');
            dashboardTrendState.wr.chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        ...trailDatasets,
                        {
                            data: currentData,
                            backgroundColor: currentData.map(d => {
                                const isTopMover = topMovers.has(d.player.id);
                                const color = teamColors[d.player.team] || '#666';
                                const r = parseInt(color.slice(1, 3), 16);
                                const g = parseInt(color.slice(3, 5), 16);
                                const b = parseInt(color.slice(5, 7), 16);
                                return isTopMover ? `rgba(${r}, ${g}, ${b}, 0.9)` : `rgba(${r}, ${g}, ${b}, 0.6)`;
                            }),
                            borderColor: currentData.map(d => {
                                const isTopMover = topMovers.has(d.player.id);
                                const color = teamColors[d.player.team] || '#666';
                                return isTopMover ? color : color;
                            }),
                            borderWidth: 2,
                            pointRadius: 6,
                            pointHoverRadius: 8
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const lastDataset = dashboardTrendState.wr.chart.data.datasets.length - 1;
                            if (elements[0].datasetIndex === lastDataset) {
                                const index = elements[0].index;
                                const player = currentData[index].player;
                                handleChartClick(event, player, openPlayerModal);
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            ...getMobileChartTooltipConfig(),
                            filter: (tooltipItem) => {
                                // Only show tooltips for main scatter dataset
                                return tooltipItem.datasetIndex === dashboardTrendState.wr.chart.data.datasets.length - 1;
                            },
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    return [
                                        p.name,
                                        `Targets/G: ${context.parsed.x.toFixed(1)}`,
                                        `Pts/Target: ${context.parsed.y.toFixed(2)}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            min: dashboardTrendState.wr.fixedAxes.x.min,
                            max: dashboardTrendState.wr.fixedAxes.x.max,
                            title: { display: true, text: 'Targets per Game', color: '#8e8e93', font: { size: 11 } },
                            grid: {
                                color: '#2c2c2e',
                                drawTicks: true
                            },
                            ticks: {
                                color: '#8e8e93',
                                font: { size: 10 },
                                stepSize: 2
                            }
                        },
                        y: {
                            min: dashboardTrendState.wr.fixedAxes.y.min,
                            max: dashboardTrendState.wr.fixedAxes.y.max,
                            title: { display: true, text: 'Points per Target', color: '#8e8e93', font: { size: 11 } },
                            grid: {
                                color: '#2c2c2e',
                                drawTicks: true
                            },
                            ticks: {
                                color: '#8e8e93',
                                font: { size: 10 },
                                stepSize: 0.5
                            }
                        }
                    }
                },
                plugins: [{
                    id: 'quadrantLines',
                    afterDatasetsDraw: (chart) => {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const xAxis = chart.scales.x;
                        const yAxis = chart.scales.y;

                        // Use stored median values
                        const xMid = dashboardTrendState.wr.medianX;
                        const yMid = dashboardTrendState.wr.medianY;

                        // Draw dotted median lines
                        ctx.strokeStyle = 'rgba(142, 142, 147, 0.5)';
                        ctx.setLineDash([3, 3]);
                        ctx.lineWidth = 1;

                        // Vertical line
                        ctx.beginPath();
                        ctx.moveTo(xAxis.getPixelForValue(xMid), chartArea.top);
                        ctx.lineTo(xAxis.getPixelForValue(xMid), chartArea.bottom);
                        ctx.stroke();

                        // Horizontal line
                        ctx.beginPath();
                        ctx.moveTo(chartArea.left, yAxis.getPixelForValue(yMid));
                        ctx.lineTo(chartArea.right, yAxis.getPixelForValue(yMid));
                        ctx.stroke();

                        ctx.setLineDash([]);

                        // Add quadrant labels - WR Chart
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.textAlign = 'center';

                        const xMidPixel = xAxis.getPixelForValue(xMid);
                        const yMidPixel = yAxis.getPixelForValue(yMid);

                        // Top-right: High Volume + High Efficiency
                        ctx.fillStyle = '#30d158';
                        ctx.fillText('ELITE', (xMidPixel + chartArea.right) / 2, (chartArea.top + yMidPixel) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('High Vol + Efficiency', (xMidPixel + chartArea.right) / 2, (chartArea.top + yMidPixel) / 2 + 8);

                        // Top-left: Low Volume + High Efficiency
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillStyle = '#0a84ff';
                        ctx.fillText('SLEEPER', (chartArea.left + xMidPixel) / 2, (chartArea.top + yMidPixel) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('Efficient, Low Vol', (chartArea.left + xMidPixel) / 2, (chartArea.top + yMidPixel) / 2 + 8);

                        // Bottom-right: High Volume + Low Efficiency
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillStyle = '#FFD60A';
                        ctx.fillText('HOLD', (xMidPixel + chartArea.right) / 2, (yMidPixel + chartArea.bottom) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('Volume, Poor Efficiency', (xMidPixel + chartArea.right) / 2, (yMidPixel + chartArea.bottom) / 2 + 8);

                        // Bottom-left: Low Volume + Low Efficiency
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillStyle = '#ff453a';
                        ctx.fillText('FADE', (chartArea.left + xMidPixel) / 2, (yMidPixel + chartArea.bottom) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('Low Vol + Efficiency', (chartArea.left + xMidPixel) / 2, (yMidPixel + chartArea.bottom) / 2 + 8);
                    }
                }]
            });
        }

        // Render dashboard RB trend chart (similar to WR)
        function renderDashboardRBTrend() {
            const canvas = document.getElementById('rb-trend-chart');
            if (!canvas) {                return;
            }

            // Check if we have data
            if (!aggregatedRBs || Object.keys(aggregatedRBs).length === 0) {                return;
            }

            const rbs = Object.values(aggregatedRBs)
                .filter(p => p.gamesPlayed >= 3)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 36);

            const trancheData = calculateTrancheData(rbs, 'RB');

            // Update tranche label based on current position (not last tranche)
            updateTrancheLabel('rb', dashboardTrendState.rb.currentTranche);

            // Calculate fixed axes and median if not set
            if (!dashboardTrendState.rb.fixedAxes) {
                const result = calculateFixedAxesAndMedian(trancheData);
                dashboardTrendState.rb.fixedAxes = result.axes;
                dashboardTrendState.rb.medianX = result.median.x;
                dashboardTrendState.rb.medianY = result.median.y;
            }

            // Find top movers (by distance traveled)
            const sortedByDistance = [...trancheData].sort((a, b) => b.totalDistance - a.totalDistance);
            const topMovers = new Set(sortedByDistance.slice(0, 5).map(d => d.player.id));

            // Calculate movement direction (efficiency change from tranche 2 to 3 - previous to current)
            const movementData = trancheData.map(pd => {
                const effT2 = pd.tranches.find(t => t.tranche === 2)?.efficiency || 0;
                const effT3 = pd.tranches.find(t => t.tranche === 3)?.efficiency || 0;
                const volT2 = pd.tranches.find(t => t.tranche === 2)?.volume || 0;
                const volT3 = pd.tranches.find(t => t.tranche === 3)?.volume || 0;

                // Calculate combined movement (efficiency change + volume change normalized)
                const effChange = effT3 - effT2;
                const volChange = (volT3 - volT2) / 10; // Normalize volume change
                const movement = effChange + volChange;

                return { playerId: pd.player.id, movement };
            });

            // Apply filter based on selection
            const filter = dashboardTrendState.rb.filter;
            let filteredPlayerIds = new Set(trancheData.map(d => d.player.id));

            if (filter === 'positive') {
                // Top 10 positive movers
                const topPositive = movementData
                    .filter(m => m.movement > 0)
                    .sort((a, b) => b.movement - a.movement)
                    .slice(0, 10)
                    .map(m => m.playerId);
                filteredPlayerIds = new Set(topPositive);
            } else if (filter === 'negative') {
                // Top 10 negative movers
                const topNegative = movementData
                    .filter(m => m.movement < 0)
                    .sort((a, b) => a.movement - b.movement)
                    .slice(0, 10)
                    .map(m => m.playerId);
                filteredPlayerIds = new Set(topNegative);
            }

            // Destroy existing chart
            if (dashboardTrendState.rb.chart) {
                dashboardTrendState.rb.chart.destroy();
            }

            // Get current tranche (interpolated)
            const currentTranche = dashboardTrendState.rb.currentTranche;
            let currentData = interpolateTranchePlayers(trancheData, currentTranche, 'rb');

            // Filter data based on selection
            currentData = currentData.filter(d => filteredPlayerIds.has(d.player.id));

            // Build trail data with gradient fade - optimized for performance
            const trailDatasets = [];
            if (currentTranche > 0) {
                // Track current phase (0-1, 1-2, 2-3) and clear trails when phase changes
                const currentPhase = Math.floor(currentTranche);
                if (!dashboardTrendState.rb.lastPhase) {
                    dashboardTrendState.rb.lastPhase = 0;
                }

                // Clear trails when entering a new phase
                if (currentPhase > dashboardTrendState.rb.lastPhase) {
                    dashboardTrendState.rb.trails = {};
                    dashboardTrendState.rb.lastPhase = currentPhase;
                }

                currentData.forEach(point => {
                    const playerId = point.player.id;

                    // Add to trail history
                    if (!dashboardTrendState.rb.trails[playerId]) {
                        dashboardTrendState.rb.trails[playerId] = [];
                    }
                    dashboardTrendState.rb.trails[playerId].push({ x: point.x, y: point.y });

                    // Keep trail length reasonable (max 30 points for better performance)
                    if (dashboardTrendState.rb.trails[playerId].length > 30) {
                        dashboardTrendState.rb.trails[playerId].shift();
                    }

                    // Create trail as a single line dataset with gradient effect
                    const trail = dashboardTrendState.rb.trails[playerId];
                    if (trail.length > 2) {
                        const teamColor = teamColors[point.player.team] || '#666';
                        const r = parseInt(teamColor.slice(1, 3), 16);
                        const g = parseInt(teamColor.slice(3, 5), 16);
                        const b = parseInt(teamColor.slice(5, 7), 16);

                        // Create a single line dataset with all trail points
                        trailDatasets.push({
                            type: 'line',
                            data: trail,
                            borderColor: `rgba(${r}, ${g}, ${b}, 0.3)`,
                            borderWidth: 2.5, // Thicker trail for better visibility
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            tension: 0.4, // Smooth curve
                            segment: {
                                borderColor: ctx => {
                                    // Gradient along the line - fade from transparent to more visible
                                    const progress = ctx.p0DataIndex / (trail.length - 1);
                                    const opacity = 0.1 + (progress * 0.3);
                                    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                                }
                            }
                        });
                    }
                });
            }

            const ctx = canvas.getContext('2d');
            dashboardTrendState.rb.chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        ...trailDatasets,
                        {
                            data: currentData,
                            backgroundColor: currentData.map(d => {
                                const isTopMover = topMovers.has(d.player.id);
                                const color = teamColors[d.player.team] || '#666';
                                const r = parseInt(color.slice(1, 3), 16);
                                const g = parseInt(color.slice(3, 5), 16);
                                const b = parseInt(color.slice(5, 7), 16);
                                return isTopMover ? `rgba(${r}, ${g}, ${b}, 0.9)` : `rgba(${r}, ${g}, ${b}, 0.6)`;
                            }),
                            borderColor: currentData.map(d => {
                                const color = teamColors[d.player.team] || '#666';
                                return color;
                            }),
                            borderWidth: 2,
                            pointRadius: 6,
                            pointHoverRadius: 8
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const lastDataset = dashboardTrendState.rb.chart.data.datasets.length - 1;
                            if (elements[0].datasetIndex === lastDataset) {
                                const index = elements[0].index;
                                const player = currentData[index].player;
                                handleChartClick(event, player, openPlayerModal);
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            ...getMobileChartTooltipConfig(),
                            filter: (tooltipItem) => {
                                return tooltipItem.datasetIndex === dashboardTrendState.rb.chart.data.datasets.length - 1;
                            },
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    return [
                                        p.name,
                                        `Opps/G: ${context.parsed.x.toFixed(1)}`,
                                        `Pts/Opp: ${context.parsed.y.toFixed(2)}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            min: dashboardTrendState.rb.fixedAxes.x.min,
                            max: dashboardTrendState.rb.fixedAxes.x.max,
                            title: { display: true, text: 'RB Opportunities per Game', color: '#8e8e93', font: { size: 11 } },
                            grid: {
                                color: '#2c2c2e',
                                drawTicks: true
                            },
                            ticks: {
                                color: '#8e8e93',
                                font: { size: 10 },
                                stepSize: 2
                            }
                        },
                        y: {
                            min: dashboardTrendState.rb.fixedAxes.y.min,
                            max: dashboardTrendState.rb.fixedAxes.y.max,
                            title: { display: true, text: 'Points per Opportunity', color: '#8e8e93', font: { size: 11 } },
                            grid: {
                                color: '#2c2c2e',
                                drawTicks: true
                            },
                            ticks: {
                                color: '#8e8e93',
                                font: { size: 10 },
                                stepSize: 0.2
                            }
                        }
                    }
                },
                plugins: [{
                    id: 'quadrantLines',
                    afterDatasetsDraw: (chart) => {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const xAxis = chart.scales.x;
                        const yAxis = chart.scales.y;

                        // Use stored median values
                        const xMid = dashboardTrendState.rb.medianX;
                        const yMid = dashboardTrendState.rb.medianY;

                        // Draw dotted median lines
                        ctx.strokeStyle = 'rgba(142, 142, 147, 0.5)';
                        ctx.setLineDash([3, 3]);
                        ctx.lineWidth = 1;

                        // Vertical line
                        ctx.beginPath();
                        ctx.moveTo(xAxis.getPixelForValue(xMid), chartArea.top);
                        ctx.lineTo(xAxis.getPixelForValue(xMid), chartArea.bottom);
                        ctx.stroke();

                        // Horizontal line
                        ctx.beginPath();
                        ctx.moveTo(chartArea.left, yAxis.getPixelForValue(yMid));
                        ctx.lineTo(chartArea.right, yAxis.getPixelForValue(yMid));
                        ctx.stroke();

                        ctx.setLineDash([]);

                        // Add quadrant labels - RB Chart
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.textAlign = 'center';

                        const xMidPixel = xAxis.getPixelForValue(xMid);
                        const yMidPixel = yAxis.getPixelForValue(yMid);

                        // Top-right: High Volume + High Efficiency
                        ctx.fillStyle = '#30d158';
                        ctx.fillText('ELITE', (xMidPixel + chartArea.right) / 2, (chartArea.top + yMidPixel) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('High Vol + Efficiency', (xMidPixel + chartArea.right) / 2, (chartArea.top + yMidPixel) / 2 + 8);

                        // Top-left: Low Volume + High Efficiency
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillStyle = '#0a84ff';
                        ctx.fillText('SLEEPER', (chartArea.left + xMidPixel) / 2, (chartArea.top + yMidPixel) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('Efficient, Low Vol', (chartArea.left + xMidPixel) / 2, (chartArea.top + yMidPixel) / 2 + 8);

                        // Bottom-right: High Volume + Low Efficiency
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillStyle = '#FFD60A';
                        ctx.fillText('HOLD', (xMidPixel + chartArea.right) / 2, (yMidPixel + chartArea.bottom) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('Volume, Poor Efficiency', (xMidPixel + chartArea.right) / 2, (yMidPixel + chartArea.bottom) / 2 + 8);

                        // Bottom-left: Low Volume + Low Efficiency
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillStyle = '#ff453a';
                        ctx.fillText('FADE', (chartArea.left + xMidPixel) / 2, (yMidPixel + chartArea.bottom) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('Low Vol + Efficiency', (chartArea.left + xMidPixel) / 2, (yMidPixel + chartArea.bottom) / 2 + 8);
                    }
                }]
            });
        }

        // Easing function for smooth transitions (ease-in-out cubic)
        function easeInOutCubic(t) {
            return t < 0.5
                ? 4 * t * t * t
                : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // Interpolate player positions between tranches
        function interpolateTranchePlayers(trancheData, currentTranche, position) {
            // Get position-specific median for center point
            const medianX = dashboardTrendState[position].medianX;
            const medianY = dashboardTrendState[position].medianY;

            return trancheData.map(playerData => {
                // Handle tranche 0 - all at center
                if (currentTranche === 0) {
                    return {
                        x: medianX,
                        y: medianY,
                        player: playerData.player
                    };
                }

                // For tranches 0-1, interpolate from center to tranche 1
                if (currentTranche < 1) {
                    const data1 = playerData.tranches.find(t => t.tranche === 1);
                    if (!data1) return null;

                    const t = easeInOutCubic(currentTranche); // Apply easing
                    return {
                        x: medianX + (data1.volume - medianX) * t,
                        y: medianY + (data1.efficiency - medianY) * t,
                        player: playerData.player
                    };
                }

                // For tranches >= 1, use existing logic with easing
                const tranche1 = Math.floor(currentTranche);
                const tranche2 = Math.ceil(currentTranche);
                const rawT = currentTranche - tranche1; // interpolation factor (0 to 1)
                const t = easeInOutCubic(rawT); // Apply easing for smooth transitions

                const data1 = playerData.tranches.find(t => t.tranche === tranche1);
                const data2 = playerData.tranches.find(t => t.tranche === tranche2);

                if (!data1 && !data2) return null;
                if (!data2 || tranche1 === tranche2) {
                    return data1 ? {
                        x: data1.volume,
                        y: data1.efficiency,
                        player: playerData.player
                    } : null;
                }
                if (!data1) {
                    return {
                        x: data2.volume,
                        y: data2.efficiency,
                        player: playerData.player
                    };
                }

                // Eased interpolation for rounded transitions
                return {
                    x: data1.volume + (data2.volume - data1.volume) * t,
                    y: data1.efficiency + (data2.efficiency - data1.efficiency) * t,
                    player: playerData.player
                };
            }).filter(d => d !== null);
        }

        // Toggle dashboard trend animation - single run only
        function toggleDashboardTrend(positionParam) {
            // If called with 'combined', use the current position
            const position = positionParam === 'combined' ? dashboardTrendState.currentPosition : positionParam;
            const state = dashboardTrendState[position];

            if (state.isPlaying) {
                // Stop if already playing
                state.isPlaying = false;
                const btn = document.getElementById(`${position}-play-btn`);
                btn.textContent = '▶';
                btn.classList.remove('playing');
                return;
            }

            // Reset to start
            state.currentTranche = 0;
            state.trails = {}; // Clear trails
            state.lastPhase = 0; // Reset phase tracker
            state.isPlaying = true;

            const btn = document.getElementById(`${position}-play-btn`);
            btn.textContent = '⏸';
            btn.classList.add('playing');

            const scrubber = document.getElementById(`${position}-tranche-scrubber`);
            scrubber.value = 0;

            updateTrancheLabel(position, 0);

            animateDashboardTrend(position);
        }

        // Animate dashboard trend - smoother animation
        function animateDashboardTrend(position) {
            const state = dashboardTrendState[position];
            if (!state.isPlaying) return;

            state.currentTranche += 0.0325; // Slowed down by 35% for better visual clarity

            if (state.currentTranche >= 3) {
                state.currentTranche = 3;
                state.isPlaying = false;

                const btn = document.getElementById(`${position}-play-btn`);
                btn.textContent = '▶';
                btn.classList.remove('playing');
            }

            // Update scrubber
            const scrubber = document.getElementById(`${position}-tranche-scrubber`);
            scrubber.value = state.currentTranche;

            // Update label
            updateTrancheLabel(position, state.currentTranche);

            // Re-render appropriate chart
            if (position === 'wr') {
                renderDashboardWRTrend();
            } else {
                renderDashboardRBTrend();
            }

            // Continue animation if still playing
            if (state.isPlaying) {
                requestAnimationFrame(() => animateDashboardTrend(position));
            }
        }

        // Update tranche label
        function updateTrancheLabel(position, tranche) {
            const label = document.getElementById(`${position}-tranche-label`);
            if (!label) return;

            // Find max week dynamically from the data
            let globalMaxWeek = 0;
            const players = position === 'wr' ? aggregatedWRs : aggregatedRBs;
            Object.values(players).forEach(player => {
                if (player.weeks && player.weeks.length > 0) {
                    const maxWeek = Math.max(...player.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });

            // Handle tranche 0 (center position)
            if (tranche === 0) {
                label.textContent = 'Start';
                return;
            }

            // Interpolate between positions for smooth label updates
            if (tranche < 1) {
                label.textContent = 'Start → Weeks 1-3';
                return;
            }

            // Create dynamic tranche names based on actual max week
            const trancheNames = [
                'Start',           // 0
                'Weeks 1-3',       // 1
                'Weeks 4-6',       // 2
                `Weeks 7-${globalMaxWeek}` // 3
            ];

            // For values between tranches, show transition
            if (tranche % 1 !== 0) {
                const idx1 = Math.floor(tranche);
                const idx2 = Math.ceil(tranche);
                label.textContent = `${trancheNames[idx1]} → ${trancheNames[idx2]}`;
            } else {
                // Exact tranche
                const idx = Math.round(tranche);
                label.textContent = trancheNames[idx] || trancheNames[3];
            }
        }

        // Setup scrubber listeners
        function setupDashboardTrendScrubbers() {
            // Setup WR scrubber
            const wrScrubber = document.getElementById('wr-tranche-scrubber');
            if (wrScrubber) {
                wrScrubber.addEventListener('input', (e) => {
                    const tranche = parseFloat(e.target.value);
                    dashboardTrendState.wr.currentTranche = tranche;
                    dashboardTrendState.wr.isPlaying = false;
                    dashboardTrendState.wr.lastPhase = Math.floor(tranche); // Update phase tracker

                    const btn = document.getElementById('wr-play-btn');
                    btn.textContent = '▶';
                    btn.classList.remove('playing');

                    updateTrancheLabel('wr', tranche);
                    renderDashboardWRTrend();
                });
            }

            // Setup RB scrubber
            const rbScrubber = document.getElementById('rb-tranche-scrubber');
            if (rbScrubber) {
                rbScrubber.addEventListener('input', (e) => {
                    const tranche = parseFloat(e.target.value);
                    dashboardTrendState.rb.currentTranche = tranche;
                    dashboardTrendState.rb.isPlaying = false;
                    dashboardTrendState.rb.lastPhase = Math.floor(tranche); // Update phase tracker

                    const btn = document.getElementById('rb-play-btn');
                    btn.textContent = '▶';
                    btn.classList.remove('playing');

                    updateTrancheLabel('rb', tranche);
                    renderDashboardRBTrend();
                });
            }
        }

        // Render Dashboard Categories
        function renderDashboardCategories() {
            const container = document.getElementById('dashboard-categories');
            if (!container) {                return;
            }

            const categories = calculateDashboardCategories();
            if (!categories) {                container.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 40px;">Loading categories...</p>';
                return;
            }

            // Log each category's data
            // Also update stat of the week
            renderStatOfTheWeek();

            // Render dashboard trend chart (both WR and RB)
            renderDashboardCombinedTrend();

            const categoryConfigs = [
                { key: 'volumeMonsters', title: 'Volume Monsters (RB)', color: '#ff453a', tooltip: 'RBs with the highest opportunities (carries + targets) per game in last 3 weeks. High volume = reliable fantasy production.' },
                { key: 'efficiencyElites', title: 'Efficiency Elites', color: '#FFD60A', tooltip: 'Players scoring the most fantasy points per touch in last 3 weeks. High efficiency = doing more with less. League-winner upside if volume increases.' },
                { key: 'redZoneKingsWR', title: 'Red Zone Kings (WR)', color: '#bf5af2', tooltip: 'WRs with the most red zone targets per game in last 3 weeks. More RZ targets = higher TD upside.' },
                { key: 'redZoneBacks', title: 'Red Zone Backs (RB)', color: '#ff453a', tooltip: 'RBs with the most red zone opportunities (carries + targets) per game in last 3 weeks. Dominant in scoring position.' },
                { key: 'rbEfficiency', title: 'RB Efficiency (Yds/Att)', color: '#30d158', tooltip: 'RBs with highest yards per carry in last 3 weeks. Explosive runners who maximize every touch.' },
                { key: 'consistentFloor', title: 'High-Volume Alphas (WR)', color: '#64d2ff', tooltip: 'WRs with the most targets per game in last 3 weeks. Commanding volume = alpha status in their offense.' },
                { key: 'airYardsLeaders', title: 'Air Yards Leaders (WR)', color: '#0a84ff', tooltip: 'WRs with highest air yards per game in last 3 weeks. Deep threats with explosive upside potential.' },
                { key: 'passCatchingBacks', title: 'Pass-Catching Backs (RB)', color: '#5e5ce6', tooltip: 'RBs with highest target share in last 3 weeks. PPR gold with receiving work in the passing game.' },
                { key: 'targetLeadersTE', title: 'Target Leaders (TE)', color: '#30d158', tooltip: 'TEs with the most targets per game in last 3 weeks. High volume = consistent TE production.' },
                { key: 'redZoneDominanceTE', title: 'Red Zone Dominance (TE)', color: '#bf5af2', tooltip: 'TEs with most red zone production in last 3 weeks. RZ Score = (RZ Targets + RZ TDs × 3) per game. TDs weighted 3x because they\'re more valuable than targets.' },
                { key: 'totalTouchdownLeadersWR', title: 'Total TD Leaders (WR)', color: '#ff453a', tooltip: 'WRs scoring the most total touchdowns (receiving + rushing) in last 3 weeks. Elite scorers.' }
            ];

            let html = '';
            html += '<div class="categories-carousel-container">';
            html += '<div class="categories-carousel-scroll" id="categories-carousel">';

            let hasAnyData = false;
            let categoriesHTML = ''; // Build categories first

            categoryConfigs.forEach(config => {
                const categoryData = categories[config.key];
                if (!categoryData || categoryData.length === 0) {                    return;
                }

                hasAnyData = true;
                categoriesHTML += `
                    <div class="category-carousel-item">
                        <div class="category-header">
                            <div class="category-title" style="position: relative;">
                                ${config.title}
                                <div class="leaderboard-info-icon" onclick="toggleLeaderboardTooltip(event)">
                                    i
                                    <div class="leaderboard-tooltip">
                                        ${config.tooltip}
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="category-cards-container" id="category-${config.key}">
                `;

                // Show all 8 players
                categoryData.forEach((item, idx) => {
                    categoriesHTML += renderCategoryCard(item, config.color, config.key, config.title);
                });

                categoriesHTML += `
                        </div>
                    </div>
                `;
            });

            // Duplicate categories for infinite scroll (like ticker)
            html += categoriesHTML + categoriesHTML;

            html += '</div>';
            html += '</div>';

            // Add pagination dots for mobile
            const categoryCount = categoryConfigs.filter(config => categories[config.key] && categories[config.key].length > 0).length;
            html += '<div class="carousel-dots" id="carousel-dots">';
            for (let i = 0; i < categoryCount; i++) {
                html += `<div class="carousel-dot ${i === 0 ? 'active' : ''}" data-index="${i}"></div>`;
            }
            html += '</div>';

            if (!hasAnyData) {                container.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 40px;">No category data available. Please upload player data.</p>';
            } else {
                container.innerHTML = html;
                // CSS animation handles the infinite scroll automatically

                // Add scroll listener for mobile dots
                initializeCarouselDots();
            }
        }

        // Initialize carousel dot tracking
        function initializeCarouselDots() {
            const carouselContainer = document.querySelector('.categories-carousel-container');
            const carousel = document.getElementById('categories-carousel');
            const dots = document.querySelectorAll('.carousel-dot');

            if (!carouselContainer || !carousel || dots.length === 0) return;

            // Add click handlers to dots (works on any screen size where carousel is visible)
            dots.forEach((dot, dotIndex) => {
                dot.addEventListener('click', () => {
                    const itemWidth = carousel.querySelector('.category-carousel-item')?.offsetWidth || 0;
                    const gap = 20;
                    const scrollPosition = dotIndex * (itemWidth + gap);

                    carouselContainer.scrollTo({
                        left: scrollPosition,
                        behavior: 'smooth'
                    });
                });
            });

            let scrollTimeout;
            carouselContainer.addEventListener('scroll', () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    const scrollLeft = carouselContainer.scrollLeft;
                    const itemWidth = carousel.querySelector('.category-carousel-item')?.offsetWidth || 0;
                    const gap = 20;
                    const currentIndex = Math.round(scrollLeft / (itemWidth + gap));

                    // Update active dot
                    dots.forEach((dot, index) => {
                        if (index === currentIndex) {
                            dot.classList.add('active');
                        } else {
                            dot.classList.remove('active');
                        }
                    });
                }, 50);
            });
        }

        // Render all leaderboards in a static 2x2 grid for the all-leaderboards page
        function renderAllLeaderboards() {
            const container = document.getElementById('all-leaderboards-grid');
            if (!container) {                return;
            }

            const categories = calculateDashboardCategories();

            if (!categories) {                container.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 40px;">Loading categories...</p>';
                return;
            }

            const categoryConfigs = [
                { key: 'volumeMonsters', title: 'Volume Monsters (RB)', color: '#ff453a', tooltip: 'RBs with the highest opportunities (carries + targets) per game in last 3 weeks.' },
                { key: 'consistentFloor', title: 'High-Volume Alphas (WR)', color: '#64d2ff', tooltip: 'WRs with the most targets per game in last 3 weeks.' },
                { key: 'redZoneKingsWR', title: 'Red Zone Kings (WR)', color: '#bf5af2', tooltip: 'WRs with the most red zone targets per game in last 3 weeks.' },
                { key: 'redZoneBacks', title: 'Red Zone Backs (RB)', color: '#ff453a', tooltip: 'RBs with the most red zone opportunities per game in last 3 weeks.' },
                { key: 'efficiencyElites', title: 'Efficiency Elites', color: '#FFD60A', tooltip: 'Players scoring the most fantasy points per touch in last 3 weeks.' },
                { key: 'rbEfficiency', title: 'RB Efficiency (Yds/Att)', color: '#30d158', tooltip: 'RBs with highest yards per carry in last 3 weeks.' },
                { key: 'airYardsLeaders', title: 'Air Yards Leaders (WR)', color: '#0a84ff', tooltip: 'WRs with highest air yards per game in last 3 weeks.' },
                { key: 'passCatchingBacks', title: 'Pass-Catching Backs (RB)', color: '#5e5ce6', tooltip: 'RBs with highest target share in last 3 weeks.' },
                { key: 'targetLeadersTE', title: 'Target Leaders (TE)', color: '#30d158', tooltip: 'TEs with the most targets per game in last 3 weeks.' },
                { key: 'redZoneDominanceTE', title: 'Red Zone Dominance (TE)', color: '#bf5af2', tooltip: 'TEs with most red zone production in last 3 weeks. RZ Score = (RZ Targets + RZ TDs × 3) per game. TDs weighted 3x.' },
                { key: 'totalTouchdownLeadersWR', title: 'Total TD Leaders (WR)', color: '#ff453a', tooltip: 'WRs with the most total touchdowns (receiving + rushing) in last 3 weeks.' }
            ];

            let html = '';

            categoryConfigs.forEach(config => {
                const categoryData = categories[config.key];
                if (!categoryData || categoryData.length === 0) {
                    return;
                }

                html += `
                    <div style="background: var(--bg-secondary); border-radius: 12px; padding: 20px; border: 1px solid var(--border-color);">
                        <div class="category-header" style="margin-bottom: 16px;">
                            <div class="category-title" style="position: relative; font-size: 16px; font-weight: 700; color: var(--text-primary);">
                                ${config.title}
                                <div class="leaderboard-info-icon" onclick="toggleLeaderboardTooltip(event)">
                                    i
                                    <div class="leaderboard-tooltip">
                                        ${config.tooltip}
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr; gap: 8px;">
                `;

                // Show all 8 players with compact cards
                const maxMetricValue = Math.max(...categoryData.map(item => parseFloat(item.metric) || 0));

                categoryData.forEach((item, idx) => {
                    html += renderCompactCategoryCard(item, config.color, config.key, config.title, maxMetricValue);
                });

                html += `
                        </div>
                    </div>
                `;
            });

            if (html === '') {
                container.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 40px; grid-column: 1 / -1;">No leaderboard data available. Please upload player data.</p>';
            } else {
                // Wrap in grid container - responsive like PPG
                container.innerHTML = `<div style="display: grid; grid-template-columns: repeat(auto-fit, minwidth(350px, 1fr)); gap: 24px; width: 100%;">${html}</div>`;
            }

            // Render PPG leaderboard
            renderPPGLeaderboard('WR');
        }

        // Render PPG Leaderboard
        function renderPPGLeaderboard(position) {
            const container = document.getElementById('ppg-leaderboard-content');
            if (!container) return;

            let players = [];
            if (position === 'WR') {
                players = Object.values(aggregatedWRs);
            } else if (position === 'RB') {
                players = Object.values(aggregatedRBs);
            } else if (position === 'TE') {
                players = Object.values(aggregatedTEs);
            }

            // Filter and sort by avg points
            const topPlayers = players
                .filter(p => p.gamesPlayed >= 3)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 20);

            let html = '';
            topPlayers.forEach((player, idx) => {
                const teamColor = teamColors[player.team] || '#666';
                const escapedId = player.id.replace(/'/g, "\\'");
                const rank = idx + 1;

                html += `
                    <div onclick="openPlayerModal('${escapedId}')" style="
                        background: var(--bg-tertiary);
                        border: 1px solid var(--border-color);
                        border-radius: 8px;
                        padding: 12px;
                        display: flex;
                        align-items: center;
                        gap: 12px;
                        cursor: pointer;
                        transition: all 0.2s ease;
                    " onmouseover="this.style.borderColor='var(--positive)'" onmouseout="this.style.borderColor='var(--border-color)'">
                        <div style="
                            font-size: 18px;
                            font-weight: 700;
                            color: var(--text-tertiary);
                            min-width: 32px;
                            text-align: center;
                        ">#${rank}</div>
                        
                        <div style="
                            background: ${teamColor};
                            color: white;
                            font-size: 10px;
                            font-weight: 700;
                            padding: 4px 6px;
                            border-radius: 4px;
                            min-width: 36px;
                            text-align: center;
                        ">${player.team}</div>

                        <div style="flex: 1;">
                            <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">${player.name}</div>
                            <div style="font-size: 11px; color: var(--text-tertiary);">${player.position} · ${player.gamesPlayed} GP</div>
                        </div>

                        <div style="text-align: right;">
                            <div style="font-size: 18px; font-weight: 700; color: var(--positive);">${player.avgPoints.toFixed(1)}</div>
                            <div style="font-size: 10px; color: var(--text-tertiary);">PPG</div>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Filter PPG Leaderboard by position
        function filterPPGLeaderboard(position) {
            // Update button states
            document.querySelectorAll('.ppg-position-btn').forEach(btn => {
                if (btn.dataset.position === position) {
                    btn.classList.add('active');
                    btn.style.background = 'var(--positive)';
                    btn.style.borderColor = 'var(--positive)';
                    btn.style.color = 'white';
                } else {
                    btn.classList.remove('active');
                    btn.style.background = 'var(--bg-tertiary)';
                    btn.style.borderColor = 'var(--border-color)';
                    btn.style.color = 'var(--text-secondary)';
                }
            });

            renderPPGLeaderboard(position);
        }

        // Toggle PRS footnote
        function togglePRSFootnote() {
            const content = document.getElementById('prs-footnote-content');
            const icon = document.getElementById('prs-footnote-icon');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.textContent = '✕';
            } else {
                content.style.display = 'none';
                icon.textContent = 'ⓘ';
            }
        }

        // Calculate PRS (Player Rating System) - matching player card calculation
        function calculatePRS(player, allPlayers) {
            // Calculate average usage share across all weeks
            const usageShare = player.weeks.reduce((sum, w) => sum + (w.usageShare || 0), 0) / player.weeks.length;
            
            // Calculate RZ share
            const rzShare = player.weeks.reduce((sum, w) => sum + (w.rzShare || 0), 0) / player.weeks.length;
            
            // Get max games in dataset
            const maxGames = Math.max(...allPlayers.map(p => p.gamesPlayed));
            const gamesPlayedPct = player.gamesPlayed / maxGames;

            // Normalize USAGE using production-weighted opportunity score
            const usageValues = allPlayers.map(p => {
                const avgUsage = p.weeks.reduce((sum, w) => sum + (w.usageShare || 0), 0) / p.weeks.length;
                return avgUsage * p.avgPoints;
            });
            const minUsage = Math.min(...usageValues);
            const maxUsage = Math.max(...usageValues);
            const playerUsageScore = usageShare * player.avgPoints;
            const usageNorm = maxUsage > minUsage ? (playerUsageScore - minUsage) / (maxUsage - minUsage) : 0;

            // Normalize RZ ROLE
            const rzValues = allPlayers.map(p => {
                const avgRZ = p.weeks.reduce((sum, w) => sum + (w.rzShare || 0), 0) / p.weeks.length;
                return avgRZ * p.avgPoints;
            });
            const minRZ = Math.min(...rzValues);
            const maxRZ = Math.max(...rzValues);
            const playerRZScore = rzShare * player.avgPoints;
            const rzNorm = maxRZ > minRZ ? (playerRZScore - minRZ) / (maxRZ - minRZ) : 0;

            // Calculate FLOOR RELIABILITY
            const floorReliabilityValues = allPlayers.map(p => {
                let hitCount = 0;
                let totalDiff = 0;
                let validWeeks = 0;
                
                p.weeks.forEach(w => {
                    if (w.expectedFpts > 0 && w.fpts !== undefined) {
                        const diff = w.fpts - w.expectedFpts;
                        const diffPct = diff / w.expectedFpts;
                        const threshold = p.avgPoints >= 14 ? -0.15 : -0.10;
                        
                        if (diffPct >= threshold) hitCount++;
                        totalDiff += diffPct;
                        validWeeks++;
                    }
                });
                
                if (validWeeks === 0) return 0;
                
                const hitRate = hitCount / validWeeks;
                const avgDiffPct = totalDiff / validWeeks;
                const expectedBonus = p.avgPoints >= 14 ? 0.15 : 0;
                const diffComponent = Math.min(0.50, Math.max(0, avgDiffPct + 0.25));
                return (0.60 * hitRate) + (0.40 * diffComponent) + expectedBonus;
            });
            
            const minFloor = Math.min(...floorReliabilityValues);
            const maxFloor = Math.max(...floorReliabilityValues);
            
            // Calculate this player's floor reliability
            let consistencyNorm = 0;
            let playerHitCount = 0;
            let playerTotalDiff = 0;
            let playerValidWeeks = 0;
            
            player.weeks.forEach(w => {
                if (w.expectedFpts > 0 && w.fpts !== undefined) {
                    const diff = w.fpts - w.expectedFpts;
                    const diffPct = diff / w.expectedFpts;
                    const threshold = player.avgPoints >= 14 ? -0.15 : -0.10;
                    
                    if (diffPct >= threshold) playerHitCount++;
                    playerTotalDiff += diffPct;
                    playerValidWeeks++;
                }
            });
            
            if (playerValidWeeks > 0) {
                const playerHitRate = playerHitCount / playerValidWeeks;
                const playerAvgDiffPct = playerTotalDiff / playerValidWeeks;
                const playerExpectedBonus = player.avgPoints >= 14 ? 0.15 : 0;
                const playerDiffComponent = Math.min(0.50, Math.max(0, playerAvgDiffPct + 0.25));
                const playerFloorScore = (0.60 * playerHitRate) + (0.40 * playerDiffComponent) + playerExpectedBonus;
                
                consistencyNorm = maxFloor > minFloor ? (playerFloorScore - minFloor) / (maxFloor - minFloor) : 0;
            }

            // Calculate PRS with position-specific weights
            let prsRaw;
            if (player.position === 'WR') {
                prsRaw = (0.40 * usageNorm) + (0.20 * rzNorm) + (0.30 * consistencyNorm) + (0.10 * gamesPlayedPct);
            } else {
                prsRaw = (0.40 * usageNorm) + (0.30 * rzNorm) + (0.20 * consistencyNorm) + (0.10 * gamesPlayedPct);
            }
            
            return Math.round(prsRaw * 100);
        }

        // Render PRS Leaderboard
        function renderPRSLeaderboard(position) {
            const container = document.getElementById('prs-leaderboard-content');
            if (!container) return;

            let players = [];
            if (position === 'WR') {
                players = Object.values(aggregatedWRs);
            } else if (position === 'RB') {
                players = Object.values(aggregatedRBs);
            } else if (position === 'TE') {
                players = Object.values(aggregatedTEs);
            }

            // Filter eligible players
            const eligiblePlayers = players.filter(p => p.gamesPlayed >= 3);

            // Calculate PRS for each player
            const playersWithPRS = eligiblePlayers.map(player => ({
                ...player,
                prs: calculatePRS(player, eligiblePlayers)
            }));

            // Sort by PRS
            const topPlayers = playersWithPRS
                .sort((a, b) => b.prs - a.prs)
                .slice(0, 20);

            let html = '';
            topPlayers.forEach((player, idx) => {
                const teamColor = teamColors[player.team] || '#666';
                const escapedId = player.id.replace(/'/g, "\\'");
                const rank = idx + 1;
                const prs = player.prs;

                // Color based on PRS tier
                let prsColor = '#30d158'; // Green
                if (prs < 60) prsColor = '#ff453a'; // Red
                else if (prs < 75) prsColor = '#FFD60A'; // Yellow

                html += `
                    <div onclick="openPlayerModal('${escapedId}')" style="
                        background: var(--bg-tertiary);
                        border: 1px solid var(--border-color);
                        border-radius: 8px;
                        padding: 12px;
                        display: flex;
                        align-items: center;
                        gap: 12px;
                        cursor: pointer;
                        transition: all 0.2s ease;
                    " onmouseover="this.style.borderColor='var(--positive)'" onmouseout="this.style.borderColor='var(--border-color)'">
                        <div style="
                            font-size: 16px;
                            font-weight: 700;
                            color: var(--text-tertiary);
                            min-width: 28px;
                            text-align: center;
                        ">#${rank}</div>
                        
                        <div style="
                            background: ${teamColor};
                            color: white;
                            font-size: 10px;
                            font-weight: 700;
                            padding: 4px 6px;
                            border-radius: 4px;
                            min-width: 36px;
                            text-align: center;
                        ">${player.team}</div>

                        <div style="flex: 1; min-width: 0;">
                            <div style="font-size: 13px; font-weight: 600; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${player.name}</div>
                            <div style="font-size: 10px; color: var(--text-tertiary);">${player.avgPoints.toFixed(1)} PPG · ${player.gamesPlayed} GP</div>
                        </div>

                        <div style="text-align: right;">
                            <div style="font-size: 18px; font-weight: 700; color: ${prsColor};">${prs.toFixed(1)}</div>
                            <div style="font-size: 9px; color: var(--text-tertiary);">PRS</div>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Filter PRS Leaderboard by position
        function filterPRSLeaderboard(position) {
            // Update button states
            document.querySelectorAll('.prs-position-btn').forEach(btn => {
                if (btn.dataset.position === position) {
                    btn.classList.add('active');
                    btn.style.background = 'var(--positive)';
                    btn.style.borderColor = 'var(--positive)';
                    btn.style.color = 'white';
                } else {
                    btn.classList.remove('active');
                    btn.style.background = 'var(--bg-tertiary)';
                    btn.style.borderColor = 'var(--border-color)';
                    btn.style.color = 'var(--text-secondary)';
                }
            });

            renderPRSLeaderboard(position);
        }

        // Comprehensive player schedule renderer with defensive rankings
        async function loadPlayerSchedule(team, position) {
            const container = document.getElementById('modal-schedule-chart-content');
            if (!container) return;
            
            // Build schedule HTML for weeks 11-18
            let scheduleHTML = `
                <div class="schedule-list">
            `;
            
            for (let week = 11; week <= 18; week++) {
                const scheduleData = NFL_SCHEDULE_2025[team]?.[week];
                
                if (!scheduleData) continue;
                
                const opponent = scheduleData.opponent;
                const isHome = scheduleData.home;
                
                // Handle BYE weeks
                if (opponent === 'BYE') {
                    scheduleHTML += `
                        <div class="schedule-row bye-week">
                            <div class="week-info">
                                <div class="week-label">Week</div>
                                <div class="week-number">${week}</div>
                            </div>
                            <div class="matchup-info">
                                <div class="opponent-line">
                                    <span class="opponent-team">BYE WEEK</span>
                                </div>
                            </div>
                            <div class="defense-rank">
                                <div class="rank-label">—</div>
                                <div class="rank-value" style="background: transparent; border: none; color: #8e8e93;">—</div>
                            </div>
                            <div class="defense-rank">
                                <div class="rank-label">—</div>
                                <div class="rank-value" style="background: transparent; border: none; color: #8e8e93;">—</div>
                            </div>
                        </div>
                    `;
                    continue;
                }
                
                // Get defensive rankings
                const vsPositionRank = getVsPositionRank(opponent, position);
                const passOrRushRank = (position === 'RB') ? getRushDefenseRank(opponent) : getPassDefenseRank(opponent);
                
                const vsPositionClass = getDefenseRankClass(vsPositionRank, 'position');
                const passOrRushClass = getDefenseRankClass(passOrRushRank, position === 'RB' ? 'rush' : 'pass');
                
                const vsPositionTooltip = getRankTooltip(vsPositionRank, 'position', position);
                const passOrRushTooltip = getRankTooltip(passOrRushRank, position === 'RB' ? 'rush' : 'pass');
                
                // Build the row
                scheduleHTML += `
                    <div class="schedule-row">
                        <div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
                            <div class="week-info">
                                <div class="week-label">Week</div>
                                <div class="week-number">${week}</div>
                            </div>
                            
                            <div class="matchup-info">
                                <div class="opponent-line">
                                    <span class="vs-label">${isHome ? 'vs' : '@'}</span>
                                    <span class="opponent-team">${opponent}</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Mobile defense ranks inline -->
                        <div class="mobile-defense-ranks">
                            <span class="mobile-rank ${vsPositionClass}">vs ${position}: ${vsPositionRank}${getOrdinal(vsPositionRank)}</span>
                            <span class="mobile-rank-separator">•</span>
                            <span class="mobile-rank ${passOrRushClass}">${position === 'RB' ? 'Rush' : 'Pass'} D: ${passOrRushRank}${getOrdinal(passOrRushRank)}</span>
                        </div>
                        
                        <div class="defense-rank desktop-only">
                            <div class="rank-label">
                                vs ${position}
                                <span class="info-icon">i</span>
                            </div>
                            <div class="rank-value ${vsPositionClass}">${vsPositionRank}${getOrdinal(vsPositionRank)}</div>
                            <div class="rank-tooltip">
                                <div class="tooltip-title">Defense vs ${position}</div>
                                <div class="tooltip-text">${vsPositionTooltip}</div>
                            </div>
                        </div>
                        
                        <div class="defense-rank desktop-only">
                            <div class="rank-label">
                                ${position === 'RB' ? 'Rush D' : 'Pass D'}
                                <span class="info-icon">i</span>
                            </div>
                            <div class="rank-value ${passOrRushClass}">${passOrRushRank}${getOrdinal(passOrRushRank)}</div>
                            <div class="rank-tooltip">
                                <div class="tooltip-title">${position === 'RB' ? 'Rush Defense Rank' : 'Pass Defense Rank'}</div>
                                <div class="tooltip-text">${passOrRushTooltip}</div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            scheduleHTML += `
                    </div>
            `;

            container.innerHTML = scheduleHTML;
        }
        // Render compact category card for all-leaderboards page (single line, no grey labels)
        function renderCompactCategoryCard(item, color, categoryKey, categoryTitle, maxMetricValue) {
            const player = item.player;
            const teamColor = teamColors[player.team] || '#666';
            const escapedId = player.id.replace(/'/g, "\\'");
            const escapedCategory = (categoryTitle || '').replace(/'/g, "\\'");
            const escapedExplanation = (item.explanation || '').replace(/'/g, "\\'");

            // Calculate bar width percentage
            const metricValue = parseFloat(item.metric) || 0;
            const barWidthPercent = maxMetricValue > 0 ? (metricValue / maxMetricValue) * 100 : 0;

            // Determine if change should be shown and its direction
            const change = parseFloat(item.change || 0);
            const changeClass = change > 0 ? 'comparison-up' : change < 0 ? 'comparison-down' : '';
            const changeIcon = change > 0 ? '▲' : change < 0 ? '▼' : '';
            const showChange = Math.abs(change) >= 0.1; // Only show if change is meaningful

            return `
                <div class="compact-player-card" onclick="openPlayerModalWithCategory('${escapedId}', '${escapedCategory}', '${escapedExplanation}', '${item.rank}', '${item.metricLabel}', '${item.metric}')" style="
                    background: var(--bg-tertiary);
                    border: 1px solid var(--border-color);
                    border-radius: 8px;
                    padding: 10px 14px;
                    display: flex;
                    align-items: center;
                    gap: 12px;
                    cursor: pointer;
                    transition: all 0.2s ease;
                ">
                    <div style="
                        background: ${teamColor};
                        color: white;
                        font-size: 10px;
                        font-weight: 700;
                        padding: 4px 6px;
                        border-radius: 4px;
                        min-width: 32px;
                        text-align: center;
                    ">${player.team}</div>

                    <div style="
                        flex: 1;
                        display: flex;
                        flex-direction: column;
                        gap: 4px;
                    ">
                        <div style="
                            font-size: 13px;
                            font-weight: 600;
                            color: var(--text-primary);
                            white-space: nowrap;
                            overflow: hidden;
                            text-overflow: ellipsis;
                        ">${player.name}</div>
                        <div class="metric-bar-container" style="width: 150px;">
                            <div class="metric-bar" style="width: ${barWidthPercent}%; background: ${teamColor};"></div>
                        </div>
                    </div>

                    <div style="
                        font-size: 11px;
                        color: var(--text-tertiary);
                        min-width: 24px;
                    ">${player.position}</div>

                    <div style="
                        font-size: 13px;
                        color: var(--text-secondary);
                        min-width: 28px;
                        text-align: center;
                    ">#${item.rank}</div>

                    <div style="
                        display: flex;
                        align-items: center;
                        gap: 6px;
                        position: relative;
                    ">
                        <span class="compact-metric-value"
                            style="
                            font-size: 14px;
                            font-weight: 700;
                            color: var(--text-primary);
                            position: relative;
                        ">
                            ${item.metric}
                        </span>
                        ${showChange ? `
                            <span class="player-comparison ${changeClass}" style="
                                display: flex;
                                align-items: center;
                                gap: 2px;
                                font-size: 11px;
                                white-space: nowrap;
                                position: relative;
                            ">
                                <span class="comparison-icon">${changeIcon}</span>
                                ${Math.abs(change).toFixed(item.metric.includes('.') && item.metric.split('.')[1].length > 1 ? 2 : 1)}
                                <span class="change-tooltip" style="
                                    position: absolute;
                                    bottom: 100%;
                                    right: 0;
                                    transform: translateY(0);
                                    margin-bottom: 8px;
                                    background: var(--bg-elevated);
                                    border: 1px solid var(--border-color-light);
                                    border-radius: 8px;
                                    padding: 8px 12px;
                                    font-size: 10px;
                                    white-space: nowrap;
                                    opacity: 0;
                                    pointer-events: none;
                                    transition: opacity 0.2s ease;
                                    z-index: 2001;
                                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
                                ">vs prior 3 weeks</span>
                            </span>
                        ` : `
                            <span style="
                                display: flex;
                                align-items: center;
                                gap: 2px;
                                font-size: 11px;
                                color: var(--text-tertiary);
                                min-width: 40px;
                                justify-content: center;
                            ">—</span>
                        `}
                    </div>
                </div>
            `;
        }

        // Manual scroll function for arrow buttons (optional - can be removed if arrows removed)
        function scrollCategories(direction) {
            const carousel = document.getElementById('categories-carousel');
            if (!carousel) return;

            // Temporarily disable animation for manual scroll
            carousel.style.animation = 'none';

            const scrollAmount = carousel.offsetWidth / 2; // Scroll by width of 2 items

            if (direction === 1) {
                carousel.scrollLeft += scrollAmount;
            } else {
                carousel.scrollLeft -= scrollAmount;
            }

            // Re-enable animation after a short delay
            setTimeout(() => {
                carousel.style.animation = '';
            }, 500);
        }

        // Render Individual Category Card
        function renderCategoryCard(item, color, categoryKey, categoryTitle) {
            const player = item.player;
            const teamColor = teamColors[player.team] || '#666';
            const escapedId = player.id.replace(/'/g, "\\'");
            const escapedCategory = (categoryTitle || '').replace(/'/g, "\\'");
            const escapedExplanation = (item.explanation || '').replace(/'/g, "\\'");

            // Determine if change should be shown and its direction
            const change = parseFloat(item.change || 0);
            const changeClass = change > 0 ? 'comparison-up' : change < 0 ? 'comparison-down' : '';
            const changeIcon = change > 0 ? '▲' : change < 0 ? '▼' : '';
            const showChange = Math.abs(change) >= 0.1; // Only show if change is meaningful

            // Create tooltip text based on metric type
            let tooltipText = '';
            if (item.metricLabel.includes('Opps/Game')) {
                tooltipText = `Average opportunities (rush attempts + targets) per game in last 3 weeks. Change vs weeks 4-6 back.`;
            } else if (item.metricLabel.includes('Pts/Tgt')) {
                tooltipText = `Fantasy points per target in last 3 weeks. Higher = more efficient. Change vs weeks 4-6 back.`;
            } else if (item.metricLabel.includes('Pts/Opp')) {
                tooltipText = `Fantasy points per opportunity in last 3 weeks. Higher = more efficient. Change vs weeks 4-6 back.`;
            } else if (item.metricLabel.includes('RZ')) {
                tooltipText = `Red zone opportunities per game in last 3 weeks. More = higher TD potential. Change vs weeks 4-6 back.`;
            } else if (item.metricLabel.includes('Tgt/Game') || item.metricLabel.includes('Tgt/G')) {
                tooltipText = `Average targets per game in last 3 weeks. Higher = more consistent volume. Change vs weeks 4-6 back.`;
            } else if (item.metricLabel.includes('Yds/Att')) {
                tooltipText = `Yards per carry in last 3 weeks. Higher = more explosive running. Change vs weeks 4-6 back.`;
            } else if (item.metricLabel.includes('Air Yds')) {
                tooltipText = `Air yards (depth of target) per game in last 3 weeks. Higher = deep threat. Change vs weeks 4-6 back.`;
            } else if (item.metricLabel.includes('Tgt Share')) {
                tooltipText = `Target share percentage in last 3 weeks. Higher = more passing game involvement. Change vs weeks 4-6 back.`;
            } else {
                tooltipText = `${item.metricLabel} in last 3 weeks. Change vs weeks 4-6 back.`;
            }

            // Create simplified tooltip for main stat value
            let mainStatTooltip = '';
            if (item.metricLabel.includes('Opps/Game')) {
                mainStatTooltip = 'Opportunities per game (Rush Att + Targets)';
            } else if (item.metricLabel.includes('Pts/Tgt')) {
                mainStatTooltip = 'Fantasy points per target';
            } else if (item.metricLabel.includes('Pts/Opp')) {
                mainStatTooltip = 'Fantasy points per opportunity';
            } else if (item.metricLabel.includes('RZ')) {
                mainStatTooltip = 'Red zone opportunities per game';
            } else if (item.metricLabel.includes('Tgt/Game') || item.metricLabel.includes('Tgt/G')) {
                mainStatTooltip = 'Targets per game';
            } else if (item.metricLabel.includes('Yds/Att')) {
                mainStatTooltip = 'Yards per carry';
            } else if (item.metricLabel.includes('Air Yds')) {
                mainStatTooltip = 'Air yards per game';
            } else if (item.metricLabel.includes('Tgt Share')) {
                mainStatTooltip = 'Target share %';
            } else {
                mainStatTooltip = `${item.metricLabel} (Avg Last 3 games)`;
            }

            return `
                <div class="player-card" onclick="openPlayerModalWithCategory('${escapedId}', '${escapedCategory}', '${escapedExplanation}', '${item.rank}', '${item.metricLabel}', '${item.metric}')">
                    <div class="player-card-header" style="margin-bottom: 0;">
                        <div class="category-rank-simple" style="margin-right: 12px;">#${item.rank}</div>
                        <div class="player-card-badge" style="background: ${teamColor};">
                            ${player.team}
                        </div>
                        <div style="flex: 1; display: flex; flex-direction: column; gap: 2px;">
                            <div class="player-card-name">${player.name}</div>
                            <div class="player-card-team">${player.position}</div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 4px; position: relative;">
                            <span class="player-stat-value" style="white-space: nowrap; font-size: 12px; font-weight: 700;">
                                ${item.metric}
                            </span>
                            ${showChange ? `
                                <span class="player-comparison ${changeClass}" style="white-space: nowrap; font-size: 12px;">
                                    <span class="comparison-icon">${changeIcon}</span>
                                    ${Math.abs(change).toFixed(item.metric.includes('.') && item.metric.split('.')[1].length > 1 ? 2 : 1)}
                                </span>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `;
        }

        // Toggle footnote visibility
        function toggleFootnote() {
            const content = document.getElementById('footnote-content');
            const icon = document.getElementById('footnote-icon');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.textContent = '✕';
            } else {
                content.style.display = 'none';
                icon.textContent = 'ⓘ';
            }
        }

        // Toggle Category Expand/Collapse

        // Render mini scatter plots for category cards
        function renderMiniScatterPlots() {
            // This will be called after categories are rendered
            // For now, we'll render simple placeholder charts
            // In a full implementation, you'd create mini scatter plots with the player highlighted

            document.querySelectorAll('.category-card-chart canvas').forEach(canvas => {
                if (!canvas.id) return;

                // Simple placeholder - you can enhance this to show actual mini scatter plots
                const ctx = canvas.getContext('2d');
                if (!ctx) return;

                canvas.width = canvas.offsetWidth;
                canvas.height = 100;

                // Draw simple gradient background
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, 'rgba(48, 209, 88, 0.1)');
                gradient.addColorStop(1, 'rgba(10, 132, 255, 0.1)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw a simple trend line or indicator
                ctx.strokeStyle = 'rgba(48, 209, 88, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height * 0.7);
                ctx.lineTo(canvas.width * 0.5, canvas.height * 0.4);
                ctx.lineTo(canvas.width, canvas.height * 0.3);
                ctx.stroke();
            });
        }

        // ADVANCED ANALYTICS

        let advancedScatterChart = null;
        let highlightedPlayerIds = []; // Now supports up to 2 players
        let selectedWeekRange = 'all';
        let advancedCurrentPosition = 'WR';
        let currentQuadrantExplanation = '';
        let advancedPlayerCount = 12; // Default: show top 12 players

        // Preset scatterplot configurations
        const scatterPresets = {
            WR: [
                {
                    name: 'Volume vs Efficiency',
                    xAxis: 'targets',
                    yAxis: 'catch_rate',
                    description: 'High-volume receivers with strong catch rates',
                    quadrantExplanation: 'Top-right = High volume + reliable hands. Bottom-right = Volume without efficiency. Top-left = Efficient but limited opportunities.'
                },
                {
                    name: 'Volume vs Production',
                    xAxis: 'targets',
                    yAxis: 'fantasy_points',
                    description: 'Target share translating to fantasy points',
                    quadrantExplanation: 'Top-right = Elite fantasy assets (volume + production). Bottom-right = High volume underperformers. Top-left = Efficient scorers with limited volume.'
                },
                {
                    name: 'Target Share vs Production',
                    xAxis: 'target_share',
                    yAxis: 'fantasy_points',
                    description: 'Team involvement vs fantasy output',
                    quadrantExplanation: 'Top-right = Offensive centerpieces. Bottom-right = High target share not converting. Top-left = Boom/bust players or red zone specialists.'
                },
                {
                    name: 'Red Zone Usage',
                    xAxis: 'rz_targets',
                    yAxis: 'fantasy_points',
                    description: 'Red zone opportunities vs scoring',
                    quadrantExplanation: 'Top-right = TD-dependent scorers. Bottom-right = Red zone targets not converting. Top-left = Yardage-based scorers with limited red zone work.'
                },
                {
                    name: 'More with Less',
                    xAxis: 'targets',
                    yAxis: 'receiving_yards',
                    description: 'Target efficiency and big-play ability',
                    quadrantExplanation: 'Top-right = High volume + yards. Top-left = Explosive playmakers doing more with fewer touches. Bottom-right = Volume without yards.'
                },
                {
                    name: 'Team Dominance',
                    xAxis: 'target_share',
                    yAxis: 'team_points',
                    description: 'Target share in high/low-scoring offenses',
                    quadrantExplanation: 'Top-right = Alpha WRs on elite offenses. Bottom-right = Dominant share on bad offenses. Top-left = Supporting cast on great offenses.'
                }
            ],
            RB: [
                {
                    name: 'Talent Indicator',
                    xAxis: 'ybc_per_att',
                    yAxis: 'yac_per_att',
                    description: 'Vision vs power/elusiveness',
                    quadrantExplanation: 'Top-right = Elite talent (vision + contact balance). Bottom-right = Great vision, poor after contact. Top-left = Contact breakers relying on line.'
                },
                {
                    name: 'Volume vs Production',
                    xAxis: 'opportunities',
                    yAxis: 'fantasy_points',
                    description: 'Opportunity share vs fantasy output',
                    quadrantExplanation: 'Top-right = Workhorse RBs producing. Bottom-right = High volume underperformers. Top-left = Efficient, limited-touch backs.'
                },
                {
                    name: 'Red Zone Usage',
                    xAxis: 'rz_opportunities',
                    yAxis: 'fantasy_points',
                    description: 'Red zone touches vs scoring',
                    quadrantExplanation: 'Top-right = Goal-line backs. Bottom-right = Red zone work not converting. Top-left = Yardage scorers with limited red zone role.'
                },
                {
                    name: 'Carries vs Opportunities',
                    xAxis: 'carries',
                    yAxis: 'opportunities',
                    description: 'Rushing role vs total touches',
                    quadrantExplanation: 'Top-right = Three-down backs (high carries + targets). Bottom-right = Pure rushers with minimal pass work. Top-left = Pass-catching specialists.'
                },
                {
                    name: 'Rushing Efficiency',
                    xAxis: 'carries',
                    yAxis: 'rushing_yards',
                    description: 'Rushing volume vs yards produced',
                    quadrantExplanation: 'Top-right = Bell-cow rushers. Bottom-right = High volume, low efficiency. Top-left = Explosive runners with limited carries.'
                },
                {
                    name: 'Team Context',
                    xAxis: 'opportunities',
                    yAxis: 'team_points',
                    description: 'Workload in high/low-scoring offenses',
                    quadrantExplanation: 'Top-right = Lead backs on elite offenses. Bottom-right = Workhorse on bad offenses. Top-left = Committee backs on great offenses.'
                }
            ],
            TE: [
                {
                    name: 'Volume vs Efficiency',
                    xAxis: 'targets',
                    yAxis: 'catch_rate',
                    description: 'High-volume tight ends with strong catch rates',
                    quadrantExplanation: 'Top-right = High volume + reliable hands. Bottom-right = Volume without efficiency. Top-left = Efficient but limited opportunities.'
                },
                {
                    name: 'Volume vs Production',
                    xAxis: 'targets',
                    yAxis: 'fantasy_points',
                    description: 'Target share translating to fantasy points',
                    quadrantExplanation: 'Top-right = Elite fantasy assets (volume + production). Bottom-right = High volume underperformers. Top-left = Efficient scorers with limited volume.'
                },
                {
                    name: 'Target Share vs Production',
                    xAxis: 'target_share',
                    yAxis: 'fantasy_points',
                    description: 'Team involvement vs fantasy output',
                    quadrantExplanation: 'Top-right = Offensive centerpieces. Bottom-right = High target share not converting. Top-left = Boom/bust players or red zone specialists.'
                },
                {
                    name: 'Red Zone Usage',
                    xAxis: 'rz_targets',
                    yAxis: 'fantasy_points',
                    description: 'Red zone opportunities vs scoring',
                    quadrantExplanation: 'Top-right = TD-dependent scorers. Bottom-right = Red zone targets not converting. Top-left = Yardage-based scorers with limited red zone work.'
                },
                {
                    name: 'More with Less',
                    xAxis: 'targets',
                    yAxis: 'receiving_yards',
                    description: 'Target efficiency and big-play ability',
                    quadrantExplanation: 'Top-right = High volume + yards. Top-left = Explosive playmakers doing more with fewer touches. Bottom-right = Volume without yards.'
                },
                {
                    name: 'Team Dominance',
                    xAxis: 'target_share',
                    yAxis: 'team_points',
                    description: 'Target share in high/low-scoring offenses',
                    quadrantExplanation: 'Top-right = Alpha TEs on elite offenses. Bottom-right = Dominant share on bad offenses. Top-left = Supporting cast on great offenses.'
                }
            ]
        };

        // Populate preset buttons
        // Player Search Functions
        function filterPlayerSearch() {
            const input = document.getElementById('player-search-input');
            const searchTerm = input.value.toLowerCase().trim();
            const dropdown = document.getElementById('player-search-dropdown');

            if (searchTerm.length === 0) {
                dropdown.style.display = 'none';
                return;
            }

            // Get all players for current position
            const players = Object.values(allPlayers).filter(p =>
                p.position === advancedCurrentPosition && p.gamesPlayed >= 3
            );

            // Filter players by search term
            const matches = players.filter(p =>
                p.name.toLowerCase().includes(searchTerm)
            ).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 10);

            if (matches.length === 0) {
                dropdown.innerHTML = '<div style="padding: 12px; color: var(--text-secondary); font-size: 13px;">No players found</div>';
                dropdown.style.display = 'block';
                return;
            }

            // Build dropdown HTML
            let html = '';
            matches.forEach(player => {
                html += `
                    <div onclick="selectPlayerHighlight('${player.id.replace(/'/g, "\\'")}', '${player.name.replace(/'/g, "\\'")}', '${player.team}')"
                         style="padding: 10px 12px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-color); transition: background 0.2s;"
                         onmouseover="this.style.background='var(--bg-tertiary)'"
                         onmouseout="this.style.background='transparent'">
                        <div>
                            <div style="font-weight: 600; color: var(--text-primary); font-size: 13px;">${player.name}</div>
                            <div style="font-size: 11px; color: var(--text-secondary);">${player.team} · ${player.avgPoints.toFixed(1)} PPG</div>
                        </div>
                        <div style="width: 24px; height: 24px; border-radius: 4px; background: ${teamColors[player.team] || '#666'}; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: 700; color: white;">
                            ${player.team}
                        </div>
                    </div>
                `;
            });

            dropdown.innerHTML = html;
            dropdown.style.display = 'block';
        }

        function showPlayerSearchDropdown() {
            const input = document.getElementById('player-search-input');
            if (input.value.length > 0) {
                filterPlayerSearch();
            }
        }

        function selectPlayerHighlight(playerId, playerName, team) {
            // Check if player is already highlighted
            if (highlightedPlayerIds.includes(playerId)) {
                return; // Don't add duplicates
            }

            // Add player (max 4 players)
            if (highlightedPlayerIds.length < 4) {
                highlightedPlayerIds.push(playerId);
            } else {
                // Replace oldest player if already at max
                highlightedPlayerIds.shift();
                highlightedPlayerIds.push(playerId);
            }

            // Update selected players display
            updateSelectedPlayersDisplay();

            // Clear the input for next selection
            const input = document.getElementById('player-search-input');
            input.value = '';

            const dropdown = document.getElementById('player-search-dropdown');
            dropdown.style.display = 'none';

            const clearBtn = document.getElementById('clear-player-btn');
            clearBtn.style.display = highlightedPlayerIds.length > 0 ? 'block' : 'none';

            updateAdvancedScatter();
        }

        function updateSelectedPlayersDisplay() {
            const container = document.getElementById('selected-players-container');

            if (highlightedPlayerIds.length === 0) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'flex';

            let html = '';
            highlightedPlayerIds.forEach((playerId, index) => {
                const player = allPlayers[playerId];
                if (player) {
                    // Use white border for all highlighted players
                    html += `
                        <div style="
                            display: flex;
                            align-items: center;
                            gap: 6px;
                            padding: 4px 8px;
                            background: var(--bg-elevated);
                            border: 2px solid #fff;
                            border-radius: 6px;
                            font-size: 12px;
                            font-weight: 600;
                        ">
                            <span>${player.name} (${player.team})</span>
                            <button onclick="removePlayerHighlight('${playerId}')" style="
                                background: transparent;
                                border: none;
                                color: var(--text-secondary);
                                cursor: pointer;
                                font-size: 16px;
                                padding: 0;
                                width: 16px;
                                height: 16px;
                                line-height: 1;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            ">×</button>
                        </div>
                    `;
                }
            });

            container.innerHTML = html;
        }

        function removePlayerHighlight(playerId) {
            highlightedPlayerIds = highlightedPlayerIds.filter(id => id !== playerId);
            updateSelectedPlayersDisplay();

            const clearBtn = document.getElementById('clear-player-btn');
            clearBtn.style.display = highlightedPlayerIds.length > 0 ? 'block' : 'none';

            updateAdvancedScatter();
        }

        function clearPlayerHighlight() {
            highlightedPlayerIds = [];

            const input = document.getElementById('player-search-input');
            input.value = '';

            updateSelectedPlayersDisplay();

            const clearBtn = document.getElementById('clear-player-btn');
            clearBtn.style.display = 'none';

            const dropdown = document.getElementById('player-search-dropdown');
            dropdown.style.display = 'none';

            updateAdvancedScatter();
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            const input = document.getElementById('player-search-input');
            const dropdown = document.getElementById('player-search-dropdown');
            if (input && dropdown && !input.contains(e.target) && !dropdown.contains(e.target)) {
                dropdown.style.display = 'none';
            }
        });

        // Week Range Filter Function
        function getWeekFilteredData(player, weekRange) {
            if (weekRange === 'all') {
                return player.weeks;
            }

            // Find global max week
            let globalMaxWeek = 0;
            Object.values(allPlayers).forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });

            if (weekRange === 'last3') {
                const targetWeeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
                return player.weeks.filter(w => targetWeeks.includes(w.week));
            } else if (weekRange === 'last5') {
                const targetWeeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2, globalMaxWeek - 3, globalMaxWeek - 4];
                return player.weeks.filter(w => targetWeeks.includes(w.week));
            } else if (weekRange.includes('-')) {
                const [start, end] = weekRange.split('-').map(Number);
                return player.weeks.filter(w => w.week >= start && w.week <= end);
            } else if (!isNaN(weekRange)) {
                return player.weeks.filter(w => w.week == weekRange);
            }

            return player.weeks;
        }

        function populatePresetButtons() {
            const container = document.getElementById('preset-buttons-container');
            if (!container) return;

            const presets = scatterPresets[advancedCurrentPosition];

            container.innerHTML = presets.map(preset => `
                <button class="preset-btn" onclick="applyPreset('${preset.xAxis}', '${preset.yAxis}')" title="${preset.description}">
                    ${preset.name}
                </button>
            `).join('');
        }

        // Apply a preset configuration
        function applyPreset(xAxis, yAxis) {
            const xSelect = document.getElementById('x-axis-select');
            const ySelect = document.getElementById('y-axis-select');

            if (xSelect && ySelect) {
                xSelect.value = xAxis;
                ySelect.value = yAxis;

                // Find the preset to get its quadrant explanation
                const presets = scatterPresets[advancedCurrentPosition];
                const preset = presets.find(p => p.xAxis === xAxis && p.yAxis === yAxis);

                // Store the quadrant explanation for use in rendering
                currentQuadrantExplanation = preset ? preset.quadrantExplanation : '';

                updateAdvancedScatter();
            }
        }

        // Stat definitions with calculation functions
        const advancedStatDefinitions = {
            WR: [
                {
                    id: 'fantasy_points',
                    label: 'Fantasy Points per Game',
                    calculate: (player) => player.avgPoints || 0
                },
                {
                    id: 'points_per_target',
                    label: 'Points per Target',
                    calculate: (player) => {
                        const targetsPerGame = player.totalTargets / player.gamesPlayed;
                        return targetsPerGame > 0 ? player.avgPoints / targetsPerGame : 0;
                    }
                },
                {
                    id: 'targets',
                    label: 'Targets per Game',
                    calculate: (player) => player.totalTargets / player.gamesPlayed
                },
                {
                    id: 'receptions',
                    label: 'Receptions per Game',
                    calculate: (player) => player.totalRec / player.gamesPlayed
                },
                {
                    id: 'receiving_yards',
                    label: 'Receiving Yards per Game',
                    calculate: (player) => player.totalYDS / player.gamesPlayed
                },
                {
                    id: 'catch_rate',
                    label: 'Catch Rate (%)',
                    calculate: (player) => player.catchRate || 0
                },
                {
                    id: 'target_share',
                    label: 'Target Share (%)',
                    calculate: (player) => {
                        // Calculate average team share across all weeks
                        if (!player.weeks || player.weeks.length === 0) return 0;
                        const totalShare = player.weeks.reduce((sum, w) => sum + (w.teamShare || 0), 0);
                        return totalShare / player.weeks.length;
                    }
                },
                {
                    id: 'rz_targets',
                    label: 'Red Zone Targets per Game',
                    calculate: (player) => (player.rzOpportunities || 0) / player.gamesPlayed
                },
                {
                    id: 'air_yards',
                    label: 'Air Yards per Game',
                    calculate: (player) => player.airYardsPerGame || 0
                },
                {
                    id: 'yac_per_rec',
                    label: 'Yards After Catch per Reception',
                    calculate: (player) => player.yacPerRec || 0
                },
                {
                    id: 'team_points',
                    label: 'Team Points per Game',
                    calculate: (player) => {
                        // Get team's average points from teamStats
                        if (!teamStats || !teamStats[player.team]) return 0;
                        return teamStats[player.team].avgPoints || 0;
                    }
                },
                {
                    id: 'receiving_tds',
                    label: 'Receiving TDs per Game',
                    calculate: (player) => (player.totalRecTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'rushing_tds',
                    label: 'Rushing TDs per Game',
                    calculate: (player) => (player.totalRushTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'total_tds',
                    label: 'Total TDs per Game',
                    calculate: (player) => ((player.totalRecTDs || 0) + (player.totalRushTDs || 0)) / player.gamesPlayed
                },
                {
                    id: 'rz_tds',
                    label: 'Red Zone TDs per Game',
                    calculate: (player) => (player.rzTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'yards_per_touch',
                    label: 'Yards per Touch',
                    calculate: (player) => {
                        const totalYards = (player.totalYDS || 0) + (player.totalRushYards || 0);
                        const totalTouches = (player.totalRec || 0) + (player.totalCarries || 0);
                        return totalTouches > 0 ? totalYards / totalTouches : 0;
                    }
                },
                {
                    id: 'td_rate',
                    label: 'TD Rate (per Touch)',
                    calculate: (player) => {
                        const totalTDs = (player.totalRecTDs || 0) + (player.totalRushTDs || 0);
                        const totalTouches = (player.totalRec || 0) + (player.totalCarries || 0);
                        return totalTouches > 0 ? (totalTDs / totalTouches) * 100 : 0;
                    }
                },
                {
                    id: 'total_yards',
                    label: 'Total Yards per Game',
                    calculate: (player) => {
                        const totalYards = (player.totalYDS || 0) + (player.totalRushYards || 0);
                        return totalYards / player.gamesPlayed;
                    }
                },
                {
                    id: 'rushing_yards',
                    label: 'Rushing Yards per Game',
                    calculate: (player) => (player.totalRushYards || 0) / player.gamesPlayed
                }
            ],
            RB: [
                {
                    id: 'fantasy_points',
                    label: 'Fantasy Points per Game',
                    calculate: (player) => player.avgPoints || 0
                },
                {
                    id: 'points_per_opportunity',
                    label: 'Points per Opportunity',
                    calculate: (player) => {
                        const oppsPerGame = player.totalOpportunities / player.gamesPlayed;
                        return oppsPerGame > 0 ? player.avgPoints / oppsPerGame : 0;
                    }
                },
                {
                    id: 'opportunities',
                    label: 'Opportunities per Game',
                    calculate: (player) => player.totalOpportunities / player.gamesPlayed
                },
                {
                    id: 'rushing_yards',
                    label: 'Rushing Yards per Game',
                    calculate: (player) => (player.totalRushYards || 0) / player.gamesPlayed
                },
                {
                    id: 'ybc_per_att',
                    label: 'Yards Before Contact per Att',
                    calculate: (player) => {
                        const carries = player.totalCarries || 0;
                        return carries > 0 ? (player.totalYBCON || 0) / carries : 0;
                    }
                },
                {
                    id: 'yac_per_att',
                    label: 'Yards After Contact per Att',
                    calculate: (player) => {
                        const carries = player.totalCarries || 0;
                        return carries > 0 ? (player.totalYACON || 0) / carries : 0;
                    }
                },
                {
                    id: 'rz_opportunities',
                    label: 'Red Zone Opportunities per Game',
                    calculate: (player) => (player.rzOpportunities || 0) / player.gamesPlayed
                },
                {
                    id: 'carries',
                    label: 'Carries per Game',
                    calculate: (player) => (player.totalCarries || 0) / player.gamesPlayed
                },
                {
                    id: 'targets',
                    label: 'Targets per Game',
                    calculate: (player) => (player.totalTargets || 0) / player.gamesPlayed
                },
                {
                    id: 'team_points',
                    label: 'Team Points per Game',
                    calculate: (player) => {
                        // Get team's average points from teamStats
                        if (!teamStats || !teamStats[player.team]) return 0;
                        return teamStats[player.team].avgPoints || 0;
                    }
                },
                {
                    id: 'receiving_tds',
                    label: 'Receiving TDs per Game',
                    calculate: (player) => (player.totalRecTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'rushing_tds',
                    label: 'Rushing TDs per Game',
                    calculate: (player) => (player.totalRushTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'total_tds',
                    label: 'Total TDs per Game',
                    calculate: (player) => ((player.totalRecTDs || 0) + (player.totalRushTDs || 0)) / player.gamesPlayed
                },
                {
                    id: 'rz_tds',
                    label: 'Red Zone TDs per Game',
                    calculate: (player) => (player.rzTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'yards_per_touch',
                    label: 'Yards per Touch',
                    calculate: (player) => {
                        const totalYards = (player.totalRushYards || 0) + (player.totalRecYards || 0);
                        const totalTouches = (player.totalCarries || 0) + (player.totalRec || 0);
                        return totalTouches > 0 ? totalYards / totalTouches : 0;
                    }
                },
                {
                    id: 'td_rate',
                    label: 'TD Rate (per Touch)',
                    calculate: (player) => {
                        const totalTDs = (player.totalRecTDs || 0) + (player.totalRushTDs || 0);
                        const totalTouches = (player.totalCarries || 0) + (player.totalRec || 0);
                        return totalTouches > 0 ? (totalTDs / totalTouches) * 100 : 0;
                    }
                },
                {
                    id: 'total_yards',
                    label: 'Total Yards per Game',
                    calculate: (player) => {
                        const totalYards = (player.totalRushYards || 0) + (player.totalRecYards || 0);
                        return totalYards / player.gamesPlayed;
                    }
                },
                {
                    id: 'receiving_yards',
                    label: 'Receiving Yards per Game',
                    calculate: (player) => (player.totalRecYards || 0) / player.gamesPlayed
                }
            ],
            TE: [
                {
                    id: 'fantasy_points',
                    label: 'Fantasy Points per Game',
                    calculate: (player) => player.avgPoints || 0
                },
                {
                    id: 'points_per_target',
                    label: 'Points per Target',
                    calculate: (player) => {
                        const targetsPerGame = player.totalTargets / player.gamesPlayed;
                        return targetsPerGame > 0 ? player.avgPoints / targetsPerGame : 0;
                    }
                },
                {
                    id: 'targets',
                    label: 'Targets per Game',
                    calculate: (player) => player.totalTargets / player.gamesPlayed
                },
                {
                    id: 'receptions',
                    label: 'Receptions per Game',
                    calculate: (player) => player.totalRec / player.gamesPlayed
                },
                {
                    id: 'receiving_yards',
                    label: 'Receiving Yards per Game',
                    calculate: (player) => player.totalYDS / player.gamesPlayed
                },
                {
                    id: 'catch_rate',
                    label: 'Catch Rate (%)',
                    calculate: (player) => player.catchRate || 0
                },
                {
                    id: 'target_share',
                    label: 'Target Share (%)',
                    calculate: (player) => {
                        // Calculate average team share across all weeks
                        if (!player.weeks || player.weeks.length === 0) return 0;
                        const totalShare = player.weeks.reduce((sum, w) => sum + (w.teamShare || 0), 0);
                        return totalShare / player.weeks.length;
                    }
                },
                {
                    id: 'rz_targets',
                    label: 'Red Zone Targets per Game',
                    calculate: (player) => (player.rzOpportunities || 0) / player.gamesPlayed
                },
                {
                    id: 'air_yards',
                    label: 'Air Yards per Game',
                    calculate: (player) => player.airYardsPerGame || 0
                },
                {
                    id: 'yac_per_rec',
                    label: 'Yards After Catch per Reception',
                    calculate: (player) => player.yacPerRec || 0
                },
                {
                    id: 'team_points',
                    label: 'Team Points per Game',
                    calculate: (player) => {
                        // Get team's average points from teamStats
                        if (!teamStats || !teamStats[player.team]) return 0;
                        return teamStats[player.team].avgPoints || 0;
                    }
                },
                {
                    id: 'receiving_tds',
                    label: 'Receiving TDs per Game',
                    calculate: (player) => (player.totalRecTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'rz_tds',
                    label: 'Red Zone TDs per Game',
                    calculate: (player) => (player.rzTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'yards_per_touch',
                    label: 'Yards per Reception',
                    calculate: (player) => {
                        return player.totalRec > 0 ? (player.totalYDS || 0) / player.totalRec : 0;
                    }
                },
                {
                    id: 'td_rate',
                    label: 'TD Rate (per Target)',
                    calculate: (player) => {
                        const totalTDs = player.totalRecTDs || 0;
                        return player.totalTargets > 0 ? (totalTDs / player.totalTargets) * 100 : 0;
                    }
                }
            ]
        };

        // Switch position in Advanced Analytics
        // Toggle axis control collapse/expand
        function toggleAxisControl(axisId) {
            const content = document.getElementById(`${axisId}-content`);
            const icon = document.getElementById(`${axisId}-icon`);

            if (content && icon) {
                if (content.classList.contains('collapsed')) {
                    content.classList.remove('collapsed');
                    icon.classList.remove('collapsed');
                } else {
                    content.classList.add('collapsed');
                    icon.classList.add('collapsed');
                }
            }
        }

        function switchAdvancedPosition(position) {
            advancedCurrentPosition = position;

            // Clear quadrant explanation when switching positions
            currentQuadrantExplanation = '';

            // Clear player highlight when switching positions
            clearPlayerHighlight();

            // Update button states
            document.getElementById('advanced-wr-btn').classList.toggle('active', position === 'WR');
            document.getElementById('advanced-rb-btn').classList.toggle('active', position === 'RB');
            document.getElementById('advanced-te-btn').classList.toggle('active', position === 'TE');

            // Populate preset buttons for new position
            populatePresetButtons();

            // Populate dropdowns with new stats
            populateAdvancedDropdowns();

            // Update scatter plot
            updateAdvancedScatter();
        }

        // Set player count filter
        function setPlayerCount(count) {
            advancedPlayerCount = count;
            
            // Update button states
            document.getElementById('count-12').classList.toggle('active', count === 12);
            document.getElementById('count-24').classList.toggle('active', count === 24);
            document.getElementById('count-36').classList.toggle('active', count === 36);
            document.getElementById('count-50').classList.toggle('active', count === 50);
            document.getElementById('count-all').classList.toggle('active', count === null);
            
            // Update scatter plot
            updateAdvancedScatter();
        }

        // Reset zoom to original view
        function resetAdvancedZoom() {
            if (advancedScatterChart) {
                advancedScatterChart.resetZoom();
            }
        }

        // Populate stat dropdowns
        function populateAdvancedDropdowns() {
            const stats = advancedStatDefinitions[advancedCurrentPosition];
            const xSelect = document.getElementById('x-axis-select');
            const ySelect = document.getElementById('y-axis-select');

            // Store current selections
            const currentX = xSelect.value;
            const currentY = ySelect.value;

            // Clear and populate
            xSelect.innerHTML = '';
            ySelect.innerHTML = '';

            stats.forEach(stat => {
                const xOption = document.createElement('option');
                xOption.value = stat.id;
                xOption.textContent = stat.label;
                xSelect.appendChild(xOption);

                const yOption = document.createElement('option');
                yOption.value = stat.id;
                yOption.textContent = stat.label;
                ySelect.appendChild(yOption);
            });

            // Set default selections or restore previous
            if (currentX && stats.find(s => s.id === currentX)) {
                xSelect.value = currentX;
            } else {
                // Default X-axis: Targets for WR, Opportunities for RB
                xSelect.value = advancedCurrentPosition === 'WR' ? 'targets' : 'opportunities';
            }

            if (currentY && stats.find(s => s.id === currentY)) {
                ySelect.value = currentY;
            } else {
                // Default Y-axis: Fantasy Points for both
                ySelect.value = 'fantasy_points';
            }
        }

        // Calculate stat value for a player
        function calculateAdvancedStat(player, statId, weekFilteredWeeks = null) {
            const stats = advancedStatDefinitions[advancedCurrentPosition];
            const stat = stats.find(s => s.id === statId);
            if (!stat) return 0;

            // Create a temporary player object with filtered weeks if provided
            const playerForCalc = weekFilteredWeeks ? {
                ...player,
                weeks: weekFilteredWeeks,
                gamesPlayed: weekFilteredWeeks.length,
                totalTargets: weekFilteredWeeks.reduce((sum, w) => sum + (w.targets || 0), 0),
                totalOpportunities: weekFilteredWeeks.reduce((sum, w) => sum + ((w.rushAttempts || 0) + (w.targets || 0)), 0),
                totalPoints: weekFilteredWeeks.reduce((sum, w) => sum + w.fpts, 0),
                avgPoints: weekFilteredWeeks.length > 0 ? weekFilteredWeeks.reduce((sum, w) => sum + w.fpts, 0) / weekFilteredWeeks.length : 0
            } : player;

            const value = stat.calculate(playerForCalc);
            return isFinite(value) ? value : 0;
        }

        // Get stat label
        function getAdvancedStatLabel(statId) {
            const stats = advancedStatDefinitions[advancedCurrentPosition];
            const stat = stats.find(s => s.id === statId);
            return stat ? stat.label : '';
        }

        // Generate intelligent quadrant explanations for custom stat combinations
        function generateQuadrantExplanation(xStatId, yStatId, xLabel, yLabel) {
            // Define stat categories
            const volumeStats = ['targets_per_game', 'opportunities_per_game', 'team_share', 'air_yards_per_game'];
            const efficiencyStats = ['yards_per_target', 'yards_per_reception', 'yards_per_touch', 'catch_rate', 'points_per_target', 'points_per_opportunity'];
            const productionStats = ['fantasy_ppg', 'yards_per_game', 'receiving_yards_per_game', 'rushing_yards_per_game'];
            const scoringStats = ['rz_targets_per_game', 'rz_opportunities_per_game', 'td_rate'];

            const xIsVolume = volumeStats.includes(xStatId);
            const xIsEfficiency = efficiencyStats.includes(xStatId);
            const xIsProduction = productionStats.includes(xStatId);
            const xIsScoring = scoringStats.includes(xStatId);

            const yIsVolume = volumeStats.includes(yStatId);
            const yIsEfficiency = efficiencyStats.includes(yStatId);
            const yIsProduction = productionStats.includes(yStatId);
            const yIsScoring = scoringStats.includes(yStatId);

            let explanation = '';

            // Volume vs Efficiency
            if ((xIsVolume && yIsEfficiency) || (xIsEfficiency && yIsVolume)) {
                explanation = `<strong>What to look for:</strong> Top-right = elite players with high volume AND efficiency (studs). Bottom-right = volume without efficiency (sell high). Top-left = efficient with low volume (buy low candidates).`;
            }
            // Volume vs Production
            else if ((xIsVolume && yIsProduction) || (xIsProduction && yIsVolume)) {
                explanation = `<strong>What to look for:</strong> Top-right = workhorses producing (league winners). Bottom-right = volume hogs underperforming (regression candidates). Top-left = efficient producers lacking volume (breakout potential if usage increases).`;
            }
            // Volume vs Scoring
            else if ((xIsVolume && yIsScoring) || (xIsScoring && yIsVolume)) {
                explanation = `<strong>What to look for:</strong> Top-right = high-volume goal-line threats (must-starts with TD upside). Bottom-right = volume without scoring opportunities (TD-dependent floor). Top-left = goal-line specialists (boom/bust).`;
            }
            // Efficiency vs Production
            else if ((xIsEfficiency && yIsProduction) || (xIsProduction && yIsEfficiency)) {
                explanation = `<strong>What to look for:</strong> Top-right = efficient producers (sustainable performers). Bottom-right = producing despite inefficiency (volume-driven, regression risk). Top-left = efficient low producers (need more volume).`;
            }
            // Efficiency vs Scoring
            else if ((xIsEfficiency && yIsScoring) || (xIsScoring && yIsEfficiency)) {
                explanation = `<strong>What to look for:</strong> Top-right = efficient players with TD equity (high ceiling). Bottom-right = TD-dependent without efficiency (volatility). Top-left = efficient players without scoring (steady floor, limited ceiling).`;
            }
            // Production vs Scoring
            else if ((xIsProduction && yIsScoring) || (xIsScoring && yIsProduction)) {
                explanation = `<strong>What to look for:</strong> Top-right = elite producers with scoring equity (championship upside). Bottom-right = big producers without TDs (high floor). Top-left = TD-dependent scorers (boom/bust weekly).`;
            }
            // Same category (e.g., two volume stats)
            else if ((xIsVolume && yIsVolume) || (xIsEfficiency && yIsEfficiency) || (xIsProduction && yIsProduction) || (xIsScoring && yIsScoring)) {
                explanation = `<strong>What to look for:</strong> Top-right = elite in both ${xLabel.includes('Opp') || yLabel.includes('Opp') ? 'opportunity metrics' : 'metrics'} (target these players). Bottom-left = struggling in both areas (avoid). Diagonal = trade-offs between the two stats.`;
            }
            // Generic fallback
            else {
                explanation = `<strong>What to look for:</strong> Top-right = above median in both ${xLabel} and ${yLabel} (target these players). Bottom-left = below median in both (avoid). <span style="color: var(--text-tertiary);">Grey dotted lines show median values.</span>`;
            }

            return explanation;
        }

        // Update scatter plot
        function updateAdvancedScatter() {
            // Dismiss any open chart tooltips when chart changes
            hideStickyChartTooltip();
            
            if (!allPlayers || Object.keys(allPlayers).length === 0) {                return;
            }

            const xStatId = document.getElementById('x-axis-select').value;
            const yStatId = document.getElementById('y-axis-select').value;
            const weekRange = document.getElementById('week-range-select').value;

            const xLabel = getAdvancedStatLabel(xStatId);
            const yLabel = getAdvancedStatLabel(yStatId);

            // Update title with week range info
            const weekRangeText = weekRange === 'all' ? '' : ` (${document.getElementById('week-range-select').selectedOptions[0].text})`;
            document.getElementById('scatter-title').textContent = `${yLabel} vs ${xLabel}${weekRangeText}`;

            // Generate intelligent quadrant explanation based on stat combination
            const descriptionEl = document.getElementById('scatter-description');
            if (currentQuadrantExplanation) {
                descriptionEl.innerHTML =
                    `<strong>What to look for:</strong> ${currentQuadrantExplanation}`;
            } else {
                // Generate smart explanation based on metrics
                let explanation = generateQuadrantExplanation(xStatId, yStatId, xLabel, yLabel);
                descriptionEl.innerHTML = explanation;
            }

            // Convert allPlayers object to array and filter by position and games played
            const players = Object.values(allPlayers).filter(p =>
                p.position === advancedCurrentPosition &&
                p.gamesPlayed >= 3
            );

            // Calculate stats for each player with week filtering
            const scatterData = players.map(player => {
                const weekFilteredWeeks = getWeekFilteredData(player, weekRange);

                // Skip if no data in the selected week range
                if (weekFilteredWeeks.length === 0) return null;

                const x = calculateAdvancedStat(player, xStatId, weekFilteredWeeks);
                const y = calculateAdvancedStat(player, yStatId, weekFilteredWeeks);

                return {
                    x: x,
                    y: y,
                    player: player,
                    avgPoints: player.avgPoints || 0 // For sorting
                };
            }).filter(d => d && isFinite(d.x) && isFinite(d.y));

            // Sort by average fantasy points and limit if player count is set
            let filteredData = scatterData.sort((a, b) => b.avgPoints - a.avgPoints);
            
            // Apply player count filter (but always include highlighted players)
            if (advancedPlayerCount) {
                const highlightedData = filteredData.filter(d => highlightedPlayerIds.includes(d.player.id));
                const nonHighlightedData = filteredData.filter(d => !highlightedPlayerIds.includes(d.player.id));
                
                // Take top N non-highlighted players
                const topNonHighlighted = nonHighlightedData.slice(0, advancedPlayerCount);
                
                // Combine highlighted + top N
                filteredData = [...highlightedData, ...topNonHighlighted];
            }

            // Render chart
            renderAdvancedScatter(filteredData, xLabel, yLabel);
        }

        // Render the scatter plot
        function renderAdvancedScatter(data, xLabel, yLabel) {
            const canvas = document.getElementById('advanced-scatter-chart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Destroy existing chart
            if (advancedScatterChart) {
                advancedScatterChart.destroy();
            }

            // Calculate medians
            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);

            const xMedian = xValues.length > 0 ? xValues[Math.floor(xValues.length / 2)] : 0;
            const yMedian = yValues.length > 0 ? yValues[Math.floor(yValues.length / 2)] : 0;

            // Calculate axis ranges with padding
            const xMin = Math.min(...xValues);
            const xMax = Math.max(...xValues);
            const yMin = Math.min(...yValues);
            const yMax = Math.max(...yValues);

            const xRange = xMax - xMin;
            const yRange = yMax - yMin;

            // Ensure minimum range to prevent overly zoomed charts
            const minRange = 0.1;
            const xPadding = Math.max(xRange * 0.1, minRange); // 10% padding or minimum
            const yPadding = Math.max(yRange * 0.1, minRange);

            // Handle edge case where all values are identical
            const xAxisMin = xRange > 0 ? xMin - xPadding : xMin - 1;
            const xAxisMax = xRange > 0 ? xMax + xPadding : xMax + 1;
            const yAxisMin = yRange > 0 ? yMin - yPadding : yMin - 1;
            const yAxisMax = yRange > 0 ? yMax + yPadding : yMax + 1;

            // Prepare datasets - separate highlighted players from others
            let datasets = [];

            // Regular players dataset (exclude any highlighted players)
            const regularData = highlightedPlayerIds.length > 0
                ? data.filter(d => !highlightedPlayerIds.includes(d.player.id))
                : data;

            datasets.push({
                label: advancedCurrentPosition,
                data: regularData,
                backgroundColor: regularData.map(d => {
                    const color = teamColors[d.player.team] || '#666';
                    return color + '99'; // Add transparency
                }),
                borderColor: regularData.map(d => teamColors[d.player.team] || '#666'),
                borderWidth: 2,
                pointRadius: 8,
                pointHoverRadius: 12,
                pointHoverBorderWidth: 3
            });

            // Highlighted players datasets (up to 4 players, all with white borders)
            if (highlightedPlayerIds.length > 0) {
                highlightedPlayerIds.forEach((playerId, index) => {
                    const highlightedData = data.filter(d => d.player.id === playerId);
                    if (highlightedData.length > 0) {
                        const player = highlightedData[0].player;
                        const color = teamColors[player.team] || '#666';

                        datasets.push({
                            label: `Highlighted ${index + 1}`,
                            data: highlightedData,
                            backgroundColor: color,
                            borderColor: '#fff',
                            borderWidth: 4,
                            pointRadius: 16,
                            pointHoverRadius: 20,
                            pointHoverBorderWidth: 5,
                            pointStyle: 'circle'
                        });
                    }
                });
            }

            // Custom plugin for dynamic player labels
            const dynamicLabelsPlugin = {
                id: 'dynamicLabels',
                afterDatasetsDraw(chart) {
                    const ctx = chart.ctx;
                    const meta = chart.getDatasetMeta(0); // Get first dataset (regular players)
                    if (!meta || !meta.data) return;

                    // Get all points with their screen positions
                    const allPoints = [];
                    chart.data.datasets.forEach((dataset, datasetIndex) => {
                        const datasetMeta = chart.getDatasetMeta(datasetIndex);
                        if (!datasetMeta || !datasetMeta.data) return;

                        datasetMeta.data.forEach((point, index) => {
                            const dataPoint = dataset.data[index];
                            if (!dataPoint || !dataPoint.player) return;

                            allPoints.push({
                                x: point.x,
                                y: point.y,
                                dataX: dataPoint.x,
                                dataY: dataPoint.y,
                                player: dataPoint.player,
                                isHighlighted: highlightedPlayerIds.includes(dataPoint.player.id),
                                teamColor: teamColors[dataPoint.player.team] || '#666'
                            });
                        });
                    });

                    // Calculate which points are "extreme" (outliers to label)
                    // Sort by distance from center (median)
                    const centerX = (chart.scales.x.min + chart.scales.x.max) / 2;
                    const centerY = (chart.scales.y.min + chart.scales.y.max) / 2;

                    const pointsWithDistance = allPoints.map(p => ({
                        ...p,
                        distanceFromCenter: Math.sqrt(
                            Math.pow(p.dataX - centerX, 2) + 
                            Math.pow(p.dataY - centerY, 2)
                        )
                    })).sort((a, b) => b.distanceFromCenter - a.distanceFromCenter);

                    // Determine how many labels to show based on zoom level
                    const xRange = chart.scales.x.max - chart.scales.x.min;
                    const yRange = chart.scales.y.max - chart.scales.y.min;
                    const initialXRange = xAxisMax - xAxisMin;
                    const initialYRange = yAxisMax - yAxisMin;
                    const zoomFactor = Math.min(initialXRange / xRange, initialYRange / yRange);

                    // More labels when zoomed in
                    let maxLabels = Math.min(15, Math.floor(10 + zoomFactor * 5));

                    // Collision detection parameters
                    const minSpacing = 50; // Minimum pixels between labels
                    const labelPadding = 6;
                    const lineLength = 16; // Length of connecting line

                    // Track label positions for collision detection
                    const labelBounds = [];

                    // Function to check if a label would collide
                    const wouldCollide = (x, y, width, height) => {
                        for (const bounds of labelBounds) {
                            if (!(x + width + minSpacing < bounds.x ||
                                  x - minSpacing > bounds.x + bounds.width ||
                                  y + height + minSpacing < bounds.y ||
                                  y - minSpacing > bounds.y + bounds.height)) {
                                return true;
                            }
                        }
                        return false;
                    };

                    // Draw labels for extreme points
                    ctx.save();

                    let labelsDrawn = 0;
                    for (const point of pointsWithDistance) {
                        if (labelsDrawn >= maxLabels) break;

                        // Get last name
                        const nameParts = point.player.name.split(' ');
                        const lastName = nameParts[nameParts.length - 1];

                        // Measure text
                        ctx.font = '11px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
                        const textWidth = ctx.measureText(lastName).width;
                        const textHeight = 16;

                        // Label position (to the right of point, after line)
                        const labelX = point.x + lineLength + 2;
                        const labelY = point.y;

                        // Check collision
                        if (!wouldCollide(labelX - labelPadding, labelY - textHeight/2 - labelPadding, 
                                         textWidth + labelPadding * 2, textHeight + labelPadding * 2)) {
                            
                            // Draw connecting line (very light grey)
                            ctx.strokeStyle = 'rgba(200, 200, 200, 0.25)';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(point.x + 8, point.y); // Start from edge of point
                            ctx.lineTo(point.x + lineLength, point.y);
                            ctx.stroke();

                            // Convert hex team color to rgba
                            let r = 10, g = 132, b = 255; // Default blue
                            if (point.teamColor.startsWith('#')) {
                                r = parseInt(point.teamColor.slice(1, 3), 16);
                                g = parseInt(point.teamColor.slice(3, 5), 16);
                                b = parseInt(point.teamColor.slice(5, 7), 16);
                            }

                            // Draw subtle glow (team colored)
                            ctx.shadowColor = `rgba(${r}, ${g}, ${b}, 0.3)`;
                            ctx.shadowBlur = 12;

                            // Draw background with glassmorphism effect
                            const gradient = ctx.createLinearGradient(
                                labelX - labelPadding, 
                                labelY - textHeight/2 - labelPadding,
                                labelX + textWidth + labelPadding, 
                                labelY + textHeight/2 + labelPadding
                            );
                            gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.15)`);
                            gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0.10)`);
                            
                            ctx.fillStyle = gradient;
                            ctx.fillRect(
                                labelX - labelPadding, 
                                labelY - textHeight/2 - labelPadding,
                                textWidth + labelPadding * 2, 
                                textHeight + labelPadding * 2
                            );

                            // Draw border
                            ctx.shadowBlur = 0;
                            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
                            ctx.lineWidth = 1;
                            ctx.strokeRect(
                                labelX - labelPadding, 
                                labelY - textHeight/2 - labelPadding,
                                textWidth + labelPadding * 2, 
                                textHeight + labelPadding * 2
                            );

                            // Draw text
                            ctx.fillStyle = point.isHighlighted ? '#fff' : '#fff';
                            ctx.font = '500 11px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
                            ctx.textAlign = 'left';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(lastName, labelX, labelY);

                            // Record bounds
                            labelBounds.push({
                                x: labelX - labelPadding,
                                y: labelY - textHeight/2 - labelPadding,
                                width: textWidth + labelPadding * 2,
                                height: textHeight + labelPadding * 2
                            });

                            labelsDrawn++;
                        }
                    }

                    ctx.restore();
                }
            };

            // Create chart with median annotations
            advancedScatterChart = new Chart(ctx, {
                type: 'scatter',
                data: { datasets },
                plugins: [dynamicLabelsPlugin],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: false, // Disable default tooltip
                            external: function(context) {
                                // Skip tooltip on mobile devices - we use sticky tooltip with button instead
                                if (isMobileDevice()) {
                                    return;
                                }
                                
                                // Custom external tooltip with color boxes for each player (DESKTOP ONLY)
                                const tooltipModel = context.tooltip;
                                
                                // Hide if no tooltip
                                if (tooltipModel.opacity === 0) {
                                    const existingTooltip = document.getElementById('advanced-chart-tooltip');
                                    if (existingTooltip) {
                                        existingTooltip.style.opacity = '0';
                                        setTimeout(() => existingTooltip.remove(), 200);
                                    }
                                    return;
                                }
                                
                                // Get or create tooltip element
                                let tooltipEl = document.getElementById('advanced-chart-tooltip');
                                if (!tooltipEl) {
                                    tooltipEl = document.createElement('div');
                                    tooltipEl.id = 'advanced-chart-tooltip';
                                    tooltipEl.style.position = 'absolute';
                                    tooltipEl.style.pointerEvents = 'none';
                                    tooltipEl.style.transition = 'opacity 0.2s';
                                    document.body.appendChild(tooltipEl);
                                }
                                
                                // Get hovered point
                                if (tooltipModel.dataPoints && tooltipModel.dataPoints.length > 0) {
                                    const hoveredPoint = tooltipModel.dataPoints[0].raw;
                                    const threshold = 0.3;
                                    
                                    // Collect unique overlapping players
                                    const uniquePlayers = new Map();
                                    
                                    advancedScatterChart.data.datasets.forEach(dataset => {
                                        if (!dataset.data) return;
                                        
                                        dataset.data.forEach(point => {
                                            if (!point || !point.player) return;
                                            
                                            const distance = Math.sqrt(
                                                Math.pow(point.x - hoveredPoint.x, 2) + 
                                                Math.pow(point.y - hoveredPoint.y, 2)
                                            );
                                            
                                            if (distance < threshold) {
                                                if (!uniquePlayers.has(point.player.id)) {
                                                    uniquePlayers.set(point.player.id, {
                                                        player: point.player,
                                                        x: point.x,
                                                        y: point.y,
                                                        color: teamColors[point.player.team] || '#666'
                                                    });
                                                }
                                            }
                                        });
                                    });
                                    
                                    // Build HTML with color boxes for each player
                                    let innerHTML = '';
                                    let index = 0;
                                    uniquePlayers.forEach((p) => {
                                        if (index > 0) {
                                            innerHTML += '<div style="height: 8px;"></div>'; // Spacing
                                        }
                                        
                                        innerHTML += `
                                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                                                <div style="width: 10px; height: 10px; background-color: ${p.color}; border-radius: 2px; flex-shrink: 0;"></div>
                                                <span style="font-weight: 600;">${p.player.name}</span>
                                            </div>
                                            <div style="margin-left: 18px; font-size: 12px; color: #ddd;">
                                                ${xLabel}: ${p.x.toFixed(1)}
                                            </div>
                                            <div style="margin-left: 18px; font-size: 12px; color: #ddd; margin-bottom: 4px;">
                                                ${yLabel}: ${p.y.toFixed(1)}
                                            </div>
                                        `;
                                        index++;
                                    });
                                    
                                    tooltipEl.innerHTML = innerHTML;
                                }
                                
                                // Style the tooltip
                                tooltipEl.style.opacity = '1';
                                tooltipEl.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
                                tooltipEl.style.color = 'white';
                                tooltipEl.style.border = '1px solid #2c2c2e';
                                tooltipEl.style.borderRadius = '8px';
                                tooltipEl.style.padding = '12px';
                                tooltipEl.style.fontSize = '13px';
                                tooltipEl.style.zIndex = '10000';
                                
                                // Position tooltip
                                const position = context.chart.canvas.getBoundingClientRect();
                                tooltipEl.style.left = position.left + window.pageXOffset + tooltipModel.caretX + 'px';
                                tooltipEl.style.top = position.top + window.pageYOffset + tooltipModel.caretY + 'px';
                            }
                        },
                        annotation: {
                            annotations: {
                                xMedianLine: {
                                    type: 'line',
                                    xMin: xMedian,
                                    xMax: xMedian,
                                    borderColor: 'rgba(142, 142, 147, 0.4)',
                                    borderWidth: 2,
                                    borderDash: [8, 4],
                                    label: {
                                        display: false
                                    }
                                },
                                yMedianLine: {
                                    type: 'line',
                                    yMin: yMedian,
                                    yMax: yMedian,
                                    borderColor: 'rgba(142, 142, 147, 0.4)',
                                    borderWidth: 2,
                                    borderDash: [8, 4],
                                    label: {
                                        display: false
                                    }
                                }
                            }
                        },
                        zoom: {
                            pan: {
                                enabled: true, // Enable pan for all devices
                                mode: 'xy',
                                modifierKey: null,
                                onPanComplete: function({chart}) {
                                    // Trigger label update after pan
                                    chart.update('none');
                                }
                            },
                            zoom: {
                                wheel: {
                                    enabled: true, // Enable wheel zoom on desktop
                                    speed: 0.1
                                },
                                pinch: {
                                    enabled: true // Enable pinch zoom on mobile
                                },
                                mode: 'xy',
                                speed: 0.1,
                                onZoomComplete: function({chart}) {
                                    // Trigger label update after zoom
                                    chart.update('none');
                                }
                            },
                            limits: {
                                x: {min: xAxisMin, max: xAxisMax},
                                y: {min: yAxisMin, max: yAxisMax}
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: xLabel,
                                color: '#8e8e93',
                                font: {
                                    size: 14,
                                    weight: '600'
                                }
                            },
                            min: xAxisMin,
                            max: xAxisMax,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)'
                            },
                            ticks: {
                                color: '#8e8e93',
                                font: {
                                    size: 12
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: yLabel,
                                color: '#8e8e93',
                                font: {
                                    size: 14,
                                    weight: '600'
                                }
                            },
                            min: yAxisMin,
                            max: yAxisMax,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)'
                            },
                            ticks: {
                                color: '#8e8e93',
                                font: {
                                    size: 12
                                }
                            }
                        }
                    },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const datasetIndex = elements[0].datasetIndex;
                            const dataIndex = elements[0].index;
                            const dataset = advancedScatterChart.data.datasets[datasetIndex];
                            const clickedPoint = dataset.data[dataIndex];
                            const player = clickedPoint.player;
                            
                            // Pass additional data for overlapping detection
                            const additionalData = {
                                findOverlapping: true,
                                point: { x: clickedPoint.x, y: clickedPoint.y },
                                threshold: 0.5, // Adjust based on your data scale
                                stats: (p) => {
                                    // Format stats for each player
                                    return `${xLabel}: ${p.x.toFixed(1)}\n${yLabel}: ${p.y.toFixed(1)}`;
                                }
                            };
                            
                            handleChartClick(event, player, openPlayerModal, additionalData);
                        }
                    }
                }
            });
        }

        // Initialize Advanced Analytics when page loads
        function initializeAdvancedAnalytics() {
            populatePresetButtons();
            populateAdvancedDropdowns();
            populateWeekSelector();
            updateAdvancedScatter();
        }

        // Populate week selector with dynamic week options
        function populateWeekSelector() {
            const select = document.getElementById('week-range-select');
            if (!select) return;

            // Find global max week
            let globalMaxWeek = 0;
            Object.values(allPlayers).forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });

            // Keep existing options and add individual week options
            let html = `
                <option value="all">All Weeks</option>
                <option value="last3">Last 3 Weeks</option>
                <option value="last5">Last 5 Weeks</option>
                <option value="1-4">Weeks 1-4</option>
                <option value="5-8">Weeks 5-8</option>
            `;

            // Add individual week options
            if (globalMaxWeek > 0) {
                html += `<option disabled>──────────</option>`;
                for (let week = 1; week <= globalMaxWeek; week++) {
                    html += `<option value="${week}">Week ${week} Only</option>`;
                }
            }

            select.innerHTML = html;
        }

        // FOOTER & AUTH FUNCTIONS

        // Google Sheets Integration for Waitlist
        const GOOGLE_SHEETS_URL = 'https://script.google.com/macros/s/AKfycbxgIp_XJLI1rc8g3cH4V6mQhXOQRE80vNyIQU18JiFRSInJwjjPfI5Qjj2i_3XgqRbSUg/exec';

        // Debug: Log that this script is loaded
        function submitWaitlist(event) {            event.preventDefault();
            event.stopPropagation();

            const emailInput = document.getElementById('waitlist-email');
            const successMsg = document.getElementById('waitlist-success');

            if (!emailInput || !successMsg) {                showWaitlistModal(false, 'Error: Form not properly initialized');
                return false;
            }

            const email = emailInput.value.trim();
            // Enhanced email validation
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!email || !emailRegex.test(email)) {                alert('⚠️ Please enter a valid email address');
                emailInput.focus();
                return false;
            }
            // Disable button and show loading state
            const submitBtn = event.target.querySelector('button[type="submit"]');
            if (submitBtn) {
                const originalBtnText = submitBtn.textContent;
                submitBtn.disabled = true;
                submitBtn.textContent = 'Submitting...';

                // Send to Google Sheets
                const payload = {
                    email: email,
                    timestamp: new Date().toISOString()
                };
                fetch(GOOGLE_SHEETS_URL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                }).then(() => {
                    // Show modal
                    showWaitlistModal(true);
                    emailInput.value = '';

                    // Re-enable button
                    submitBtn.disabled = false;
                    submitBtn.textContent = originalBtnText;

                }).catch(err => {
                    // Show modal anyway (no-cors mode doesn't return errors reliably)
                    showWaitlistModal(true);
                    emailInput.value = '';

                    // Re-enable button
                    submitBtn.disabled = false;
                    submitBtn.textContent = originalBtnText;
                });
            }

            return false;
        }

        // Make submitWaitlist globally available
        window.submitWaitlist = submitWaitlist;

        // Show waitlist confirmation modal
        function showWaitlistModal(success, customMessage) {
            const modal = document.getElementById('waitlist-modal');
            if (modal) {
                if (!success && customMessage) {
                    alert(customMessage);
                    return;
                }
                modal.classList.add('show');
            }
        }

        // Close waitlist modal
        function closeWaitlistModal() {
            const modal = document.getElementById('waitlist-modal');
            if (modal) {
                modal.classList.remove('show');
            }
        }

        // Login Modal Functions
        function showLoginModal() {
            document.getElementById('login-modal').style.display = 'flex';
            document.getElementById('login-error').classList.remove('show');
        }

        function closeLoginModal() {
            document.getElementById('login-modal').style.display = 'none';
            document.getElementById('login-email').value = '';
            document.getElementById('login-password').value = '';
            document.getElementById('login-error').classList.remove('show');
        }

        // Privacy Modal Functions
        function showPrivacyModal() {
            document.getElementById('privacy-modal').style.display = 'flex';
        }

        function closePrivacyModal() {
            document.getElementById('privacy-modal').style.display = 'none';
        }

        // Login handler - make it globally accessible
        window.handleLogin = function(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            const emailEl = document.getElementById('login-email');
            const passwordEl = document.getElementById('login-password');

            if (!emailEl || !passwordEl) {                alert('Error: Login form not properly initialized');
                return false;
            }

            const email = emailEl.value.trim();
            const password = passwordEl.value;
            const ADMIN_EMAIL = 'aryi3025@gmail.com';
            const ADMIN_PASSWORD = 'admin051213!';

            if (email === ADMIN_EMAIL && password === ADMIN_PASSWORD) {
                // Successful login                localStorage.setItem('ffse_admin_logged_in', 'true');
                closeLoginModal();
                updateUIForAdmin(true);

                // Navigate to admin panel
                setTimeout(() => {
                    navigateToPage('admin-panel');
                }, 100);

                alert('Login successful! Welcome back.');
            } else {
                // Failed login
                const errorMsg = document.getElementById('login-error');
                if (errorMsg) {
                    errorMsg.classList.add('show');

                    setTimeout(() => {
                        errorMsg.classList.remove('show');
                    }, 3000);
                } else {
                    alert('Invalid credentials. Please try again.');
                }
            }

            return false;
        };

        // Check if user is logged in on page load
        function checkAdminStatus() {
            const isLoggedIn = localStorage.getItem('ffse_admin_logged_in') === 'true';
            if (isLoggedIn) {                updateUIForAdmin(true);
            } else {
                updateUIForAdmin(false);
            }
            updateLastUpdatedDisplay();
        }

        // Function to navigate to a page (used by footer links)
        // MOBILE MENU FUNCTIONS

        function toggleMobileMenu() {
            const menuButton = document.querySelector('.mobile-menu-button');
            const menuOverlay = document.getElementById('mobile-menu-overlay');
            const menu = document.getElementById('mobile-menu');

            menuButton.classList.toggle('active');
            menuOverlay.classList.toggle('active');
            menu.classList.toggle('active');

            // Prevent body scroll when menu is open
            if (menu.classList.contains('active')) {
                document.body.style.overflow = 'hidden';
            } else {
                document.body.style.overflow = '';
            }
        }

        function closeMobileMenu() {
            const menuButton = document.querySelector('.mobile-menu-button');
            const menuOverlay = document.getElementById('mobile-menu-overlay');
            const menu = document.getElementById('mobile-menu');

            menuButton.classList.remove('active');
            menuOverlay.classList.remove('active');
            menu.classList.remove('active');
            document.body.style.overflow = '';
        }

        function navigateFromMobileMenu(pageName) {
            // Update mobile menu active state
            document.querySelectorAll('.mobile-menu-item').forEach(item => {
                item.classList.remove('active');
            });
            const activeMenuItem = document.querySelector(`.mobile-menu-item[data-page="${pageName}"]`);
            if (activeMenuItem) activeMenuItem.classList.add('active');

            // Close menu
            closeMobileMenu();

            // Navigate to page
            navigateToPage(pageName);

            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // NAVIGATION FUNCTIONS

        function navigateToPage(pageName) {
            // Dismiss any open chart tooltips
            hideStickyChartTooltip();
            
            // Update active tab
            document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
            const activeTab = document.querySelector(`.nav-tab[data-page="${pageName}"]`);
            if (activeTab) activeTab.classList.add('active');

            // Show page
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            const targetPage = document.getElementById(pageName);
            if (targetPage) targetPage.classList.add('active');

            // Expand all tiers IMMEDIATELY when navigating to WR, RB, or TE pages
            if (['wide-receivers', 'running-backs', 'tight-ends'].includes(pageName)) {
                expandAllTiers();
                // Also call again after a short delay to ensure everything is rendered
                setTimeout(() => {
                    expandAllTiers();
                }, 100);
            }

            // Render dashboard categories if on dashboard page
            if (pageName === 'top-movers') {
                setTimeout(() => {
                    renderDashboardCategories();
                    setTimeout(renderMiniScatterPlots, 100);
                }, 100);
            }

            // Render team analysis charts if on teams page (so animations play)
            if (pageName === 'teams') {
                setTimeout(() => {
                    updateTeamAnalysis();
                }, 100);
            }

            // Render all leaderboards if on all-leaderboards page
            if (pageName === 'all-leaderboards') {
                setTimeout(() => {
                    renderAllLeaderboards();
                }, 100);
            }

            // Initialize tooltips if on analytics dashboard
            if (pageName === 'analytics-dashboard') {
                setTimeout(() => {
                    initializeMetricTooltip();
                }, 100);
            }

            // Scroll to top of page
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Set scoring format and reprocess all data
        function setScoringFormat(format) {
            console.log(`===== SCORING FORMAT CHANGE =====`);
            console.log(`Old format: ${currentScoringFormat}, New format: ${format}`);
            
            // Show scoring format details
            if (format === 'std') {            } else if (format === 'half') {            } else {            }

            // Update global variable
            currentScoringFormat = format;

            // Save to localStorage
            localStorage.setItem('ffse_scoring_format', format);

            // Update UI - toggle buttons
            document.querySelectorAll('.scoring-option').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.format === format) {
                    btn.classList.add('active');
                }
            });

            // Add fade animation to main content
            const mainContent = document.querySelector('.main-content');
            if (mainContent) {
                mainContent.classList.add('updating-values');
                setTimeout(() => {
                    mainContent.classList.remove('updating-values');
                }, 600);
            }
            
            // Show loading on analytics dashboard if active
            const activePage = document.querySelector('.page.active');
            if (activePage && activePage.id === 'analytics-page') {
                const heatmapGrid = document.getElementById('heatmap-cards-grid');
                if (heatmapGrid) {
                    heatmapGrid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: var(--text-secondary); font-size: 14px;">⟳ Recalculating for ' + (format === 'ppr' ? 'PPR' : format === 'half' ? 'Half-PPR' : 'Standard') + ' scoring...</div>';
                }
            }

            // Reprocess all data with new scoring format
            if (wrData && rbData) {
                console.log(`Data available - WR: ${wrData ? wrData.length : 0}, RB: ${rbData ? rbData.length : 0}, TE: ${teData ? teData.length : 0}`);
                console.log('Starting data reprocessing...');
                
                // Small delay to let fade animation start
                setTimeout(() => {
                    console.log('📊 Reprocessing data for new scoring format:', currentScoringFormat);
                    
                    // Explicitly recalculate each position
                    if (wrData) {
                        console.log('🔄 Recalculating WR data...');
                        aggregatedWRs = aggregatePlayerData(wrData, 'WR');
                        evaluationDataWR = calculateWREvaluationMetrics(wrData);
                        console.log('✅ WR recalculation complete:', Object.keys(aggregatedWRs).length, 'players');
                    }
                    
                    if (rbData) {
                        console.log('🔄 Recalculating RB data...');
                        aggregatedRBs = aggregatePlayerData(rbData, 'RB');
                        evaluationDataRB = calculateRBEvaluationMetrics(rbData);
                        console.log('✅ RB recalculation complete:', Object.keys(aggregatedRBs).length, 'players');
                    }
                    
                    if (teData) {
                        console.log('🔄 Recalculating TE data...');
                        aggregatedTEs = aggregatePlayerData(teData, 'TE');
                        console.log('✅ TE recalculation complete:', Object.keys(aggregatedTEs).length, 'players');
                    }
                    
                    // Combine all players
                    allPlayers = { ...aggregatedWRs, ...aggregatedRBs, ...aggregatedTEs };
                    
                    // Calculate ROS ranks
                    calculateROSRanks();
                    
                    // Calculate momentum scores
                    calculateAllMomentum();
                    
                    // Force re-render ALL position pages
                    console.log('🎨 Re-rendering all position pages...');
                    renderWRPlayerCards();
                    renderRBPlayerCards();
                    renderTEPlayerCards();
                    
                    // Also update other displays
                    renderTicker();
                    renderTeamsTicker();
                    renderScatterPlots();
                    
                    // Update all leaderboards page elements
                    renderPPGLeaderboard(document.querySelector('.ppg-position-btn.active')?.dataset.position || 'WR');
                    
                    // Update analytics insights ticker on leaderboards page
                    const analyticsInsightsTrack = document.getElementById('analytics-insights-track');
                    if (analyticsInsightsTrack) {
                        const topWRs = Object.values(aggregatedWRs)
                            .filter(p => p.gamesPlayed >= 3)
                            .sort((a, b) => b.avgPoints - a.avgPoints)
                            .slice(0, 10)
                            .map((p, idx) => ({ ...p, rank: idx + 1 }));

                        const topRBs = Object.values(aggregatedRBs)
                            .filter(p => p.gamesPlayed >= 3)
                            .sort((a, b) => b.avgPoints - a.avgPoints)
                            .slice(0, 10)
                            .map((p, idx) => ({ ...p, rank: idx + 1 }));

                        const topTEs = Object.values(aggregatedTEs)
                            .filter(p => p.gamesPlayed >= 3)
                            .sort((a, b) => b.avgPoints - a.avgPoints)
                            .slice(0, 10)
                            .map((p, idx) => ({ ...p, rank: idx + 1 }));

                        const allTopPlayers = [...topWRs, ...topRBs, ...topTEs];

                        const analyticsTickerHTML = allTopPlayers.map((player) => {
                            return `
                                <div class="ticker-item">
                                    <span style="font-weight: 700; color: var(--text-tertiary); font-size: 12px; min-width: 24px;">#${player.rank}</span>
                                    <span class="player-name">${player.name}</span>
                                    <span style="color: var(--text-secondary); font-size: 11px;">${player.position} · ${player.team}</span>
                                    <span class="avg-pts">${player.avgPoints.toFixed(1)} PPG</span>
                                </div>
                            `;
                        }).join('');

                        analyticsInsightsTrack.innerHTML = analyticsTickerHTML + analyticsTickerHTML;
                    }
                    
                    // Always update analytics dashboard data (even if not visible)
                    // This ensures it's ready when user switches tabs
                    if (aggregatedWRs && aggregatedRBs && aggregatedTEs) {
                        initializeAnalyticsDashboard();
                    }
                    
                    console.log('✅ Scoring format change complete!');
                    console.log('Data reprocessing complete');
                    console.log(`WR aggregated players: ${Object.keys(aggregatedWRs).length}`);
                    console.log(`RB aggregated players: ${Object.keys(aggregatedRBs).length}`);
                    console.log(`TE aggregated players: ${Object.keys(aggregatedTEs).length}`);
                    
                    // Sample a WR player to check data
                    const sampleWR = Object.values(aggregatedWRs)[0];
                    if (sampleWR) {
                        console.log(`Sample WR: ${sampleWR.name}`);
                        console.log(`  - Avg Points: ${sampleWR.avgPoints.toFixed(2)}`);
                        console.log(`  - pctOverExpected: ${sampleWR.pctOverExpected.toFixed(2)}%`);
                        if (sampleWR.weeks && sampleWR.weeks.length > 0) {
                            const lastWeek = sampleWR.weeks[sampleWR.weeks.length - 1];
                            console.log(`  - Last week fpts: ${lastWeek.fpts.toFixed(2)}`);
                            console.log(`  - Last week expectedFpts: ${lastWeek.expectedFpts.toFixed(2)}`);
                        }
                    }
                }, 100);
            } else {
                console.log('Data not ready for reprocessing');
            }
        }

        // Initialize scoring format on page load
        function initializeScoringFormat() {
            const savedFormat = localStorage.getItem('ffse_scoring_format') || 'ppr';
            currentScoringFormat = savedFormat;

            // Update UI to match saved format
            document.querySelectorAll('.scoring-option').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.format === savedFormat) {
                    btn.classList.add('active');
                }
            });

            // Update header dropdown
            updateHeaderScoringDropdown(savedFormat);            if (savedFormat === 'std') {            } else if (savedFormat === 'half') {            } else {            }
        }

        // Toggle header scoring dropdown
        function toggleHeaderScoringDropdown() {
            const dropdown = document.getElementById('header-scoring-dropdown');
            dropdown.classList.toggle('open');

            // Close dropdown when clicking outside
            if (dropdown.classList.contains('open')) {
                setTimeout(() => {
                    document.addEventListener('click', closeHeaderDropdownOutside);
                }, 0);
            } else {
                document.removeEventListener('click', closeHeaderDropdownOutside);
            }
        }

        function closeHeaderDropdownOutside(e) {
            const dropdown = document.getElementById('header-scoring-dropdown');
            if (!dropdown.contains(e.target)) {
                dropdown.classList.remove('open');
                document.removeEventListener('click', closeHeaderDropdownOutside);
            }
        }

        // Set scoring format from header dropdown
        function setHeaderScoringFormat(format) {
            // Close dropdown
            document.getElementById('header-scoring-dropdown').classList.remove('open');
            document.removeEventListener('click', closeHeaderDropdownOutside);

            // Update header dropdown UI
            updateHeaderScoringDropdown(format);

            // Call existing setScoringFormat function
            setScoringFormat(format);
        }

        // Update header dropdown display
        function updateHeaderScoringDropdown(format) {
            const label = document.getElementById('header-scoring-label');
            const buttons = document.querySelectorAll('.header-scoring-menu button');

            // Update label text
            if (format === 'ppr') {
                label.textContent = 'PPR';
            } else if (format === 'half') {
                label.textContent = 'Half-PPR';
            } else {
                label.textContent = 'Standard';
            }

            // Update active state
            buttons.forEach(btn => {
                btn.classList.remove('active');
                if ((format === 'ppr' && btn.textContent === 'PPR') ||
                    (format === 'half' && btn.textContent === 'Half-PPR') ||
                    (format === 'std' && btn.textContent === 'Standard')) {
                    btn.classList.add('active');
                }
            });
        }

        // Scroll to waitlist section
        function scrollToWaitlist() {
            const footer = document.querySelector('.footer');
            if (footer) {
                footer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                setTimeout(() => {
                    const emailInput = document.getElementById('waitlist-email');
                    if (emailInput) emailInput.focus();
                }, 500);
            }
        }

        // Update last updated date display
        function updateLastUpdatedDisplay() {
            const lastUpdated = localStorage.getItem('ffse_last_updated');
            const displayEl = document.getElementById('last-updated-date');

            if (displayEl) {
                if (lastUpdated) {
                    const date = new Date(lastUpdated);
                    const options = { month: 'short', day: 'numeric', year: 'numeric' };
                    displayEl.textContent = date.toLocaleDateString('en-US', options);
                } else {
                    displayEl.textContent = 'No data uploaded';
                }
            }
        }

        // Set last updated date
        function setLastUpdatedDate() {
            const now = new Date().toISOString();
            localStorage.setItem('ffse_last_updated', now);
            updateLastUpdatedDisplay();
        }

        // Update UI based on admin status
        function updateUIForAdmin(isAdmin) {
            const adminLoginLink = document.getElementById('admin-login-link');
            const adminTab = document.getElementById('admin-tab');
            const mobileAdminTab = document.getElementById('mobile-admin-tab');

            if (isAdmin) {
                // Show admin tab (desktop and mobile)
                if (adminTab) adminTab.style.display = 'block';
                if (mobileAdminTab) mobileAdminTab.style.display = 'block';

                // Update footer link
                if (adminLoginLink) {
                    adminLoginLink.textContent = 'Admin Panel';
                    adminLoginLink.onclick = (e) => {
                        e.preventDefault();
                        navigateToPage('admin-panel');
                        return false;
                    };
                }
            } else {
                // Hide admin tab (desktop and mobile)
                if (adminTab) adminTab.style.display = 'none';
                if (mobileAdminTab) mobileAdminTab.style.display = 'none';

                // Update footer link
                if (adminLoginLink) {
                    adminLoginLink.textContent = 'Admin Login';
                    adminLoginLink.onclick = (e) => {
                        e.preventDefault();
                        showLoginModal();
                        return false;
                    };
                }
            }

            // Update admin panel display if on that page
            updateAdminPanelDisplay();
        }

        // Logout admin
        function logoutAdmin() {
            localStorage.removeItem('ffse_admin_logged_in');
            updateUIForAdmin(false);
            // Navigate to dashboard if currently on admin panel
            if (document.getElementById('admin-panel').classList.contains('active')) {
                navigateToPage('top-movers');
            }
            alert('Logged out successfully');
        }

        // Update admin panel display with current data info
        function updateAdminPanelDisplay() {
            const lastUpdatedEl = document.getElementById('admin-last-updated');
            if (lastUpdatedEl) {
                const lastUpdated = localStorage.getItem('ffse_last_updated');
                if (lastUpdated) {
                    const date = new Date(lastUpdated);
                    const options = { month: 'short', day: 'numeric', year: 'numeric', hour: 'numeric', minute: '2-digit' };
                    lastUpdatedEl.textContent = date.toLocaleDateString('en-US', options);
                } else {
                    lastUpdatedEl.textContent = 'No data uploaded';
                }
            }
        }

        // Admin upload handlers
        function handleAdminWRUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const statusEl = document.getElementById('admin-wr-status');
                if (statusEl) statusEl.textContent = 'Processing...';
                if (statusEl) statusEl.style.color = 'var(--text-secondary)';

                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        wrData = results.data.filter(row => row.Player && row.Week);
                        localStorage.setItem('wrData', JSON.stringify(wrData));

                        if (statusEl) statusEl.textContent = '✓ WR data uploaded successfully';
                        if (statusEl) statusEl.style.color = 'var(--positive)';

                        if (rbData && teData) {
                            processAllData();
                            updateAdminPanelDisplay();
                        }
                    },
                    error: function(error) {
                        if (statusEl) statusEl.textContent = '✗ Error uploading WR data';
                        if (statusEl) statusEl.style.color = 'var(--negative)';                    }
                });
            }
        }

        function handleAdminRBUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const statusEl = document.getElementById('admin-rb-status');
                if (statusEl) statusEl.textContent = 'Processing...';
                if (statusEl) statusEl.style.color = 'var(--text-secondary)';

                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        rbData = results.data.filter(row => row.Player && row.Week);
                        localStorage.setItem('rbData', JSON.stringify(rbData));

                        if (statusEl) statusEl.textContent = '✓ RB data uploaded successfully';
                        if (statusEl) statusEl.style.color = 'var(--positive)';

                        if (wrData && teData) {
                            processAllData();
                            updateAdminPanelDisplay();
                        }
                    },
                    error: function(error) {
                        if (statusEl) statusEl.textContent = '✗ Error uploading RB data';
                        if (statusEl) statusEl.style.color = 'var(--negative)';                    }
                });
            }
        }

        function handleAdminTEUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const statusEl = document.getElementById('admin-te-status');
                if (statusEl) statusEl.textContent = 'Processing...';
                if (statusEl) statusEl.style.color = 'var(--text-secondary)';

                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        teData = results.data.filter(row => row.Player && row.Week);
                        localStorage.setItem('teData', JSON.stringify(teData));

                        if (statusEl) statusEl.textContent = '✓ TE data uploaded successfully';
                        if (statusEl) statusEl.style.color = 'var(--positive)';

                        if (wrData && rbData) {
                            processAllData();
                            updateAdminPanelDisplay();
                        }
                    },
                    error: function(error) {
                        if (statusEl) statusEl.textContent = '✗ Error uploading TE data';
                        if (statusEl) statusEl.style.color = 'var(--negative)';                    }
                });
            }
        }

        // Ticker tooltip toggle function (mobile-friendly)
        function toggleTickerTooltip(event) {
            event.stopPropagation();
            const icon = event.currentTarget;
            const tooltip = icon.querySelector('.ticker-tooltip');

            // Close all other ticker tooltips
            document.querySelectorAll('.ticker-tooltip.active').forEach(otherTooltip => {
                if (otherTooltip !== tooltip) {
                    otherTooltip.classList.remove('active');
                }
            });

            // Toggle this tooltip
            tooltip.classList.toggle('active');
        }

        // Close ticker tooltips when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.ticker-info-icon')) {
                document.querySelectorAll('.ticker-tooltip.active').forEach(tooltip => {
                    tooltip.classList.remove('active');
                });
            }
        });

        // Leaderboard tooltip toggle function (mobile-friendly)
        function toggleLeaderboardTooltip(event) {
            event.stopPropagation();
            const icon = event.currentTarget;
            const tooltip = icon.querySelector('.leaderboard-tooltip');

            // Close all other leaderboard tooltips
            document.querySelectorAll('.leaderboard-tooltip.active').forEach(otherTooltip => {
                if (otherTooltip !== tooltip) {
                    otherTooltip.classList.remove('active');
                }
            });

            // Toggle this tooltip
            tooltip.classList.toggle('active');
        }

        // Close leaderboard tooltips when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.leaderboard-info-icon')) {
                document.querySelectorAll('.leaderboard-tooltip.active').forEach(tooltip => {
                    tooltip.classList.remove('active');
                });
            }
        });

        // Dashboard scatter tooltip toggle function (mobile-friendly)
        function toggleDashboardScatterTooltip(event) {
            event.stopPropagation();
            const icon = event.currentTarget;
            const tooltip = icon.querySelector('.dashboard-scatter-tooltip');

            // Close all other dashboard scatter tooltips
            document.querySelectorAll('.dashboard-scatter-tooltip.active').forEach(otherTooltip => {
                if (otherTooltip !== tooltip) {
                    otherTooltip.classList.remove('active');
                }
            });

            // Toggle this tooltip
            tooltip.classList.toggle('active');
        }

        // Close dashboard scatter tooltips when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.dashboard-scatter-info')) {
                document.querySelectorAll('.dashboard-scatter-tooltip.active').forEach(tooltip => {
                    tooltip.classList.remove('active');
                });
            }
        });

        // Portal tooltip system for leaderboard metrics
        function initializePortalTooltip() {
            // Create tooltip element if it doesn't exist
            let tooltip = document.getElementById('portal-tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'portal-tooltip';
                document.body.appendChild(tooltip);
            }

            // Add event listeners using delegation
            document.addEventListener('mouseover', function(e) {
                const target = e.target.closest('.compact-metric-value');
                if (target && target.hasAttribute('data-tooltip-text')) {
                    const tooltipText = target.getAttribute('data-tooltip-text');
                    const rect = target.getBoundingClientRect();

                    // Set tooltip content
                    tooltip.innerHTML = tooltipText + '<span class="tooltip-secondary">Bar shows relative performance vs. #1</span>';

                    // Make visible but transparent to measure
                    tooltip.style.opacity = '0';
                    tooltip.style.display = 'block';

                    // Get dimensions after content is set
                    const tooltipWidth = tooltip.offsetWidth;
                    const tooltipHeight = tooltip.offsetHeight;

                    // Position tooltip to the left of the element
                    let left = rect.left - tooltipWidth - 12;
                    let top = rect.top + (rect.height / 2) - (tooltipHeight / 2);

                    // If tooltip goes off left edge, show on right instead
                    if (left < 10) {
                        left = rect.right + 12;
                    }

                    // Keep tooltip within viewport vertically
                    if (top < 10) {
                        top = 10;
                    } else if (top + tooltipHeight > window.innerHeight - 10) {
                        top = window.innerHeight - tooltipHeight - 10;
                    }

                    tooltip.style.left = left + 'px';
                    tooltip.style.top = top + 'px';
                    tooltip.style.opacity = '';
                    tooltip.style.display = '';
                    tooltip.classList.add('visible');
                }
            });

            document.addEventListener('mouseout', function(e) {
                const target = e.target.closest('.compact-metric-value');
                if (target && target.hasAttribute('data-tooltip-text')) {
                    tooltip.classList.remove('visible');
                }
            });
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', () => {
            initializeScoringFormat();
            checkAdminStatus();
            initializePortalTooltip();

            // Fetch injury data from Sleeper API (runs in background)
            fetchInjuryData().then(() => {
                console.log('Injury data loaded from API:', Object.keys(injuryData).length, 'players');
                
                // Re-render pages if injury data affects display
                const activePage = document.querySelector('.page.active');
                if (activePage && activePage.id === 'wr-page' && wrData) {
                    renderWRPlayerCards();
                } else if (activePage && activePage.id === 'rb-page' && rbData) {
                    renderRBPlayerCards();
                } else if (activePage && activePage.id === 'te-page' && teData) {
                    renderTEPlayerCards();
                } else if (activePage && activePage.id === 'analytics-page') {
                    // Refresh market opportunities with updated injury data
                    console.log('Refreshing market opportunities with updated injury data');
                    updateMarketOpportunities();
                }
            });

            // Expand all tiers on page load
            setTimeout(() => {
                expandAllTiers();
                
                // Center heatmap legend scroll on mobile
                if (window.innerWidth <= 768) {
                    const legendItems = document.getElementById('heatmap-legend-items');
                    if (legendItems) {
                        legendItems.scrollLeft = (legendItems.scrollWidth - legendItems.clientWidth) / 2;
                    }
                }
            }, 100);
        });

        // Mobile touch handling for Floor Metrics tooltips
        if ('ontouchstart' in window) {
            document.addEventListener('DOMContentLoaded', () => {
                document.addEventListener('click', (e) => {
                    const tooltipParent = e.target.closest('.radial-with-tooltip');
                    if (tooltipParent) {
                        e.preventDefault();
                        // Toggle active class for this tooltip
                        const wasActive = tooltipParent.classList.contains('active');
                        
                        // Remove active from all tooltips
                        document.querySelectorAll('.radial-with-tooltip').forEach(el => {
                            el.classList.remove('active');
                        });
                        
                        // Add active to this one if it wasn't already
                        if (!wasActive) {
                            tooltipParent.classList.add('active');
                        }
                    } else {
                        // Click outside - remove all actives
                        document.querySelectorAll('.radial-with-tooltip').forEach(el => {
                            el.classList.remove('active');
                        });
                    }
                });
            });
        }

    </script>
</body>
</html>
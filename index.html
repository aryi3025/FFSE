<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FFSE - Fantasy Football Stock Exchange</title>
    <!--
    FFSE - Fantasy Football Stock Exchange
    Version: v77

    LATEST UPDATES (v77):
    - ✅ Clickable carousel dots on dashboard (all screen sizes)
    - ✅ Auto-expand tiers on page navigation
    - ✅ Collapsible tier functionality
    - ✅ Mobile optimizations (ticker, top movers, tooltips)
    - ✅ Full TE integration with 7-tier system

    FEATURES:
    - Auto-fetch data from GitHub repository
    - WR/RB/TE rankings with tier-based organization
    - Advanced analytics with interactive scatter plots
    - Team outlook with offensive identity analysis
    - Community sentiment voting system
    - Mobile-responsive design

    GitHub Data Repository: https://github.com/aryi3025/ffse-data

    Full changelog: See CHANGELOG.md
    -->

    <!-- External Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <style>
        /* ============================================
           1. BASE & RESET
           ============================================ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Background Colors */
            --bg-primary: #000;
            --bg-secondary: #0a0a0a;
            --bg-tertiary: #1c1c1e;
            --bg-elevated: #2c2c2e;

            /* Text Colors */
            --text-primary: #fff;
            --text-secondary: #8e8e93;
            --text-tertiary: #636366;

            /* Accent Colors */
            --positive: #30d158;
            --positive-bg: rgba(48, 209, 88, 0.15);
            --negative: #ff453a;
            --negative-bg: rgba(255, 69, 58, 0.15);

            /* UI Elements */
            --border-color: #1c1c1e;
            --border-color-light: #2c2c2e;

            /* Spacing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', system-ui, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow-x: hidden;
        }

        /* ============================================
           2. LAYOUT
           ============================================ */
        .app-container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .main-content {
            flex: 1;
            padding: var(--spacing-lg);
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        .page {
            display: none;
            animation: fadeIn 0.3s ease-in;
        }

        .page.active {
            display: block;
        }

        @media (max-width: 768px) {
            .page {
                overflow-x: hidden;
                max-width: 100vw;
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* ============================================
           3. HEADER
           ============================================ */
        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .ticker-section {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            overflow: hidden;
            position: sticky;
            top: 73px; /* Below header */
            z-index: 99;
            margin-bottom: 24px;
            border-radius: 0; /* Remove border radius when sticky */
        }

        .ticker-header {
            padding: 8px 24px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ticker-info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1.5px solid var(--text-tertiary);
            color: var(--text-tertiary);
            font-size: 10px;
            font-weight: 700;
            font-style: normal;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            z-index: 9999; /* High z-index for icon and its tooltip */
            flex-shrink: 0;
        }

        .ticker-info-icon:hover {
            border-color: var(--text-secondary);
            color: var(--text-secondary);
            background: rgba(255, 255, 255, 0.05);
        }

        .ticker-info-icon:active {
            transform: scale(0.95);
        }

        .ticker-tooltip {
            position: absolute;
            left: calc(100% + 8px);
            top: 50%;
            transform: translateY(-30%);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 11px;
            font-weight: 400;
            color: var(--text-primary);
            line-height: 1.4;
            white-space: normal;
            width: 300px;
            max-width: calc(100vw - 80px);
            text-transform: none;
            letter-spacing: normal;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10000; /* Very high z-index to appear above everything */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }

        .ticker-tooltip.active {
            opacity: 1;
            visibility: visible;
        }

        .ticker-tooltip::before {
            content: '';
            position: absolute;
            right: 100%;
            top: 20%;
            border: 6px solid transparent;
            border-right-color: var(--border-color);
        }

        .ticker-tooltip::after {
            content: '';
            position: absolute;
            right: 100%;
            top: 20%;
            border: 5px solid transparent;
            border-right-color: var(--bg-secondary);
            margin-right: -1px;
        }

        @media (max-width: 768px) {
            .ticker-tooltip {
                width: 260px;
                font-size: 10px;
                padding: 8px 12px;
                left: auto;
                right: -8px;
                transform: translateY(-30%) translateX(100%);
            }

            .ticker-tooltip::before {
                right: auto;
                left: 100%;
                top: 20%;
                border-right-color: transparent;
                border-left-color: var(--border-color);
            }

            .ticker-tooltip::after {
                right: auto;
                left: 100%;
                top: 20%;
                margin-right: 0;
                margin-left: -1px;
                border-right-color: transparent;
                border-left-color: var(--bg-secondary);
            }
        }

        /* Leaderboard Info Icon & Tooltip */
        .leaderboard-info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 1.5px solid var(--text-tertiary);
            color: var(--text-tertiary);
            font-size: 9px;
            font-weight: 700;
            font-style: normal;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            z-index: 9999; /* High z-index for icon and its tooltip */
            flex-shrink: 0;
            margin-left: 6px;
        }

        .leaderboard-info-icon:hover {
            border-color: var(--text-secondary);
            color: var(--text-secondary);
            background: rgba(255, 255, 255, 0.05);
        }

        .leaderboard-info-icon:active {
            transform: scale(0.95);
        }

        .leaderboard-tooltip {
            position: absolute;
            left: calc(100% + 8px);
            top: 50%;
            transform: translateY(-30%);
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 11px;
            font-weight: 400;
            color: var(--text-primary);
            line-height: 1.4;
            white-space: normal;
            width: 280px;
            max-width: calc(100vw - 80px);
            text-transform: none;
            letter-spacing: normal;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10000; /* Very high z-index to appear above everything */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }

        .leaderboard-tooltip.active {
            opacity: 1;
            visibility: visible;
        }

        .leaderboard-tooltip::before {
            content: '';
            position: absolute;
            right: 100%;
            top: 20%;
            border: 6px solid transparent;
            border-right-color: var(--border-color);
        }

        .leaderboard-tooltip::after {
            content: '';
            position: absolute;
            right: 100%;
            top: 20%;
            border: 5px solid transparent;
            border-right-color: var(--bg-secondary);
            margin-right: -1px;
        }

        @media (max-width: 768px) {
            .leaderboard-tooltip {
                width: 240px;
                font-size: 10px;
                padding: 8px 12px;
            }
        }

        .ticker-content {
            overflow: hidden;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: var(--spacing-md) var(--spacing-lg);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 24px;
            font-weight: 700;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #30d158, #0a84ff);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            font-size: 22px;
            font-weight: 900;
            color: white;
            box-shadow: 0 0 20px rgba(48, 209, 88, 0.4),
                        0 0 40px rgba(10, 132, 255, 0.2);
            transition: all 0.3s ease;
        }

        .logo-icon:hover {
            animation: logoPulse 2s ease-in-out infinite;
        }

        @keyframes logoPulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(48, 209, 88, 0.4),
                            0 0 40px rgba(10, 132, 255, 0.2);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 30px rgba(48, 209, 88, 0.6),
                            0 0 60px rgba(10, 132, 255, 0.4);
                transform: scale(1.05);
            }
        }

        .logo-icon::before {
            content: '>';
            transform: scaleX(1.3);
        }

        .nav-tabs {
            display: flex;
            gap: var(--spacing-sm);
        }

        .nav-tab {
            padding: var(--spacing-sm) var(--spacing-md);
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .nav-tab:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .nav-tab.active {
            background: var(--bg-tertiary);
            color: var(--positive);
            font-weight: 700;
            position: relative;
        }

        .nav-tab.active::after {
            content: '';
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 2px;
            background: var(--positive);
            border-radius: 2px;
        }

        .upload-btn {
            padding: var(--spacing-sm) var(--spacing-md);
            background: var(--positive);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .upload-btn:hover {
            background: #28c149;
            transform: translateY(-1px);
        }

        /* ============================================
           4. TICKER
           ============================================ */

        /* Header Scoring Dropdown */
        .header-scoring-dropdown {
            position: relative;
            display: inline-block;
        }

        .header-scoring-button {
            padding: 6px 16px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-primary);
            background: var(--bg-tertiary);
            border: none;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 6px;
            position: relative;
        }

        .header-scoring-button::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 50%;
            transform: translateX(-50%);
            width: 16px;
            height: 2px;
            background: var(--positive);
            border-radius: 2px;
        }

        .header-scoring-button:hover {
            background: var(--bg-elevated);
        }

        .header-scoring-button .arrow {
            font-size: 10px;
            transition: transform 0.2s ease;
        }

        .header-scoring-dropdown.open .header-scoring-button .arrow {
            transform: rotate(180deg);
        }

        .header-scoring-menu {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: var(--bg-elevated);
            border-radius: 12px;
            padding: 6px;
            min-width: 140px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.2s ease;
            z-index: 1000;
        }

        .header-scoring-dropdown.open .header-scoring-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .header-scoring-menu button {
            width: 100%;
            padding: 10px 16px;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .header-scoring-menu button:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
        }

        .header-scoring-menu button.active {
            background: var(--positive);
            color: white;
        }

        .ticker-container {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            overflow: hidden;
            height: 40px;
            display: flex;
            align-items: center;
        }

        .ticker-track {
            display: flex;
            animation: scroll 60s linear infinite;
            white-space: nowrap;
        }

        @keyframes scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        @keyframes scrollReverse {
            0% { transform: translateX(-50%); }
            100% { transform: translateX(0%); }
        }

        .ticker-track {
            animation-duration: 540s !important;
        }

        .ticker-item {
            padding: 0 var(--spacing-lg);
            font-size: 13px;
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .ticker-item .player-name {
            font-weight: 600;
            color: var(--text-primary);
        }

        .ticker-item .avg-pts {
            color: var(--text-secondary);
        }

        .ticker-item .change {
            font-weight: 600;
        }

        .ticker-item .change.positive {
            color: var(--positive);
        }

        .ticker-item .change.negative {
            color: var(--negative);
        }

        /* ============================================
           SCORING FORMAT TOGGLE (Legacy - now in header)
           ============================================ */
        .scoring-toggle-container {
            display: none; /* Moved to header */
        }

        .scoring-toggle {
            display: inline-flex;
            background: var(--bg-tertiary);
            border-radius: 20px;
            padding: 4px;
            gap: 4px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .scoring-option {
            padding: 8px 20px;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            background: transparent;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
        }

        .scoring-option:hover {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.05);
        }

        .scoring-option.active {
            background: var(--bg-elevated);
            color: var(--text-primary);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .scoring-option.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 2px;
            background: var(--positive);
            border-radius: 2px;
        }

        /* Value update animation */
        @keyframes fadeUpdate {
            0% { opacity: 1; }
            50% { opacity: 0.4; }
            100% { opacity: 1; }
        }

        .updating-values {
            animation: fadeUpdate 0.6s ease-in-out;
        }

        /* ============================================
           5. TABLES
           ============================================ */
        .player-table {
            background: var(--bg-secondary);
            border-radius: 12px;
            overflow: hidden;
            margin-top: var(--spacing-lg);
        }

        .table-header {
            display: grid;
            grid-template-columns: 50px 60px 1fr 80px 80px 80px 100px 120px;
            gap: var(--spacing-md);
            padding: var(--spacing-md) var(--spacing-lg);
            background: var(--bg-tertiary);
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid var(--border-color);
        }

        .table-header > div {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .table-header > div:hover {
            color: var(--text-primary);
        }

        .player-row {
            display: grid;
            grid-template-columns: 50px 60px 1fr 80px 80px 80px 100px 120px;
            gap: var(--spacing-md);
            padding: var(--spacing-md) var(--spacing-lg);
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .mini-chart {
            width: 100%;
            height: 30px;
            position: relative;
        }

        .mini-chart canvas {
            width: 100% !important;
            height: 30px !important;
        }

        .player-row:hover {
            background: var(--bg-tertiary);
        }

        .player-row:last-child {
            border-bottom: none;
        }

        .player-rank {
            font-weight: 700;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .team-badge {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 700;
            color: white;
        }

        .player-info {
            display: flex;
            flex-direction: column;
        }

        .player-name-text {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* New Feature: Player Headshots */
        .player-headshot {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--bg-elevated);
            border: 2px solid var(--border-color);
            object-fit: cover;
            flex-shrink: 0;
        }

        .player-headshot.loading {
            background: linear-gradient(90deg, var(--bg-elevated) 25%, var(--bg-tertiary) 50%, var(--bg-elevated) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .player-position {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .player-stat {
            font-weight: 600;
            font-size: 14px;
        }

        .stat-change {
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 600;
            font-size: 14px;
        }

        .stat-change.positive {
            color: var(--positive);
        }

        .stat-change.negative {
            color: var(--negative);
        }

        /* ============================================
           6. CARDS
           ============================================ */
        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: var(--spacing-md);
            margin-top: var(--spacing-lg);
            justify-content: center;
        }

        .team-card {
            width: 100%;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: var(--spacing-md);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
        }

        .team-card:hover {
            transform: translateY(-2px);
            border-color: var(--border-color-light);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }

        .team-card-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-sm);
        }

        .team-card-badge {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            color: white;
        }

        .team-card-name {
            font-size: 16px;
            font-weight: 700;
        }

        .team-card-stats {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
            margin-bottom: var(--spacing-sm);
        }

        .team-stat {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            position: relative;
        }

        .team-stat:hover .stat-tooltip {
            opacity: 1;
        }

        .team-stat-label {
            color: var(--text-secondary);
            font-size: 8px;
        }

        .team-stat-value {
            font-weight: 600;
            font-size: 12px;
        }

        .team-card-chart {
            height: 140px;
            margin-top: auto;
            position: relative;
        }

        .team-card-chart canvas {
            max-height: 140px;
        }

        /* Player Cards (similar to team cards) */
        .player-card {
            width: 100%;
            max-width: 480px; /* Limit to roughly 1.5 column widths to prevent overly wide cards */
            min-height: 280px; /* Ensure consistent card height */
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: var(--spacing-lg);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
        }

        /* Player cards grid layout */
        .player-cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 20px;
            overflow: visible; /* Prevent clipping of hovered cards */
        }

        .player-card:hover {
            transform: translateY(-2px);
            border-color: var(--border-color-light);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            z-index: 10; /* Ensure hovered card appears above others */
            position: relative; /* Required for z-index to work */
        }

        .player-card-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .player-card-badge {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 700;
            color: white;
            text-align: center;
        }

        .player-card-name {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .player-card-team {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .player-tags {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 6px;
        }

        .player-tag {
            font-size: 10px;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            position: relative;
            cursor: help;
        }

        .player-tag:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            font-size: 11px;
            font-weight: 500;
            border-radius: 6px;
            white-space: nowrap;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.1);
            letter-spacing: 0;
            text-transform: none;
        }

        .player-tag:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 2px;
            border: 4px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.95);
            z-index: 1000;
        }

        .player-tag.buy-low {
            background: rgba(48, 209, 88, 0.15);
            color: #30d158;
            border: 1px solid rgba(48, 209, 88, 0.3);
        }

        .player-tag.sell-high {
            background: rgba(255, 69, 58, 0.15);
            color: #ff453a;
            border: 1px solid rgba(255, 69, 58, 0.3);
        }

        .player-tag.rz-up {
            background: rgba(255, 214, 10, 0.15);
            color: #FFD60A;
            border: 1px solid rgba(255, 214, 10, 0.3);
        }

        /* Injury Status Badge */
        .injury-badge {
            font-size: 9px;
            font-weight: 700;
            padding: 2px 6px;
            border-radius: 3px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: inline-block;
            margin-left: 6px;
            position: relative;
            cursor: help;
        }

        .injury-badge.questionable {
            background: rgba(255, 214, 10, 0.2);
            color: #FFD60A;
            border: 1px solid rgba(255, 214, 10, 0.4);
        }

        .injury-badge.doubtful {
            background: rgba(255, 149, 0, 0.2);
            color: #FF9500;
            border: 1px solid rgba(255, 149, 0, 0.4);
        }

        .injury-badge.out,
        .injury-badge.ir,
        .injury-badge.pup {
            background: rgba(255, 69, 58, 0.2);
            color: #FF453A;
            border: 1px solid rgba(255, 69, 58, 0.4);
        }

        .injury-badge.suspended,
        .injury-badge.cov {
            background: rgba(142, 142, 147, 0.2);
            color: #8E8E93;
            border: 1px solid rgba(142, 142, 147, 0.4);
        }

        .injury-badge:hover::after {
            content: attr(data-injury-details);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            font-size: 11px;
            font-weight: 500;
            border-radius: 6px;
            white-space: nowrap;
            z-index: 10000;
            border: 1px solid rgba(255, 255, 255, 0.1);
            letter-spacing: 0;
            text-transform: none;
        }

        .injury-badge:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 2px;
            border: 4px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.95);
            z-index: 10000;
        }

        .player-card-stats {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
        }

        .player-stat {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            position: relative;
        }

        /* Only show stat tooltip when hovering the label specifically */
        .player-stat-label:hover + .stat-tooltip,
        .player-stat-label:hover ~ .stat-tooltip {
            opacity: 1;
        }

        /* Alternative: show on stat hover but hide when hovering comparison area */
        .player-stat:hover .stat-tooltip {
            opacity: 1;
        }

        .player-stat:hover .player-stat-with-comparison:hover ~ .stat-tooltip,
        .player-stat-with-comparison:hover ~ .stat-tooltip {
            opacity: 0 !important; /* Hide stat tooltip when hovering comparison */
        }

        .stat-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .player-stat-label {
            color: var(--text-secondary);
        }

        .player-stat-value {
            font-weight: 600;
        }

        .player-comparison {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .comparison-icon {
            font-size: 10px;
        }

        .comparison-up {
            color: var(--positive);
        }

        .comparison-down {
            color: var(--negative);
        }

        .player-stat-with-comparison {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            position: relative;
        }

        .comparison-tooltip {
            position: absolute;
            bottom: 100%;
            right: 0; /* Position relative to comparison element */
            transform: translateY(0);
            margin-bottom: 8px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1001; /* Higher than stat-tooltip */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        /* Only show comparison tooltip when hovering the comparison element itself */
        .player-comparison:hover + .comparison-tooltip,
        .player-comparison:hover ~ .comparison-tooltip {
            opacity: 1;
        }

        .tooltip-label {
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .tooltip-data {
            font-weight: 600;
            color: var(--text-primary);
        }

        .player-card-chart {
            height: 120px;
            margin-top: auto;
            position: relative;
        }

        .player-card-chart canvas {
            max-height: 120px;
        }

        .tier-section {
            margin-bottom: var(--spacing-xl);
        }

        .tier-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
            padding-bottom: var(--spacing-md);
            border-bottom: 2px solid var(--border-color);
            cursor: pointer;
            user-select: none;
            transition: opacity 0.2s ease;
        }

        .tier-header:hover {
            opacity: 0.8;
        }

        .tier-collapse-icon {
            font-size: 14px;
            color: var(--text-secondary);
            transition: transform 0.3s ease;
            margin-left: 8px;
        }

        .tier-collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .tier-cards-container {
            overflow: hidden;
            max-height: 100000px; /* Large enough for any tier */
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 1;
        }

        .tier-cards-container.collapsed {
            max-height: 0 !important;
            opacity: 0;
        }

        .tier-badge {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tier-badge.elite {
            background: rgba(48, 209, 88, 0.2);
            color: #30d158;
        }

        .tier-badge.wr2 {
            background: rgba(10, 132, 255, 0.2);
            color: #0a84ff;
        }

        .tier-badge.flex {
            background: rgba(255, 214, 10, 0.2);
            color: #FFD60A;
        }

        .tier-badge.depth {
            background: rgba(142, 142, 147, 0.2);
            color: #8e8e93;
        }

        .tier-title {
            font-size: 20px;
            font-weight: 700;
        }

        .tier-count {
            font-size: 14px;
            color: var(--text-secondary);
            text-align: right;
            margin-left: auto;
        }

        /* ============================================
           MOMENTUM BADGES & TOP MOVERS
           ============================================ */

        /* Momentum badge next to player name */
        .momentum-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            margin-left: 4px;
            cursor: help;
            position: relative;
            transition: all 0.2s ease;
        }

        .momentum-badge.up {
            background: rgba(52, 199, 89, 0.2);
            color: #34c759;
            border: 1px solid rgba(52, 199, 89, 0.4);
        }

        .momentum-badge.down {
            background: rgba(255, 69, 58, 0.2);
            color: #ff453a;
            border: 1px solid rgba(255, 69, 58, 0.4);
        }

        .momentum-badge.neutral {
            display: none; /* Hide neutral badges */
        }

        .momentum-badge:hover {
            transform: scale(1.1);
        }

        /* Tooltip for momentum badge */
        .momentum-badge::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            font-size: 11px;
            font-weight: 500;
            border-radius: 6px;
            white-space: nowrap;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .momentum-badge:hover::after {
            opacity: 1;
        }

        .momentum-badge::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 2px;
            border: 4px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .momentum-badge:hover::before {
            opacity: 1;
        }

        /* Top Movers Sidebar Widgets */
        .top-movers-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
        }

        .top-movers-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 24px;
        }

        .top-movers-widget {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid var(--border-color);
            animation: fadeInUp 0.4s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .top-movers-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            user-select: none;
        }

        .top-movers-header:hover {
            opacity: 1; /* No hover effect since not clickable */
        }

        .top-movers-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .top-movers-title {
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .top-movers-widget.risers .top-movers-title {
            color: #28E98A;
        }

        .top-movers-widget.fallers .top-movers-title {
            color: #FF5C5C;
        }

        .top-movers-icon {
            font-size: 16px;
        }

        .top-movers-list {
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* Default to 2x2 */
            gap: 8px;
        }

        .top-mover-item {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
            padding: 10px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .top-mover-item:hover {
            background: var(--bg-elevated);
            transform: translateY(-2px);
        }

        .top-mover-rank {
            font-size: 11px;
            font-weight: 700;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .top-mover-arrow {
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 14px;
            flex-shrink: 0;
        }

        .top-movers-widget.risers .top-mover-arrow {
            color: #28E98A;
        }

        .top-movers-widget.fallers .top-mover-arrow {
            color: #FF5C5C;
        }

        .top-mover-info {
            flex: 1;
            min-width: 0;
            width: 100%;
        }

        .top-mover-name {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 2px;
        }

        .top-mover-team {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .top-mover-score {
            font-size: 13px;
            font-weight: 700;
            flex-shrink: 0;
        }

        .top-movers-widget.risers .top-mover-score {
            color: #28E98A;
        }

        .top-movers-widget.fallers .top-mover-score {
            color: #FF5C5C;
        }

        /* Top Movers Hidden/Expand */
        .top-mover-hidden {
            display: none;
        }

        .top-movers-expand-btn {
            width: 100%;
            padding: 10px;
            margin-top: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .top-movers-expand-btn:hover {
            background: var(--bg-elevated);
            border-color: var(--positive);
        }

        /* Collapsible content */
        .top-movers-content {
            max-height: 1000px;
            overflow: visible; /* Changed from hidden to allow tooltips to show */
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 1;
        }

        .top-movers-content.collapsed {
            max-height: 0;
            opacity: 0;
        }

        /* Responsive adjustments */
        @media (min-width: 1024px) {
            .top-movers-list {
                grid-template-columns: repeat(4, 1fr); /* 4 across on large screens */
            }
        }

        @media (max-width: 900px) {
            .top-movers-container {
                grid-template-columns: 1fr;
            }
        }

        /* Make player cards container position relative for absolute badges */
        .player-card {
            position: relative;
        }

        /* ============================================
           7. CHARTS
           ============================================ */
        .charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: var(--spacing-lg);
            margin-top: var(--spacing-lg);
        }

        .chart-card {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: var(--spacing-lg);
        }

        .chart-card canvas {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
        }

        .chart-header {
            margin-bottom: var(--spacing-md);
        }

        .chart-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: var(--spacing-xs);
        }

        .chart-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .chart-wrapper {
            position: relative;
            height: 400px;
        }

        /* Glow effects for team outlook charts */
        #team-pie-chart, #team-secondary-chart {
            filter: drop-shadow(0 0 15px rgba(10, 132, 255, 0.4));
        }

        /* Glow effects for scatter plots */
        #team-balance-scatter, #advanced-scatter-chart, #wr-trend-chart, #rb-trend-chart {
            filter: drop-shadow(0 0 15px rgba(10, 132, 255, 0.4));
        }

        .chart-insight {
            background: var(--bg-tertiary);
            border-left: 3px solid var(--positive);
            padding: 12px 16px;
            margin-bottom: 16px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-secondary);
        }

        .chart-insight strong {
            color: var(--text-primary);
            font-weight: 600;
        }

        /* New Feature: Trend Toggle Button */
        .trend-toggle-container {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 12px;
        }

        .trend-toggle-btn {
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .trend-toggle-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        .trend-toggle-btn.active {
            background: var(--positive-bg);
            border-color: var(--positive);
            color: var(--positive);
        }

        .trend-toggle-icon {
            font-size: 14px;
        }

        /* New: Week Indicator for Trend Animation */
        .week-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 700;
            z-index: 20;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        /* Player Evaluation Matrix | Week Scrubber Styles */
        .week-scrubber-container {
            margin-top: 16px;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .scrubber-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .scrubber-label {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .playback-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .playback-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .playback-btn:hover {
            background: var(--positive-bg);
            border-color: var(--positive);
            color: var(--positive);
        }

        .playback-btn.playing {
            background: var(--positive-bg);
            border-color: var(--positive);
            color: var(--positive);
        }

        .play-icon {
            font-size: 12px;
        }

        .week-scrubber {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, var(--positive) 0%, var(--positive) 100%, var(--bg-elevated) 100%);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        .week-scrubber::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--positive);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(48, 209, 88, 0.4);
            transition: all 0.15s ease;
        }

        .week-scrubber::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 3px 10px rgba(48, 209, 88, 0.6);
        }

        .week-scrubber::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--positive);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(48, 209, 88, 0.4);
            transition: all 0.15s ease;
        }

        .week-scrubber::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 3px 10px rgba(48, 209, 88, 0.6);
        }

        /* New Feature: Quadrant Highlighting */
        .quadrant-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .quadrant-highlight {
            position: absolute;
            border: 2px solid var(--positive);
            border-radius: 8px;
            background: rgba(48, 209, 88, 0.05);
            animation: pulseHighlight 2s infinite;
            pointer-events: none;
        }

        @keyframes pulseHighlight {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.02); }
        }

        .highlighted-player {
            filter: drop-shadow(0 0 12px var(--positive));
            animation: glowPlayer 2s infinite;
        }

        @keyframes glowPlayer {
            0%, 100% { filter: drop-shadow(0 0 10px var(--positive)); }
            50% { filter: drop-shadow(0 0 18px var(--positive)); }
        }

        .chart-wrapper {
            position: relative;
        }

        /* Quadrant labels removed - now using chart annotations */

        /* ============================================
           7. SENTIMENT & VOTING
           ============================================ */
        .sentiment-bar-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
        }

        .sentiment-bar {
            flex: 1;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
            display: flex;
            position: relative;
        }

        .sentiment-bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            position: absolute;
            top: 0;
            left: 0;
        }

        .sentiment-bar-buy {
            background: var(--positive);
            z-index: 2;
        }

        .sentiment-bar-sell {
            background: var(--negative);
            z-index: 1;
            width: 100% !important;
        }

        /* 3-Section Sentiment Bar */
        .sentiment-segment-buy {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }

        .sentiment-segment-hold {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
        }

        .sentiment-segment-sell {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }

        .sentiment-label {
            font-size: 11px;
            color: var(--text-secondary);
            min-width: 45px;
            text-align: right;
        }

        .vote-buttons {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .vote-btn {
            flex: 1;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .vote-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        .vote-btn.active {
            border-color: currentColor;
        }

        .vote-btn.buy-btn {
            color: var(--positive);
        }

        .vote-btn.buy-btn.active {
            background: var(--positive-bg);
        }

        .vote-btn.sell-btn {
            color: var(--negative);
        }

        .vote-btn.sell-btn.active {
            background: var(--negative-bg);
        }

        .vote-btn.hold-btn.active {
            background: rgba(142, 142, 147, 0.15);
        }

        .vote-count {
            font-size: 11px;
            opacity: 0.7;
        }

        .signal-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .signal-tag.positive {
            background: var(--positive-bg);
            color: var(--positive);
        }

        .signal-tag.neutral {
            background: rgba(142, 142, 147, 0.15);
            color: var(--text-secondary);
        }

        .signal-tag.opportunity {
            background: rgba(10, 132, 255, 0.15);
            color: #0a84ff;
        }

        .comment-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .comment-header {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-primary);
        }

        .comment-input-container {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .comment-input {
            flex: 1;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
            font-family: inherit;
        }

        .comment-input:focus {
            outline: none;
            border-color: var(--positive);
        }

        .comment-submit {
            padding: 8px 16px;
            background: var(--positive);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
        }

        .comment-submit:hover {
            background: #28c149;
        }

        .comment-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .comment-item {
            padding: 10px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 13px;
            line-height: 1.4;
        }

        .comment-meta {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        /* ============================================
           8. MODAL
           ============================================ */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.2s ease;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: 16px;
            width: 90%;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .modal-header {
            padding: var(--spacing-lg);
            border-bottom: 1px solid var(--border-color);
        }

        .modal-player-info {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .modal-team-badge {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 700;
            color: white;
        }

        .modal-player-details {
            flex: 1;
        }

        .modal-player-name {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .modal-player-meta {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .modal-close {
            background: var(--bg-tertiary);
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        .modal-stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--spacing-md);
        }

        .modal-stat-box {
            background: var(--bg-tertiary);
            padding: var(--spacing-md);
            border-radius: 8px;
            text-align: center;
            position: relative;
            cursor: help;
        }

        .modal-stat-box:hover {
            background: var(--bg-elevated);
        }

        .modal-stat-box:hover .stat-tooltip {
            opacity: 1;
        }

        .modal-stat-box .stat-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            color: var(--text-primary);
            min-width: 200px;
            white-space: normal;
            text-align: center;
            line-height: 1.4;
        }

        .modal-stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .modal-stat-value {
            font-size: 24px;
            font-weight: 700;
        }

        .modal-stat-subvalue {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 2px;
            font-weight: 400;
        }

        .modal-body {
            padding: var(--spacing-lg);
        }

        .chart-tabs {
            display: flex;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-lg);
            border-bottom: 1px solid var(--border-color);
        }

        .chart-tab {
            padding: var(--spacing-md);
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s ease;
        }

        .chart-tab:hover {
            color: var(--text-primary);
        }

        .chart-tab.active {
            color: var(--text-primary);
            border-bottom-color: var(--positive);
        }

        .chart-content {
            display: none;
        }

        .chart-content.active {
            display: block;
        }

        .modal-chart-wrapper {
            position: relative;
            height: 350px;
        }

        /* ============================================
           10. UPLOAD SECTION
           ============================================ */
        .upload-section {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: var(--spacing-xl);
            text-align: center;
            margin-top: var(--spacing-lg);
        }

        .upload-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
        }

        .upload-subtitle {
            color: var(--text-secondary);
            margin-bottom: var(--spacing-lg);
        }

        .upload-buttons {
            display: flex;
            gap: var(--spacing-md);
            justify-content: center;
            flex-wrap: wrap;
        }

        .upload-file-btn {
            padding: var(--spacing-md) var(--spacing-lg);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 2px dashed var(--border-color-light);
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
        }

        .upload-file-btn:hover {
            border-color: var(--positive);
            background: var(--bg-elevated);
        }

        input[type="file"] {
            display: none;
        }

        .data-status {
            margin-top: var(--spacing-lg);
            padding: var(--spacing-md);
            background: var(--positive-bg);
            border-radius: 8px;
            color: var(--positive);
            font-weight: 600;
        }

        /* ============================================
           11. RESPONSIVE
           ============================================ */

        /* Large tablets and small laptops (3 columns) */
        @media (max-width: 1200px) {
            .cards-grid {
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            }
        }

        /* Tablets (2 columns) */
        @media (max-width: 900px) {
            .cards-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }
        }

        /* Mobile (2 columns, smaller cards) */
        @media (max-width: 768px) {
            .nav-tabs {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .table-header,
            .player-row {
                grid-template-columns: 40px 50px 1fr 70px;
                font-size: 12px;
            }

            .table-header > div:nth-child(5),
            .table-header > div:nth-child(6),
            .table-header > div:nth-child(7),
            .table-header > div:nth-child(8),
            .player-row > div:nth-child(5),
            .player-row > div:nth-child(6),
            .player-row > div:nth-child(7),
            .player-row > div:nth-child(8) {
                display: none;
            }

            .modal-stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .charts-container {
                grid-template-columns: 1fr;
            }

            .movers-container {
                grid-template-columns: 1fr;
            }

            .cards-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }

            /* REFACTORED: Better mobile support for new features */
            .player-headshot {
                width: 28px;
                height: 28px;
                font-size: 10px;
            }

            .chart-wrapper {
                height: 300px !important; /* Shorter charts on mobile */
            }

            .trend-toggle-btn {
                font-size: 11px;
                padding: 4px 8px;
            }

            .signal-tag {
                font-size: 9px;
                padding: 3px 6px;
            }

            /* Mobile Modal Optimizations */
            .modal-overlay {
                padding: 10px;
            }

            .modal-header {
                padding: 16px;
            }

            .modal-title {
                font-size: 18px;
            }

            .modal-subtitle {
                font-size: 12px;
            }

            .modal-body {
                padding: 16px;
                max-height: calc(90vh - 120px);
                overflow-y: auto;
            }

            .modal-stat-box {
                padding: 10px;
            }

            .modal-stat-label {
                font-size: 10px;
            }

            .modal-stat-value {
                font-size: 18px;
            }

            .modal-stat-change {
                font-size: 11px;
            }

            /* Mobile Sentiment in Modal */
            .sentiment-card {
                padding: 12px;
            }

            .sentiment-percentage {
                font-size: 28px;
            }

            .sentiment-label {
                font-size: 11px;
            }

            .sentiment-breakdown {
                font-size: 10px;
            }

            /* Mobile - Reconfigure Horizontal Sentiment Bar */
            .modal-body > div[style*="display: flex"][style*="gap: 20px"] {
                flex-direction: column !important;
                gap: 12px !important;
                padding: 12px 16px !important;
            }

            /* Sentiment Label Section */
            .modal-body > div[style*="display: flex"] > div[style*="flex-shrink: 0"]:first-child {
                display: flex;
                justify-content: space-between;
                align-items: center;
                width: 100%;
            }

            /* Make sentiment text smaller for mobile (fits better) */
            #modal-sentiment-compact {
                font-size: 18px !important;
            }

            /* Bigger sentiment bar on mobile - ensure parent container doesn't hide it */
            .modal-body > div[style*="display: flex"] > div[style*="flex: 1"] {
                display: block !important;
            }

            .sentiment-bar {
                height: 40px !important;
                margin: 8px 0 !important;
                display: block !important;
            }

            /* Vote buttons full width on mobile */
            .vote-buttons {
                width: 100% !important;
                justify-content: space-between !important;
            }

            .vote-btn {
                flex: 1 !important;
                padding: 10px 8px !important;
                font-size: 12px !important;
            }

            /* Mobile Swipeable Stats Grid */
            .modal-stats-container {
                position: relative;
                overflow: hidden;
                margin-top: 20px;
            }

            .modal-stats-wrapper {
                display: flex;
                transition: transform 0.3s ease;
                touch-action: pan-y;
            }

            .modal-stats-page {
                min-width: 100%;
                flex-shrink: 0;
            }

            .modal-stats-grid {
                grid-template-columns: repeat(2, 1fr) !important;
                gap: 12px !important;
            }

            /* Stats Page Dots */
            .stats-dots {
                display: flex;
                justify-content: center;
                gap: 8px;
                margin-top: 16px;
                padding-bottom: 8px;
            }

            .stats-dot {
                width: 8px;
                height: 8px;
                border-radius: 50%;
                background: #6b7280;
                opacity: 0.5;
                transition: all 0.3s ease;
                cursor: pointer;
            }

            .stats-dot.active {
                opacity: 1;
                background: #10b981;
                transform: scale(1.2);
            }

            /* Mobile Chart Tabs */
            .chart-tabs {
                gap: 6px;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .chart-tab {
                padding: 6px 12px;
                font-size: 11px;
                white-space: nowrap;
            }

            /* Mobile Tooltips - Keep near element but prevent off-screen */
            [data-tooltip]::after,
            .stat-tooltip,
            .comparison-tooltip,
            .ticker-tooltip,
            .leaderboard-tooltip,
            .player-tag:hover::after,
            .injury-badge:hover::after,
            .momentum-badge:hover::after {
                position: absolute !important;
                left: auto !important;
                right: auto !important;
                transform: translateX(-50%) !important;
                max-width: min(200px, 90vw) !important;
                white-space: normal !important;
                text-align: center !important;
                margin-left: 0 !important;
                margin-right: 0 !important;
            }

            /* Remove the fixed positioning override */
            .tooltip,
            [class*="tooltip"]:not(.stat-tooltip):not(.comparison-tooltip):not(.ticker-tooltip):not(.leaderboard-tooltip) {
                max-width: min(250px, 90vw) !important;
            }

            /* Top Movers Info Icon - Prevent Leaking Through Menu */
            .ticker-info-icon {
                z-index: 100 !important; /* Lower than mobile menu */
            }

            .ticker-tooltip {
                z-index: 101 !important; /* Lower than mobile menu */
            }

            /* Ensure hamburger menu is above everything */
            .mobile-nav-toggle {
                z-index: 10001 !important;
            }

            .nav-tabs {
                z-index: 10000 !important;
            }
        }

        /* ============================================
           COLLAPSIBLE DIVISIONS
           ============================================ */
        .division-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            margin-bottom: 16px;
            overflow: hidden;
        }

        .division-header {
            padding: 16px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background 0.2s ease;
            user-select: none;
        }

        .division-header:hover {
            background: var(--bg-tertiary);
        }

        .division-title {
            font-size: 15px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .division-arrow {
            font-size: 12px;
            color: var(--text-secondary);
            transition: transform 0.3s ease;
        }

        .division-arrow.expanded {
            transform: rotate(180deg);
        }

        .division-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }

        .division-content.expanded {
            max-height: 1000px;
            padding: 0 20px 20px 20px;
        }

        .division-teams-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 12px;
        }

        .division-team-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .division-team-card:hover {
            background: var(--bg-elevated);
            border-color: var(--positive);
        }

        .division-team-logo {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--bg-elevated);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 14px;
            color: white;
        }

        .division-team-info {
            flex: 1;
        }

        .division-team-name {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .division-team-stats {
            font-size: 11px;
            color: var(--text-secondary);
        }

        /* ============================================
           12. UTILITIES
           ============================================ */
        .hidden {
            display: none !important;
        }

        .loading {
            text-align: center;
            padding: var(--spacing-xl);
            color: var(--text-secondary);
        }

        .empty-state {
            text-align: center;
            padding: var(--spacing-xl);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: var(--spacing-md);
        }

        .empty-state-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
        }

        .empty-state-subtitle {
            color: var(--text-secondary);
        }

        /* Matrix tabs styling */
        .matrix-tab {
            transition: all 0.2s ease;
        }

        .matrix-tab:hover {
            background: var(--bg-elevated) !important;
        }

        .matrix-tab.active {
            background: var(--positive) !important;
            color: white !important;
        }

        .matrix-chart-tab {
            transition: all 0.2s ease;
        }

        .matrix-chart-tab:hover {
            color: var(--text-primary) !important;
        }

        .matrix-chart-tab.active {
            color: var(--text-primary) !important;
            border-bottom-color: var(--positive) !important;
        }

        .matrix-section {
            animation: fadeIn 0.3s ease;
        }

        .matrix-chart-content {
            animation: fadeIn 0.3s ease;
        }
        /* ============================================
           CATEGORY CARDS (Dashboard)
           ============================================ */
        /* Dashboard Header Widgets */
        .dashboard-header-widgets {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 16px;
        }

        .dashboard-widget {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            overflow: hidden;
        }

        .widget-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            background: var(--bg-tertiary);
        }

        .mover-filter-btns {
            display: flex;
            gap: 4px;
        }

        .filter-btn {
            padding: 6px 12px;
            font-size: 11px;
            font-weight: 600;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .filter-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        .filter-btn.active {
            background: var(--positive);
            color: white;
            border-color: var(--positive);
        }

        .widget-title {
            font-size: 13px;
            font-weight: 700;
            color: var(--text-primary);
        }

        /* Expand button */
        .expand-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            line-height: 1;
        }

        .expand-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
            border-color: var(--positive);
        }

        /* Expanded state for charts */
        .dashboard-widget.expanded {
            grid-column: span 2 !important;
        }

        .dashboard-widget.collapsed {
            display: none;
        }

        .dashboard-widget.expanded .expand-btn {
            background: var(--positive);
            color: white;
            border-color: var(--positive);
        }

        .widget-body {
            padding: 16px;
        }

        /* Full Width Stat of the Week Widget */
        .stat-widget-full {
            margin-bottom: 24px;
        }

        .stat-widget-full .widget-body {
            padding: 16px 24px;
        }

        .stat-highlight-horizontal {
            display: flex;
            align-items: center;
            gap: 24px;
        }

        .stat-highlight-horizontal .stat-highlight-value {
            font-size: 48px;
            font-weight: 900;
            background: linear-gradient(135deg, #30d158, #0a84ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            flex-shrink: 0;
        }

        .stat-highlight-content {
            flex: 1;
        }

        .stat-highlight-horizontal .stat-highlight-label {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .stat-highlight-horizontal .stat-highlight-text {
            font-size: 13px;
            line-height: 1.5;
            color: var(--text-secondary);
        }

        .stat-highlight-horizontal .stat-highlight-text strong {
            color: var(--positive);
            font-weight: 700;
        }

        /* Insight Navigation Buttons */
        .insight-nav-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            width: 28px;
            height: 28px;
            border-radius: 6px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            padding: 0;
            line-height: 1;
        }

        .insight-nav-btn:hover {
            background: var(--bg-elevated);
            border-color: var(--text-tertiary);
            transform: translateY(-1px);
        }

        .insight-nav-btn:active {
            transform: translateY(0);
        }

        /* Legacy vertical stat styling */
        .stat-highlight {
            text-align: center;
        }

        .stat-highlight-value {
            font-size: 32px;
            font-weight: 900;
            background: linear-gradient(135deg, #30d158, #0a84ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 4px;
        }

        .stat-highlight-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .stat-highlight-text {
            font-size: 11px;
            line-height: 1.5;
            color: var(--text-secondary);
        }

        .stat-highlight-text strong {
            color: var(--positive);
            font-weight: 700;
        }

        /* Trend Widget */
        .trend-widget {
            display: flex;
            flex-direction: column;
        }

        .trend-widget .widget-body {
            padding: 12px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .dashboard-chart-wrapper {
            flex: 1;
            min-height: 220px;
            position: relative;
        }

        .dashboard-chart-wrapper canvas {
            width: 100% !important;
            height: 100% !important;
        }

        .dashboard-scrubber {
            margin-top: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .scrubber-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            min-width: 80px;
        }

        .dashboard-scrubber .week-scrubber {
            flex: 1;
        }

        .playback-btn-small {
            width: 28px;
            height: 28px;
            background: var(--positive);
            border: none;
            border-radius: 4px;
            color: #000;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .playback-btn-small:hover {
            background: #28c149;
        }

        .playback-btn-small.playing {
            background: var(--negative);
        }

        /* Categories Section */
        .categories-section {
            margin: 16px 0;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            max-height: none; /* Remove height restriction */
            overflow: visible; /* Allow full height */
            padding-right: 8px;
        }

        /* Override grid when carousel is present */
        .categories-section:has(.categories-carousel-container) {
            display: block;
            padding-right: 0;
        }

        /* Custom scrollbar for categories section */
        .categories-section::-webkit-scrollbar {
            width: 8px;
        }

        .categories-section::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        .categories-section::-webkit-scrollbar-thumb {
            background: var(--bg-elevated);
            border-radius: 4px;
        }

        .categories-section::-webkit-scrollbar-thumb:hover {
            background: var(--border-color-light);
        }

        .category-row {
            margin-bottom: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
        }

        /* Categories Carousel */
        .categories-carousel-container {
            position: relative;
            margin-bottom: 0;
            margin-top: -24px; /* Closer to header */
            min-height: 340px; /* Reduced for tighter spacing */
            overflow: hidden; /* Clip carousel to container width - critical for alignment */
            width: 100%; /* Stay within parent container */
            max-width: 100%; /* Enforce boundary */
        }

        .categories-carousel-scroll {
            display: flex;
            gap: 20px;
            overflow: visible; /* Allow items to exist but container clips them */
            scrollbar-width: none;
            -ms-overflow-style: none;
            padding: 20px 0;  /* Vertical padding only - no horizontal padding */
            margin: 0;        /* No margins that could push beyond bounds */
            animation: scrollReverse 240s linear infinite;
            white-space: nowrap;
            width: fit-content; /* Only as wide as content */
        }

        .categories-carousel-scroll:hover {
            animation-play-state: paused; /* Pause animation on hover */
        }

        .categories-carousel-scroll::-webkit-scrollbar {
            display: none;
        }

        .category-carousel-item {
            flex: 0 0 calc(50% - 10px);
            scroll-snap-align: start;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 10px;
            min-width: 360px;
            max-width: 400px;
            min-height: 280px; /* Further reduced for tighter fit */
            overflow: visible; /* Show all content */
        }

        .carousel-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color);
            width: 48px;
            height: 48px;
            border-radius: 50%;
            font-size: 28px;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .carousel-nav:hover {
            background: var(--text-primary);
            color: var(--bg-primary);
            transform: translateY(-50%) scale(1.1);
        }

        .carousel-nav-left {
            left: 10px;
        }

        .carousel-nav-right {
            right: 10px;
        }

        /* Category Footnote */
        .category-footnote {
            margin-top: 16px;
            text-align: center;
        }

        .footnote-toggle {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 16px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .footnote-toggle:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        .footnote-content {
            margin-top: 12px;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 11px;
            line-height: 1.6;
            color: var(--text-secondary);
            text-align: left;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        /* Team Modal Enhancements */
        .team-stat-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            transition: all 0.2s ease;
        }

        .team-stat-card:hover {
            transform: translateY(-2px);
            border-color: var(--border-color-light);
        }

        .team-stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .team-stat-label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .team-stats-summary {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }

        .key-player-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .key-player-card:hover {
            transform: translateY(-2px);
            border-color: var(--positive);
            background: var(--bg-elevated);
        }

        .key-player-position {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            color: white;
            flex-shrink: 0;
        }

        .key-player-info {
            flex: 1;
        }

        .key-player-name {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .key-player-stat {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 2px solid var(--border-color);
        }

        .category-title {
            font-size: 16px;
            font-weight: 700;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 6px;
            letter-spacing: 0.3px;
        }

        .category-icon {
            font-size: 18px;
            filter: brightness(1.2);
        }

        .category-expand-btn {
            padding: 6px 12px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .category-expand-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-color: var(--border-color-light);
        }

        .category-cards-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 4px;
            margin-top: 6px;
            max-height: none; /* Remove any height restrictions */
            overflow: visible; /* Ensure all cards are visible */
        }

        /* Category rank - simple text on right */
        .category-rank-simple {
            font-size: 14px;
            font-weight: 700;
            color: var(--text-secondary);
            flex-shrink: 0;
        }

        /* Make dashboard category cards very compact */
        .category-cards-container .player-card {
            padding: 4px;
            position: relative;
            margin-bottom: 0;
            min-height: 38px !important; /* Override base min-height for tight fit */
            height: auto;
        }

        .category-cards-container .player-card-header {
            margin-bottom: 0;
            gap: 8px;
        }

        .category-cards-container .player-card-badge {
            width: 28px;
            height: 28px;
            font-size: 9px;
        }

        .category-cards-container .player-card-name {
            font-size: 12px;
            line-height: 1.2;
        }

        .category-cards-container .player-card-team {
            font-size: 10px;
            margin-top: 0;
        }

        .category-cards-container .player-card-stats {
            gap: 4px;
            margin-bottom: 0;
            display: grid;
            grid-template-columns: 1fr 1fr;
        }

        .category-cards-container .player-stat {
            font-size: 10px;
            justify-content: flex-start;
            gap: 2px;
            position: relative;
        }

        /* Show tooltip only when hovering over the info icon */
        .category-info-icon:hover .stat-tooltip {
            opacity: 1;
        }

        /* Show tooltip when hovering over stat value */
        .category-cards-container .player-stat-value:hover .stat-tooltip {
            opacity: 1;
        }

        /* Show change tooltip when hovering over comparison */
        .category-cards-container .player-comparison:hover .change-tooltip {
            opacity: 1;
        }

        /* Also show tooltip on hover of comparison span inside */
        .category-cards-container .player-comparison span:hover .change-tooltip {
            opacity: 1;
        }

        .category-cards-container .player-stat-label {
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .category-cards-container .player-stat-value {
            font-size: 12px;
            font-weight: 700;
        }

        .category-cards-container .player-comparison {
            font-size: 12px;
        }

        .category-cards-container .player-card-chart {
            display: none;
        }

        /* Enable tooltips on category cards with proper styling */
        .category-cards-container .stat-tooltip {
            font-size: 10px;
            white-space: normal;
            max-width: 200px;
            z-index: 2000;
            line-height: 1.4;
        }

        .category-cards-container .comparison-tooltip {
            display: none; /* Keep comparison tooltips hidden for cleaner UI */
        }

        /* Change tooltip for leaderboard cards */
        .change-tooltip {
            position: absolute;
            bottom: 100%;
            right: 0;
            transform: translateY(0);
            margin-bottom: 8px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 10px;
            white-space: normal;
            max-width: 180px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 2001;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            line-height: 1.4;
        }

        .player-comparison:hover .change-tooltip {
            opacity: 1;
        }

        /* Compact player cards for all-leaderboards page */
        .compact-player-card:hover {
            background: var(--bg-elevated);
            border-color: var(--border-color-light);
            transform: translateY(-1px);
        }

        .compact-player-card .player-comparison:hover .change-tooltip {
            opacity: 1;
        }

        .compact-metric-value:hover .stat-tooltip {
            opacity: 1;
        }

        /* Portal-style tooltip */
        #portal-tooltip {
            position: fixed;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 11px;
            line-height: 1.5;
            color: var(--text-primary);
            max-width: 280px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s ease;
            z-index: 99999;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
        }

        #portal-tooltip.visible {
            opacity: 1;
        }

        #portal-tooltip .tooltip-secondary {
            color: var(--text-tertiary);
            margin-top: 6px;
            display: block;
            font-size: 10px;
        }

        /* Horizontal bar for leaderboard metrics */
        .metric-bar-container {
            position: relative;
            width: 100%;
            height: 10px;
            margin-top: 4px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.05);
            overflow: hidden;
        }

        .metric-bar {
            height: 100%;
            border-radius: 5px;
            transition: width 0.6s ease;
        }

        /* Category card specific styles - Using player-card base styles */
        /* Rank badges handled inline in renderCategoryCard */

        /* Expanded state */
        .category-cards-expanded {
            grid-template-columns: 1fr;
        }

        .category-card-hidden {
            display: none;
        }

        /* ============================================
           ADVANCED ANALYTICS STYLES
           ============================================ */
        .advanced-analytics-container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .advanced-header {
            margin-bottom: 32px;
        }

        .advanced-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .advanced-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .position-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 24px;
            padding: 4px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            width: fit-content;
        }

        .position-toggle-btn {
            padding: 10px 24px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .position-toggle-btn.active {
            background: var(--bg-secondary);
            color: var(--text-primary);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .preset-section {
            margin-bottom: 24px;
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .preset-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 8px;
        }

        .preset-btn {
            padding: 10px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color-light);
            color: var(--text-primary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
            white-space: nowrap;
            text-align: center;
        }

        .preset-btn:hover {
            background: var(--bg-elevated);
            border-color: var(--positive);
            transform: translateY(-1px);
        }

        .preset-btn:active {
            transform: translateY(0);
        }

        .axis-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-bottom: 32px;
        }

        .axis-control {
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        /* Subtle pulse animation for axis labels */
        @keyframes subtle-pulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(10, 132, 255, 0);
            }
            50% {
                box-shadow: 0 0 8px 2px rgba(10, 132, 255, 0.3);
            }
        }

        .axis-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
            padding: 8px 12px;
            margin: -8px -12px 4px -12px;
            border-radius: 8px;
            transition: all 0.3s ease;
            animation: subtle-pulse 3s ease-in-out infinite;
        }

        .axis-label:hover {
            background: var(--bg-secondary);
            color: var(--accent);
            animation: none;
        }

        /* Non-clickable labels (for Highlight Player, Week Range) - no animations */
        .axis-label-static {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
        }

        .axis-label-text {
            flex: 1;
        }

        .axis-collapse-icon {
            font-size: 14px;
            transition: transform 0.2s ease;
            color: var(--text-tertiary);
        }

        .axis-collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .axis-control-content {
            max-height: 200px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 1;
        }

        .axis-control-content.collapsed {
            max-height: 0;
            opacity: 0;
        }

        .axis-select {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .axis-select:hover {
            border-color: var(--positive);
        }

        .axis-select:focus {
            outline: none;
            border-color: var(--positive);
            box-shadow: 0 0 0 3px rgba(48, 209, 88, 0.1);
        }

        .scatter-chart-card {
            background: var(--bg-tertiary);
            border-radius: 16px;
            padding: 24px;
            border: 1px solid var(--border-color);
        }

        .scatter-chart-header {
            margin-bottom: 20px;
        }

        .scatter-chart-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .scatter-chart-description {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        .scatter-chart-description strong {
            color: var(--text-primary);
            font-weight: 600;
        }

        .scatter-chart-wrapper {
            position: relative;
            height: 600px;
        }

        /* ============================================
           FOOTER
           ============================================ */
        .footer {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 48px 24px 24px;
            margin-top: 80px;
        }

        .footer-content {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 2fr 1fr 1fr;
            gap: 48px;
        }

        .footer-section h3 {
            font-size: 14px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 16px;
            letter-spacing: 0.5px;
        }

        .footer-section p {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 16px;
        }

        .waitlist-form {
            display: flex;
            gap: 8px;
            margin-top: 16px;
        }

        .waitlist-input {
            flex: 1;
            padding: 10px 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 13px;
            transition: all 0.2s ease;
        }

        .waitlist-input:focus {
            outline: none;
            border-color: #0a84ff;
            background: var(--bg-elevated);
        }

        .waitlist-input::placeholder {
            color: var(--text-tertiary);
        }

        .waitlist-btn {
            padding: 10px 20px;
            background: var(--positive);
            border: none;
            border-radius: 8px;
            color: #fff;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .waitlist-btn:hover {
            background: #2dc14e;
            transform: translateY(-1px);
        }

        .waitlist-btn:active {
            transform: translateY(0);
        }

        .footer-links {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .footer-link {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 13px;
            transition: color 0.2s ease;
        }

        .footer-link:hover {
            color: var(--text-primary);
        }

        .footer-bottom {
            max-width: 1400px;
            margin: 32px auto 0;
            padding-top: 24px;
            border-top: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 12px;
            color: var(--text-tertiary);
        }

        .footer-logo {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 16px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .footer-logo-icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #30d158, #0a84ff);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 900;
            color: white;
            box-shadow: 0 0 15px rgba(48, 209, 88, 0.3),
                        0 0 30px rgba(10, 132, 255, 0.15);
        }

        .footer-logo-icon::before {
            content: '>';
            transform: scaleX(1.3);
        }

        .footer-copyright {
            flex: 1;
            text-align: center;
        }

        .success-message {
            padding: 10px 14px;
            background: var(--positive-bg);
            border: 1px solid var(--positive);
            border-radius: 8px;
            color: var(--positive);
            font-size: 13px;
            margin-top: 8px;
            display: none;
        }

        .success-message.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        /* Waitlist Confirmation Modal */
        .waitlist-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(4px);
        }

        .waitlist-modal.show {
            display: flex;
            animation: fadeIn 0.3s ease;
        }

        .waitlist-modal-content {
            background: var(--bg-elevated);
            border-radius: 16px;
            padding: 32px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            border: 1px solid var(--border-color-light);
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .waitlist-modal-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .waitlist-modal-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .waitlist-modal-message {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 24px;
            line-height: 1.5;
        }

        .waitlist-modal-btn {
            padding: 12px 32px;
            background: var(--positive);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .waitlist-modal-btn:hover {
            background: #28c149;
            transform: translateY(-1px);
        }

        @media (max-width: 768px) {
            .footer-content {
                grid-template-columns: 1fr;
                gap: 32px;
            }

            /* Mobile carousel - swipeable, one card at a time */
            .category-carousel-item {
                flex: 0 0 100%;
                min-width: calc(100vw - 80px);
                max-width: calc(100vw - 80px);
                scroll-snap-align: center;
            }

            .categories-carousel-container {
                overflow-x: scroll;
                overflow-y: hidden;
                scroll-snap-type: x mandatory;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
                -ms-overflow-style: none;
                scroll-behavior: smooth;
                touch-action: pan-x;
            }

            .categories-carousel-container::-webkit-scrollbar {
                display: none;
            }

            .categories-carousel-scroll {
                animation: none !important; /* Disable auto-scroll on mobile */
                gap: 20px;
                padding: 20px 40px;
                display: flex;
                width: auto;
            }
        }

        @media (min-width: 769px) {
            .category-carousel-item {
                flex: 0 0 calc(50% - 10px);
                min-width: 360px;
                max-width: 400px;
            }
        }

        /* ============================================
           MOBILE HAMBURGER MENU
           ============================================ */
        .mobile-menu-button {
            display: none; /* Hidden on desktop */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 40px;
            height: 40px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 10002; /* Above everything including tooltips */
            position: relative;
        }

        .mobile-menu-button:hover {
            background: var(--bg-elevated);
        }

        .hamburger-line {
            width: 20px;
            height: 2px;
            background: var(--text-primary);
            margin: 3px 0;
            transition: all 0.3s ease;
        }

        .mobile-menu-button.active .hamburger-line:nth-child(1) {
            transform: rotate(45deg) translate(6px, 6px);
        }

        .mobile-menu-button.active .hamburger-line:nth-child(2) {
            opacity: 0;
        }

        .mobile-menu-button.active .hamburger-line:nth-child(3) {
            transform: rotate(-45deg) translate(6px, -6px);
        }

        .mobile-menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000; /* Above tooltips but below menu button */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .mobile-menu-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .mobile-menu {
            position: fixed;
            top: 0;
            right: -100%;
            width: 280px;
            height: 100vh;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            z-index: 10001; /* Above overlay and tooltips */
            padding: 24px;
            overflow-y: auto;
            transition: right 0.3s ease;
        }

        .mobile-menu.active {
            right: 0;
        }

        .mobile-menu-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 32px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .mobile-menu-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .mobile-menu-close {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .mobile-menu-close:hover {
            background: var(--bg-elevated);
        }

        .mobile-menu-items {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .mobile-menu-item {
            padding: 14px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }

        .mobile-menu-item:hover {
            background: var(--bg-elevated);
            border-color: var(--positive);
        }

        .mobile-menu-item.active {
            background: var(--positive-bg);
            border-color: var(--positive);
            color: var(--positive);
        }

        .mobile-menu-divider {
            height: 1px;
            background: var(--border-color);
            margin: 16px 0;
        }

        .mobile-menu-waitlist {
            margin-top: 16px;
            padding: 14px 16px;
            background: var(--positive);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
        }

        .mobile-menu-waitlist:hover {
            background: #28c149;
            transform: translateY(-1px);
        }

        /* Carousel Pagination Dots (Mobile) */
        .carousel-dots {
            display: none; /* Hidden on desktop */
            justify-content: center;
            gap: 8px;
            padding: 16px 0;
            margin-top: -16px;
        }

        .carousel-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-tertiary);
            opacity: 0.3;
            transition: all 0.3s ease;
            cursor: pointer; /* Make dots clickable */
        }

        .carousel-dot:hover {
            opacity: 0.6; /* Hover feedback */
        }

        .carousel-dot.active {
            width: 24px;
            border-radius: 4px;
            background: var(--positive);
            opacity: 1;
        }

        @media (max-width: 768px) {
            .carousel-dots {
                display: flex;
            }
        }

        /* ============================================
           MOBILE RESPONSIVE
           ============================================ */
        @media (max-width: 1024px) {
            .main-content {
                padding: var(--spacing-md);
            }

            .player-cards-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 16px;
            }
        }

        @media (max-width: 768px) {
            .header {
                padding: 12px 16px;
            }

            .logo {
                font-size: 18px;
            }

            /* Hide desktop navigation on mobile */
            .nav-tabs {
                display: none;
            }

            /* Show scoring dropdown and hamburger on mobile, hide join waitlist */
            .header-right-section {
                display: flex !important;
            }

            .header-right-section .upload-btn {
                display: none !important;
            }

            .header-right-section .header-scoring-dropdown {
                display: block !important;
            }

            /* Show hamburger menu button */
            .mobile-menu-button {
                display: flex !important;
            }

            .nav-tab {
                padding: 8px 12px;
                font-size: 12px;
                flex-shrink: 0;
            }

            .upload-btn {
                padding: 8px 14px;
                font-size: 12px;
            }

            .main-content {
                padding: 16px;
                overflow-x: hidden;
                max-width: 100vw;
            }

            .page-title {
                font-size: 20px;
            }

            .page-subtitle {
                font-size: 13px;
            }

            .player-cards-grid {
                grid-template-columns: repeat(2, 1fr) !important;
                gap: 12px;
                max-width: 100%;
                overflow: hidden;
            }

            .player-card {
                padding: 12px;
                max-width: 100%;
                overflow: hidden;
                box-sizing: border-box;
            }

            /* Compact player card elements for 2-column layout */
            .player-card-badge {
                width: 40px;
                height: 40px;
                font-size: 10px;
            }

            .player-card-name {
                font-size: 14px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            .player-card-team {
                font-size: 11px;
            }

            .player-card-header {
                gap: 10px;
                margin-bottom: 10px;
            }

            .stat-value {
                font-size: 18px;
            }

            .stat-label {
                font-size: 10px;
            }

            .player-tags {
                gap: 4px;
            }

            .player-tag {
                font-size: 9px;
                padding: 2px 6px;
            }

            .teams-grid {
                grid-template-columns: 1fr;
            }

            /* Team Analysis Controls - 2x2 on mobile */
            .team-analysis-controls {
                grid-template-columns: repeat(2, 1fr) !important;
            }

            /* Stack team charts on mobile - pie on top, bar below */
            #team-charts-container {
                grid-template-columns: 1fr !important;
                min-height: auto !important;
            }

            /* Make scatter plot more readable on mobile */
            #team-balance-scatter {
                height: 350px !important;
            }

            .chart-wrapper {
                height: 300px !important;
            }

            .categories-grid {
                grid-template-columns: 1fr;
            }

            .scatter-plots {
                grid-template-columns: 1fr;
            }

            /* Stack dashboard scatter plots on mobile */
            .dashboard-header-widgets {
                grid-template-columns: 1fr !important;
            }

            /* Fix ticker to top-movers spacing on mobile */
            .ticker-section {
                position: relative !important; /* Disable sticky on mobile */
                top: auto !important;
                margin-bottom: 24px !important;
            }

            #wr-top-movers-sidebar,
            #rb-top-movers-sidebar,
            #te-top-movers-sidebar {
                margin-top: 0 !important;
            }

            .modal {
                width: 95%;
                max-width: 95%;
                margin: 20px;
                max-height: 90vh;
                padding: 20px;
            }

            /* Team Modal - Stack charts on mobile */
            .team-modal-charts-grid {
                grid-template-columns: 1fr !important;
                gap: 16px !important;
            }

            #team-modal-controls-grid {
                gap: 12px !important;
            }

            /* Adjust team modal stats summary */
            #team-stats-summary {
                grid-template-columns: repeat(2, 1fr) !important;
            }

            /* Key players grid - keep 2 columns or stack */
            #key-players-grid {
                gap: 12px !important;
            }

            .modal-charts-grid {
                grid-template-columns: 1fr !important;
            }

            .axis-controls {
                grid-template-columns: 1fr;
            }

            .preset-buttons {
                grid-template-columns: 1fr;
            }

            /* Advanced Analytics - Reorder on mobile and make presets 2x2 */
            .advanced-analytics-charts-wrapper {
                display: flex;
                flex-direction: column-reverse; /* Scatter first, presets second */
            }

            .preset-buttons {
                grid-template-columns: repeat(2, 1fr) !important;
            }

            .footer {
                padding: 32px 16px 16px;
            }

            .footer-content {
                grid-template-columns: 1fr;
                gap: 24px;
            }

            .footer-bottom {
                flex-direction: column;
                gap: 16px;
                text-align: center;
            }

            .footer-copyright {
                text-align: center;
            }

            .waitlist-form {
                flex-direction: column;
            }

            .waitlist-btn {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            .logo span {
                display: inline;
                font-size: 16px;
            }

            .nav-tab {
                padding: 6px 10px;
                font-size: 11px;
            }

            .page-title {
                font-size: 18px;
            }

            /* Single column for very small screens */
            .cards-grid {
                grid-template-columns: 1fr !important;
                gap: 12px;
            }

            /* Even more compact player cards on small phones */
            .player-card {
                padding: 10px;
            }

            .player-stat-value {
                font-size: 14px;
            }

            /* Top Movers - Stack on mobile */
            #wide-receivers > div[style*="grid-template-columns"],
            #running-backs > div[style*="grid-template-columns"] {
                grid-template-columns: 1fr !important;
            }

            #wr-top-movers-sidebar,
            #rb-top-movers-sidebar {
                position: static !important;
                margin-top: 20px;
            }
        }

        /* ============================================
           LOADING SPINNER
           ============================================ */
        .loading-spinner {
            width: 40px;
            height: 40px;
            margin: 0 auto;
            border: 4px solid var(--bg-tertiary);
            border-top: 4px solid var(--positive);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="header-content">
                <div class="logo" onclick="
                    document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                    document.querySelector('.nav-tab[data-page=\'top-movers\']').classList.add('active');
                    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
                    document.getElementById('top-movers').classList.add('active');

                    // Update mobile menu active state
                    document.querySelectorAll('.mobile-menu-item').forEach(item => item.classList.remove('active'));
                    const mobileMenuItem = document.querySelector('.mobile-menu-item[data-page=\'top-movers\']');
                    if (mobileMenuItem) mobileMenuItem.classList.add('active');

                    setTimeout(() => {
                        renderDashboardCategories();
                        setTimeout(renderMiniScatterPlots, 100);
                    }, 100);
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                " style="cursor: pointer;">
                    <div class="logo-icon"></div>
                    <span>FFSE</span>
                </div>

                <nav class="nav-tabs">
                    <button class="nav-tab" data-page="top-movers">Dashboard</button>
                    <button class="nav-tab active" data-page="wide-receivers">WR</button>
                    <button class="nav-tab" data-page="running-backs">RB</button>
                    <button class="nav-tab" data-page="tight-ends">TE</button>
                    <button class="nav-tab" data-page="teams">Team Outlook</button>
                    <button class="nav-tab" data-page="advanced-analytics">Advanced Analytics</button>
                    <button class="nav-tab" id="admin-tab" data-page="admin-panel" style="display: none;">Admin</button>
                </nav>
                <div class="header-right-section" style="display: flex; align-items: center; gap: 16px;">
                    <!-- Header Scoring Dropdown -->
                    <div class="header-scoring-dropdown" id="header-scoring-dropdown">
                        <button class="header-scoring-button" onclick="toggleHeaderScoringDropdown()">
                            <span id="header-scoring-label">PPR</span>
                            <span class="arrow">▼</span>
                        </button>
                        <div class="header-scoring-menu">
                            <button class="active" onclick="setHeaderScoringFormat('ppr')">PPR</button>
                            <button onclick="setHeaderScoringFormat('half')">Half-PPR</button>
                            <button onclick="setHeaderScoringFormat('std')">Standard</button>
                        </div>
                    </div>
                    <button class="upload-btn" onclick="scrollToWaitlist()">Join Waitlist</button>

                    <!-- Hamburger Menu Button (Mobile Only) - Now on the right -->
                    <button class="mobile-menu-button" onclick="toggleMobileMenu()">
                        <div class="hamburger-line"></div>
                        <div class="hamburger-line"></div>
                        <div class="hamburger-line"></div>
                    </button>
                </div>
            </div>
        </header>

        <!-- Mobile Menu Overlay -->
        <div class="mobile-menu-overlay" id="mobile-menu-overlay" onclick="closeMobileMenu()"></div>
        <div class="mobile-menu" id="mobile-menu">
            <div class="mobile-menu-header">
                <div class="mobile-menu-title">Menu</div>
                <button class="mobile-menu-close" onclick="closeMobileMenu()">×</button>
            </div>
            <div class="mobile-menu-items">
                <button class="mobile-menu-item" data-page="top-movers" onclick="navigateFromMobileMenu('top-movers')">
                    Dashboard
                </button>
                <button class="mobile-menu-item active" data-page="wide-receivers" onclick="navigateFromMobileMenu('wide-receivers')">
                    Wide Receivers
                </button>
                <button class="mobile-menu-item" data-page="running-backs" onclick="navigateFromMobileMenu('running-backs')">
                    Running Backs
                </button>
                <button class="mobile-menu-item" data-page="tight-ends" onclick="navigateFromMobileMenu('tight-ends')">
                    Tight Ends
                </button>
                <button class="mobile-menu-item" data-page="teams" onclick="navigateFromMobileMenu('teams')">
                    Team Outlook
                </button>
                <button class="mobile-menu-item" data-page="advanced-analytics" onclick="navigateFromMobileMenu('advanced-analytics')">
                    Advanced Analytics
                </button>
                <button class="mobile-menu-item" id="mobile-admin-tab" data-page="admin-panel" onclick="navigateFromMobileMenu('admin-panel')" style="display: none;">
                    Admin Panel
                </button>
            </div>
            <div class="mobile-menu-divider"></div>
            <button class="mobile-menu-waitlist" onclick="closeMobileMenu(); scrollToWaitlist();">
                Join Waitlist
            </button>
        </div>

        <!-- Scoring Format Toggle -->
        <div class="scoring-toggle-container">
            <div class="scoring-toggle">
                <button class="scoring-option active" data-format="ppr" onclick="setScoringFormat('ppr')">PPR</button>
                <button class="scoring-option" data-format="half" onclick="setScoringFormat('half')">Half-PPR</button>
                <button class="scoring-option" data-format="std" onclick="setScoringFormat('std')">Standard</button>
            </div>
        </div>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Wide Receivers Page -->
            <div id="wide-receivers" class="page active">
                <!-- WR Ticker -->
                <div class="ticker-section" id="wr-ticker-section">
                    <div class="ticker-header">
                        <span>Wide Receivers - Top 50 by Avg Points</span>
                        <div class="ticker-info-icon" onclick="toggleTickerTooltip(event)">
                            i
                            <div class="ticker-tooltip">
                                Shows average fantasy points per game and % change in target share (week-over-week).
                            </div>
                        </div>
                    </div>
                    <div class="ticker-content" id="wr-ticker-content">
                        <div class="ticker-container">
                            <div class="ticker-track" id="wr-ticker-track" style="animation-duration: 720s !important;">
                                <!-- WR ticker items will be inserted here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Top Movers Widgets at Top -->
                <div id="wr-top-movers-sidebar" style="margin-bottom: 24px;">
                    <!-- Top movers widgets will be inserted here -->
                </div>

                <!-- Main content area -->
                <div>
                    <!-- Rankings Tab Content (Default) -->
                    <div id="wr-rankings-content" class="sub-content active">
                        <div id="wr-players-grid">
                            <!-- WR player cards will be inserted here by tier -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Running Backs Page -->
            <div id="running-backs" class="page">
                <!-- RB Ticker -->
                <div class="ticker-section" id="rb-ticker-section">
                    <div class="ticker-header">
                        <span>Running Backs - Top 50 by Avg Points</span>
                        <div class="ticker-info-icon" onclick="toggleTickerTooltip(event)">
                            i
                            <div class="ticker-tooltip">
                                Shows average fantasy points per game and % change in opportunity share (rush attempts + targets, week-over-week).
                            </div>
                        </div>
                    </div>
                    <div class="ticker-content" id="rb-ticker-content">
                        <div class="ticker-container">
                            <div class="ticker-track" id="rb-ticker-track" style="animation-duration: 720s !important;">
                                <!-- RB ticker items will be inserted here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Top Movers Widgets at Top -->
                <div id="rb-top-movers-sidebar" style="margin-bottom: 24px;">
                    <!-- Top movers widgets will be inserted here -->
                </div>

                <!-- Main content area -->
                <div>
                    <!-- Rankings Tab Content (Default) -->
                    <div id="rb-rankings-content" class="sub-content active">
                        <div id="rb-players-grid">
                            <!-- RB player cards will be inserted here by tier -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tight Ends Page -->
            <div id="tight-ends" class="page">
                <!-- TE Ticker -->
                <div class="ticker-section" id="te-ticker-section">
                    <div class="ticker-header">
                        <span>Tight Ends - Top 50 by Avg Points</span>
                        <div class="ticker-info-icon" onclick="toggleTickerTooltip(event)">
                            i
                            <div class="ticker-tooltip">
                                Shows average fantasy points per game and % change in target share (week-over-week).
                            </div>
                        </div>
                    </div>
                    <div class="ticker-content" id="te-ticker-content">
                        <div class="ticker-container">
                            <div class="ticker-track" id="te-ticker-track" style="animation-duration: 720s !important;">
                                <!-- TE ticker items will be inserted here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Top Movers Widgets at Top -->
                <div id="te-top-movers-sidebar" style="margin-bottom: 24px;">
                    <!-- Top movers widgets will be inserted here -->
                </div>

                <!-- Main content area -->
                <div>
                    <!-- Rankings Tab Content (Default) -->
                    <div id="te-rankings-content" class="sub-content active">
                        <div id="te-players-grid">
                            <!-- TE player cards will be inserted here by tier -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Teams Page -->
            <div id="teams" class="page">
                <!-- Teams Ticker -->
                <div class="ticker-section" id="teams-ticker-section">
                    <div class="ticker-header">
                        <span>Teams - Ranked by Total Fantasy Points</span>
                        <div class="ticker-info-icon" onclick="toggleTickerTooltip(event)">
                            i
                            <div class="ticker-tooltip">
                                Shows total fantasy points (WR + RB combined) from the latest week and % change from previous week.
                            </div>
                        </div>
                    </div>
                    <div class="ticker-content" id="teams-ticker-content">
                        <div class="ticker-container">
                            <div class="ticker-track" id="teams-ticker-track" style="animation-duration: 480s !important;">
                                <!-- Teams ticker items will be inserted here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Team Analysis Section -->
                <div class="advanced-analytics-container" style="margin-bottom: 32px;">
                    <div class="advanced-header">
                        <div class="advanced-title">Team Analysis</div>
                        <div class="advanced-subtitle">Deep dive into team-level target and opportunity distribution</div>
                    </div>

                    <!-- League Comparison Toggle -->
                    <div style="margin-bottom: 16px; display: flex; align-items: center; gap: 12px;">
                        <button
                            id="league-comparison-toggle"
                            onclick="toggleLeagueComparison()"
                            style="padding: 8px 16px; background: var(--positive); border: 1px solid var(--positive); border-radius: 8px; color: white; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 8px;"
                        >
                            <span id="league-comparison-icon">●</span>
                            <span>Show League Comparison</span>
                        </button>
                        <span style="font-size: 12px; color: var(--text-tertiary);">Compare team's volume to league average</span>
                    </div>

                    <!-- Team Analysis Controls -->
                    <div class="team-analysis-controls" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin-bottom: 16px;">
                        <!-- Team Selector -->
                        <div class="axis-control">
                            <div class="axis-label-static">Select Team</div>
                            <select class="axis-select" id="team-select" onchange="updateTeamAnalysis()">
                                <!-- Teams will be populated by JavaScript -->
                            </select>
                        </div>

                        <!-- Position Group -->
                        <div class="axis-control">
                            <div class="axis-label-static">Position Group</div>
                            <select class="axis-select" id="position-group-select" onchange="updateTeamAnalysis()">
                                <option value="WR">Pass-Catchers</option>
                                <option value="RB">Running Backs</option>
                            </select>
                        </div>

                        <!-- Time Frame -->
                        <div class="axis-control">
                            <div class="axis-label-static">Time Frame</div>
                            <select class="axis-select" id="time-frame-select" onchange="updateTeamAnalysis()">
                                <option value="single">Single Week</option>
                                <option value="last3">Last 3 Weeks</option>
                                <option value="last5">Last 5 Weeks</option>
                                <option value="season">Season Long</option>
                            </select>
                        </div>

                        <!-- Week Selector (shown only for single week) -->
                        <div class="axis-control" id="week-select-container">
                            <div class="axis-label-static">Select Week</div>
                            <select class="axis-select" id="week-select" onchange="updateTeamAnalysis()">
                                <!-- Weeks will be populated by JavaScript -->
                            </select>
                        </div>
                    </div>

                    <!-- Chart Area -->
                    <div class="scatter-chart-card">
                        <div class="scatter-chart-header">
                            <div class="scatter-chart-title" id="team-chart-title">Team Target Distribution</div>
                            <div class="scatter-chart-description" id="team-chart-description">
                                Select a team and time frame to view distribution
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; min-height: 420px;" id="team-charts-container">
                            <!-- Placeholder message when no team selected -->
                            <div id="team-chart-placeholder" style="grid-column: 1; display: flex; align-items: center; justify-content: center;">
                                <div style="text-align: center; color: #8e8e93; font-size: 18px; font-weight: 600;">
                                    Select a Team
                                </div>
                            </div>
                            <!-- Charts will be rendered here -->
                            <div class="chart-wrapper" style="display: none;">
                                <canvas id="team-pie-chart"></canvas>
                            </div>
                            <div class="chart-wrapper" id="team-secondary-chart-wrapper" style="display: none;">
                                <canvas id="team-secondary-chart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Team Offensive Balance Scatter -->
                <div class="chart-card" style="margin-bottom: 32px;">
                    <div class="chart-header">
                        <div class="chart-title">Offensive Identity Map</div>
                        <div class="chart-subtitle">Pass-Heavy vs Run-Heavy Offenses</div>
                    </div>
                    <div class="chart-insight">
                        <strong>What to look for:</strong> Top Right = Pass Heavy + Run Heavy, Bottom Right = Pass Heavy, Top Left = Run Heavy, Bottom Left = Avoid. Bigger Circles = More Total Fantasy Output.
                    </div>
                    <div class="chart-wrapper">
                        <canvas id="team-balance-scatter"></canvas>
                    </div>
                </div>

                <div class="cards-grid" id="teams-grid" style="display: none;">
                    <!-- Legacy team cards (hidden, keeping for backward compatibility) -->
                </div>
            </div>

            <!-- Insights Page -->
            <div id="top-movers" class="page">
                <!-- Dashboard Ticker -->
                <div class="ticker-section" id="insights-ticker-section">
                    <div class="ticker-header">
                        <span>Trending Opportunity Shifts Over Last 3 Weeks</span>
                        <div class="ticker-info-icon" onclick="toggleTickerTooltip(event)">
                            i
                            <div class="ticker-tooltip">
                                Shows players with the biggest changes in target/opportunity share over the last 3 weeks.
                            </div>
                        </div>
                    </div>
                    <div class="ticker-content" id="insights-ticker-content">
                        <div class="ticker-container">
                            <div class="ticker-track" id="insights-ticker-track" style="animation-duration: 540s !important;">
                                <!-- Ticker items will be inserted here -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Key Insight - Full Width -->
                <div class="dashboard-widget stat-widget-full">
                    <div class="widget-header">
                        <span class="widget-title" style="font-size: 16px;">Key Insight</span>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <button onclick="previousInsight()" class="insight-nav-btn" title="Previous insight">‹</button>
                            <span id="insight-indicator" style="font-size: 11px; color: var(--text-tertiary);">1/4</span>
                            <button onclick="nextInsight()" class="insight-nav-btn" title="Next insight">›</button>
                        </div>
                    </div>
                    <div class="widget-body">
                        <div class="stat-highlight-horizontal" id="stat-of-week" style="transition: opacity 0.3s ease;">
                            <div class="stat-highlight-value">Loading...</div>
                            <div class="stat-highlight-content">
                                <div class="stat-highlight-label">Analyzing data...</div>
                                <div class="stat-highlight-text">
                                    Processing player statistics to find actionable insights.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Leaderboards Section Header -->
                <div class="dashboard-widget" style="margin-bottom: 24px;">
                    <div class="widget-header">
                        <div>
                            <span class="widget-title" style="font-size: 18px; text-transform: uppercase; letter-spacing: 0.5px;">Leaderboards</span>
                            <div style="font-size: 11px; color: var(--text-tertiary); margin-top: 2px;">Last 3 Weeks Performance</div>
                        </div>
                        <button onclick="navigateToPage('all-leaderboards')" style="padding: 8px 16px; background: var(--positive); color: white; border: none; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">
                            See All
                        </button>
                    </div>
                </div>

                <!-- Categories Section - Now at top -->
                <div class="categories-section" id="dashboard-categories">
                    <!-- Categories will be dynamically inserted here -->
                </div>

                <!-- Dashboard Scatter Plots -->
                <div class="dashboard-header-widgets">
                    <!-- WR Trend Scatter Plot -->
                    <div class="dashboard-widget trend-widget" id="wr-trend-widget" style="grid-column: span 1;">
                        <div class="widget-header">
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <span class="widget-title" style="font-size: 16px;">WR Trends: Volume vs Efficiency</span>
                                <button class="expand-btn" onclick="toggleChartExpand('wr')" id="wr-expand-btn" title="Expand">
                                    ⛶
                                </button>
                            </div>
                            <div class="mover-filter-btns">
                                <button class="filter-btn active" onclick="setDashboardFilter('wr', 'all')" id="wr-filter-all">All</button>
                                <button class="filter-btn" onclick="setDashboardFilter('wr', 'positive')" id="wr-filter-positive">Top 10 ↑</button>
                                <button class="filter-btn" onclick="setDashboardFilter('wr', 'negative')" id="wr-filter-negative">Top 10 ↓</button>
                            </div>
                        </div>
                        <div class="widget-body">
                            <div class="dashboard-chart-wrapper">
                                <canvas id="wr-trend-chart"></canvas>
                            </div>
                            <div class="dashboard-scrubber">
                                <div class="scrubber-label" id="wr-tranche-label">Current</div>
                                <input type="range" class="week-scrubber" id="wr-tranche-scrubber" min="0" max="3" value="3" step="0.005">
                                <button class="playback-btn-small" onclick="toggleDashboardTrend('wr')" id="wr-play-btn">▶</button>
                            </div>
                        </div>
                    </div>

                    <!-- RB Trend Scatter Plot -->
                    <div class="dashboard-widget trend-widget" id="rb-trend-widget" style="grid-column: span 1;">
                        <div class="widget-header">
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <span class="widget-title" style="font-size: 16px;">RB Trends: Volume vs Efficiency</span>
                                <button class="expand-btn" onclick="toggleChartExpand('rb')" id="rb-expand-btn" title="Expand">
                                    ⛶
                                </button>
                            </div>
                            <div class="mover-filter-btns">
                                <button class="filter-btn active" onclick="setDashboardFilter('rb', 'all')" id="rb-filter-all">All</button>
                                <button class="filter-btn" onclick="setDashboardFilter('rb', 'positive')" id="rb-filter-positive">Top 10 ↑</button>
                                <button class="filter-btn" onclick="setDashboardFilter('rb', 'negative')" id="rb-filter-negative">Top 10 ↓</button>
                            </div>
                        </div>
                        <div class="widget-body">
                            <div class="dashboard-chart-wrapper">
                                <canvas id="rb-trend-chart"></canvas>
                            </div>
                            <div class="dashboard-scrubber">
                                <div class="scrubber-label" id="rb-tranche-label">Current</div>
                                <input type="range" class="week-scrubber" id="rb-tranche-scrubber" min="0" max="3" value="3" step="0.005">
                                <button class="playback-btn-small" onclick="toggleDashboardTrend('rb')" id="rb-play-btn">▶</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Category Methodology Footnote -->
                <div class="category-footnote">
                    <button class="footnote-toggle" onclick="toggleFootnote()">
                        <span id="footnote-icon">ⓘ</span> Methodology
                    </button>
                    <div class="footnote-content" id="footnote-content" style="display: none;">
                        <strong>📊 Category Leaderboard Methodology</strong><br><br>

                        <strong>Time Window:</strong> All rankings are based on performance over the <strong>last 3 weeks of the season</strong>. Players must have played (with fantasy points scored) in at least <strong>2 of the last 3 weeks</strong> to be eligible for any category.<br><br>

                        <strong>Minimum Threshold:</strong> Players must average <strong>7.0+ fantasy points per game</strong> over their qualifying games to appear on leaderboards.<br><br>

                        <strong>Category Definitions:</strong><br>
                        • <strong>Volume Monsters (RB):</strong> Running backs with the highest opportunities per game (rush attempts + targets) over the last 3 weeks. Identifies true workhorse backs.<br>
                        • <strong>Efficiency Elites:</strong> Players with the best points per touch/target ratio over the last 3 weeks. Shows who's doing the most with their opportunities.<br>
                        • <strong>Red Zone Kings:</strong> Players with the most red zone opportunities per game. For WRs: red zone targets. For RBs: red zone rush attempts + targets. High TD upside.<br>
                        • <strong>High-Volume Alphas (WR):</strong> Wide receivers with the most targets per game over the last 3 weeks. High-volume pass catchers dominating their team's offense.<br><br>

                        <strong>Why Last 3 Weeks?</strong> Recent performance is more predictive than season-long averages. Player roles evolve, injuries affect usage, and offensive schemes shift throughout the season. The last 3 weeks capture current reality and help identify emerging trends and hot streaks.
                    </div>
                </div>

            </div>

            <!-- Advanced Analytics Page -->
            <div id="advanced-analytics" class="page">
                <div class="advanced-analytics-container">
                    <div class="advanced-header">
                        <div class="advanced-title">Advanced Analytics</div>
                        <div class="advanced-subtitle">Build custom scatterplots to explore correlations between any stats</div>
                    </div>

                    <div class="position-toggle">
                        <button class="position-toggle-btn active" onclick="switchAdvancedPosition('WR')" id="advanced-wr-btn">
                            Wide Receivers
                        </button>
                        <button class="position-toggle-btn" onclick="switchAdvancedPosition('RB')" id="advanced-rb-btn">
                            Running Backs
                        </button>
                        <button class="position-toggle-btn" onclick="switchAdvancedPosition('TE')" id="advanced-te-btn">
                            Tight Ends
                        </button>
                    </div>

                    <!-- Player Search and Week Selector -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
                        <!-- Player Search -->
                        <div class="axis-control">
                            <div class="axis-label-static">Highlight Player</div>
                            <div id="selected-players-container" style="display: none; margin-bottom: 8px; display: flex; gap: 8px; flex-wrap: wrap;">
                                <!-- Selected players will appear here -->
                            </div>
                            <div style="position: relative;">
                                <input
                                    type="text"
                                    id="player-search-input"
                                    class="axis-select"
                                    placeholder="Search to highlight players (Max 4)"
                                    oninput="filterPlayerSearch()"
                                    onfocus="showPlayerSearchDropdown()"
                                    style="padding-right: 30px;"
                                />
                                <button
                                    id="clear-player-btn"
                                    onclick="clearPlayerHighlight()"
                                    style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: transparent; border: none; color: var(--text-secondary); cursor: pointer; font-size: 18px; display: none; padding: 0; width: 20px; height: 20px; line-height: 1;"
                                    title="Clear highlighted players"
                                >×</button>
                                <div id="player-search-dropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: var(--bg-elevated); border: 1px solid var(--border-color); border-radius: 8px; margin-top: 4px; max-height: 200px; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);">
                                    <!-- Player options will be populated by JavaScript -->
                                </div>
                            </div>
                        </div>

                        <!-- Week Selector -->
                        <div class="axis-control">
                            <div class="axis-label-static">Week Range</div>
                            <select class="axis-select" id="week-range-select" onchange="updateAdvancedScatter()">
                                <option value="all">All Weeks</option>
                                <option value="last3">Last 3 Weeks</option>
                                <option value="last5">Last 5 Weeks</option>
                                <option value="1-4">Weeks 1-4</option>
                                <option value="5-8">Weeks 5-8</option>
                                <!-- Dynamic week options will be added by JavaScript -->
                            </select>
                        </div>
                    </div>

                    <div class="axis-controls">
                        <div class="axis-control">
                            <div class="axis-label" onclick="toggleAxisControl('x-axis')">
                                <span class="axis-label-text">X-Axis Stat</span>
                                <span class="axis-collapse-icon collapsed" id="x-axis-icon">▼</span>
                            </div>
                            <div class="axis-control-content collapsed" id="x-axis-content">
                                <select class="axis-select" id="x-axis-select" onchange="currentQuadrantExplanation = ''; updateAdvancedScatter()">
                                    <!-- Options will be populated by JavaScript -->
                                </select>
                            </div>
                        </div>
                        <div class="axis-control">
                            <div class="axis-label" onclick="toggleAxisControl('y-axis')">
                                <span class="axis-label-text">Y-Axis Stat</span>
                                <span class="axis-collapse-icon collapsed" id="y-axis-icon">▼</span>
                            </div>
                            <div class="axis-control-content collapsed" id="y-axis-content">
                                <select class="axis-select" id="y-axis-select" onchange="currentQuadrantExplanation = ''; updateAdvancedScatter()">
                                    <!-- Options will be populated by JavaScript -->
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Wrapper for mobile reordering -->
                    <div class="advanced-analytics-charts-wrapper">
                        <!-- Preset Scatterplots - Moved below axis controls -->
                        <div class="preset-section" style="margin-top: 16px;">
                            <div class="preset-label">Quick Presets</div>
                            <div class="preset-buttons" id="preset-buttons-container">
                                <!-- Preset buttons will be populated by JavaScript -->
                            </div>
                        </div>

                        <div class="scatter-chart-card">
                            <div class="scatter-chart-header">
                                <div class="scatter-chart-title" id="scatter-title">Fantasy Points vs Targets</div>
                                <div class="scatter-chart-description" id="scatter-description">
                                    Click on any point to view player details
                                </div>
                            </div>
                            <div class="scatter-chart-wrapper">
                                <canvas id="advanced-scatter-chart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- All Leaderboards Page -->
            <div id="all-leaderboards" class="page">
                <div class="page-header">
                    <h1 class="page-title">All Leaderboards</h1>
                    <p class="page-subtitle">Last 3 Weeks Performance - All Categories</p>
                </div>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(450px, 1fr)); gap: 24px; padding: 24px 24px 48px;">
                    <!-- All 11 leaderboards will be rendered here -->
                    <div id="all-leaderboards-grid"></div>
                </div>
            </div>

            <!-- Admin Panel Page -->
            <div id="admin-panel" class="page">
                <div class="page-header">
                    <h1 class="page-title">Admin Panel</h1>
                    <p class="page-subtitle">Upload new data and manage the site</p>
                </div>

                <div style="max-width: 800px; margin: 0 auto;">
                    <!-- Admin Info Card -->
                    <div style="background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 24px; margin-bottom: 24px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                            <div>
                                <div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">Logged in as Admin</div>
                                <div style="font-size: 12px; color: var(--text-tertiary);" id="admin-email-display">aryi3025@gmail.com</div>
                            </div>
                            <button onclick="logoutAdmin()" style="padding: 8px 16px; background: var(--negative); border: none; border-radius: 8px; color: white; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">
                                Sign Out
                            </button>
                        </div>
                        <div style="padding-top: 16px; border-top: 1px solid var(--border-color); font-size: 12px; color: var(--text-secondary);">
                            Last updated: <span id="admin-last-updated">No data uploaded</span>
                        </div>
                    </div>

                    <!-- Upload Data Card -->
                    <div style="background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 24px;">
                        <h2 style="font-size: 18px; font-weight: 700; color: var(--text-primary); margin-bottom: 16px;">Upload New Data</h2>

                        <div style="display: flex; flex-direction: column; gap: 20px;">
                            <!-- WR Upload -->
                            <div>
                                <label style="display: block; font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">Wide Receiver Data (CSV)</label>
                                <input type="file" id="admin-wr-upload" accept=".csv" onchange="handleAdminWRUpload(event)" style="display: block; width: 100%; padding: 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 13px; cursor: pointer;">
                                <div id="admin-wr-status" style="margin-top: 6px; font-size: 12px; color: var(--text-tertiary);"></div>
                            </div>

                            <!-- RB Upload -->
                            <div>
                                <label style="display: block; font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">Running Back Data (CSV)</label>
                                <input type="file" id="admin-rb-upload" accept=".csv" onchange="handleAdminRBUpload(event)" style="display: block; width: 100%; padding: 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 13px; cursor: pointer;">
                                <div id="admin-rb-status" style="margin-top: 6px; font-size: 12px; color: var(--text-tertiary);"></div>
                            </div>

                            <!-- TE Upload -->
                            <div>
                                <label style="display: block; font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">Tight End Data (CSV)</label>
                                <input type="file" id="admin-te-upload" accept=".csv" onchange="handleAdminTEUpload(event)" style="display: block; width: 100%; padding: 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 13px; cursor: pointer;">
                                <div id="admin-te-status" style="margin-top: 6px; font-size: 12px; color: var(--text-tertiary);"></div>
                            </div>

                            <!-- Instructions -->
                            <div style="margin-top: 8px; padding: 16px; background: var(--bg-tertiary); border-radius: 8px; font-size: 13px; color: var(--text-secondary); line-height: 1.6;">
                                <strong style="color: var(--text-primary);">Instructions:</strong><br>
                                1. Upload WR, RB, and TE CSV files<br>
                                2. Data will be processed automatically<br>
                                3. All pages will update with new data<br>
                                4. "Last updated" date will be set to today<br>
                                5. Data persists until you upload again
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Footer -->
        <footer class="footer">
            <div class="footer-content">
                <!-- Waitlist Section -->
                <div class="footer-section">
                    <h3>JOIN THE WAITLIST</h3>
                    <p>Get early access to premium features, real-time updates, and exclusive fantasy football insights.</p>
                    <form class="waitlist-form" onsubmit="submitWaitlist(event)">
                        <input
                            type="email"
                            class="waitlist-input"
                            id="waitlist-email"
                            placeholder="Enter your email"
                            required
                        />
                        <button type="submit" class="waitlist-btn">Join Waitlist</button>
                    </form>
                    <div class="success-message" id="waitlist-success">
                        ✓ Thanks! You've been added to the waitlist.
                    </div>
                </div>

                <!-- Quick Links -->
                <div class="footer-section">
                    <h3>QUICK LINKS</h3>
                    <div class="footer-links">
                        <a href="#" class="footer-link" id="admin-login-link" onclick="showLoginModal(); return false;">Admin Login</a>
                        <a href="#" class="footer-link" onclick="navigateToPage('top-movers'); return false;">Dashboard</a>
                        <a href="#" class="footer-link" onclick="navigateToPage('advanced-analytics'); return false;">Analytics</a>
                    </div>
                </div>

                <!-- About -->
                <div class="footer-section">
                    <h3>ABOUT FFSE</h3>
                    <div class="footer-links">
                        <a href="#" class="footer-link" onclick="showPrivacyModal(); return false;">Privacy Policy</a>
                        <a href="#" class="footer-link">Contact</a>
                    </div>
                    <div style="margin-top: 16px; font-size: 11px; color: var(--text-tertiary);">
                        Last updated: <span id="last-updated-date">No data uploaded</span>
                    </div>
                </div>
            </div>

            <div class="footer-bottom">
                <div class="footer-logo">
                    <div class="footer-logo-icon"></div>
                    <span>FFSE</span>
                </div>
                <div class="footer-copyright">
                    © 2025 Fantasy Football Stock Exchange. All rights reserved. | Data updated weekly during NFL season.
                </div>
            </div>
        </footer>

        <!-- Waitlist Confirmation Modal -->
        <div class="waitlist-modal" id="waitlist-modal">
            <div class="waitlist-modal-content">
                <div class="waitlist-modal-icon">🎉</div>
                <div class="waitlist-modal-title">Welcome to the Waitlist!</div>
                <div class="waitlist-modal-message">
                    Thanks for signing up! We'll keep you updated on new features, premium analytics, and exclusive fantasy football insights.
                </div>
                <button class="waitlist-modal-btn" onclick="closeWaitlistModal()">Got it!</button>
            </div>
        </div>
    </div>

    <!-- Player Modal -->
    <div class="modal-overlay" id="player-modal">
        <div class="modal">
            <div class="modal-header">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; width: 100%;">
                    <div class="modal-player-info">
                        <div class="modal-team-badge" id="modal-team-badge"></div>
                        <div class="modal-player-details">
                            <div class="modal-player-name" id="modal-player-name"></div>
                            <div class="modal-player-meta" id="modal-player-meta"></div>
                        </div>
                    </div>

                    <button class="modal-close" onclick="closeModal()" style="position: absolute; top: 16px; right: 16px;">×</button>
                </div>

                <!-- Category Context (shown when opened from a category) -->
                <div id="modal-category-context" style="display: none; margin-top: 16px; padding: 12px 16px; background: var(--bg-elevated); border-radius: 8px; border-left: 3px solid var(--positive);">
                    <div style="font-size: 11px; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 4px;">
                        Category Ranking
                    </div>
                    <div style="font-size: 14px; font-weight: 700; color: var(--text-primary); margin-bottom: 8px;">
                        <span id="modal-category-title"></span> - <span id="modal-category-rank"></span>
                    </div>
                    <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                        <span id="modal-category-explanation"></span>
                    </div>
                    <div style="display: flex; gap: 16px; margin-top: 8px; font-size: 12px;">
                        <div>
                            <span style="color: var(--text-secondary);"><span id="modal-category-metric-label"></span>:</span>
                            <span style="color: var(--text-primary); font-weight: 600; margin-left: 4px;" id="modal-category-metric-value"></span>
                        </div>
                    </div>
                </div>

                <!-- Mobile Swipeable Stats Container -->
                <div class="modal-stats-container">
                    <div class="modal-stats-wrapper" id="modal-stats-wrapper">
                        <!-- Page 1: Points Stats -->
                        <div class="modal-stats-page">
                            <div class="modal-stats-grid" style="margin-top: 20px; grid-template-columns: repeat(4, 1fr); gap: 12px;">
                                <div class="modal-stat-box">
                                    <div class="modal-stat-label">AVG PTS</div>
                                    <div class="modal-stat-value" id="modal-avg-pts"></div>
                                    <div class="stat-tooltip">Average fantasy points per game across all weeks played</div>
                                </div>
                                <div class="modal-stat-box">
                                    <div class="modal-stat-label" id="modal-exp-pts-label">EXP PTS (W9)</div>
                                    <div class="modal-stat-value" id="modal-exp-pts"></div>
                                    <div class="stat-tooltip">Expected points based on opportunities and efficiency metrics</div>
                                </div>
                                <div class="modal-stat-box">
                                    <div class="modal-stat-label" id="modal-actual-pts-label">ACTUAL (W9)</div>
                                    <div class="modal-stat-value" id="modal-actual-pts"></div>
                                    <div class="stat-tooltip">Actual fantasy points scored in this week's game</div>
                                </div>
                                <div class="modal-stat-box">
                                    <div class="modal-stat-label">DIFF %</div>
                                    <div class="modal-stat-value" id="modal-diff-pct"></div>
                                    <div class="stat-tooltip">Performance vs expectations: (Actual - Expected) / Expected × 100%</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Page 2: Opportunity Stats -->
                        <div class="modal-stats-page">
                            <div class="modal-stats-grid" style="margin-top: 20px; grid-template-columns: repeat(4, 1fr); gap: 12px;">
                                <div class="modal-stat-box" id="modal-stat-opp-this">
                                    <div class="modal-stat-label">OPP SHARE THIS WK</div>
                                    <div class="modal-stat-value" id="modal-opp-this-week"></div>
                                    <div class="stat-tooltip">Player's share of team opportunities in latest week</div>
                                </div>
                                <div class="modal-stat-box" id="modal-stat-opp-last">
                                    <div class="modal-stat-label">OPP SHARE LAST WK</div>
                                    <div class="modal-stat-value" id="modal-opp-last-week"></div>
                                    <div class="stat-tooltip">Player's share of team opportunities in previous week</div>
                                </div>
                                <div class="modal-stat-box" id="modal-stat-vs-avg">
                                    <div class="modal-stat-label">OPP VS TOP 24 AVG</div>
                                    <div class="modal-stat-value" id="modal-vs-avg"></div>
                                    <div class="modal-stat-subvalue" id="modal-vs-avg-detail"></div>
                                    <div class="stat-tooltip">Opportunity differential vs Top 24 average for this week</div>
                                </div>
                                <div class="modal-stat-box" id="modal-stat-opp-change">
                                    <div class="modal-stat-label">SHARE CHANGE</div>
                                    <div class="modal-stat-value" id="modal-share-change"></div>
                                    <div class="stat-tooltip">Week-over-week change in opportunity share</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Page Dots -->
                    <div class="stats-dots">
                        <div class="stats-dot active" data-page="0"></div>
                        <div class="stats-dot" data-page="1"></div>
                    </div>
                </div>
            </div>
            <div class="modal-body">
                <!-- Community Sentiment Section - 3-Section Bar -->
                <div style="background: var(--bg-tertiary); border-radius: 8px; padding: 12px 16px; margin-bottom: 20px;">
                    <!-- Header Row -->
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
                        <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600;">
                            Community Sentiment
                        </div>
                        <div style="text-align: right;">
                            <div id="modal-sentiment-compact" style="font-size: 18px; font-weight: bold; line-height: 1;">
                                <!-- Will be filled dynamically -->
                            </div>
                            <div id="modal-sentiment-vote-count" style="font-size: 10px; color: #666; margin-top: 2px;">
                                <!-- Vote count will be filled dynamically -->
                            </div>
                        </div>
                    </div>

                    <!-- 3-Section Bar -->
                    <div class="sentiment-bar-3section" style="height: 40px; border-radius: 8px; display: flex; overflow: hidden; margin-bottom: 12px; background: var(--bg-secondary);">
                        <div class="sentiment-segment sentiment-segment-buy" id="modal-sentiment-segment-buy" style="display: flex; align-items: center; justify-content: center; font-size: 11px; font-weight: 600; color: #fff; transition: width 0.3s ease;">
                            <!-- Will show percentage -->
                        </div>
                        <div class="sentiment-segment sentiment-segment-hold" id="modal-sentiment-segment-hold" style="display: flex; align-items: center; justify-content: center; font-size: 11px; font-weight: 600; color: #fff; transition: width 0.3s ease;">
                            <!-- Will show percentage -->
                        </div>
                        <div class="sentiment-segment sentiment-segment-sell" id="modal-sentiment-segment-sell" style="display: flex; align-items: center; justify-content: center; font-size: 11px; font-weight: 600; color: #fff; transition: width 0.3s ease;">
                            <!-- Will show percentage -->
                        </div>
                    </div>

                    <!-- Vote Buttons -->
                    <div class="vote-buttons" style="gap: 8px; display: flex; width: 100%;">
                        <button class="vote-btn buy-btn" onclick="castVote('buy')" style="flex: 1; padding: 10px 8px; font-size: 12px;">
                            Buy
                        </button>
                        <button class="vote-btn hold-btn" onclick="castVote('hold')" style="flex: 1; padding: 10px 8px; font-size: 12px;">
                            Hold
                        </button>
                        <button class="vote-btn sell-btn" onclick="castVote('sell')" style="flex: 1; padding: 10px 8px; font-size: 12px;">
                            Sell
                        </button>
                    </div>
                </div>

                <div class="chart-tabs">
                    <button class="chart-tab active" onclick="switchModalChart('outcomes')">Performance Consistency</button>
                    <button class="chart-tab" onclick="switchModalChart('spider')">Player Profile</button>
                </div>
                <div id="modal-chart-variance" class="chart-content active">
                    <div class="modal-chart-wrapper">
                        <canvas id="modal-variance-chart"></canvas>
                    </div>
                </div>
                <div id="modal-chart-outcomes" class="chart-content">
                    <div class="modal-chart-wrapper">
                        <canvas id="modal-outcomes-chart"></canvas>
                    </div>
                </div>
                <div id="modal-chart-spider" class="chart-content">
                    <div class="modal-chart-wrapper">
                        <canvas id="modal-spider-chart"></canvas>
                    </div>

                    <!-- Metrics Explanation Section -->
                    <div style="margin-top: 16px; border-top: 1px solid var(--border-color); padding-top: 12px;">
                        <button onclick="toggleSpiderExplanation()"
                                style="display: flex; align-items: center; gap: 6px; background: transparent; border: none; color: var(--text-secondary); cursor: pointer; font-size: 12px; padding: 0; font-weight: 500; transition: color 0.2s;"
                                onmouseover="this.style.color='var(--text-primary)'"
                                onmouseout="this.style.color='var(--text-secondary)'">
                            <span id="spider-explanation-icon" style="font-size: 14px;">ℹ️</span>
                            <span>How rankings are calculated</span>
                        </button>

                        <div id="spider-explanation" style="display: none; margin-top: 12px; background: var(--bg-elevated); border-radius: 8px; padding: 16px; font-size: 13px; line-height: 1.6;">
                            <div style="color: var(--text-primary); font-weight: 600; margin-bottom: 8px;">Player Profile Rankings</div>
                            <div style="color: var(--text-secondary); margin-bottom: 12px;">
                                Each metric is ranked against <strong style="color: var(--text-primary);">all eligible players</strong> (minimum 3 games played) using per-game averages. Your rank determines your score: <strong style="color: var(--positive);">#1 = 100 points</strong>, <strong style="color: var(--text-primary);">#100 = 50 points</strong>, <strong style="color: var(--text-tertiary);">#200 = 0.5 points</strong>.
                            </div>

                            <div id="spider-wr-metrics" style="display: none;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px; font-size: 12px;">WR Metrics:</div>
                                <div style="display: grid; gap: 8px; color: var(--text-secondary); font-size: 12px;">
                                    <div><strong style="color: var(--text-primary);">Volume:</strong> Targets per game (total targets ÷ games played)</div>
                                    <div><strong style="color: var(--text-primary);">Efficiency:</strong> Fantasy points per target (avg points ÷ targets per game)</div>
                                    <div><strong style="color: var(--text-primary);">Red Zone:</strong> Red zone opportunities per game (total RZ opps ÷ games played)</div>
                                    <div><strong style="color: var(--text-primary);">Team Share:</strong> Target share % in most recent week</div>
                                    <div><strong style="color: var(--text-primary);">Catch Rate:</strong> Receptions per target (total receptions ÷ total targets × 100%)</div>
                                </div>
                            </div>

                            <div id="spider-rb-metrics" style="display: none;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px; font-size: 12px;">RB Metrics:</div>
                                <div style="display: grid; gap: 8px; color: var(--text-secondary); font-size: 12px;">
                                    <div><strong style="color: var(--text-primary);">Volume:</strong> Opportunities per game (total opportunities ÷ games played)</div>
                                    <div><strong style="color: var(--text-primary);">Efficiency:</strong> Fantasy points per opportunity (avg points ÷ opps per game)</div>
                                    <div><strong style="color: var(--text-primary);">Red Zone:</strong> Red zone opportunities per game (total RZ opps ÷ games played)</div>
                                    <div><strong style="color: var(--text-primary);">Team Share:</strong> Opportunity share % in most recent week</div>
                                    <div><strong style="color: var(--text-primary);">Yards After Contact:</strong> Yards after contact per attempt (total YACON ÷ total attempts)</div>
                                </div>
                            </div>

                            <div id="spider-te-metrics" style="display: none;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px; font-size: 12px;">TE Metrics:</div>
                                <div style="display: grid; gap: 8px; color: var(--text-secondary); font-size: 12px;">
                                    <div><strong style="color: var(--text-primary);">Volume:</strong> Targets per game (total targets ÷ games played)</div>
                                    <div><strong style="color: var(--text-primary);">Efficiency:</strong> Fantasy points per target (avg points ÷ targets per game)</div>
                                    <div><strong style="color: var(--text-primary);">Red Zone:</strong> Red zone opportunities per game (total RZ opps ÷ games played)</div>
                                    <div><strong style="color: var(--text-primary);">Team Share:</strong> Target share % in most recent week</div>
                                    <div><strong style="color: var(--text-primary);">Catch Rate:</strong> Receptions per target (total receptions ÷ total targets × 100%)</div>
                                </div>
                            </div>

                            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color); font-size: 11px; color: var(--text-tertiary);">
                                <strong style="color: var(--text-secondary);">Note:</strong> Rankings only shown for Top 200 players. All metrics are calculated as per-game averages to ensure fair comparison regardless of games played.
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Comments Section -->
                <div class="comment-section">
                    <div class="comment-header">Quick Takes</div>
                    <div class="comment-input-container">
                        <input type="text" class="comment-input" id="comment-input" placeholder="Share your take (280 chars max)" maxlength="280">
                        <button class="comment-submit" onclick="submitComment()">Post</button>
                    </div>
                    <div class="comment-list" id="comment-list">
                        <!-- Comments will be inserted here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Team Modal -->
    <div class="modal-overlay" id="team-modal">
        <div class="modal">
            <div class="modal-header">
                <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                    <div class="modal-player-info">
                        <div class="modal-team-badge" id="team-modal-badge"></div>
                        <div class="modal-player-details">
                            <div class="modal-player-name" id="team-modal-name"></div>
                            <div class="modal-player-meta" id="team-modal-meta"></div>
                        </div>
                    </div>
                    <button class="modal-close" onclick="closeTeamModal()">×</button>
                </div>
            </div>
            <div class="modal-body">
                <!-- Team Stats Summary -->
                <div class="team-stats-summary" id="team-stats-summary" style="display: none;">
                    <!-- Stats will be inserted here -->
                </div>

                <!-- Key Players Section -->
                <div class="key-players-section" id="key-players-section" style="margin-bottom: 24px;">
                    <h3 style="font-size: 16px; font-weight: 700; margin-bottom: 12px; color: var(--text-primary);">Key Players</h3>
                    <div id="key-players-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
                        <!-- Key players will be inserted here -->
                    </div>
                </div>

                <!-- Time Frame and Week Selectors in Grid -->
                <div id="team-modal-controls-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                    <!-- Metric Selector -->
                    <div>
                        <label style="display: block; font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px;">Metric</label>
                        <select id="team-modal-metric" onchange="updateTeamModalCharts()" style="width: 100%; padding: 10px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 14px; cursor: pointer;">
                            <option value="points">Points</option>
                            <option value="targets">Targets</option>
                            <option value="redzone">Red Zone Opps</option>
                        </select>
                    </div>

                    <!-- Time Frame Selector -->
                    <div>
                        <label style="display: block; font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px;">Time Frame</label>
                        <select id="team-modal-timeframe" onchange="updateTeamModalCharts()" style="width: 100%; padding: 10px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 14px; cursor: pointer;">
                            <option value="season">Season Long</option>
                            <option value="season-avg">Season Avg (PPG)</option>
                            <option value="last5">Last 5 Weeks</option>
                            <option value="last3">Last 3 Weeks</option>
                            <option value="single">Single Week</option>
                        </select>
                    </div>

                    <!-- Week Selector (only shown for Single Week) -->
                    <div id="team-modal-week-selector" style="display: none; grid-column: span 2;">
                        <label style="display: block; font-size: 13px; font-weight: 600; color: var(--text-secondary); margin-bottom: 8px;">Select Week</label>
                        <select id="team-modal-week" onchange="updateTeamModalCharts()" style="width: 100%; padding: 10px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 14px; cursor: pointer;">
                            <!-- Weeks will be populated dynamically -->
                        </select>
                    </div>
                </div>

                <!-- Charts -->
                <div class="team-modal-charts-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div class="chart-card">
                        <div class="chart-header" id="team-modal-players-chart-header">Top 6 Players by Points</div>
                        <div class="chart-wrapper" style="height: 300px;">
                            <canvas id="team-modal-players-chart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header" id="team-modal-position-chart-header">Points by Position</div>
                        <div class="chart-wrapper" style="height: 300px;">
                            <canvas id="team-modal-position-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Login Modal -->
    <div class="modal-overlay" id="login-modal" style="display: none;">
        <div class="modal" style="max-width: 400px;">
            <div class="modal-header">
                <h2 style="font-size: 20px; font-weight: 700; color: var(--text-primary);">Admin Login</h2>
                <button class="modal-close" onclick="closeLoginModal()">×</button>
            </div>
            <div class="modal-body">
                <form onsubmit="handleLogin(event)" style="display: flex; flex-direction: column; gap: 16px;">
                    <div>
                        <label style="display: block; font-size: 13px; color: var(--text-secondary); margin-bottom: 6px;">Email</label>
                        <input
                            type="email"
                            id="login-email"
                            class="waitlist-input"
                            placeholder="admin@ffse.com"
                            required
                            style="width: 100%;"
                        />
                    </div>
                    <div>
                        <label style="display: block; font-size: 13px; color: var(--text-secondary); margin-bottom: 6px;">Password</label>
                        <input
                            type="password"
                            id="login-password"
                            class="waitlist-input"
                            placeholder="Enter password"
                            required
                            style="width: 100%;"
                        />
                    </div>
                    <button type="submit" class="waitlist-btn" onclick="handleLogin(event); return false;" style="width: 100%; padding: 12px;">
                        Login
                    </button>
                </form>
                <div class="success-message" id="login-error" style="background: var(--negative-bg); border-color: var(--negative); color: var(--negative);">
                    Invalid credentials
                </div>
            </div>
        </div>
    </div>

    <!-- Privacy Policy Modal -->
    <div class="modal-overlay" id="privacy-modal" style="display: none;">
        <div class="modal" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
            <div class="modal-header">
                <h2 style="font-size: 20px; font-weight: 700; color: var(--text-primary);">Privacy Policy</h2>
                <button class="modal-close" onclick="closePrivacyModal()">×</button>
            </div>
            <div class="modal-body" style="color: var(--text-secondary); line-height: 1.6;">
                <p style="margin-bottom: 16px; color: var(--text-tertiary); font-size: 13px;">
                    <strong>Effective Date:</strong> November 2025
                </p>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">1. Information We Collect</h3>
                <p style="margin-bottom: 12px; font-size: 14px;">
                    We collect information you provide directly to us, including:
                </p>
                <ul style="margin-left: 24px; margin-bottom: 16px; font-size: 14px;">
                    <li style="margin-bottom: 8px;">Email addresses submitted through our waitlist</li>
                    <li style="margin-bottom: 8px;">Usage data and analytics about how you interact with our platform</li>
                    <li style="margin-bottom: 8px;">Device and browser information</li>
                </ul>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">2. How We Use Your Information</h3>
                <p style="margin-bottom: 12px; font-size: 14px;">
                    We use the information we collect to:
                </p>
                <ul style="margin-left: 24px; margin-bottom: 16px; font-size: 14px;">
                    <li style="margin-bottom: 8px;">Provide, maintain, and improve our services</li>
                    <li style="margin-bottom: 8px;">Send you updates about FFSE features and releases</li>
                    <li style="margin-bottom: 8px;">Respond to your comments and questions</li>
                    <li style="margin-bottom: 8px;">Analyze usage patterns to enhance user experience</li>
                </ul>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">3. Information Sharing</h3>
                <p style="margin-bottom: 16px; font-size: 14px;">
                    We do not sell, trade, or rent your personal information to third parties. We may share your information only in the following circumstances:
                </p>
                <ul style="margin-left: 24px; margin-bottom: 16px; font-size: 14px;">
                    <li style="margin-bottom: 8px;">With your consent</li>
                    <li style="margin-bottom: 8px;">To comply with legal obligations</li>
                    <li style="margin-bottom: 8px;">With service providers who assist in our operations</li>
                </ul>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">4. Data Security</h3>
                <p style="margin-bottom: 16px; font-size: 14px;">
                    We implement appropriate technical and organizational measures to protect your personal information against unauthorized access, alteration, disclosure, or destruction.
                </p>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">5. Cookies and Tracking</h3>
                <p style="margin-bottom: 16px; font-size: 14px;">
                    We use cookies and similar tracking technologies to collect information about your browsing activities and to remember your preferences. You can control cookies through your browser settings.
                </p>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">6. Your Rights</h3>
                <p style="margin-bottom: 12px; font-size: 14px;">
                    You have the right to:
                </p>
                <ul style="margin-left: 24px; margin-bottom: 16px; font-size: 14px;">
                    <li style="margin-bottom: 8px;">Access the personal information we hold about you</li>
                    <li style="margin-bottom: 8px;">Request correction of inaccurate information</li>
                    <li style="margin-bottom: 8px;">Request deletion of your information</li>
                    <li style="margin-bottom: 8px;">Opt-out of marketing communications</li>
                </ul>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">7. Children's Privacy</h3>
                <p style="margin-bottom: 16px; font-size: 14px;">
                    Our service is not directed to individuals under the age of 13. We do not knowingly collect personal information from children under 13.
                </p>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">8. Changes to This Policy</h3>
                <p style="margin-bottom: 16px; font-size: 14px;">
                    We may update this Privacy Policy from time to time. We will notify you of any changes by posting the new Privacy Policy on this page and updating the "Effective Date."
                </p>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">9. Contact Us</h3>
                <p style="margin-bottom: 16px; font-size: 14px;">
                    If you have any questions about this Privacy Policy, please contact us through the FFSE platform.
                </p>

                <div style="margin-top: 32px; padding-top: 24px; border-top: 1px solid var(--border-color);">
                    <p style="font-size: 12px; color: var(--text-tertiary);">
                        By using FFSE, you acknowledge that you have read and understood this Privacy Policy.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Upload Section (Hidden Input) -->
    <input type="file" id="wr-file-input" accept=".csv" onchange="handleWRUpload(event)">
    <input type="file" id="rb-file-input" accept=".csv" onchange="handleRBUpload(event)">

    <script>
        // TE INTEGRATION PREPARATION
        // The code is ready for TE data! When TE CSV is uploaded:
        // 1. teData array will be populated (already declared)
        // 2. TE nav tab will auto-show (#te-tab style display)
        // 3. TE page needs to be created (copy WR page structure)
        // 4. TE Advanced Analytics button will auto-show (#advanced-te-btn)
        // 5. Team Analysis "Pass Catchers" will include TEs automatically
        // 6. Add TE leaderboards: "Volume TEs", "Red Zone TEs", "Efficiency TEs"
        // 7. TE color is orange (#FF9F0A) - use getPositionColor('TE')
        // 8. TEs use WR-style metrics (targets, receptions, air yards, etc.)

        // 1. DATA LAYER

        // Position Colors
        const positionColors = {
            'WR': '#0a84ff',  // Blue
            'RB': '#30d158',  // Green
            'TE': '#ff9f0a'   // Orange/Amber
        };

        // NFL Team Colors
        const teamColors = {
            // AFC East
            'BUF': '#00338D', 'MIA': '#008E97', 'NE': '#223C67', 'NYJ': '#125740',
            // AFC North
            'BAL': '#241773', 'CIN': '#FB4F14', 'CLE': '#5A381E', 'PIT': '#FFB612', // Fixed PIT to gold
            // AFC South
            'HOU': '#14344C', 'IND': '#002C5F', 'JAC': '#006778', 'JAX': '#006778', 'TEN': '#0C2340',
            // AFC West
            'DEN': '#FB4F14', 'KC': '#E31837', 'LV': '#A5ACAF', 'LAC': '#0080C6',
            // NFC East
            'DAL': '#003594', 'NYG': '#0B2265', 'PHI': '#004C54', 'WAS': '#7A2222',
            // NFC North
            'CHI': '#2E3E66', 'DET': '#0076B6', 'GB': '#203731', 'MIN': '#4F2683',
            // NFC South
            'ATL': '#A71930', 'CAR': '#0085CA', 'NO': '#D3BC8D', 'TB': '#D50A0A',
            // NFC West
            'ARI': '#97233F', 'LAR': '#003594', 'SF': '#AA0000', 'SEA': '#223C67'
        };

        // NFL Team Full Color Palettes (Primary, Secondary, Tertiary, Fallback) - Dark UI Optimized
        const teamColorPalettes = {
            // AFC North
            'BAL': ['#241773', '#9E7C0C', '#C8102E', '#8E8AFF'],
            'CIN': ['#FB4F14', '#FF8F33', '#FFD6A5', '#FFB300'],
            'CLE': ['#5A381E', '#FF3C00', '#FF8F66', '#FFB547'],
            'PIT': ['#FFB612', '#00539B', '#C8102E', '#FFD65E'],
            // AFC East
            'BUF': ['#00338D', '#C60C30', '#66A3FF', '#0096FF'],
            'MIA': ['#008E97', '#FC4C02', '#4DD5D0', '#00CFFF'],
            'NE': ['#223C67', '#C60C30', '#B0B7BC', '#748FFF'],
            'NYJ': ['#125740', '#FFFFFF', '#5DBB63', '#29D98C'],
            // AFC South
            'HOU': ['#14344C', '#A6192E', '#D6E3F8', '#007BFF'],
            'IND': ['#002C5F', '#A2AAAD', '#589BFF', '#00A3E0'],
            'JAC': ['#006778', '#D7A22A', '#9F792C', '#00CFCF'],
            'JAX': ['#006778', '#D7A22A', '#9F792C', '#00CFCF'],
            'TEN': ['#0C2340', '#4B92DB', '#C8102E', '#85BFFF'],
            // AFC West
            'DEN': ['#FB4F14', '#223C67', '#FFD6A5', '#FFB300'],
            'KC': ['#E31837', '#FFB81C', '#FF9A66', '#FFD65E'],
            'LV': ['#A5ACAF', '#FFFFFF', '#E6E6E6', '#B8C2CC'],
            'LAC': ['#0080C6', '#FFC20E', '#F4F4F4', '#00CFFF'],
            // NFC North
            'CHI': ['#2E3E66', '#C83803', '#FF8A3D', '#FFB547'],
            'DET': ['#0076B6', '#B0B7BC', '#5CB3FF', '#00A3E0'],
            'GB': ['#203731', '#FFB81C', '#9FCF5A', '#D9B200'],
            'MIN': ['#4F2683', '#FFC62F', '#A285E0', '#8E8AFF'],
            // NFC East
            'DAL': ['#003594', '#869397', '#A8B0B7', '#8CB5FF'],
            'NYG': ['#0B2265', '#A71930', '#7FA9FF', '#007BFF'],
            'PHI': ['#004C54', '#A5ACAF', '#2BAEA6', '#00D6B4'],
            'WAS': ['#7A2222', '#FFB612', '#FFD65E', '#D2691E'],
            // NFC South
            'ATL': ['#A71930', '#A5ACAF', '#E94958', '#FFB5C3'],
            'CAR': ['#0085CA', '#BFC0BF', '#59C9FF', '#00CFFF'],
            'NO': ['#D3BC8D', '#F5E6CC', '#FFF1D4', '#FFD65E'],
            'TB': ['#D50A0A', '#FF7900', '#D3D3D3', '#FFD65E'],
            // NFC West
            'ARI': ['#97233F', '#FFB612', '#E94958', '#FF8C8C'],
            'LAR': ['#003594', '#FFA300', '#FFD65E', '#00CFFF'],
            'SF': ['#AA0000', '#B3995D', '#FFD65E', '#FF8A8A'],
            'SEA': ['#223C67', '#69BE28', '#A5ACAF', '#9EFF78']
        };

        // Global data storage
        let wrData = null;
        let rbData = null;
        let teData = null;
        let injuryData = {}; // Sleeper API injury data
        let aggregatedWRs = {};
        let aggregatedRBs = {};
        let aggregatedTEs = {};
        let currentScoringFormat = localStorage.getItem('ffse_scoring_format') || 'ppr'; // 'ppr', 'half', or 'std'
        let allPlayers = {};
        let teamStats = {}; // Store team statistics globally for Advanced Analytics

        // Team Analysis variables
        let teamAnalysisCharts = {
            pie: null,
            secondary: null
        };
        let leagueComparisonEnabled = true; // Start with league comparison ON
        let currentTeamAnalysisTeam = null;

        // NFL Divisions structure
        const nflDivisions = {
            'AFC East': ['BUF', 'MIA', 'NYJ', 'NE'],
            'AFC North': ['BAL', 'CIN', 'CLE', 'PIT'],
            'AFC South': ['HOU', 'IND', 'JAX', 'TEN'],
            'AFC West': ['DEN', 'KC', 'LV', 'LAC'],
            'NFC East': ['DAL', 'NYG', 'PHI', 'WAS'],
            'NFC North': ['CHI', 'DET', 'GB', 'MIN'],
            'NFC South': ['ATL', 'CAR', 'NO', 'TB'],
            'NFC West': ['ARI', 'LAR', 'SF', 'SEA']
        };

        // Position colors
        const POSITION_COLORS = {
            'WR': '#0a84ff',  // Blue
            'RB': '#30d158',  // Green
            'TE': '#FF9F0A'   // Orange
        };

        // Helper function to get position color
        function getPositionColor(position) {
            return POSITION_COLORS[position] || '#8e8e93'; // Default gray
        }

        // Sentiment & voting data
        let playerVotes = {}; // { playerName: { buy: count, sell: count, hold: count, lastVote: timestamp } }
        let playerComments = {}; // { playerName: [ { text, timestamp, user } ] }

        // Load sentiment data from localStorage
        function loadSentimentData() {
            // FORCE CLEAR - Remove this after first successful load
            const forceClear = false; // Set to false after testing

            if (forceClear) {                localStorage.removeItem('ffse_player_votes');
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith('ffse_user_vote_')) {
                        localStorage.removeItem(key);
                    }
                });
                playerVotes = {};
                return; // Start completely fresh
            }

            const stored = localStorage.getItem('ffse_player_votes');
            if (stored) {
                playerVotes = JSON.parse(stored);

                // Clean old votes (older than 30 days)
                const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
                Object.keys(playerVotes).forEach(player => {
                    if (playerVotes[player].lastVote < thirtyDaysAgo) {
                        delete playerVotes[player];
                    }
                });
            }
        }

        // MANUAL RESET FUNCTION - for testing
        function resetAllSentimentData() {
            localStorage.removeItem('ffse_player_votes');
            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('ffse_user_vote_')) {
                    localStorage.removeItem(key);
                }
            });
            playerVotes = {};
            alert('✅ All sentiment data cleared! Refreshing page...');
            location.reload();
        }

        // Save sentiment data to localStorage
        function saveSentimentData() {
            localStorage.setItem('ffse_player_votes', JSON.stringify(playerVotes));
        }

        // Calculate sentiment score with 7-day decay
        function getSentimentScore(playerName) {
            if (!playerVotes[playerName]) return { score: 0, buy: 0, sell: 0, hold: 0, total: 0 };

            const votes = playerVotes[playerName];
            const now = Date.now();
            const sevenDays = 7 * 24 * 60 * 60 * 1000;

            // Apply time decay (votes older than 7 days have reduced weight)
            const daysSinceVote = (now - votes.lastVote) / (24 * 60 * 60 * 1000);
            const decayFactor = Math.max(0, 1 - (daysSinceVote / 7));

            const weightedBuy = votes.buy * decayFactor;
            const weightedSell = votes.sell * decayFactor;
            const weightedHold = votes.hold * decayFactor;
            const total = weightedBuy + weightedSell + weightedHold;

            // Score: +1 for buy, 0 for hold, -1 for sell
            const score = total > 0 ? (weightedBuy - weightedSell) / total : 0;

            return {
                score: score, // -1 to +1
                buy: votes.buy,
                sell: votes.sell,
                hold: votes.hold,
                total: votes.buy + votes.sell + votes.hold,
                decayFactor: decayFactor
            };
        }

        // Generate signal tags based on data
        function getSignalTag(playerData) {
            if (!playerData.oppShare || !playerData.weeklyData) return null;

            // Calculate opportunity share change (last 2 weeks vs previous 2 weeks)
            const weeks = playerData.weeklyData.sort((a, b) => b.week - a.week);
            if (weeks.length < 4) return null;

            const recent2 = weeks.slice(0, 2);
            const previous2 = weeks.slice(2, 4);
            const recentAvg = recent2.reduce((sum, w) => sum + (parseFloat(w.oppShare) || 0), 0) / 2;
            const previousAvg = previous2.reduce((sum, w) => sum + (parseFloat(w.oppShare) || 0), 0) / 2;
            const change = recentAvg - previousAvg;

            if (change >= 5) return { type: 'trending', label: 'Trending Up', class: 'positive' };

            // Check consistency (avg ± 3 pts for 4+ weeks)
            const avgPoints = weeks.reduce((sum, w) => sum + (parseFloat(w.fpts) || 0), 0) / weeks.length;
            const variance = weeks.reduce((sum, w) => sum + Math.pow((parseFloat(w.fpts) || 0) - avgPoints, 2), 0) / weeks.length;
            const stdDev = Math.sqrt(variance);

            if (stdDev <= 3 && weeks.length >= 4) return { type: 'consistent', label: 'Consistent', class: 'neutral' };

            // Check if undershooting projection
            const undershoots = weeks.filter(w => {
                const actual = parseFloat(w.fpts) || 0;
                const expected = parseFloat(w.expected) || actual;
                return actual < expected;
            }).length;

            if (undershoots >= 3 && weeks.length >= 4) return { type: 'oversold', label: 'Buy Low', class: 'opportunity' };

            return null;
        }

        // Chart instances
        let wrScatterChart = null;
        let rbScatterChart = null;
        let modalVarianceChart = null;
        let modalOutcomesChart = null;
        let modalSpiderChart = null;
        let modalShareChart = null;
        let modalTrendsChart = null;
        let teamModalShareChart = null;
        let teamModalTrendsChart = null;

        // Matrix chart instances
        let wrEfficiencyMatrix = null;
        let wrShareMatrix = null;
        let wrFloorMatrix = null;
        let wrRedzoneMatrix = null;
        let wrVolumeMonsterMatrix = null;
        let wrCatchRateMatrix = null;
        let rbEfficiencyMatrix = null;
        let rbTalentMatrix = null;
        let rbOpportunityMatrix = null;
        let rbShareMatrix = null;
        let rbFloorMatrix = null;
        let rbRedzoneMatrix = null;

        /* New: Player Evaluation Metrics - Data and Chart Instances */
        let evaluationDataWR = {};
        let evaluationDataRB = {};

        /* v7: Segment averages (4-week rolling) */
        let segmentDataWR = {};
        let segmentDataRB = {};

        let wrEvalVolumeEfficiencyChart = null;
        let wrEvalShareRZChart = null;
        let rbEvalTotalRZChart = null;
        let rbEvalVolumeEfficiencyChart = null;

        // Trend animation state
        let evaluationTrendActive = {};
        let evaluationTrendIntervals = {};
        let evaluationTrendCurrentWeek = {};

        // Helper function to generate color variations for players on same team
        function getColorPalette(baseColor, count) {
            // Convert hex to RGB
            const r = parseInt(baseColor.slice(1, 3), 16);
            const g = parseInt(baseColor.slice(3, 5), 16);
            const b = parseInt(baseColor.slice(5, 7), 16);

            const colors = [];
            for (let i = 0; i < count; i++) {
                // Create variations by adjusting brightness and saturation
                const factor = 1 + (i * 0.3); // 0%, 30%, 60%, 90% lighter
                const lighten = Math.min(1, 0.7 + (i * 0.1)); // Start at 70% brightness

                const newR = Math.min(255, Math.floor(r * lighten + (255 - r * lighten) * (i / count)));
                const newG = Math.min(255, Math.floor(g * lighten + (255 - g * lighten) * (i / count)));
                const newB = Math.min(255, Math.floor(b * lighten + (255 - b * lighten) * (i / count)));

                colors.push(`rgb(${newR}, ${newG}, ${newB})`);
            }

            return colors;
        }

        /* ============================================
           New Feature: Player Headshot Handler
           ============================================ */

        // Generate headshot URL for a player
        function getPlayerHeadshotUrl(playerName, team) {
            // Map of player names to their uploaded headshot files
            const headshotMap = {
                'Christian McCaffrey': '/mnt/user-data/uploads/McCaffrey_Christian.JPG',
                'Jonathan Taylor': '/mnt/user-data/uploads/Taylor_Jonathan.JPG',
                'Justin Jefferson': '/mnt/user-data/uploads/Jefferson_Justin.jpg',
                'Ladd McConkey': '/mnt/user-data/uploads/McConkey_Ladd.jpg',
                'Ja\'Marr Chase': '/mnt/user-data/uploads/Chase_Ja_Marr.jpg',
                'Bijan Robinson': '/mnt/user-data/uploads/Robinson_Bijan.JPG'
            };

            return headshotMap[playerName] || null;
        }

        // Create headshot img element
        function createHeadshotElement(playerName, team) {
            const url = getPlayerHeadshotUrl(playerName, team);

            if (url) {
                // REFACTORED: Lazy load images
                return `<img src="" data-src="${url}" alt="${playerName}" class="player-headshot loading" onerror="this.style.display='none'" loading="lazy">`;
            } else {
                // Placeholder: Use team color circle with initials
                const initials = playerName
                    .split(' ')
                    .map(n => n[0])
                    .join('')
                    .toUpperCase()
                    .slice(0, 2);
                const bgColor = teamColors[team] || '#666';
                return `<div class="player-headshot" style="background: ${bgColor}; display: flex; align-items: center; justify-content: center; font-size: 11px; font-weight: 700; color: white;">${initials}</div>`;
            }
        }

        // REFACTORED: Lazy load headshot images with Intersection Observer
        function initLazyLoadHeadshots() {
            if ('IntersectionObserver' in window) {
                const imageObserver = new IntersectionObserver((entries, observer) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const img = entry.target;
                            img.src = img.dataset.src;
                            img.classList.remove('loading');
                            observer.unobserve(img);
                        }
                    });
                });

                document.querySelectorAll('img.player-headshot[data-src]').forEach(img => {
                    imageObserver.observe(img);
                });
            } else {
                // Fallback for older browsers
                document.querySelectorAll('img.player-headshot[data-src]').forEach(img => {
                    img.src = img.dataset.src;
                    img.classList.remove('loading');
                });
            }
        }

        /* ============================================
           REFACTORED: Animation & Chart Utilities
           ============================================ */

        // Easing functions for smooth animations
        const Easing = {
            linear: t => t,
            easeInOutSine: t => -(Math.cos(Math.PI * t) - 1) / 2,
            easeOutCubic: t => 1 - Math.pow(1 - t, 3),
            easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2
        };

        // Chart update utility - update data instead of destroying
        function updateChartData(chart, newData) {
            if (!chart) return;
            chart.data.datasets[0].data = newData;
            chart.update('none'); // Update without animation for performance
        }

        // Smooth interpolation
        function lerp(start, end, t) {
            return start + (end - start) * t;
        }

        // Get chart instance by ID

        /* ============================================
           New Feature: Trend Animation
           ============================================ */

        let trendAnimationActive = {};
        let trendAnimationFrames = {};

        function toggleTrendAnimation(chartId) {
            trendAnimationActive[chartId] = !trendAnimationActive[chartId];
            trendAnimationFrames[chartId] = 0;

            const btn = document.querySelector(`[data-chart="${chartId}"]`);
            if (btn) {
                btn.classList.toggle('active');
            }

            // Note: Animation loop would be triggered here if we had weekly player data
            // For now, this is a placeholder for future implementation
        }

        /* ============================================
           Quadrant Highlighting Removed - Using chart annotations instead
           ============================================ */

        // Helper function for linear regression
        function calculateLinearRegression(data) {
            const n = data.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;

            data.forEach(point => {
                sumX += point.x;
                sumY += point.y;
                sumXY += point.x * point.y;
                sumX2 += point.x * point.x;
            });

            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;

            return { slope, intercept };
        }

        /* ============================================
           New: Player Evaluation Metrics Functions
           ============================================ */

        /**
         * Calculate evaluation metrics from raw weekly data
         * Creates per-week and aggregated metrics for WRs
         */
        function calculateWREvaluationMetrics(weeklyData) {
            const wrsByWeek = {};
            const wrTeamTotals = {}; // Track team totals by week

            // First pass: organize by player and week, calculate team totals
            weeklyData.forEach(row => {
                const week = parseInt(row.Week);
                const player = row.Player?.trim();
                const team = row.Team?.trim();

                if (!player || !week || week === 0) return;

                // Initialize player data
                if (!wrsByWeek[player]) {
                    wrsByWeek[player] = { team: team, weeks: {} };
                }

                // Extract metrics
                const targets = parseFloat(row.TGT) || 0;
                const fpts = parseFloat(row.FPTS) || 0;
                const rzTargets = parseFloat(row['RZ TGT']) || parseFloat(row['RZ_TGT']) || 0;

                // Store week data
                wrsByWeek[player].weeks[week] = {
                    targets: targets,
                    fpts: fpts,
                    rzTargets: rzTargets,
                    team: team
                };

                // Track team totals for share calculation
                const teamKey = `${team}-${week}`;
                if (!wrTeamTotals[teamKey]) {
                    wrTeamTotals[teamKey] = { targets: 0, rzTargets: 0 };
                }
                wrTeamTotals[teamKey].targets += targets;
                wrTeamTotals[teamKey].rzTargets += rzTargets;
            });

            // Second pass: calculate derived metrics
            Object.keys(wrsByWeek).forEach(player => {
                const playerData = wrsByWeek[player];
                const weeks = Object.keys(playerData.weeks).map(Number).sort((a, b) => a - b);

                weeks.forEach(week => {
                    const weekData = playerData.weeks[week];
                    const teamKey = `${weekData.team}-${week}`;
                    const teamTotals = wrTeamTotals[teamKey] || { targets: 1, rzTargets: 1 };

                    // Calculate per-game and share metrics
                    weekData.targetsPerGame = weekData.targets; // Already per-game in weekly data
                    weekData.fptsPerTarget = weekData.targets > 0 ? weekData.fpts / weekData.targets : 0;
                    weekData.targetShare = (weekData.targets / teamTotals.targets) * 100;
                    weekData.rzTargetShare = teamTotals.rzTargets > 0 ? (weekData.rzTargets / teamTotals.rzTargets) * 100 : 0;
                });

                // Calculate aggregates across all weeks
                const allWeekData = weeks.map(w => playerData.weeks[w]);
                playerData.aggregate = {
                    gamesPlayed: weeks.length,
                    totalTargets: allWeekData.reduce((sum, w) => sum + w.targets, 0),
                    totalFpts: allWeekData.reduce((sum, w) => sum + w.fpts, 0),
                    totalRZTargets: allWeekData.reduce((sum, w) => sum + w.rzTargets, 0),
                    avgTargetsPerGame: allWeekData.reduce((sum, w) => sum + w.targets, 0) / weeks.length,
                    avgFptsPerTarget: allWeekData.reduce((sum, w) => sum + w.fpts, 0) / allWeekData.reduce((sum, w) => sum + w.targets, 0.0001),
                    avgTargetShare: allWeekData.reduce((sum, w) => sum + w.targetShare, 0) / weeks.length,
                    avgRZTargetShare: allWeekData.reduce((sum, w) => sum + w.rzTargetShare, 0) / weeks.length,
                    latestWeek: Math.max(...weeks)
                };
            });

            return wrsByWeek;
        }

        /**
         * Calculate evaluation metrics from raw weekly data
         * Creates per-week and aggregated metrics for RBs
         */
        function calculateRBEvaluationMetrics(weeklyData) {
            const rbsByWeek = {};
            const rbTeamTotals = {}; // Track team totals by week

            // First pass: organize by player and week
            weeklyData.forEach(row => {
                const week = parseInt(row.Week);
                const player = row.Player?.trim();
                const team = row.Team?.trim();

                if (!player || !week || week === 0) return;

                // Initialize player data
                if (!rbsByWeek[player]) {
                    rbsByWeek[player] = { team: team, weeks: {} };
                }

                // Extract metrics
                const rushAtt = parseFloat(row.ATT) || 0;
                const targets = parseFloat(row.TGT) || 0;
                const fpts = parseFloat(row.FPTS) || 0;
                const rzRushAtt = parseFloat(row.RZ_RUSH_ATT) || 0;
                const rzTargets = parseFloat(row['RZ TGT']) || parseFloat(row['RZ_TGT']) || 0;
                const opportunities = rushAtt + targets;
                const rzOpportunities = rzRushAtt + rzTargets;

                // Store week data
                rbsByWeek[player].weeks[week] = {
                    opportunities: opportunities,
                    fpts: fpts,
                    rzOpportunities: rzOpportunities,
                    team: team
                };

                // Track team totals
                const teamKey = `${team}-${week}`;
                if (!rbTeamTotals[teamKey]) {
                    rbTeamTotals[teamKey] = { opportunities: 0, rzOpportunities: 0 };
                }
                rbTeamTotals[teamKey].opportunities += opportunities;
                rbTeamTotals[teamKey].rzOpportunities += rzOpportunities;
            });

            // Second pass: calculate derived metrics
            Object.keys(rbsByWeek).forEach(player => {
                const playerData = rbsByWeek[player];
                const weeks = Object.keys(playerData.weeks).map(Number).sort((a, b) => a - b);

                weeks.forEach(week => {
                    const weekData = playerData.weeks[week];
                    // Calculate per-game and efficiency metrics
                    weekData.opportunitiesPerGame = weekData.opportunities;
                    weekData.rzOpportunitiesPerGame = weekData.rzOpportunities;
                    weekData.efficiency = weekData.opportunities > 0 ? weekData.fpts / weekData.opportunities : 0;
                });

                // Calculate aggregates
                const allWeekData = weeks.map(w => playerData.weeks[w]);
                playerData.aggregate = {
                    gamesPlayed: weeks.length,
                    totalOpportunities: allWeekData.reduce((sum, w) => sum + w.opportunities, 0),
                    totalFpts: allWeekData.reduce((sum, w) => sum + w.fpts, 0),
                    totalRZOpportunities: allWeekData.reduce((sum, w) => sum + w.rzOpportunities, 0),
                    avgOpportunitiesPerGame: allWeekData.reduce((sum, w) => sum + w.opportunities, 0) / weeks.length,
                    avgRZOpportunitiesPerGame: allWeekData.reduce((sum, w) => sum + w.rzOpportunities, 0) / weeks.length,
                    avgEfficiency: allWeekData.reduce((sum, w) => sum + w.fpts, 0) / allWeekData.reduce((sum, w) => sum + w.opportunities, 0.0001),
                    latestWeek: Math.max(...weeks)
                };
            });

            return rbsByWeek;
        }

        /**
         * Get the data for a specific week or latest week
         */
        function getEvaluationWeekData(evaluationData, week = null) {
            const result = [];

            Object.keys(evaluationData).forEach(player => {
                const playerData = evaluationData[player];
                const targetWeek = week || playerData.aggregate.latestWeek;
                const weekData = playerData.weeks[targetWeek];

                if (weekData) {
                    result.push({
                        player: player,
                        team: playerData.team,
                        ...weekData,
                        aggregate: playerData.aggregate
                    });
                }
            });

            return result;
        }

        /**
         * Get all available weeks from evaluation data
         */
        function getAvailableWeeks(evaluationData) {
            const weeks = new Set();
            Object.values(evaluationData).forEach(playerData => {
                Object.keys(playerData.weeks).forEach(week => weeks.add(parseInt(week)));
            });
            return Array.from(weeks).sort((a, b) => a - b);
        }

        /* ========================================================================
         * v7: SEGMENT CALCULATION FUNCTIONS
         * Calculate rolling N-week segment averages from weekly data
         * ======================================================================== */

        /**
         * Calculate NON-OVERLAPPING 4-week segment averages
         * Segments: Weeks 1-4, 5-8, 9-12, 13-16, etc.
         * @param {Object} evaluationData - Player-keyed evaluation data (wrsByWeek or rbsByWeek format)
         * @param {number} segmentSize - Number of weeks per segment (default: 4)
         * @returns {Object} Segment data keyed by segment index
         */
        function calculateSegmentAverages(evaluationData, segmentSize = 4) {
            // Get all available weeks from all players
            const allWeeks = new Set();
            Object.values(evaluationData).forEach(playerData => {
                Object.keys(playerData.weeks).forEach(week => {
                    allWeeks.add(parseInt(week));
                });
            });

            const weeks = Array.from(allWeeks).sort((a, b) => a - b);

            if (weeks.length < segmentSize) {                return {};
            }

            const minWeek = weeks[0];
            const maxWeek = weeks[weeks.length - 1];

            // Calculate number of non-overlapping segments
            const numSegments = Math.ceil(maxWeek / segmentSize);
            const segmentData = {};

            // Create each non-overlapping segment
            for (let segmentIndex = 0; segmentIndex < numSegments; segmentIndex++) {
                const segmentStartWeek = (segmentIndex * segmentSize) + 1;
                const segmentEndWeek = Math.min(segmentStartWeek + segmentSize - 1, maxWeek);
                const segmentWeeks = [];

                // Build array of weeks in this segment
                for (let w = segmentStartWeek; w <= segmentEndWeek; w++) {
                    if (weeks.includes(w)) {
                        segmentWeeks.push(w);
                    }
                }

                if (segmentWeeks.length === 0) continue;

                // Calculate averages for each player in this segment
                const segmentPlayers = [];

                Object.keys(evaluationData).forEach(playerName => {
                    const playerData = evaluationData[playerName];
                    const playerWeeksInSegment = [];

                    // Collect this player's data for weeks in this segment
                    segmentWeeks.forEach(week => {
                        if (playerData.weeks[week]) {
                            playerWeeksInSegment.push({
                                week: week,
                                ...playerData.weeks[week]
                            });
                        }
                    });

                    // Skip if player has no data in this segment
                    if (playerWeeksInSegment.length === 0) return;

                    // Calculate averages
                    const avgPlayer = {
                        player: playerName,
                        team: playerData.team,
                        segmentWeeks: segmentWeeks,
                        weeksInSegment: playerWeeksInSegment.length
                    };

                    // Fields to average - check what fields exist
                    const fieldsToAverage = [
                        'targets', 'targetsPerGame', 'fpts', 'fptsPerTarget',
                        'targetShare', 'rzTargets', 'rzTargetShare',
                        'opportunities', 'rzOpportunities', 'efficiency'
                    ];

                    fieldsToAverage.forEach(field => {
                        const values = playerWeeksInSegment
                            .map(w => w[field])
                            .filter(v => v !== undefined && v !== null && !isNaN(v));

                        if (values.length > 0) {
                            avgPlayer[field] = values.reduce((sum, v) => sum + v, 0) / values.length;
                        }
                    });

                    // Use player's aggregate data (calculated across all weeks)
                    avgPlayer.aggregate = playerData.aggregate;

                    segmentPlayers.push(avgPlayer);
                });

                segmentData[segmentIndex] = segmentPlayers;
            }

            return segmentData;
        }

        /**
         * Get available segments from segment data
         * @param {Object} segmentData - Segment data object
         * @returns {Array<number>} Sorted array of segment indices
         */
        function getAvailableSegments(segmentData) {
            return Object.keys(segmentData)
                .map(Number)
                .filter(s => !isNaN(s))
                .sort((a, b) => a - b);
        }

        /**
         * Get data for a specific segment
         * @param {Object} segmentData - Segment data object
         * @param {number} segmentIndex - Segment index (can be fractional for interpolation)
         * @returns {Array} Player data for the segment
         */
        function getEvaluationSegmentData(segmentData, segmentIndex = null) {
            const segments = getAvailableSegments(segmentData);

            if (segments.length === 0) {
                return [];
            }

            // If no segment specified, return latest
            if (segmentIndex === null) {
                return segmentData[segments[segments.length - 1]] || [];
            }

            // If integer segment, return directly
            if (Number.isInteger(segmentIndex) && segmentData[segmentIndex]) {
                return segmentData[segmentIndex] || [];
            }

            // For fractional segments, return floor value (interpolation handled by animation)
            const floorIndex = Math.floor(segmentIndex);
            return segmentData[floorIndex] || [];
        }

        /**
         * Get the week range for a segment index
         * @param {Object} segmentData - Segment data object
         * @param {number} segmentIndex - Segment index
         * @returns {Array<number>} Array of week numbers in the segment
         */
        function getSegmentWeekRange(segmentData, segmentIndex) {
            const segmentPlayers = segmentData[segmentIndex];
            if (!segmentPlayers || segmentPlayers.length === 0) {
                return [];
            }

            // Get weeks from first player (all players in segment have same weeks)
            return segmentPlayers[0].segmentWeeks || [];
        }

        /**
         * Format segment label for display
         * @param {number} segmentFloat - Segment index (can be fractional)
         * @param {Object} segmentData - Segment data object
         * @returns {string} Formatted label (e.g., "Segments 1-4")
         */
        function formatSegmentLabel(segmentFloat, segmentData) {
            const segmentIndex = Math.floor(segmentFloat);
            const weeks = getSegmentWeekRange(segmentData, segmentIndex);

            if (weeks.length === 0) {
                return `Segment ${segmentIndex}`;
            }

            const firstWeek = weeks[0];
            const lastWeek = weeks[weeks.length - 1];

            if (firstWeek === lastWeek) {
                return `Week ${firstWeek}`;
            }

            return `Segments ${firstWeek}-${lastWeek}`;
        }

        /* End of v7 Segment Calculation Functions */

        // AI Analysis Generator
        function generatePlayerAnalysis(player) {
            const insights = [];

            // 1. Opportunity Share Analysis
            const oppShare = player.latestWeekOppShare;
            if (oppShare > 30) {
                insights.push(`<strong>High target</strong> with ${oppShare.toFixed(0)}% opportunity share - commanding a significant portion of team's offense.`);
            } else if (oppShare > 20) {
                insights.push(`<strong>Solid role</strong> with ${oppShare.toFixed(0)}% opportunity share - reliable contributor in the offense.`);
            } else if (oppShare > 10) {
                insights.push(`<strong>Limited role</strong> at ${oppShare.toFixed(0)}% opportunity share - may need more involvement for consistent production.`);
            } else {
                insights.push(`<strong>Minimal role</strong> with only ${oppShare.toFixed(0)}% opportunity share - volatility risk is high.`);
            }

            // 2. Performance vs Expected
            const overPerformances = player.weeks.filter(w => w.variance > 0).length;
            const totalWeeks = player.weeks.length;
            const overPerformRate = (overPerformances / totalWeeks) * 100;

            if (overPerformRate > 65) {
                insights.push(`<strong>Exceeding expectations</strong> - outperformed projections in ${overPerformances} of ${totalWeeks} games (${overPerformRate.toFixed(0)}%). High efficiency player.`);
            } else if (overPerformRate > 35) {
                insights.push(`<strong>Meeting expectations</strong> - balanced performance around projections (${overPerformRate.toFixed(0)}% over-performance rate).`);
            } else {
                insights.push(`<strong>Underperforming</strong> - only exceeded expectations in ${overPerformances} of ${totalWeeks} games. May be dealing with efficiency issues or tough matchups.`);
            }

            // 3. Volume vs Efficiency Analysis
            const avgVariance = player.weeks.reduce((sum, w) => sum + w.variance, 0) / totalWeeks;
            const totalOpps = player.position === 'WR' ? player.totalTargets : player.totalOpportunities;

            if (totalOpps > 70 && avgVariance < -1) {
                insights.push(`<strong>High-volume, low-efficiency</strong> - receiving significant opportunities (${totalOpps}) but averaging ${Math.abs(avgVariance).toFixed(1)} points below expected per game.`);
            } else if (totalOpps > 70 && avgVariance > 1) {
                insights.push(`<strong>High-volume, high-efficiency</strong> - elite combination of opportunity (${totalOpps}) and production (+${avgVariance.toFixed(1)} vs expected per game).`);
            } else if (totalOpps < 40 && avgVariance > 1) {
                insights.push(`<strong>Limited volume, high efficiency</strong> - making the most of opportunities with +${avgVariance.toFixed(1)} vs expected, but volume (${totalOpps}) caps upside.`);
            }

            // 4. Consistency Analysis
            const variances = player.weeks.map(w => w.variance);
            const stdDev = Math.sqrt(variances.reduce((sum, v) => sum + Math.pow(v, 2), 0) / totalWeeks);

            if (stdDev < 3) {
                insights.push(`<strong>High floor, stable producer</strong> - low variance (${stdDev.toFixed(1)}) suggests consistent weekly outcomes.`);
            } else if (stdDev > 6) {
                insights.push(`<strong>Boom-or-bust profile</strong> - high variance (${stdDev.toFixed(1)}) indicates wide range of weekly outcomes.`);
            }

            // 5. Trend Analysis
            if (player.oppChange > 5) {
                insights.push(`<strong>📈 Trending up</strong> - opportunity share increased by ${player.oppChange.toFixed(1)}% recently, suggesting growing role.`);
            } else if (player.oppChange < -5) {
                insights.push(`<strong>📉 Trending down</strong> - opportunity share decreased by ${Math.abs(player.oppChange).toFixed(1)}%, role may be shrinking.`);
            }

            return insights.join(' ');
        }

        // Load data from localStorage on page load
        function loadStoredData() {
            const storedWR = localStorage.getItem('wrData');
            const storedRB = localStorage.getItem('rbData');
            const storedTE = localStorage.getItem('teData');

            if (storedWR) {
                wrData = JSON.parse(storedWR);
            }
            if (storedRB) {
                rbData = JSON.parse(storedRB);
            }
            if (storedTE) {
                teData = JSON.parse(storedTE);
            }

            if (wrData || rbData || teData) {
                processAllData();
            }
        }

        // GitHub Data URLs - update these when you upload new CSVs
        const GITHUB_DATA_URLS = {
            wr: 'https://raw.githubusercontent.com/aryi3025/ffse-data/refs/heads/main/wr_data.csv',
            rb: 'https://raw.githubusercontent.com/aryi3025/ffse-data/refs/heads/main/rb_data.csv',
            te: 'https://raw.githubusercontent.com/aryi3025/ffse-data/refs/heads/main/te_data.csv'
        };

        // Fetch data from GitHub
        async function fetchDataFromGitHub() {
            try {
                const [wrResponse, rbResponse, teResponse] = await Promise.all([
                    fetch(GITHUB_DATA_URLS.wr),
                    fetch(GITHUB_DATA_URLS.rb),
                    fetch(GITHUB_DATA_URLS.te)
                ]);

                if (!wrResponse.ok || !rbResponse.ok || !teResponse.ok) {
                    throw new Error('Failed to fetch data from GitHub');
                }

                const [wrText, rbText, teText] = await Promise.all([
                    wrResponse.text(),
                    rbResponse.text(),
                    teResponse.text()
                ]);

                // Parse WR data
                Papa.parse(wrText, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        wrData = results.data.filter(row => row.Player && row.Week);
                        localStorage.setItem('wrData', JSON.stringify(wrData));                        checkAndProcessData();
                    }
                });

                // Parse RB data
                Papa.parse(rbText, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        rbData = results.data.filter(row => row.Player && row.Week);
                        localStorage.setItem('rbData', JSON.stringify(rbData));                        checkAndProcessData();
                    }
                });

                // Parse TE data
                Papa.parse(teText, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        teData = results.data.filter(row => row.Player && row.Week);
                        localStorage.setItem('teData', JSON.stringify(teData));                        checkAndProcessData();
                    }
                });

            } catch (error) {                // Fall back to localStorage data if fetch fails
                loadStoredData();
                hideLoadingIndicator();
            }
        }

        // Fetch injury data from Sleeper API
        async function fetchInjuryData() {
            try {
                // Fetch all NFL players from Sleeper API
                const response = await fetch('https://api.sleeper.app/v1/players/nfl');
                
                if (!response.ok) {
                    throw new Error('Failed to fetch injury data from Sleeper');
                }

                const players = await response.json();
                
                // Process and store injury data
                injuryData = {};
                
                for (const playerId in players) {
                    const player = players[playerId];
                    
                    // Only store players with injury status
                    if (player.injury_status && player.injury_status !== 'Healthy') {
                        const fullName = `${player.first_name} ${player.last_name}`;
                        
                        injuryData[fullName] = {
                            status: player.injury_status, // 'Questionable', 'Doubtful', 'Out', 'IR', 'PUP', etc.
                            injuryBody: player.injury_body_part || 'Unknown',
                            team: player.team || 'FA',
                            position: player.position,
                            lastUpdate: Date.now()
                        };
                    }
                }

                // Cache injury data in localStorage (expires after 1 hour)
                localStorage.setItem('injuryData', JSON.stringify({
                    data: injuryData,
                    timestamp: Date.now()
                }));

                return injuryData;
                
            } catch (error) {
                // Try to use cached data if API fails
                const cached = localStorage.getItem('injuryData');
                if (cached) {
                    const parsedCache = JSON.parse(cached);
                    const cacheAge = Date.now() - parsedCache.timestamp;
                    
                    // Use cache if less than 1 hour old
                    if (cacheAge < 3600000) {
                        injuryData = parsedCache.data;
                        return injuryData;
                    }
                }
                
                return {};
            }
        }

        // Get injury info for a specific player
        function getPlayerInjuryStatus(playerName) {
            if (!injuryData || !injuryData[playerName]) {
                return null;
            }
            
            return injuryData[playerName];
        }

        // Format injury status for display
        function formatInjuryStatus(status) {
            const statusMap = {
                'Questionable': { badge: 'Q', class: 'questionable', fullText: 'Questionable' },
                'Doubtful': { badge: 'D', class: 'doubtful', fullText: 'Doubtful' },
                'Out': { badge: 'O', class: 'out', fullText: 'Out' },
                'IR': { badge: 'IR', class: 'ir', fullText: 'Injured Reserve' },
                'PUP': { badge: 'PUP', class: 'pup', fullText: 'Physically Unable to Perform' },
                'Suspended': { badge: 'SUS', class: 'suspended', fullText: 'Suspended' },
                'COV': { badge: 'COV', class: 'cov', fullText: 'COVID-19 List' }
            };
            
            return statusMap[status] || { badge: status, class: 'questionable', fullText: status };
        }

        // Check if all data is loaded and process
        let dataLoadedCount = 0;
        function checkAndProcessData() {
            dataLoadedCount++;
            if (dataLoadedCount >= 3) { // All three datasets loaded
                processAllData();
                hideLoadingIndicator();

                // Render dashboard if it's the active page
                setTimeout(() => {
                    const dashboardPage = document.getElementById('top-movers');
                    if (dashboardPage && dashboardPage.classList.contains('active')) {
                        renderDashboardCategories();
                        setTimeout(renderMiniScatterPlots, 100);
                    }
                }, 200);

                dataLoadedCount = 0; // Reset for next fetch
            }
        }

        function showLoadingIndicator() {
            const mainContent = document.querySelector('.main-content');
            const loadingDiv = document.createElement('div');
            loadingDiv.id = 'data-loading-indicator';
            loadingDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: var(--bg-elevated);
                padding: 40px 60px;
                border-radius: 16px;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
                text-align: center;
                z-index: 10000;
            `;
            loadingDiv.innerHTML = `
                <div style="font-size: 24px; font-weight: 700; color: var(--text-primary); margin-bottom: 12px;">
                    Loading Latest Data...
                </div>
                <div style="font-size: 14px; color: var(--text-secondary);">
                    Fetching player stats from database
                </div>
                <div style="margin-top: 20px;">
                    <div class="loading-spinner"></div>
                </div>
            `;
            document.body.appendChild(loadingDiv);

            // Add backdrop
            const backdrop = document.createElement('div');
            backdrop.id = 'loading-backdrop';
            backdrop.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 9999;
            `;
            document.body.appendChild(backdrop);
        }

        function hideLoadingIndicator() {
            const indicator = document.getElementById('data-loading-indicator');
            const backdrop = document.getElementById('loading-backdrop');
            if (indicator) indicator.remove();
            if (backdrop) backdrop.remove();
        }

        // CSV Upload Handlers
        function showUploadSection() {
            const hasData = wrData && rbData && teData;
            if (hasData) {
                if (confirm('You already have data loaded. Do you want to upload new data?')) {
                    document.getElementById('wr-file-input').click();
                }
            } else {
                document.getElementById('wr-file-input').click();
            }
        }

        function handleWRUpload(event) {
            const file = event.target.files[0];
            if (file) {
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        wrData = results.data.filter(row => row.Player && row.Week);
                        localStorage.setItem('wrData', JSON.stringify(wrData));

                        if (rbData) {
                            processAllData();
                        } else {
                            setTimeout(() => {
                                document.getElementById('rb-file-input').click();
                            }, 300);
                        }
                    }
                });
            }
        }

        function handleRBUpload(event) {
            const file = event.target.files[0];
            if (file) {
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        rbData = results.data.filter(row => row.Player && row.Week);
                        localStorage.setItem('rbData', JSON.stringify(rbData));
                        processAllData();
                    }
                });
            }
        }

        // 2. CALCULATIONS

        function processAllData() {
            if (wrData) {
                aggregatedWRs = aggregatePlayerData(wrData, 'WR');
                // New: Calculate evaluation metrics for WRs
                evaluationDataWR = calculateWREvaluationMetrics(wrData);
            }
            if (rbData) {
                aggregatedRBs = aggregatePlayerData(rbData, 'RB');
                // New: Calculate evaluation metrics for RBs
                evaluationDataRB = calculateRBEvaluationMetrics(rbData);
            }
            if (teData) {
                aggregatedTEs = aggregatePlayerData(teData, 'TE');
            }

            // v7: Calculate 4-week rolling segment averages
            if (Object.keys(evaluationDataWR).length > 0) {
                segmentDataWR = calculateSegmentAverages(evaluationDataWR, 4);            }
            if (Object.keys(evaluationDataRB).length > 0) {
                segmentDataRB = calculateSegmentAverages(evaluationDataRB, 4);            }

            // Combine all players
            allPlayers = { ...aggregatedWRs, ...aggregatedRBs, ...aggregatedTEs };


            // Calculate ROS ranks
            calculateROSRanks();

            // Calculate momentum scores
            calculateAllMomentum();

            // Render all pages
            renderAllPages();

            // Update last updated date
            setLastUpdatedDate();
        }

        function aggregatePlayerData(weeklyData, position) {
            const players = {};

            // Helper function to calculate adjusted fantasy points based on scoring format
            const getAdjustedFantasyPoints = (pprPoints, receptions) => {
                if (currentScoringFormat === 'std') {
                    // Standard: Remove all reception points
                    return pprPoints - receptions;
                } else if (currentScoringFormat === 'half') {
                    // Half-PPR: Remove half of reception points
                    return pprPoints - (0.5 * receptions);
                } else {
                    // PPR: Use points as-is
                    return pprPoints;
                }
            };

            weeklyData.forEach(row => {
                if (!row.Player || !row.Week) return;

                const id = `${row.Team}-${row.Player}`;

                if (!players[id]) {
                    players[id] = {
                        id: id,
                        name: row.Player,
                        team: row.Team,
                        position: position,
                        weeks: [],
                        totalPoints: 0,
                        gamesPlayed: 0,
                        totalTargets: 0,
                        totalOpportunities: 0,
                        rzOpportunities: 0,
                        avgPoints: 0,
                        latestWeek: 0,
                        latestWeekPoints: 0,
                        latestWeekOppShare: 0,
                        oppChange: 0,
                        // WR metrics
                        totalRec: 0,
                        totalAir: 0,
                        totalCatchable: 0,
                        totalYDS: 0,
                        totalYAC: 0,
                        catchRate: 0,
                        catchableCatchRate: 0,
                        racr: 0,
                        tgtPerGame: 0,
                        airYardsPerGame: 0,
                        yacPerRec: 0,
                        // TD stats (all positions)
                        totalRecTDs: 0,
                        totalRushTDs: 0,
                        rzTDs: 0,
                        // RB metrics
                        totalCarries: 0,
                        totalRushYards: 0,
                        totalRecYards: 0,
                        totalYBCON: 0,
                        totalYACON: 0
                    };
                }

                const weekNum = parseInt(row.Week);
                const fptsPPR = parseFloat(row.FPTS || row.Fpts) || 0; // Base PPR points from CSV
                const receptions = parseFloat(row.REC) || 0; // Get receptions for adjustment

                // Calculate adjusted fantasy points based on current scoring format
                const fpts = getAdjustedFantasyPoints(fptsPPR, receptions);

                // Get expected fantasy points and variance based on current scoring format
                let expFpts, variance;
                if (currentScoringFormat === 'std') {
                    expFpts = parseFloat(row.Exp_Ft_Points_STD) || 0;
                    variance = parseFloat(row.FPTS_Variance_STD) || 0;
                } else if (currentScoringFormat === 'half') {
                    expFpts = parseFloat(row.Exp_Ft_Points_HALF) || 0;
                    variance = parseFloat(row.FPTS_Variance_HALF) || 0;
                } else { // PPR (default)
                    expFpts = parseFloat(row.Exp_Ft_Points || row.Exp_Ft_Points_PPR) || 0;
                    variance = parseFloat(row.FPTS_Variance || row.FPTS_Variance_PPR) || 0;
                }

                const weekData = {
                    week: weekNum,
                    fpts: fpts, // Adjusted fantasy points
                    fptsPPR: fptsPPR, // Store original PPR points for reference
                    receptions: receptions, // Store receptions for future adjustments
                    expectedFpts: expFpts,
                    variance: variance
                };

                if (position === 'WR' || position === 'TE') {
                    const tgt = parseFloat(row.TGT) || 0;
                    const rzTgt = parseFloat(row['RZ TGT']) || parseFloat(row.RZ_TGT) || 0;
                    const teamShare = parseFloat(row['% TM']) || 0;
                    const rec = parseFloat(row.REC) || 0;
                    const air = parseFloat(row.AIR) || 0;
                    const catchable = parseFloat(row.CATCHABLE) || 0;
                    // For TEs, yards might be in YDS column instead of REC_YDS
                    const yds = parseFloat(row.REC_YDS) || parseFloat(row.YDS) || 0;
                    const yac = parseFloat(row.YAC) || 0;
                    const recTD = parseFloat(row.REC_TD) || 0;
                    const rushTD = parseFloat(row.RUSH_TD) || 0;
                    // RZ TDs = RZ_REC_TD + RZ_RUSH_TD
                    const rzRecTD = parseFloat(row.RZ_REC_TD) || 0;
                    const rzRushTD = parseFloat(row.RZ_RUSH_TD) || 0;
                    const rzTD = rzRecTD + rzRushTD;
                    const rushYds = parseFloat(row.RUSH_YDS) || 0;
                    const carries = parseFloat(row.CARRIES) || 0;

                    weekData.targets = tgt;
                    weekData.rzTargets = rzTgt;
                    weekData.teamShare = teamShare;

                    players[id].totalTargets += tgt;
                    players[id].rzOpportunities += rzTgt;
                    players[id].totalRec += rec;
                    players[id].totalAir += air;
                    players[id].totalCatchable += catchable;
                    players[id].totalYDS += yds;
                    players[id].totalYAC += yac;
                    players[id].totalRecTDs += recTD;
                    players[id].totalRushTDs += rushTD;
                    players[id].rzTDs += rzTD;
                    players[id].totalRushYards += rushYds;
                    players[id].totalCarries += carries;
                } else {
                    const rbOpp = parseFloat(row['RB Opp']) || 0;
                    const rzRushAtt = parseFloat(row['RZ_RUSH_ATT']) || 0;
                    const rzTgt = parseFloat(row['RZ TGT']) || parseFloat(row['RZ_TGT']) || 0;
                    const rushAtt = parseFloat(row.ATT) || 0;
                    const tgt = parseFloat(row.TGT) || 0;
                    const rushYds = parseFloat(row.YDS) || 0;
                    const recYds = parseFloat(row.REC_YDS) || 0;
                    const ybcon = parseFloat(row.YBCON) || 0;
                    const yacon = parseFloat(row.YACON) || 0;
                    const rec = parseFloat(row.REC) || 0;
                    const recTD = parseFloat(row.REC_TD) || 0;
                    const rushTD = parseFloat(row.RUSH_TD) || 0;
                    // RZ TDs = RZ_REC_TD + RZ_RUSH_TD
                    const rzRecTD = parseFloat(row.RZ_REC_TD) || 0;
                    const rzRushTD = parseFloat(row.RZ_RUSH_TD) || 0;
                    const rzTD = rzRecTD + rzRushTD;

                    weekData.opportunities = rbOpp;
                    weekData.rzOpportunities = rzRushAtt + rzTgt; // Include both RZ rush attempts and RZ targets
                    weekData.rushAttempts = rushAtt;
                    weekData.targets = tgt;

                    players[id].totalOpportunities += rbOpp;
                    players[id].rzOpportunities += (rzRushAtt + rzTgt); // Include both RZ rush attempts and RZ targets
                    players[id].totalCarries += rushAtt;
                    players[id].totalTargets += tgt;
                    players[id].totalRushYards += rushYds;
                    players[id].totalRecYards += recYds;
                    players[id].totalYBCON += ybcon;
                    players[id].totalYACON += yacon;
                    players[id].totalRec += rec;
                    players[id].totalRecTDs += recTD;
                    players[id].totalRushTDs += rushTD;
                    players[id].rzTDs += rzTD;
                }

                players[id].weeks.push(weekData);
                players[id].totalPoints += fpts;
                players[id].gamesPlayed++;

                if (weekNum > players[id].latestWeek) {
                    players[id].latestWeek = weekNum;
                    players[id].latestWeekPoints = fpts;
                    if (position === 'WR') {
                        players[id].latestWeekOppShare = parseFloat(row['% TM']) || 0;
                    }
                }
            });

            // Calculate averages and opportunity shares for RBs
            Object.values(players).forEach(player => {
                player.avgPoints = player.gamesPlayed > 0 ? player.totalPoints / player.gamesPlayed : 0;

                // Calculate percentage over expected
                const totalExpected = player.weeks.reduce((sum, w) => sum + w.expectedFpts, 0);
                player.pctOverExpected = totalExpected > 0 ? ((player.totalPoints - totalExpected) / totalExpected) * 100 : 0;

                // Calculate new WR/TE metrics
                if ((position === 'WR' || position === 'TE') && player.gamesPlayed >= 3) {
                    player.catchRate = player.totalTargets > 0 ? (player.totalRec / player.totalTargets) * 100 : 0;
                    player.catchableCatchRate = player.totalCatchable > 0 ? (player.totalRec / player.totalCatchable) * 100 : 0;
                    player.racr = player.totalAir > 0 ? (player.totalYDS / player.totalAir) * 100 : 0;
                    player.tgtPerGame = player.gamesPlayed > 0 ? player.totalTargets / player.gamesPlayed : 0;
                    player.airYardsPerGame = player.gamesPlayed > 0 ? player.totalAir / player.gamesPlayed : 0;
                    player.yacPerRec = player.totalRec > 0 ? player.totalYAC / player.totalRec : 0;
                }

                // Sort weeks by week number
                player.weeks.sort((a, b) => a.week - b.week);

                if (position === 'RB') {
                    // Calculate RB opportunity share for latest week
                    player.latestWeekOppShare = calculateRBTeamShare(player, weeklyData);
                }

                // Calculate opportunity change
                player.oppChange = calculateOppChange(player);
            });

            return players;
        }

        function calculateRBTeamShare(player, weeklyData) {
            if (player.weeks.length === 0) return 0;

            const latestWeek = player.latestWeek;
            const teamData = weeklyData.filter(row =>
                row.Team === player.team &&
                parseInt(row.Week) === latestWeek &&
                row.Player &&
                parseFloat(row['RB Opp']) > 0
            );

            const teamTotal = teamData.reduce((sum, row) => sum + (parseFloat(row['RB Opp']) || 0), 0);
            const playerOpp = teamData.find(row => row.Player === player.name);
            const playerTotal = playerOpp ? parseFloat(playerOpp['RB Opp']) || 0 : 0;

            return teamTotal > 0 ? (playerTotal / teamTotal) * 100 : 0;
        }

        function calculateOppChange(player) {
            if (player.weeks.length < 2) return 0;

            const lastWeek = player.weeks[player.weeks.length - 1];
            const prevWeek = player.weeks[player.weeks.length - 2];

            let lastShare = 0;
            let prevShare = 0;

            if (player.position === 'WR') {
                lastShare = lastWeek.teamShare || 0;
                prevShare = prevWeek.teamShare || 0;
            } else {
                // For RB, we'd need to calculate team share, simplified here
                lastShare = player.latestWeekOppShare;
                // Approximate previous week share
                prevShare = lastShare;
            }

            return lastShare - prevShare;
        }

        function calculateROSRanks() {
            const allPlayersList = Object.values(allPlayers);
            allPlayersList.sort((a, b) => b.avgPoints - a.avgPoints);

            allPlayersList.forEach((player, index) => {
                player.rosRank = index + 1;
            });
        }

        // Calculate momentum scores for all players
        function calculateMomentum(player, position) {
            // Need at least 4 weeks of data
            if (!player.weeks || player.weeks.length < 4) {
                return {
                    score: 0,
                    isValid: false,
                    direction: 'neutral'
                };
            }

            const sortedWeeks = [...player.weeks].sort((a, b) => a.week - b.week);
            const totalWeeks = sortedWeeks.length;

            // Get last 3 weeks and previous 3 weeks
            const currentWindow = sortedWeeks.slice(-3);
            const previousWindow = sortedWeeks.slice(-6, -3);

            // Need both windows to have data
            if (currentWindow.length < 3 || previousWindow.length < 3) {
                return {
                    score: 0,
                    isValid: false,
                    direction: 'neutral'
                };
            }

            // Helper function to calculate average
            const avg = (arr, key) => {
                const sum = arr.reduce((s, w) => s + (w[key] || 0), 0);
                return sum / arr.length;
            };

            // Helper function to calculate % change
            const pctChange = (current, previous) => {
                if (previous === 0) return current > 0 ? 100 : 0;
                return ((current - previous) / previous) * 100;
            };

            let momentum = 0;

            if (position === 'WR') {
                // WR Momentum = 0.5 * ΔTargets% + 0.3 * ΔReceptions% + 0.2 * ΔFantasyPoints%
                const currentTargets = avg(currentWindow, 'targets');
                const previousTargets = avg(previousWindow, 'targets');
                const targetsChange = pctChange(currentTargets, previousTargets);

                const currentReceptions = avg(currentWindow, 'receptions');
                const previousReceptions = avg(previousWindow, 'receptions');
                const receptionsChange = pctChange(currentReceptions, previousReceptions);

                const currentPoints = avg(currentWindow, 'fpts');
                const previousPoints = avg(previousWindow, 'fpts');
                const pointsChange = pctChange(currentPoints, previousPoints);

                momentum = (0.5 * targetsChange) + (0.3 * receptionsChange) + (0.2 * pointsChange);

            } else if (position === 'RB') {
                // RB Momentum = 0.5 * ΔRushAttempts% + 0.4 * ΔRushYards% + 0.1 * ΔFantasyPoints%
                const currentRushAttempts = avg(currentWindow, 'rushAttempts');
                const previousRushAttempts = avg(previousWindow, 'rushAttempts');
                const rushAttemptsChange = pctChange(currentRushAttempts, previousRushAttempts);

                const currentRushYards = currentWindow.reduce((sum, w) => {
                    // Rush yards might be stored differently, need to check
                    return sum + (w.rushYards || 0);
                }, 0) / currentWindow.length;

                const previousRushYards = previousWindow.reduce((sum, w) => {
                    return sum + (w.rushYards || 0);
                }, 0) / previousWindow.length;

                const rushYardsChange = pctChange(currentRushYards, previousRushYards);

                const currentPoints = avg(currentWindow, 'fpts');
                const previousPoints = avg(previousWindow, 'fpts');
                const pointsChange = pctChange(currentPoints, previousPoints);

                momentum = (0.5 * rushAttemptsChange) + (0.4 * rushYardsChange) + (0.1 * pointsChange);
            }

            // Determine direction
            let direction = 'neutral';
            if (momentum > 5) {
                direction = 'up';
            } else if (momentum < -5) {
                direction = 'down';
            }

            return {
                score: momentum,
                isValid: true,
                direction: direction
            };
        }

        // Calculate momentum for all players
        function calculateAllMomentum() {
            // WRs
            Object.values(aggregatedWRs).forEach(player => {
                const momentum = calculateMomentum(player, 'WR');
                player.momentum = momentum;
            });

            // RBs
            Object.values(aggregatedRBs).forEach(player => {
                const momentum = calculateMomentum(player, 'RB');
                player.momentum = momentum;
            });

            // TEs (use WR momentum calculation since they're pass catchers)
            Object.values(aggregatedTEs).forEach(player => {
                const momentum = calculateMomentum(player, 'WR');
                player.momentum = momentum;
            });        }

        // Get top movers (risers and fallers) for a position
        function getTopMovers(position, count = 5) {
            const players = position === 'WR' ? Object.values(aggregatedWRs) :
                           position === 'RB' ? Object.values(aggregatedRBs) :
                           Object.values(aggregatedTEs);

            // Filter for players with valid momentum and enough games
            const validPlayers = players.filter(p =>
                p.momentum &&
                p.momentum.isValid &&
                p.gamesPlayed >= 6 // Need at least 6 weeks for momentum calculation
            );

            // Sort by momentum score
            const sorted = [...validPlayers].sort((a, b) => b.momentum.score - a.momentum.score);

            // Get top risers (highest positive momentum)
            const risers = sorted.filter(p => p.momentum.score > 0).slice(0, count);

            // Get top fallers (most negative momentum)
            const fallers = sorted.filter(p => p.momentum.score < 0).reverse().slice(0, count);

            return { risers, fallers };
        }

        // Render top movers widgets for a position
        function renderTopMoversWidgets(position, containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;

            const { risers, fallers } = getTopMovers(position, 8);

            let html = '<div class="top-movers-container">';

            // Risers widget
            if (risers.length > 0) {
                const methodologyText = position === 'WR' || position === 'TE'
                    ? 'Each player receives a <i><strong>Momentum Score</strong></i> by comparing their last 3 weeks to their previous 3 weeks. The formula weights: 50% change in targets per game + 30% change in receptions per game + 20% change in fantasy points per game. The percentage shown is the overall weighted <i><strong>Momentum Score</strong></i> - positive values indicate improvement, negative values indicate decline. Players must have at least 6 weeks of data to qualify.'
                    : 'Each player receives a <i><strong>Momentum Score</strong></i> by comparing their last 3 weeks to their previous 3 weeks. The formula weights: 50% change in rush attempts per game + 40% change in rush yards per game + 10% change in fantasy points per game. The percentage shown is the overall weighted <i><strong>Momentum Score</strong></i> - positive values indicate improvement, negative values indicate decline. Players must have at least 6 weeks of data to qualify.';

                html += `
                    <div class="top-movers-widget risers">
                        <div class="top-movers-header">
                            <div class="top-movers-header-left">
                                <span class="top-movers-title">Top Movers Up</span>
                                <div class="ticker-info-icon" onclick="event.stopPropagation(); toggleTickerTooltip(event)">
                                    i
                                    <div class="ticker-tooltip">
                                        ${methodologyText}
                                    </div>
                                </div>
                            </div>

                        </div>
                        <div class="top-movers-content" id="risers-content-${position}">
                            <div class="top-movers-list" id="risers-list-${position}">
                `;

                risers.forEach((player, index) => {
                    const escapedId = player.id.replace(/'/g, "\\'");
                    const hiddenClass = index >= 4 ? 'top-mover-hidden' : '';
                    html += `
                        <div class="top-mover-item ${hiddenClass}" onclick="openPlayerModal('${escapedId}')">
                            <div class="top-mover-rank">${index + 1}</div>
                            <div class="top-mover-arrow">↑</div>
                            <div class="top-mover-info">
                                <div class="top-mover-name">${player.name}</div>
                                <div class="top-mover-team">${player.team}</div>
                            </div>
                            <div class="top-mover-score">+${player.momentum.score.toFixed(1)}%</div>
                        </div>
                    `;
                });

                html += `
                        </div>
                        ${risers.length > 4 ? `<button class="top-movers-expand-btn" onclick="event.stopPropagation(); toggleTopMovers('risers-list-${position}', this)">Show More (4 more)</button>` : ''}
                        </div>
                    </div>
                `;
            }

            // Fallers widget
            if (fallers.length > 0) {
                const methodologyText = position === 'WR' || position === 'TE'
                    ? 'Each player receives a <i><strong>Momentum Score</strong></i> by comparing their last 3 weeks to their previous 3 weeks. The formula weights: 50% change in targets per game + 30% change in receptions per game + 20% change in fantasy points per game. The percentage shown is the overall weighted <i><strong>Momentum Score</strong></i> - positive values indicate improvement, negative values indicate decline. Players must have at least 6 weeks of data to qualify.'
                    : 'Each player receives a <i><strong>Momentum Score</strong></i> by comparing their last 3 weeks to their previous 3 weeks. The formula weights: 50% change in rush attempts per game + 40% change in rush yards per game + 10% change in fantasy points per game. The percentage shown is the overall weighted <i><strong>Momentum Score</strong></i> - positive values indicate improvement, negative values indicate decline. Players must have at least 6 weeks of data to qualify.';

                html += `
                    <div class="top-movers-widget fallers">
                        <div class="top-movers-header">
                            <div class="top-movers-header-left">
                                <span class="top-movers-title">Top Movers Down</span>
                                <div class="ticker-info-icon" onclick="event.stopPropagation(); toggleTickerTooltip(event)">
                                    i
                                    <div class="ticker-tooltip">
                                        ${methodologyText}
                                    </div>
                                </div>
                            </div>

                        </div>
                        <div class="top-movers-content" id="fallers-content-${position}">
                            <div class="top-movers-list" id="fallers-list-${position}">
                `;

                fallers.forEach((player, index) => {
                    const escapedId = player.id.replace(/'/g, "\\'");
                    const hiddenClass = index >= 4 ? 'top-mover-hidden' : '';
                    html += `
                        <div class="top-mover-item ${hiddenClass}" onclick="openPlayerModal('${escapedId}')">
                            <div class="top-mover-rank">${index + 1}</div>
                            <div class="top-mover-arrow">↓</div>
                            <div class="top-mover-info">
                                <div class="top-mover-name">${player.name}</div>
                                <div class="top-mover-team">${player.team}</div>
                            </div>
                            <div class="top-mover-score">${player.momentum.score.toFixed(1)}%</div>
                        </div>
                    `;
                });

                html += `
                        </div>
                        ${fallers.length > 4 ? `<button class="top-movers-expand-btn" onclick="event.stopPropagation(); toggleTopMovers('fallers-list-${position}', this)">Show More (4 more)</button>` : ''}
                        </div>
                    </div>
                `;
            }

            html += '</div>';
            container.innerHTML = html;
        }

        // Toggle top movers visibility
        function toggleTopMovers(listId, button) {
            const list = document.getElementById(listId);
            const hiddenItems = list.querySelectorAll('.top-mover-hidden');
            const isExpanded = button.textContent.includes('Show Less');

            if (isExpanded) {
                hiddenItems.forEach(item => item.style.display = 'none');
                button.textContent = 'Show More (4 more)';
            } else {
                hiddenItems.forEach(item => item.style.display = 'flex');
                button.textContent = 'Show Less';
            }
        }

        // Toggle tier collapse/expand
        function toggleTierCollapse(headerElement) {
            const icon = headerElement.querySelector('.tier-collapse-icon');
            const container = headerElement.nextElementSibling;

            if (icon && container) {
                // Toggle collapsed class
                icon.classList.toggle('collapsed');
                container.classList.toggle('collapsed');

                // Set max-height for smooth animation
                if (!container.classList.contains('collapsed')) {
                    container.style.maxHeight = container.scrollHeight + 'px';
                } else {
                    container.style.maxHeight = '0';
                }
            }
        }

        // Expand all tiers (called on page navigation and refresh)
        function expandAllTiers() {
            // Only expand tiers on the currently active page
            const activePage = document.querySelector('.page.active');
            if (!activePage) {                return;
            }

            const icons = activePage.querySelectorAll('.tier-collapse-icon');
            const containers = activePage.querySelectorAll('.tier-cards-container');
            icons.forEach(icon => {
                icon.classList.remove('collapsed');
            });

            containers.forEach(container => {
                container.classList.remove('collapsed');
                // Set a large max-height to ensure full visibility
                container.style.maxHeight = '100000px';
            });
        }

        // 3. UI RENDERING

        // Render mini sparkline chart
        function renderMiniChart(canvasId, player) {
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;

            const actuals = player.weeks.map(w => w.fpts);
            const expected = player.weeks.map(w => w.expectedFpts);

            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: player.weeks.map(w => w.week),
                    datasets: [
                        {
                            data: actuals,
                            borderColor: '#30d158',
                            borderWidth: 2.5, // Thicker trail for better visibility
                            fill: false,
                            pointRadius: 0,
                            tension: 0.3
                        },
                        {
                            data: expected,
                            borderColor: '#8e8e93',
                            borderWidth: 1,
                            borderDash: [2, 2],
                            fill: false,
                            pointRadius: 0,
                            tension: 0.3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    },
                    scales: {
                        x: { display: false },
                        y: { display: false }
                    },
                    interaction: { mode: null }
                }
            });
        }

        function renderAllPages() {
            renderTicker();
            renderTeamsTicker();
            renderInsightsTicker();
            renderWRPlayerCards();
            renderRBPlayerCards();
            renderTEPlayerCards();
            renderTeamsPage();
            renderScatterPlots();

            // Render top movers widgets
            renderTopMoversWidgets('WR', 'wr-top-movers-sidebar');
            renderTopMoversWidgets('RB', 'rb-top-movers-sidebar');
            renderTopMoversWidgets('TE', 'te-top-movers-sidebar');

            // Setup dashboard trend scrubbers
            setupDashboardTrendScrubbers();

            // Initialize Advanced Analytics
            initializeAdvancedAnalytics();

            // Note: Trend animations for WR/RB eval charts are lazy loaded when user clicks Advanced Analytics tab
        }

        function renderTicker() {
            // WR Ticker - by avg points
            const wrTickerTrack = document.getElementById('wr-ticker-track');
            const topWRs = Object.values(aggregatedWRs)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 50);

            const wrTickerHTML = topWRs.map((player, index) => {
                // Calculate week-over-week team share change
                let shareChange = 0;
                if (player.weeks.length >= 2) {
                    // Get last two weeks where player had targets
                    const weeksWithTargets = player.weeks.filter(w => w.teamShare && w.teamShare > 0);
                    if (weeksWithTargets.length >= 2) {
                        const latestWeek = weeksWithTargets[weeksWithTargets.length - 1];
                        const previousWeek = weeksWithTargets[weeksWithTargets.length - 2];
                        shareChange = latestWeek.teamShare - previousWeek.teamShare;
                    }
                }

                const changeClass = shareChange >= 0 ? 'positive' : 'negative';
                const changeSymbol = shareChange >= 0 ? '▲' : '▼';
                const changePct = Math.abs(shareChange).toFixed(1);
                const rank = index + 1;

                return `
                    <div class="ticker-item">
                        <span class="player-name">#${rank} ${player.name}</span>
                        <span class="avg-pts">${player.avgPoints.toFixed(1)}</span>
                        <span class="change ${changeClass}">${changeSymbol} ${changePct}% tgt share</span>
                    </div>
                `;
            }).join('');

            wrTickerTrack.innerHTML = wrTickerHTML + wrTickerHTML;

            // RB Ticker - by avg points
            const rbTickerTrack = document.getElementById('rb-ticker-track');
            const topRBs = Object.values(aggregatedRBs)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 50);

            const rbTickerHTML = topRBs.map((player, index) => {
                // Calculate week-over-week RB opp share change
                let shareChange = 0;
                if (player.weeks.length >= 2) {
                    // Get last two weeks with opportunities
                    const weeksWithOpps = player.weeks.filter(w => w.opportunities && w.opportunities > 0);
                    if (weeksWithOpps.length >= 2) {
                        // Calculate share for each week
                        const latestWeek = weeksWithOpps[weeksWithOpps.length - 1];
                        const previousWeek = weeksWithOpps[weeksWithOpps.length - 2];

                        // Get team totals for those weeks
                        const latestTeamRows = rbData.filter(row =>
                            row.Team === player.team &&
                            parseInt(row.Week) === latestWeek.week &&
                            parseFloat(row['RB Opp']) > 0
                        );
                        const prevTeamRows = rbData.filter(row =>
                            row.Team === player.team &&
                            parseInt(row.Week) === previousWeek.week &&
                            parseFloat(row['RB Opp']) > 0
                        );

                        const latestTeamTotal = latestTeamRows.reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);
                        const prevTeamTotal = prevTeamRows.reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);

                        const latestShare = latestTeamTotal > 0 ? (latestWeek.opportunities / latestTeamTotal) * 100 : 0;
                        const prevShare = prevTeamTotal > 0 ? (previousWeek.opportunities / prevTeamTotal) * 100 : 0;

                        shareChange = latestShare - prevShare;
                    }
                }

                const changeClass = shareChange >= 0 ? 'positive' : 'negative';
                const changeSymbol = shareChange >= 0 ? '▲' : '▼';
                const changePct = Math.abs(shareChange).toFixed(1);
                const rank = index + 1;

                return `
                    <div class="ticker-item">
                        <span class="player-name">#${rank} ${player.name}</span>
                        <span class="avg-pts">${player.avgPoints.toFixed(1)}</span>
                        <span class="change ${changeClass}">${changeSymbol} ${changePct}% opp share</span>
                    </div>
                `;
            }).join('');

            rbTickerTrack.innerHTML = rbTickerHTML + rbTickerHTML;

            // TE Ticker - by avg points (top 24)
            const teTickerTrack = document.getElementById('te-ticker-track');
            const topTEs = Object.values(aggregatedTEs)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 24);

            const teTickerHTML = topTEs.map((player, index) => {
                // Calculate week-over-week target share change (like WRs)
                let shareChange = 0;
                if (player.weeks.length >= 2) {
                    // Get last two weeks where player had targets
                    const weeksWithTargets = player.weeks.filter(w => w.teamShare && w.teamShare > 0);
                    if (weeksWithTargets.length >= 2) {
                        const latestWeek = weeksWithTargets[weeksWithTargets.length - 1];
                        const previousWeek = weeksWithTargets[weeksWithTargets.length - 2];
                        shareChange = latestWeek.teamShare - previousWeek.teamShare;
                    }
                }

                const changeClass = shareChange >= 0 ? 'positive' : 'negative';
                const changeSymbol = shareChange >= 0 ? '▲' : '▼';
                const changePct = Math.abs(shareChange).toFixed(1);
                const rank = index + 1;

                return `
                    <div class="ticker-item">
                        <span class="player-name">#${rank} ${player.name}</span>
                        <span class="avg-pts">${player.avgPoints.toFixed(1)}</span>
                        <span class="change ${changeClass}">${changeSymbol} ${changePct}% tgt share</span>
                    </div>
                `;
            }).join('');

            teTickerTrack.innerHTML = teTickerHTML + teTickerHTML;
        }

        function renderTeamsTicker() {
            const teamsTickerTrack = document.getElementById('teams-ticker-track');
            if (!teamsTickerTrack) {                return;
            }
            if (!wrData || !rbData) {                return;
            }
            // Get the latest week from the data
            const allWeeks = [...new Set(wrData.map(row => parseInt(row.Week)))];
            const latestWeek = Math.max(...allWeeks);
            const previousWeek = latestWeek - 1;
            // Aggregate team data by week
            const teamWeeklyData = {};

            // Process WR data
            wrData.forEach(row => {
                const team = row.Team;
                const week = parseInt(row.Week);
                const points = parseFloat(row.FPTS || row.Fpts) || 0; // Handle both FPTS and Fpts

                if (team === 'FA' || !team) return;

                if (!teamWeeklyData[team]) {
                    teamWeeklyData[team] = {
                        team: team,
                        weeks: {}
                    };
                }

                if (!teamWeeklyData[team].weeks[week]) {
                    teamWeeklyData[team].weeks[week] = { wrPoints: 0, rbPoints: 0, tePoints: 0, totalPoints: 0 };
                }

                teamWeeklyData[team].weeks[week].wrPoints += points;
                teamWeeklyData[team].weeks[week].totalPoints += points;
            });
            // Process RB data
            rbData.forEach(row => {
                const team = row.Team;
                const week = parseInt(row.Week);
                const points = parseFloat(row.FPTS || row.Fpts) || 0; // Handle both FPTS and Fpts

                if (team === 'FA' || !team) return;

                if (!teamWeeklyData[team]) {
                    teamWeeklyData[team] = {
                        team: team,
                        weeks: {}
                    };
                }

                if (!teamWeeklyData[team].weeks[week]) {
                    teamWeeklyData[team].weeks[week] = { wrPoints: 0, rbPoints: 0, tePoints: 0, totalPoints: 0 };
                }

                teamWeeklyData[team].weeks[week].rbPoints += points;
                teamWeeklyData[team].weeks[week].totalPoints += points;
            });
            // Process TE data
            if (teData) {
                teData.forEach(row => {
                    const team = row.Team;
                    const week = parseInt(row.Week);
                    const points = parseFloat(row.FPTS || row.Fpts) || 0; // Handle both FPTS and Fpts

                    if (team === 'FA' || !team) return;

                    if (!teamWeeklyData[team]) {
                        teamWeeklyData[team] = {
                            team: team,
                            weeks: {}
                        };
                    }

                    if (!teamWeeklyData[team].weeks[week]) {
                        teamWeeklyData[team].weeks[week] = { wrPoints: 0, rbPoints: 0, tePoints: 0, totalPoints: 0 };
                    }

                    teamWeeklyData[team].weeks[week].tePoints += points;
                    teamWeeklyData[team].weeks[week].totalPoints += points;
                });            }

            // Calculate totals and changes for latest week
            const teamsData = Object.values(teamWeeklyData).map(teamData => {
                const latestWeekData = teamData.weeks[latestWeek] || { wrPoints: 0, rbPoints: 0, tePoints: 0, totalPoints: 0 };
                const previousWeekData = teamData.weeks[previousWeek] || { wrPoints: 0, rbPoints: 0, tePoints: 0, totalPoints: 0 };

                // Calculate percentage change
                let percentChange = 0;
                if (previousWeekData.totalPoints > 0) {
                    percentChange = ((latestWeekData.totalPoints - previousWeekData.totalPoints) / previousWeekData.totalPoints) * 100;
                } else if (latestWeekData.totalPoints > 0) {
                    percentChange = 100; // If no previous week data but has current, show +100%
                }

                return {
                    team: teamData.team,
                    wrPoints: latestWeekData.wrPoints,
                    rbPoints: latestWeekData.rbPoints,
                    tePoints: latestWeekData.tePoints,
                    totalPoints: latestWeekData.totalPoints,
                    percentChange: percentChange,
                    previousTotal: previousWeekData.totalPoints
                };
            });
            // Sort by total points for latest week
            const topTeams = teamsData
                .sort((a, b) => b.totalPoints - a.totalPoints)
                .slice(0, 32); // All teams

            const teamsTickerHTML = topTeams.map((team, index) => {
                const rank = index + 1;
                const teamColor = teamColors[team.team] || '#0a84ff';
                const changeClass = team.percentChange >= 0 ? 'positive' : 'negative';
                const changeSymbol = team.percentChange >= 0 ? '▲' : '▼';

                return `
                    <div class="ticker-item">
                        <span style="font-weight: 700; color: white;">#${rank}</span>
                        <span class="player-name">${team.team}</span>
                        <span class="avg-pts">${team.totalPoints.toFixed(1)} pts</span>
                        <span style="color: var(--text-secondary); font-size: 11px;">
                            WR: ${team.wrPoints.toFixed(0)} | RB: ${team.rbPoints.toFixed(0)} | TE: ${team.tePoints.toFixed(0)}
                        </span>
                        <span class="change ${changeClass}">${changeSymbol} ${Math.abs(team.percentChange).toFixed(1)}%</span>
                    </div>
                `;
            }).join('');

            teamsTickerTrack.innerHTML = teamsTickerHTML + teamsTickerHTML;
        }

        function renderInsightsTicker() {
            const insightsTickerTrack = document.getElementById('insights-ticker-track');
            if (!insightsTickerTrack) return;

            // Find the global maximum week across ALL players (current week of season)
            let globalMaxWeek = 0;
            Object.values(aggregatedWRs).forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });
            Object.values(aggregatedRBs).forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });

            if (globalMaxWeek === 0) return;

            // The last 3 weeks and prior 3 weeks
            const last3ActualWeeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
            const prior3ActualWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];

            // Get all players with opportunity share changes AND record scores in last 2/3 games
            const allMovers = [];

            // Add WRs
            Object.values(aggregatedWRs).forEach(player => {
                if (!player.weeks || player.weeks.length === 0) return;

                // Filter to only games within the last 3 actual weeks where player had fantasy points
                const last3WeeksGames = player.weeks.filter(w =>
                    last3ActualWeeks.includes(w.week) && w.fpts > 0
                );

                // Player must have played at least 2 of the last 3 weeks
                if (last3WeeksGames.length < 2) return;

                // Check for record scores: Count how many of last 3 games are in player's top 2 scores
                const allGameScores = player.weeks.map(w => w.fpts).sort((a, b) => b - a);
                const top2Scores = allGameScores.slice(0, 2);
                const recordGamesInLast3 = last3WeeksGames.filter(w =>
                    top2Scores.includes(w.fpts)
                ).length;

                // Only include if player had record scores in at least 2 of last 3 games
                if (recordGamesInLast3 < 2) return;

                // Calculate average target share for last 3 weeks
                const last3Shares = player.weeks
                    .filter(w => last3ActualWeeks.includes(w.week) && w.teamShare && w.teamShare > 0)
                    .map(w => w.teamShare);

                // Calculate average target share for prior 3 weeks
                const prior3Shares = player.weeks
                    .filter(w => prior3ActualWeeks.includes(w.week) && w.teamShare && w.teamShare > 0)
                    .map(w => w.teamShare);

                // Need at least some data from both periods
                if (last3Shares.length === 0) return;

                const avgLast3 = last3Shares.reduce((sum, s) => sum + s, 0) / last3Shares.length;
                const avgPrior3 = prior3Shares.length > 0
                    ? prior3Shares.reduce((sum, s) => sum + s, 0) / prior3Shares.length
                    : 0;

                const shareChange = avgLast3 - avgPrior3;

                allMovers.push({
                    name: player.name,
                    team: player.team,
                    position: 'WR',
                    shareChange: shareChange,
                    avgPoints: player.avgPoints
                });
            });

            // Add RBs
            Object.values(aggregatedRBs).forEach(player => {
                if (!player.weeks || player.weeks.length === 0) return;

                // Filter to only games within the last 3 actual weeks where player had fantasy points
                const last3WeeksGames = player.weeks.filter(w =>
                    last3ActualWeeks.includes(w.week) && w.fpts > 0
                );

                // Player must have played at least 2 of the last 3 weeks
                if (last3WeeksGames.length < 2) return;

                // Check for record scores: Count how many of last 3 games are in player's top 2 scores
                const allGameScores = player.weeks.map(w => w.fpts).sort((a, b) => b - a);
                const top2Scores = allGameScores.slice(0, 2);
                const recordGamesInLast3 = last3WeeksGames.filter(w =>
                    top2Scores.includes(w.fpts)
                ).length;

                // Only include if player had record scores in at least 2 of last 3 games
                if (recordGamesInLast3 < 2) return;

                // Calculate average opportunity share for last 3 weeks
                const last3Shares = [];
                last3ActualWeeks.forEach(weekNum => {
                    const weekData = player.weeks.find(w => w.week === weekNum);
                    if (weekData && weekData.opportunities > 0) {
                        // Get team total for this week
                        const teamRows = rbData.filter(row =>
                            row.Team === player.team &&
                            parseInt(row.Week) === weekNum &&
                            parseFloat(row['RB Opp']) > 0
                        );
                        const teamTotal = teamRows.reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);
                        if (teamTotal > 0) {
                            const share = (weekData.opportunities / teamTotal) * 100;
                            last3Shares.push(share);
                        }
                    }
                });

                // Calculate average opportunity share for prior 3 weeks
                const prior3Shares = [];
                prior3ActualWeeks.forEach(weekNum => {
                    const weekData = player.weeks.find(w => w.week === weekNum);
                    if (weekData && weekData.opportunities > 0) {
                        // Get team total for this week
                        const teamRows = rbData.filter(row =>
                            row.Team === player.team &&
                            parseInt(row.Week) === weekNum &&
                            parseFloat(row['RB Opp']) > 0
                        );
                        const teamTotal = teamRows.reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);
                        if (teamTotal > 0) {
                            const share = (weekData.opportunities / teamTotal) * 100;
                            prior3Shares.push(share);
                        }
                    }
                });

                // Need at least some data from last 3 weeks
                if (last3Shares.length === 0) return;

                const avgLast3 = last3Shares.reduce((sum, s) => sum + s, 0) / last3Shares.length;
                const avgPrior3 = prior3Shares.length > 0
                    ? prior3Shares.reduce((sum, s) => sum + s, 0) / prior3Shares.length
                    : 0;

                const shareChange = avgLast3 - avgPrior3;

                allMovers.push({
                    name: player.name,
                    team: player.team,
                    position: 'RB',
                    shareChange: shareChange,
                    avgPoints: player.avgPoints
                });
            });

            // Sort by absolute value of share change and take top 40
            const topMovers = allMovers
                .sort((a, b) => Math.abs(b.shareChange) - Math.abs(a.shareChange))
                .slice(0, 40);

            const insightsTickerHTML = topMovers.map((player, index) => {
                const changeClass = player.shareChange >= 0 ? 'positive' : 'negative';
                const changeSymbol = player.shareChange >= 0 ? '▲' : '▼';
                const changePct = Math.abs(player.shareChange).toFixed(1);
                const rank = index + 1;

                return `
                    <div class="ticker-item">
                        <span class="player-name">#${rank} ${player.name}</span>
                        <span style="color: var(--text-secondary); font-size: 11px;">${player.position} · ${player.team}</span>
                        <span class="change ${changeClass}">${changeSymbol} ${changePct}%</span>
                        <span class="avg-pts">${player.avgPoints.toFixed(1)} pts</span>
                    </div>
                `;
            }).join('');

            insightsTickerTrack.innerHTML = insightsTickerHTML + insightsTickerHTML;
        }

        function toggleTicker(position) {
            // WR ticker should always stay expanded
            if (position === 'wr') return;

            const content = document.getElementById(`${position}-ticker-content`);
            const toggle = document.getElementById(`${position}-ticker-toggle`);
            const section = document.getElementById(`${position}-ticker-section`);

            content.classList.toggle('collapsed');
            toggle.classList.toggle('collapsed');
            section.classList.toggle('collapsed');

            // Adjust RB ticker position when WR ticker collapses (no longer needed since WR stays expanded)
        }

        // TAGGING ENGINE

        function calculatePlayerTags(position) {
            const players = position === 'WR' ? Object.values(aggregatedWRs) :
                           position === 'RB' ? Object.values(aggregatedRBs) :
                           Object.values(aggregatedTEs);
            const rawData = position === 'WR' ? wrData :
                           position === 'RB' ? rbData :
                           teData;

            // Find global max week
            let globalMaxWeek = 0;
            players.forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });

            if (globalMaxWeek < 4) return {}; // Need at least 4 weeks of data

            // Define time windows: last 2 weeks vs weeks 3-4 back
            const last2Weeks = [globalMaxWeek, globalMaxWeek - 1];
            const prior2Weeks = [globalMaxWeek - 2, globalMaxWeek - 3];

            const tagCandidates = {
                buy_low: [],
                sell_high: [],
                rz_trend_up: []
            };

            players.forEach(player => {
                if (!player.weeks || player.weeks.length < 3) return;

                // Filter: Only tag players averaging 5+ PPG
                if (player.avgPoints < 5) return;

                // Get games from last 2 weeks and prior 2 weeks
                const last2Games = player.weeks.filter(w => last2Weeks.includes(w.week) && w.fpts > 0);
                const prior2Games = player.weeks.filter(w => prior2Weeks.includes(w.week) && w.fpts > 0);

                // Need at least 1 game in each period
                if (last2Games.length === 0 || prior2Games.length === 0) return;

                // Calculate metrics for both periods
                let last2Efficiency = 0, prior2Efficiency = 0;
                let last2Volume = 0, prior2Volume = 0;
                let last2RzShare = 0, prior2RzShare = 0;

                if (position === 'WR' || position === 'TE') {
                    // WR/TE: volume = targets, efficiency = points per target
                    const last2Targets = last2Games.reduce((sum, w) => sum + (w.targets || 0), 0);
                    const last2Points = last2Games.reduce((sum, w) => sum + w.fpts, 0);
                    last2Volume = last2Targets / last2Games.length;
                    last2Efficiency = last2Targets > 0 ? last2Points / last2Targets : 0;

                    const prior2Targets = prior2Games.reduce((sum, w) => sum + (w.targets || 0), 0);
                    const prior2Points = prior2Games.reduce((sum, w) => sum + w.fpts, 0);
                    prior2Volume = prior2Targets / prior2Games.length;
                    prior2Efficiency = prior2Targets > 0 ? prior2Points / prior2Targets : 0;

                    // RZ share calculation for WRs/TEs
                    let last2RzTargets = 0, prior2RzTargets = 0;
                    last2Weeks.forEach(weekNum => {
                        const weekRow = rawData.find(row =>
                            row.Team === player.team &&
                            row.Player === player.name &&
                            parseInt(row.Week) === weekNum
                        );
                        if (weekRow) {
                            last2RzTargets += parseFloat(weekRow.RZTGT) || parseFloat(weekRow['RZ TGT']) || 0;
                        }
                    });
                    prior2Weeks.forEach(weekNum => {
                        const weekRow = rawData.find(row =>
                            row.Team === player.team &&
                            row.Player === player.name &&
                            parseInt(row.Week) === weekNum
                        );
                        if (weekRow) {
                            prior2RzTargets += parseFloat(weekRow.RZTGT) || parseFloat(weekRow['RZ TGT']) || 0;
                        }
                    });

                    last2RzShare = last2RzTargets / last2Games.length;
                    prior2RzShare = prior2RzTargets / prior2Games.length;

                } else {
                    // RB: volume = opportunities, efficiency = points per opportunity
                    const last2Opps = last2Games.reduce((sum, w) => sum + (w.opportunities || 0), 0);
                    const last2Points = last2Games.reduce((sum, w) => sum + w.fpts, 0);
                    last2Volume = last2Opps / last2Games.length;
                    last2Efficiency = last2Opps > 0 ? last2Points / last2Opps : 0;

                    const prior2Opps = prior2Games.reduce((sum, w) => sum + (w.opportunities || 0), 0);
                    const prior2Points = prior2Games.reduce((sum, w) => sum + w.fpts, 0);
                    prior2Volume = prior2Opps / prior2Games.length;
                    prior2Efficiency = prior2Opps > 0 ? prior2Points / prior2Opps : 0;

                    // RZ share calculation for RBs
                    let last2RzOpps = 0, prior2RzOpps = 0;
                    last2Weeks.forEach(weekNum => {
                        const weekRow = rawData.find(row =>
                            row.Team === player.team &&
                            row.Player === player.name &&
                            parseInt(row.Week) === weekNum
                        );
                        if (weekRow) {
                            const rzAtt = parseFloat(weekRow.RZATT) || parseFloat(weekRow['RZ ATT']) || 0;
                            const rzTgt = parseFloat(weekRow.RZTGT) || parseFloat(weekRow['RZ TGT']) || 0;
                            last2RzOpps += rzAtt + rzTgt;
                        }
                    });
                    prior2Weeks.forEach(weekNum => {
                        const weekRow = rawData.find(row =>
                            row.Team === player.team &&
                            row.Player === player.name &&
                            parseInt(row.Week) === weekNum
                        );
                        if (weekRow) {
                            const rzAtt = parseFloat(weekRow.RZATT) || parseFloat(weekRow['RZ ATT']) || 0;
                            const rzTgt = parseFloat(weekRow.RZTGT) || parseFloat(weekRow['RZ TGT']) || 0;
                            prior2RzOpps += rzAtt + rzTgt;
                        }
                    });

                    last2RzShare = last2RzOpps / last2Games.length;
                    prior2RzShare = prior2RzOpps / prior2Games.length;
                }

                // Calculate percentage changes
                const efficiencyChange = prior2Efficiency > 0 ? ((last2Efficiency - prior2Efficiency) / prior2Efficiency) * 100 : 0;
                const volumeChange = prior2Volume > 0 ? ((last2Volume - prior2Volume) / prior2Volume) * 100 : 0;
                const rzChange = prior2RzShare > 0 ? ((last2RzShare - prior2RzShare) / prior2RzShare) * 100 : 0;

                // Tag logic with 5% threshold
                // BUY LOW: efficiency up 5%+, volume down 5%+
                // But exclude top-tier players (elite performers shouldn't be "buy low")
                const topTierThreshold = position === 'WR' ? 20 : 22; // Elite WR1 / Elite RB1 threshold
                if (efficiencyChange >= 5 && volumeChange <= -5 && player.avgPoints < topTierThreshold) {
                    tagCandidates.buy_low.push({
                        player: player,
                        score: efficiencyChange + Math.abs(volumeChange) // Combined magnitude
                    });
                }

                // SELL HIGH: efficiency down 5%+, volume up 5%+
                if (efficiencyChange <= -5 && volumeChange >= 5) {
                    tagCandidates.sell_high.push({
                        player: player,
                        score: Math.abs(efficiencyChange) + volumeChange // Combined magnitude
                    });
                }

                // RZ TREND UP: red zone share up 5%+
                if (rzChange >= 5) {
                    tagCandidates.rz_trend_up.push({
                        player: player,
                        score: rzChange
                    });
                }
            });

            // Get top 4 for each tag type
            const tags = {};

            tagCandidates.buy_low.sort((a, b) => b.score - a.score).slice(0, 4).forEach(item => {
                tags[item.player.id] = tags[item.player.id] || [];
                tags[item.player.id].push('buy_low');
            });

            tagCandidates.sell_high.sort((a, b) => b.score - a.score).slice(0, 4).forEach(item => {
                tags[item.player.id] = tags[item.player.id] || [];
                tags[item.player.id].push('sell_high');
            });

            tagCandidates.rz_trend_up.sort((a, b) => b.score - a.score).slice(0, 4).forEach(item => {
                tags[item.player.id] = tags[item.player.id] || [];
                tags[item.player.id].push('rz_trend_up');
            });

            return tags;
        }

        function renderWRPlayerCards() {
            const grid = document.getElementById('wr-players-grid');
            let wrs = Object.values(aggregatedWRs).sort((a, b) => b.avgPoints - a.avgPoints);

            // Calculate tags for WRs
            const playerTags = calculatePlayerTags('WR');

            // FILTER: Remove Malik Nabers and Tyreek Hill
            wrs = wrs.filter(p => !['Malik Nabers', 'Tyreek Hill'].includes(p.name));

            // DEMOTE: Players with no stats since Week 4
            wrs = wrs.map(player => {
                if (player.latestWeek && player.latestWeek < 5) {
                    // Apply penalty to move them down tiers (reduce avg points by 50%)
                    return {
                        ...player,
                        avgPoints: player.avgPoints * 0.5,
                        inactive: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);

            // DEMOTE: Players with only 1-2 games should max out at WR3/Flex tier
            wrs = wrs.map(player => {
                if (player.gamesPlayed <= 2) {
                    // Cap their avg points at 7.9 (just below Low WR2/Flex threshold of 8)
                    return {
                        ...player,
                        avgPoints: Math.min(player.avgPoints, 7.9),
                        lowSampleSize: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);

            // Calculate top 24 averages
            const top24 = wrs.slice(0, 24);
            const top24AvgPoints = top24.reduce((sum, p) => sum + p.avgPoints, 0) / top24.length;
            const top24AvgTargets = top24.reduce((sum, p) => sum + (p.totalTargets / p.gamesPlayed), 0) / top24.length;

            // Track ranking for top 50 determination
            let overallRank = 0;

            // Define tiers - top two are rank-based (max 4 players each), then point-based
            const tiers = [
                { name: 'Elite WR1', class: 'elite', type: 'rank', maxPlayers: 4, color: '#30d158', showCharts: true },
                { name: 'High-End WR1', class: 'elite', type: 'rank', maxPlayers: 4, color: '#30d158', showCharts: true },
                { name: 'Solid WR1', class: 'elite', type: 'points', min: 17, max: 999, color: '#30d158', showCharts: true }, // Remaining WR1s (17+ ppg)
                { name: 'High Upside WR2', class: 'wr2', type: 'points', min: 14.5, max: 17, color: '#0a84ff', showCharts: true },
                { name: 'Solid WR2', class: 'wr2', type: 'points', min: 12, max: 14.5, color: '#0a84ff', showCharts: true },
                { name: 'Mid WR2', class: 'wr2', type: 'points', min: 10, max: 12, color: '#0a84ff', showCharts: true },
                { name: 'Low WR2/Flex', class: 'flex', type: 'points', min: 8, max: 10, color: '#FFD60A', showCharts: false },
                { name: 'WR3/Flex', class: 'flex', type: 'points', min: 5, max: 8, color: '#FFD60A', showCharts: false },
                { name: 'Depth/Streaming', class: 'depth', type: 'points', min: 0, max: 5, color: '#8e8e93', showCharts: false }
            ];

            let html = '';
            let chartIndex = 0;
            let rankIndex = 0; // Track position for rank-based tiers

            tiers.forEach(tier => {
                let tierPlayers = [];

                if (tier.type === 'rank') {
                    // Rank-based tier: take next N players in order
                    tierPlayers = wrs.slice(rankIndex, rankIndex + tier.maxPlayers);
                    rankIndex += tierPlayers.length;
                } else {
                    // Point-based tier: filter by point threshold from remaining players
                    const remainingPlayers = wrs.slice(rankIndex);
                    tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                    // Update rankIndex to skip these players for next tier
                    rankIndex += tierPlayers.length;
                }

                if (tierPlayers.length === 0) return;

                html += `
                    <div class="tier-section">
                        <div class="tier-header" onclick="toggleTierCollapse(this)">
                            <div class="tier-badge ${tier.class}">${tier.name}</div>
                            <div class="tier-count">Avg: ${(tierPlayers.reduce((sum, p) => sum + p.avgPoints, 0) / tierPlayers.length).toFixed(1)} pts/game</div>
                            <span class="tier-collapse-icon">▼</span>
                        </div>
                        <div class="tier-cards-container">
                            <div class="cards-grid">
                `;

                tierPlayers.forEach(player => {
                    overallRank++;
                    const chartId = `wr-player-chart-${chartIndex++}`;
                    const escapedId = player.id.replace(/'/g, "\\'");
                    const sentiment = getSentimentScore(player.name);
                    const buyPct = sentiment.total > 0 ? (sentiment.buy / sentiment.total * 100) : 0;

                    // Use original avg points for display (not demoted value)
                    const displayAvgPoints = player.inactive ? player.avgPoints * 2 : player.avgPoints;

                    // Calculate comparisons to top 24
                    const targetsPerGame = player.totalTargets / player.gamesPlayed;
                    const pointsDiff = displayAvgPoints - top24AvgPoints;
                    const targetsDiff = targetsPerGame - top24AvgTargets;

                    const pointsClass = pointsDiff >= 0 ? 'comparison-up' : 'comparison-down';
                    const pointsIcon = pointsDiff >= 0 ? '▲' : '▼';
                    const targetsClass = targetsDiff >= 0 ? 'comparison-up' : 'comparison-down';
                    const targetsIcon = targetsDiff >= 0 ? '▲' : '▼';

                    // Include chart based on tier setting
                    const includeChart = tier.showCharts;

                    // Get tags for this player
                    const tags = playerTags[player.id] || [];

                    // Build tags HTML (momentum badge moved to card root)
                    let tagElements = tags.map(tag => {
                        if (tag === 'buy_low') return '<span class="player-tag buy-low" data-tooltip="Efficiency ↑ but Volume ↓ - Undervalued opportunity">Buy Low</span>';
                        if (tag === 'sell_high') return '<span class="player-tag sell-high" data-tooltip="Volume ↑ but Efficiency ↓ - Regression risk">Sell High</span>';
                        if (tag === 'rz_trend_up') return '<span class="player-tag rz-up" data-tooltip="Red Zone opportunities trending up - TD upside">RZ↑</span>';
                        return '';
                    }).filter(t => t);

                    const tagsHTML = tagElements.length > 0 ? `
                        <div class="player-tags">
                            ${tagElements.join('')}
                        </div>
                    ` : '';

                    html += `
                        <div class="player-card" onclick="openPlayerModal('${escapedId}')" ${player.inactive ? 'style="opacity: 0.6; border-left: 3px solid #ff453a;"' : ''}>
                            <div class="player-card-header">
                                <div class="player-card-badge" style="background: ${teamColors[player.team] || '#666'}">${player.team}</div>
                                <div style="flex: 1;">
                                    <div class="player-card-name">
                                        ${player.name}${player.inactive ? ' <span style="color: #ff453a; font-size: 11px;">⚠ INACTIVE</span>' : ''}
                                    </div>
                                    <div class="player-card-team">WR · ${player.team}${(() => {
                                        let badges = '';
                                        
                                        // Add injury badge if present
                                        const injury = getPlayerInjuryStatus(player.name);
                                        if (injury) {
                                            const statusInfo = formatInjuryStatus(injury.status);
                                            const injuryDetails = `${statusInfo.fullText} - ${injury.injuryBody}`;
                                            badges += ` <span class="injury-badge ${statusInfo.class}" data-injury-details="${injuryDetails}">${statusInfo.badge}</span>`;
                                        }
                                        
                                        // Add momentum badge if present
                                        if (player.momentum && player.momentum.isValid && player.momentum.direction !== 'neutral') {
                                            badges += ` <span class="momentum-badge ${player.momentum.direction}" data-tooltip="Momentum: ${player.momentum.score > 0 ? '+' : ''}${player.momentum.score.toFixed(1)}% (last 3 vs prev 3 weeks)">${player.momentum.direction === 'up' ? '↑' : '↓'}</span>`;
                                        }
                                        
                                        return badges;
                                    })()}</div>
                                    ${tagsHTML}
                                </div>
                            </div>
                            <div class="player-card-stats">
                                <div class="player-stat">
                                    <span class="player-stat-label">Avg Points</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="player-stat-value">${displayAvgPoints.toFixed(1)}</span>
                                        <span class="player-comparison ${pointsClass}">
                                            <span class="comparison-icon">${pointsIcon}</span>
                                            ${Math.abs(pointsDiff).toFixed(1)}
                                        </span>
                                        <div class="comparison-tooltip">
                                            <div class="tooltip-label">vs Top 24 WR Avg</div>
                                            <div class="tooltip-data">${displayAvgPoints.toFixed(1)} vs ${top24AvgPoints.toFixed(1)}</div>
                                            <div class="tooltip-data">${pointsDiff >= 0 ? '+' : ''}${pointsDiff.toFixed(1)} pts</div>
                                        </div>
                                    </div>
                                    <div class="stat-tooltip">Average fantasy points per game over ${player.gamesPlayed} games</div>
                                </div>
                                <div class="player-stat">
                                    <span class="player-stat-label">Targets/Game</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="player-stat-value">${targetsPerGame.toFixed(1)}</span>
                                        <span class="player-comparison ${targetsClass}">
                                            <span class="comparison-icon">${targetsIcon}</span>
                                            ${Math.abs(targetsDiff).toFixed(1)}
                                        </span>
                                        <div class="comparison-tooltip">
                                            <div class="tooltip-label">vs Top 24 WR Avg</div>
                                            <div class="tooltip-data">${targetsPerGame.toFixed(1)} vs ${top24AvgTargets.toFixed(1)}</div>
                                            <div class="tooltip-data">${targetsDiff >= 0 ? '+' : ''}${targetsDiff.toFixed(1)} tgt/g</div>
                                        </div>
                                    </div>
                                    <div class="stat-tooltip">Average targets per game (${player.totalTargets} total targets)</div>
                                </div>
                                <div class="player-stat" style="grid-column: 1 / -1;">
                                    <span class="player-stat-label">Community Sentiment</span>
                                    <div style="margin-top: 4px;">
                                        ${sentiment.total > 0 ? (() => {
                                            const totalVotes = sentiment.total;
                                            const buyPct = Math.round((sentiment.buy / totalVotes) * 100);
                                            const holdPct = Math.round((sentiment.hold / totalVotes) * 100);
                                            const sellPct = Math.round((sentiment.sell / totalVotes) * 100);

                                            const max = Math.max(buyPct, holdPct, sellPct);
                                            let label, color, bgColor, icon;
                                            if (buyPct === max) {
                                                label = 'BUY';
                                                color = 'var(--positive)';
                                                bgColor = 'rgba(48, 209, 88, 0.15)';
                                                icon = '▲';
                                            } else if (sellPct === max) {
                                                label = 'SELL';
                                                color = 'var(--negative)';
                                                bgColor = 'rgba(255, 69, 58, 0.15)';
                                                icon = '▼';
                                            } else {
                                                label = 'HOLD';
                                                color = 'var(--text-secondary)';
                                                bgColor = 'rgba(142, 142, 147, 0.15)';
                                                icon = '—';
                                            }

                                            return '<span style="padding: 3px 6px; background: ' + bgColor + '; color: ' + color + '; border-radius: 5px; font-size: 10px; font-weight: 600; display: inline-block;">' + icon + ' ' + max + '% ' + label + '</span>';
                                        })() : '<span style="padding: 3px 6px; background: rgba(142, 142, 147, 0.15); color: var(--text-secondary); border-radius: 5px; font-size: 10px; font-weight: 600; display: inline-block;">No Votes</span>'}
                                    </div>
                                    <div class="stat-tooltip">${sentiment.total > 0 ? `Community voting: ${sentiment.total} total votes` : 'Be the first to vote! Open player modal to cast your vote.'}</div>
                                </div>
                            </div>
                            ${includeChart ? `<div class="player-card-chart">
                                <canvas id="${chartId}"></canvas>
                            </div>` : ''}
                        </div>
                    `;
                });

                html += `
                            </div>
                        </div>
                    </div>
                `;
            });

            grid.innerHTML = html;

            // Render mini charts only for tiers with showCharts: true
            chartIndex = 0;
            rankIndex = 0; // Reset rank index for chart rendering

            tiers.forEach(tier => {
                if (!tier.showCharts) {
                    // Skip chart rendering for this tier, but still count the players
                    let tierPlayers = [];
                    if (tier.type === 'rank') {
                        tierPlayers = wrs.slice(rankIndex, rankIndex + tier.maxPlayers);
                        rankIndex += tierPlayers.length;
                    } else {
                        const remainingPlayers = wrs.slice(rankIndex);
                        tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                        rankIndex += tierPlayers.length;
                    }
                    chartIndex += tierPlayers.length;
                    return;
                }

                let tierPlayers = [];
                if (tier.type === 'rank') {
                    tierPlayers = wrs.slice(rankIndex, rankIndex + tier.maxPlayers);
                    rankIndex += tierPlayers.length;
                } else {
                    const remainingPlayers = wrs.slice(rankIndex);
                    tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                    rankIndex += tierPlayers.length;
                }

                tierPlayers.forEach(player => {
                    renderPlayerCardChart(`wr-player-chart-${chartIndex}`, player, 'WR');
                    chartIndex++;
                });
            });
        }

        function renderRBPlayerCards() {
            const grid = document.getElementById('rb-players-grid');
            let rbs = Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints);

            // Calculate tags for RBs
            const playerTags = calculatePlayerTags('RB');

            // FILTER: Mark Cam Skattebo as inactive
            rbs = rbs.map(player => {
                if (player.name === 'Cam Skattebo') {
                    return {
                        ...player,
                        latestWeek: 0, // Force inactive status
                        inactive: true
                    };
                }
                return player;
            });

            // DEMOTE: Players with no stats since Week 4
            rbs = rbs.map(player => {
                if (player.latestWeek && player.latestWeek < 5) {
                    // Apply penalty to move them down tiers (reduce avg points by 50%)
                    return {
                        ...player,
                        avgPoints: player.avgPoints * 0.5,
                        inactive: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);


            // DEMOTE: Players with only 1 game should max out at Deep Flex tier
            rbs = rbs.map(player => {
                if (player.gamesPlayed === 1) {
                    // Cap their avg points at 7.9 (just below RB3/Flex threshold of 8)
                    return {
                        ...player,
                        avgPoints: Math.min(player.avgPoints, 7.9),
                        lowSampleSize: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);
            // Calculate top 24 averages
            const top24 = rbs.slice(0, 24);
            const top24AvgPoints = top24.reduce((sum, p) => sum + p.avgPoints, 0) / top24.length;
            const top24AvgOpps = top24.reduce((sum, p) => sum + (p.totalOpportunities / p.gamesPlayed), 0) / top24.length;

            // Track ranking for top 50 determination
            let overallRank = 0;

            // Define tiers based on avg points thresholds (performance-based)
            const tiers = [
                { name: 'Elite RB1', class: 'elite', min: 22, max: 999, color: '#30d158', showCharts: true },
                { name: 'High-End RB1', class: 'elite', min: 20, max: 22, color: '#30d158', showCharts: true },
                { name: 'Solid RB1', class: 'elite', min: 18, max: 20, color: '#30d158', showCharts: true },
                { name: 'Low RB1/High RB2', class: 'wr2', min: 15, max: 18, color: '#0a84ff', showCharts: true },
                { name: 'Mid RB2', class: 'wr2', min: 13, max: 15, color: '#0a84ff', showCharts: true },
                { name: 'Low RB2/Flex', class: 'flex', min: 10, max: 13, color: '#FFD60A', showCharts: true },
                { name: 'RB3/Flex', class: 'flex', min: 8, max: 10, color: '#FFD60A', showCharts: true },
                { name: 'Deep Flex', class: 'depth', min: 5, max: 8, color: '#8e8e93', showCharts: false },
                { name: 'Depth/Streaming', class: 'depth', min: 0, max: 5, color: '#8e8e93', showCharts: false }
            ];

            let html = '';
            let chartIndex = 0;

            tiers.forEach(tier => {
                const tierPlayers = rbs.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                if (tierPlayers.length === 0) return;

                html += `
                    <div class="tier-section">
                        <div class="tier-header" onclick="toggleTierCollapse(this)">
                            <div class="tier-badge ${tier.class}">${tier.name}</div>
                            <div class="tier-count">Avg: ${(tierPlayers.reduce((sum, p) => sum + p.avgPoints, 0) / tierPlayers.length).toFixed(1)} pts/game</div>
                            <span class="tier-collapse-icon">▼</span>
                        </div>
                        <div class="tier-cards-container">
                            <div class="cards-grid">
                `;

                tierPlayers.forEach(player => {
                    overallRank++;
                    const chartId = `rb-player-chart-${chartIndex++}`;
                    const escapedId = player.id.replace(/'/g, "\\'");
                    const sentiment = getSentimentScore(player.name);
                    const buyPct = sentiment.total > 0 ? (sentiment.buy / sentiment.total * 100) : 0;

                    // Use original avg points for display (not demoted value)
                    const displayAvgPoints = player.inactive ? player.avgPoints * 2 : player.avgPoints;

                    // Calculate comparisons to top 24
                    const oppsPerGame = player.totalOpportunities / player.gamesPlayed;
                    const pointsDiff = displayAvgPoints - top24AvgPoints;
                    const oppsDiff = oppsPerGame - top24AvgOpps;

                    const pointsClass = pointsDiff >= 0 ? 'comparison-up' : 'comparison-down';
                    const pointsIcon = pointsDiff >= 0 ? '▲' : '▼';
                    const oppsClass = oppsDiff >= 0 ? 'comparison-up' : 'comparison-down';
                    const oppsIcon = oppsDiff >= 0 ? '▲' : '▼';

                    // Include chart based on tier setting
                    const includeChart = tier.showCharts;

                    // Get tags for this player (RB specific)
                    const tags = playerTags[player.id] || [];

                    // Build tags HTML (momentum badge moved to card root)
                    let tagElements = tags.map(tag => {
                        if (tag === 'buy_low') return '<span class="player-tag buy-low" data-tooltip="Efficiency ↑ but Volume ↓ - Undervalued opportunity">Buy Low</span>';
                        if (tag === 'sell_high') return '<span class="player-tag sell-high" data-tooltip="Volume ↑ but Efficiency ↓ - Regression risk">Sell High</span>';
                        if (tag === 'rz_trend_up') return '<span class="player-tag rz-up" data-tooltip="Red Zone opportunities trending up - TD upside">RZ↑</span>';
                        return '';
                    }).filter(t => t);

                    const tagsHTML = tagElements.length > 0 ? `
                        <div class="player-tags">
                            ${tagElements.join('')}
                        </div>
                    ` : '';

                    html += `
                        <div class="player-card" onclick="openPlayerModal('${escapedId}')" ${player.inactive ? 'style="opacity: 0.6; border-left: 3px solid #ff453a;"' : ''}>
                            <div class="player-card-header">
                                <div class="player-card-badge" style="background: ${teamColors[player.team] || '#666'}">${player.team}</div>
                                <div style="flex: 1;">
                                    <div class="player-card-name">
                                        ${player.name}${player.inactive ? ' <span style="color: #ff453a; font-size: 11px;">⚠ INACTIVE</span>' : ''}
                                    </div>
                                    <div class="player-card-team">RB · ${player.team}${(() => {
                                        let badges = '';
                                        
                                        // Add injury badge if present
                                        const injury = getPlayerInjuryStatus(player.name);
                                        if (injury) {
                                            const statusInfo = formatInjuryStatus(injury.status);
                                            const injuryDetails = `${statusInfo.fullText} - ${injury.injuryBody}`;
                                            badges += ` <span class="injury-badge ${statusInfo.class}" data-injury-details="${injuryDetails}">${statusInfo.badge}</span>`;
                                        }
                                        
                                        // Add momentum badge if present
                                        if (player.momentum && player.momentum.isValid && player.momentum.direction !== 'neutral') {
                                            badges += ` <span class="momentum-badge ${player.momentum.direction}" data-tooltip="Momentum: ${player.momentum.score > 0 ? '+' : ''}${player.momentum.score.toFixed(1)}% (last 3 vs prev 3 weeks)">${player.momentum.direction === 'up' ? '↑' : '↓'}</span>`;
                                        }
                                        
                                        return badges;
                                    })()}</div>
                                    ${tagsHTML}
                                </div>
                            </div>
                            <div class="player-card-stats">
                                <div class="player-stat">
                                    <span class="player-stat-label">Avg Points</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="player-stat-value">${displayAvgPoints.toFixed(1)}</span>
                                        <span class="player-comparison ${pointsClass}">
                                            <span class="comparison-icon">${pointsIcon}</span>
                                            ${Math.abs(pointsDiff).toFixed(1)}
                                        </span>
                                        <div class="comparison-tooltip">
                                            <div class="tooltip-label">vs Top 24 RB Avg</div>
                                            <div class="tooltip-data">${displayAvgPoints.toFixed(1)} vs ${top24AvgPoints.toFixed(1)}</div>
                                            <div class="tooltip-data">${pointsDiff >= 0 ? '+' : ''}${pointsDiff.toFixed(1)} pts</div>
                                        </div>
                                    </div>
                                    <div class="stat-tooltip">Average fantasy points per game over ${player.gamesPlayed} games</div>
                                </div>
                                <div class="player-stat">
                                    <span class="player-stat-label">Opps/Game</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="player-stat-value">${oppsPerGame.toFixed(1)}</span>
                                        <span class="player-comparison ${oppsClass}">
                                            <span class="comparison-icon">${oppsIcon}</span>
                                            ${Math.abs(oppsDiff).toFixed(1)}
                                        </span>
                                        <div class="comparison-tooltip">
                                            <div class="tooltip-label">vs Top 24 RB Avg</div>
                                            <div class="tooltip-data">${oppsPerGame.toFixed(1)} vs ${top24AvgOpps.toFixed(1)}</div>
                                            <div class="tooltip-data">${oppsDiff >= 0 ? '+' : ''}${oppsDiff.toFixed(1)} opp/g</div>
                                        </div>
                                    </div>
                                    <div class="stat-tooltip">Average opportunities per game (${player.totalOpportunities} total opportunities)</div>
                                </div>
                                <div class="player-stat" style="grid-column: 1 / -1;">
                                    <span class="player-stat-label">Community Sentiment</span>
                                    <div style="margin-top: 4px;">
                                        ${sentiment.total > 0 ? (() => {
                                            const totalVotes = sentiment.total;
                                            const buyPct = Math.round((sentiment.buy / totalVotes) * 100);
                                            const holdPct = Math.round((sentiment.hold / totalVotes) * 100);
                                            const sellPct = Math.round((sentiment.sell / totalVotes) * 100);

                                            const max = Math.max(buyPct, holdPct, sellPct);
                                            let label, color, bgColor, icon;
                                            if (buyPct === max) {
                                                label = 'BUY';
                                                color = 'var(--positive)';
                                                bgColor = 'rgba(48, 209, 88, 0.15)';
                                                icon = '▲';
                                            } else if (sellPct === max) {
                                                label = 'SELL';
                                                color = 'var(--negative)';
                                                bgColor = 'rgba(255, 69, 58, 0.15)';
                                                icon = '▼';
                                            } else {
                                                label = 'HOLD';
                                                color = 'var(--text-secondary)';
                                                bgColor = 'rgba(142, 142, 147, 0.15)';
                                                icon = '—';
                                            }

                                            return '<span style="padding: 3px 6px; background: ' + bgColor + '; color: ' + color + '; border-radius: 5px; font-size: 10px; font-weight: 600; display: inline-block;">' + icon + ' ' + max + '% ' + label + '</span>';
                                        })() : '<span style="padding: 3px 6px; background: rgba(142, 142, 147, 0.15); color: var(--text-secondary); border-radius: 5px; font-size: 10px; font-weight: 600; display: inline-block;">No Votes</span>'}
                                    </div>
                                    <div class="stat-tooltip">${sentiment.total > 0 ? `Community voting: ${sentiment.total} total votes` : 'Be the first to vote! Open player modal to cast your vote.'}</div>
                                </div>
                            </div>
                            ${includeChart ? `<div class="player-card-chart">
                                <canvas id="${chartId}"></canvas>
                            </div>` : ''}
                        </div>
                    `;
                });

                html += `
                            </div>
                        </div>
                    </div>
                `;
            });

            grid.innerHTML = html;

            // Render mini charts ONLY for top 50 players
            chartIndex = 0;
            overallRank = 0;
            tiers.forEach(tier => {
                const tierPlayers = rbs.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                tierPlayers.forEach(player => {
                    overallRank++;
                    if (overallRank <= 50) {
                        renderPlayerCardChart(`rb-player-chart-${chartIndex}`, player, 'RB');
                    }
                    chartIndex++;
                });
            });
        }

        function renderTEPlayerCards() {
            const grid = document.getElementById('te-players-grid');
            let tes = Object.values(aggregatedTEs).sort((a, b) => b.avgPoints - a.avgPoints);

            // Calculate tags for TEs
            const playerTags = calculatePlayerTags('TE');

            // DEMOTE: Players with no stats since Week 4
            tes = tes.map(player => {
                if (player.latestWeek && player.latestWeek < 5) {
                    // Apply penalty to move them down tiers (reduce avg points by 50%)
                    return {
                        ...player,
                        avgPoints: player.avgPoints * 0.5,
                        inactive: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);

            // Find global max week (current week)
            let globalMaxWeek = 0;
            tes.forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });

            // DEMOTE: Players who haven't played in 2+ weeks - drop them 1 tier (~3.5 ppg)
            tes = tes.map(player => {
                if (player.latestWeek && globalMaxWeek - player.latestWeek >= 2) {
                    return {
                        ...player,
                        avgPoints: Math.max(0, player.avgPoints - 3.5),
                        recentlyInactive: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);

            // SPECIFIC: Move Darren Waller to TE2 tier max (6 ppg) until he plays again
            tes = tes.map(player => {
                if (player.name === 'Darren Waller') {
                    return {
                        ...player,
                        avgPoints: Math.min(player.avgPoints, 5.9), // Just below TE2 threshold
                        wallerException: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);

            // SPECIFIC: Tucker Kraft injured - mark inactive and keep below Bowers/McBride
            tes = tes.map(player => {
                if (player.name === 'Tucker Kraft') {
                    return {
                        ...player,
                        inactive: true,
                        kraftInjury: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);

            // ELITE TIER 0: Bowers and McBride are in their own tier
            // Everyone else must be within 1.5 ppg of them to join
            const eliteTwoAvg = tes.slice(0, 2).reduce((sum, p) => sum + p.avgPoints, 0) / 2;
            tes = tes.map((player, idx) => {
                // Skip the top 2 (Bowers and McBride)
                if (idx < 2) return player;

                // Everyone else must be within 1.5 ppg of the elite duo's average
                if (player.avgPoints < eliteTwoAvg - 1.5) {
                    return {
                        ...player,
                        avgPoints: Math.min(player.avgPoints, eliteTwoAvg - 1.6), // Push them down to next tier
                        notElite: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);

            // DEMOTE: Players with only 1 game should max out at tier 4 or 5 depending on points
            tes = tes.map(player => {
                if (player.gamesPlayed === 1) {
                    // If they scored 10+ points, cap at tier 4 (8 ppg)
                    // If they scored less, cap at tier 5 (6 ppg)
                    const maxPpg = player.avgPoints >= 10 ? 7.9 : 5.9;
                    return {
                        ...player,
                        avgPoints: Math.min(player.avgPoints, maxPpg),
                        lowSampleSize: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);

            // Calculate top 12 averages (not 24 like WR/RB)
            const top12 = tes.slice(0, 12);
            const top12AvgPoints = top12.reduce((sum, p) => sum + p.avgPoints, 0) / top12.length;
            const top12AvgTargets = top12.reduce((sum, p) => sum + (p.totalTargets / p.gamesPlayed), 0) / top12.length;

            // Track ranking for tier assignment
            let overallRank = 0;

            // Limit to top 50 TEs
            tes = tes.slice(0, 50);

            // Define 7 tiers with new naming
            const tiers = [
                { name: 'Elite', class: 'elite', type: 'rank', maxPlayers: 2, color: '#30d158', showCharts: true },
                { name: 'High-End TE1', class: 'elite', type: 'rank', maxPlayers: 3, color: '#30d158', showCharts: true },
                { name: 'Solid TE1', class: 'elite', type: 'rank', maxPlayers: 5, color: '#30d158', showCharts: true },
                { name: 'Low-End TE1/High-End TE2', class: 'wr2', type: 'rank', maxPlayers: 8, color: '#0a84ff', showCharts: true },
                { name: 'Solid TE2', class: 'wr2', type: 'points', min: 8, max: 999, color: '#0a84ff', showCharts: true },
                { name: 'Flex/Streamer', class: 'flex', type: 'points', min: 5.5, max: 8, color: '#FFD60A', showCharts: true },
                { name: 'Depth', class: 'depth', type: 'points', min: 0, max: 5.5, color: '#8e8e93', showCharts: false }
            ];

            let html = '';
            let chartIndex = 0;
            let rankIndex = 0; // Track position for rank-based tiers

            tiers.forEach(tier => {
                let tierPlayers = [];

                if (tier.type === 'rank') {
                    // Rank-based tier: take next N players in order
                    tierPlayers = tes.slice(rankIndex, rankIndex + tier.maxPlayers);
                    rankIndex += tierPlayers.length;
                } else {
                    // Point-based tier: filter by point threshold from remaining players
                    const remainingPlayers = tes.slice(rankIndex);
                    tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                    // Update rankIndex to skip these players for next tier
                    rankIndex += tierPlayers.length;
                }

                if (tierPlayers.length === 0) return;

                html += `
                    <div class="tier-section">
                        <div class="tier-header" onclick="toggleTierCollapse(this)">
                            <div class="tier-badge ${tier.class}">${tier.name}</div>
                            <div class="tier-count">Avg: ${(tierPlayers.reduce((sum, p) => sum + p.avgPoints, 0) / tierPlayers.length).toFixed(1)} pts/game</div>
                            <span class="tier-collapse-icon">▼</span>
                        </div>
                        <div class="tier-cards-container">
                            <div class="cards-grid">
                `;

                tierPlayers.forEach(player => {
                    overallRank++;
                    const chartId = `te-player-chart-${chartIndex++}`;
                    const escapedId = player.id.replace(/'/g, "\\'");
                    const sentiment = getSentimentScore(player.name);
                    const buyPct = sentiment.total > 0 ? (sentiment.buy / sentiment.total * 100) : 0;

                    // Use original avg points for display (not demoted value)
                    const displayAvgPoints = player.inactive ? player.avgPoints * 2 : player.avgPoints;

                    // Calculate comparisons to top 12
                    const targetsPerGame = player.totalTargets / player.gamesPlayed;
                    const pointsDiff = displayAvgPoints - top12AvgPoints;
                    const targetsDiff = targetsPerGame - top12AvgTargets;

                    const pointsClass = pointsDiff >= 0 ? 'comparison-up' : 'comparison-down';
                    const pointsIcon = pointsDiff >= 0 ? '▲' : '▼';
                    const targetsClass = targetsDiff >= 0 ? 'comparison-up' : 'comparison-down';
                    const targetsIcon = targetsDiff >= 0 ? '▲' : '▼';

                    // Include chart based on tier setting
                    const includeChart = tier.showCharts;

                    // Get tags for this player
                    const tags = playerTags[player.id] || [];

                    // Build tags HTML (momentum badge moved to card root)
                    let tagElements = tags.map(tag => {
                        if (tag === 'buy_low') return '<span class="player-tag buy-low" data-tooltip="Efficiency ↑ but Volume ↓ - Undervalued opportunity">Buy Low</span>';
                        if (tag === 'sell_high') return '<span class="player-tag sell-high" data-tooltip="Volume ↑ but Efficiency ↓ - Regression risk">Sell High</span>';
                        if (tag === 'rz_trend_up') return '<span class="player-tag rz-up" data-tooltip="Red Zone opportunities trending up - TD upside">RZ↑</span>';
                        return '';
                    }).filter(t => t);

                    const tagsHTML = tagElements.length > 0 ? `
                        <div class="player-tags">
                            ${tagElements.join('')}
                        </div>
                    ` : '';

                    html += `
                        <div class="player-card" onclick="openPlayerModal('${escapedId}')" ${player.inactive ? 'style="opacity: 0.6; border-left: 3px solid #ff453a;"' : ''}>
                            <div class="player-card-header">
                                <div class="player-card-badge" style="background: ${teamColors[player.team] || '#666'}">${player.team}</div>
                                <div style="flex: 1;">
                                    <div class="player-card-name">
                                        ${player.name}${player.inactive ? ' <span style="color: #ff453a; font-size: 11px;">⚠ INACTIVE</span>' : ''}
                                    </div>
                                    <div class="player-card-team">TE · ${player.team}${(() => {
                                        let badges = '';
                                        
                                        // Add injury badge if present
                                        const injury = getPlayerInjuryStatus(player.name);
                                        if (injury) {
                                            const statusInfo = formatInjuryStatus(injury.status);
                                            const injuryDetails = `${statusInfo.fullText} - ${injury.injuryBody}`;
                                            badges += ` <span class="injury-badge ${statusInfo.class}" data-injury-details="${injuryDetails}">${statusInfo.badge}</span>`;
                                        }
                                        
                                        // Add momentum badge if present
                                        if (player.momentum && player.momentum.isValid && player.momentum.direction !== 'neutral') {
                                            badges += ` <span class="momentum-badge ${player.momentum.direction}" data-tooltip="Momentum: ${player.momentum.score > 0 ? '+' : ''}${player.momentum.score.toFixed(1)}% (last 3 vs prev 3 weeks)">${player.momentum.direction === 'up' ? '↑' : '↓'}</span>`;
                                        }
                                        
                                        return badges;
                                    })()}</div>
                                        return '';
                                    })()}</div>
                                    ${tagsHTML}
                                </div>
                            </div>
                            <div class="player-card-stats">
                                <div class="player-stat">
                                    <span class="player-stat-label">Avg Points</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="player-stat-value">${displayAvgPoints.toFixed(1)}</span>
                                        <span class="player-comparison ${pointsClass}">
                                            <span class="comparison-icon">${pointsIcon}</span>
                                            ${Math.abs(pointsDiff).toFixed(1)}
                                        </span>
                                        <div class="comparison-tooltip">
                                            <div class="tooltip-label">vs Top 12 TE Avg</div>
                                            <div class="tooltip-data">${displayAvgPoints.toFixed(1)} vs ${top12AvgPoints.toFixed(1)}</div>
                                            <div class="tooltip-data">${pointsDiff >= 0 ? '+' : ''}${pointsDiff.toFixed(1)} pts</div>
                                        </div>
                                    </div>
                                    <div class="stat-tooltip">Average fantasy points per game over ${player.gamesPlayed} games</div>
                                </div>
                                <div class="player-stat">
                                    <span class="player-stat-label">Targets/Game</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="player-stat-value">${targetsPerGame.toFixed(1)}</span>
                                        <span class="player-comparison ${targetsClass}">
                                            <span class="comparison-icon">${targetsIcon}</span>
                                            ${Math.abs(targetsDiff).toFixed(1)}
                                        </span>
                                        <div class="comparison-tooltip">
                                            <div class="tooltip-label">vs Top 12 TE Avg</div>
                                            <div class="tooltip-data">${targetsPerGame.toFixed(1)} vs ${top12AvgTargets.toFixed(1)}</div>
                                            <div class="tooltip-data">${targetsDiff >= 0 ? '+' : ''}${targetsDiff.toFixed(1)} tgt/g</div>
                                        </div>
                                    </div>
                                    <div class="stat-tooltip">Average targets per game (${player.totalTargets} total targets)</div>
                                </div>
                                <div class="player-stat" style="grid-column: 1 / -1;">
                                    <span class="player-stat-label">Community Sentiment</span>
                                    <div style="margin-top: 4px;">
                                        ${sentiment.total > 0 ? (() => {
                                            const totalVotes = sentiment.total;
                                            const buyPct = Math.round((sentiment.buy / totalVotes) * 100);
                                            const holdPct = Math.round((sentiment.hold / totalVotes) * 100);
                                            const sellPct = Math.round((sentiment.sell / totalVotes) * 100);

                                            const max = Math.max(buyPct, holdPct, sellPct);
                                            let label, color, bgColor, icon;
                                            if (buyPct === max) {
                                                label = 'BUY';
                                                color = 'var(--positive)';
                                                bgColor = 'rgba(48, 209, 88, 0.15)';
                                                icon = '▲';
                                            } else if (sellPct === max) {
                                                label = 'SELL';
                                                color = 'var(--negative)';
                                                bgColor = 'rgba(255, 69, 58, 0.15)';
                                                icon = '▼';
                                            } else {
                                                label = 'HOLD';
                                                color = 'var(--text-secondary)';
                                                bgColor = 'rgba(142, 142, 147, 0.15)';
                                                icon = '—';
                                            }

                                            return '<span style="padding: 3px 6px; background: ' + bgColor + '; color: ' + color + '; border-radius: 5px; font-size: 10px; font-weight: 600; display: inline-block;">' + icon + ' ' + max + '% ' + label + '</span>';
                                        })() : '<span style="padding: 3px 6px; background: rgba(142, 142, 147, 0.15); color: var(--text-secondary); border-radius: 5px; font-size: 10px; font-weight: 600; display: inline-block;">No Votes</span>'}
                                    </div>
                                    <div class="stat-tooltip">${sentiment.total > 0 ? `Community voting: ${sentiment.total} total votes` : 'Be the first to vote! Open player modal to cast your vote.'}</div>
                                </div>
                            </div>
                            ${includeChart ? `<div class="player-card-chart">
                                <canvas id="${chartId}"></canvas>
                            </div>` : ''}
                        </div>
                    `;
                });

                html += `
                            </div>
                        </div>
                    </div>
                `;
            });

            grid.innerHTML = html;

            // Render mini charts only for tiers with showCharts: true
            chartIndex = 0;
            rankIndex = 0; // Reset rank index for chart rendering

            tiers.forEach(tier => {
                if (!tier.showCharts) {
                    rankIndex += tier.type === 'rank' ? tier.maxPlayers :
                                tes.slice(rankIndex).filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max).length;
                    return;
                }

                let tierPlayers = [];
                if (tier.type === 'rank') {
                    tierPlayers = tes.slice(rankIndex, rankIndex + tier.maxPlayers);
                    rankIndex += tierPlayers.length;
                } else {
                    const remainingPlayers = tes.slice(rankIndex);
                    tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                    rankIndex += tierPlayers.length;
                }

                // Render charts for this tier
                tierPlayers.forEach(player => {
                    renderPlayerCardChart(`te-player-chart-${chartIndex}`, player, 'TE');
                    chartIndex++;
                });
            });
        }
        function renderTeamsPage() {
            const teamsGrid = document.getElementById('teams-grid');

            // Reset and recalculate global teamStats
            teamStats = {};

            // NFL Division mapping
            const divisions = {
                'AFC East': ['BUF', 'MIA', 'NE', 'NYJ'],
                'AFC North': ['BAL', 'CIN', 'CLE', 'PIT'],
                'AFC South': ['HOU', 'IND', 'JAC', 'TEN'],
                'AFC West': ['DEN', 'KC', 'LAC', 'LV'],
                'NFC East': ['DAL', 'NYG', 'PHI', 'WAS'],
                'NFC North': ['CHI', 'DET', 'GB', 'MIN'],
                'NFC South': ['ATL', 'CAR', 'NO', 'TB'],
                'NFC West': ['ARI', 'LAR', 'SF', 'SEA']
            };

            // Aggregate by team
            Object.values(allPlayers).forEach(player => {
                if (!teamStats[player.team]) {
                    teamStats[player.team] = {
                        team: player.team,
                        wrCount: 0,
                        rbCount: 0,
                        totalPoints: 0,
                        players: [],
                        totalTargets: 0,
                        totalRushAtts: 0,
                        totalGames: 0,
                        weeklyTargets: {}, // Track targets by week
                        weeklyRushAtts: {} // Track rush attempts by week
                    };
                }

                if (player.position === 'WR') {
                    teamStats[player.team].wrCount++;
                } else {
                    teamStats[player.team].rbCount++;
                }

                teamStats[player.team].totalPoints += player.totalPoints;
                teamStats[player.team].players.push(player);

                // Aggregate targets and rush attempts by week
                player.weeks.forEach(week => {
                    const weekNum = week.week;

                    // Track targets (both WR and RB)
                    if (week.targets) {
                        if (!teamStats[player.team].weeklyTargets[weekNum]) {
                            teamStats[player.team].weeklyTargets[weekNum] = 0;
                        }
                        teamStats[player.team].weeklyTargets[weekNum] += week.targets;
                        teamStats[player.team].totalTargets += week.targets;
                    }

                    // Track rush attempts (RB only)
                    if (player.position === 'RB' && week.rushAttempts) {
                        if (!teamStats[player.team].weeklyRushAtts[weekNum]) {
                            teamStats[player.team].weeklyRushAtts[weekNum] = 0;
                        }
                        teamStats[player.team].weeklyRushAtts[weekNum] += week.rushAttempts;
                        teamStats[player.team].totalRushAtts += week.rushAttempts;
                    }
                });

                teamStats[player.team].totalGames = Math.max(
                    teamStats[player.team].totalGames,
                    player.weeks.length
                );
            });

            // Calculate averages and week-over-week changes for each team
            Object.values(teamStats).forEach(team => {
                // Find global max week
                let globalMaxWeek = 0;
                team.players.forEach(p => {
                    if (p.weeks && p.weeks.length > 0) {
                        const maxWeek = Math.max(...p.weeks.map(w => w.week));
                        if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                    }
                });

                // Calculate number of games (unique weeks with data)
                const uniqueWeeks = new Set();
                team.players.forEach(p => {
                    p.weeks.forEach(w => uniqueWeeks.add(w.week));
                });
                const numGames = uniqueWeeks.size;

                // Average targets per game
                team.avgTargetsPerGame = numGames > 0 ? team.totalTargets / numGames : 0;

                // Average rush attempts per game
                team.avgRushAttsPerGame = numGames > 0 ? team.totalRushAtts / numGames : 0;

                // Calculate week-over-week changes
                const lastWeek = globalMaxWeek;
                let prevWeek = globalMaxWeek - 1;

                // If team didn't play last week, look for the most recent week they did play
                let lastWeekTargets = team.weeklyTargets[lastWeek] || 0;
                let lastWeekRushAtts = team.weeklyRushAtts[lastWeek] || 0;

                // If no data for last week, find most recent week with data
                if (lastWeekTargets === 0 && lastWeekRushAtts === 0) {
                    for (let w = lastWeek - 1; w >= 1; w--) {
                        if (team.weeklyTargets[w] || team.weeklyRushAtts[w]) {
                            lastWeekTargets = team.weeklyTargets[w] || 0;
                            lastWeekRushAtts = team.weeklyRushAtts[w] || 0;
                            prevWeek = w - 1; // Compare to week before that
                            break;
                        }
                    }
                }

                const prevWeekTargets = team.weeklyTargets[prevWeek] || 0;
                const prevWeekRushAtts = team.weeklyRushAtts[prevWeek] || 0;

                team.targetsChange = prevWeekTargets > 0 ? lastWeekTargets - prevWeekTargets : 0;
                team.rushAttsChange = prevWeekRushAtts > 0 ? lastWeekRushAtts - prevWeekRushAtts : 0;

                // Calculate average points per game for Advanced Analytics
                team.avgPoints = numGames > 0 ? team.totalPoints / numGames : 0;
            });

            // Build HTML organized by division
            let html = '';
            let teamIndex = 0;

            Object.entries(divisions).forEach(([divisionName, teamCodes]) => {
                // Get teams in this division and sort by total points
                const divisionTeams = teamCodes
                    .map(code => teamStats[code])
                    .filter(team => team) // Filter out teams with no data
                    .sort((a, b) => b.totalPoints - a.totalPoints);

                if (divisionTeams.length === 0) return;

                // Division header
                html += `
                    <div style="grid-column: 1 / -1; margin-top: ${html ? '32px' : '0'};">
                        <h2 style="font-size: 18px; font-weight: 700; color: var(--text-primary); margin-bottom: 16px; padding-bottom: 8px; border-bottom: 2px solid var(--border-color);">
                            ${divisionName}
                        </h2>
                    </div>
                `;

                // Team cards for this division
                divisionTeams.forEach(team => {
                    const chartId = `team-chart-${teamIndex++}`;
                    html += `
                        <div class="team-card" onclick="openTeamModal('${team.team}')">
                            <div class="team-card-header">
                                <div class="team-card-badge" style="background: ${teamColors[team.team] || '#666'}">${team.team}</div>
                                <div class="team-card-name" style="font-weight: 700;">${team.team}</div>
                            </div>
                            <div class="team-card-stats">
                                <div class="team-stat">
                                    <span class="team-stat-label">Total Points</span>
                                    <span class="team-stat-value">${team.totalPoints.toFixed(1)}</span>
                                    <span class="stat-tooltip">Combined fantasy points from all WRs and RBs this season</span>
                                </div>
                                <div class="team-stat">
                                    <span class="team-stat-label">Avg Targets/Game</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="team-stat-value">${team.avgTargetsPerGame.toFixed(1)}</span>
                                        ${team.targetsChange !== 0 ? `
                                            <span class="player-comparison ${team.targetsChange > 0 ? 'comparison-up' : 'comparison-down'}">
                                                <span class="comparison-icon">${team.targetsChange > 0 ? '▲' : '▼'}</span>
                                                ${Math.abs(team.targetsChange).toFixed(1)}
                                            </span>
                                        ` : ''}
                                    </div>
                                    <span class="stat-tooltip">Average WR/RB targets per game (change vs last week)</span>
                                </div>
                                <div class="team-stat">
                                    <span class="team-stat-label">Avg Rush Atts/Game</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="team-stat-value">${team.avgRushAttsPerGame.toFixed(1)}</span>
                                        ${team.rushAttsChange !== 0 ? `
                                            <span class="player-comparison ${team.rushAttsChange > 0 ? 'comparison-up' : 'comparison-down'}">
                                                <span class="comparison-icon">${team.rushAttsChange > 0 ? '▲' : '▼'}</span>
                                                ${Math.abs(team.rushAttsChange).toFixed(1)}
                                            </span>
                                        ` : ''}
                                    </div>
                                    <span class="stat-tooltip">Average RB rush attempts per game (change vs last week)</span>
                                </div>
                            </div>
                            <div class="team-card-chart">
                                <canvas id="${chartId}"></canvas>
                            </div>
                        </div>
                    `;
                });
            });

            teamsGrid.innerHTML = html;

            // Now render charts for each team
            teamIndex = 0;
            Object.entries(divisions).forEach(([divisionName, teamCodes]) => {
                const divisionTeams = teamCodes
                    .map(code => teamStats[code])
                    .filter(team => team)
                    .sort((a, b) => b.totalPoints - a.totalPoints);

                divisionTeams.forEach(team => {
                    renderTeamCardChart(`team-chart-${teamIndex++}`, team);
                });
            });
        }

        function renderTeamCardChart(canvasId, team) {
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;

            // Get top 5 players by avg points
            const topPlayers = team.players
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 5);

            const labels = topPlayers.map(p => `${p.name} (${p.position})`);
            const data = topPlayers.map(p => p.avgPoints);

            // Generate color palette
            const teamColor = teamColors[team.team] || '#0a84ff';
            const colorPalette = getColorPalette(teamColor, topPlayers.length);

            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colorPalette,
                        borderColor: '#0a0a0a',
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => `${context.parsed.x.toFixed(1)} PPG`
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: false,
                            grid: { display: false }
                        },
                        y: {
                            ticks: {
                                color: '#8e8e93',
                                font: { size: 10 }
                            },
                            grid: { display: false }
                        }
                    }
                }
            });
        }

        function renderPlayerCardChart(canvasId, player, position) {
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;

            // Get weekly points data
            const weeks = player.weeks
                .sort((a, b) => a.week - b.week)
                .slice(-8); // Last 8 weeks

            const labels = weeks.map(w => `W${w.week}`);
            const actualData = weeks.map(w => w.fpts || 0);
            const expectedData = weeks.map(w => w.expectedFpts || 0);

            // Color based on team
            const teamColor = teamColors[player.team] || '#0a84ff';

            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Actual Points',
                            data: actualData,
                            borderColor: teamColor,
                            backgroundColor: teamColor + '33',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.3,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            pointBackgroundColor: teamColor,
                            pointBorderColor: '#fff',
                            pointBorderWidth: 1
                        },
                        {
                            label: 'Expected Points',
                            data: expectedData,
                            borderColor: '#8e8e93',
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false,
                            tension: 0.3,
                            pointRadius: 0,
                            pointHoverRadius: 4,
                            pointBackgroundColor: '#8e8e93',
                            pointBorderColor: '#fff',
                            pointBorderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: (context) => {
                                    const label = context.dataset.label || '';
                                    return `${label}: ${context.parsed.y.toFixed(1)} pts`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: '#8e8e93',
                                font: { size: 9 }
                            },
                            grid: { display: false }
                        },
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: '#8e8e93',
                                font: { size: 9 }
                            },
                            grid: {
                                color: '#1c1c1e'
                            }
                        }
                    }
                }
            });
        }

        function openTeamModal(teamCode) {
            const modal = document.getElementById('team-modal');
            modal.style.display = 'flex';

            // Get all players from this team
            const teamPlayers = Object.values(allPlayers).filter(p => p.team === teamCode);
            if (teamPlayers.length === 0) return;

            // Determine if WR or RB dominant team (or show both)
            const wrs = teamPlayers.filter(p => p.position === 'WR');
            const rbs = teamPlayers.filter(p => p.position === 'RB');
            const tes = teamPlayers.filter(p => p.position === 'TE');

            // Set header info
            document.getElementById('team-modal-badge').style.background = teamColors[teamCode] || '#666';
            document.getElementById('team-modal-badge').textContent = teamCode;
            document.getElementById('team-modal-name').textContent = `${teamCode} Team Analysis`;
            document.getElementById('team-modal-meta').textContent = `${wrs.length} WRs · ${rbs.length} RBs · ${tes.length} TEs`;

            // Calculate team stats
            const allTeamPlayers = [...wrs, ...rbs, ...tes];
            const totalPoints = allTeamPlayers.reduce((sum, p) => sum + (p.avgPoints * p.gamesPlayed), 0);
            const totalGames = allTeamPlayers.reduce((sum, p) => sum + p.gamesPlayed, 0);
            const avgPointsPerGame = totalGames > 0 ? totalPoints / totalGames : 0;

            const topPlayer = allTeamPlayers.sort((a, b) => b.avgPoints - a.avgPoints)[0];
            const topTargets = wrs.length > 0 ? Math.max(...wrs.map(w => w.totalTargets / w.gamesPlayed)) : 0;
            const topOpps = rbs.length > 0 ? Math.max(...rbs.map(r => r.totalOpportunities / r.gamesPlayed)) : 0;

            // Render team stats summary
            const statsHTML = `
                <div class="team-stat-card">
                    <div class="team-stat-value">${avgPointsPerGame.toFixed(1)}</div>
                    <div class="team-stat-label">Fantasy PPG</div>
                </div>
                <div class="team-stat-card">
                    <div class="team-stat-value">${topPlayer ? topPlayer.avgPoints.toFixed(1) : '0'}</div>
                    <div class="team-stat-label">Top Player PPG</div>
                </div>
                <div class="team-stat-card">
                    <div class="team-stat-value">${topTargets.toFixed(1)}</div>
                    <div class="team-stat-label">Top WR Targets</div>
                </div>
                <div class="team-stat-card">
                    <div class="team-stat-value">${topOpps.toFixed(1)}</div>
                    <div class="team-stat-label">Top RB Opps</div>
                </div>
            `;
            document.getElementById('team-stats-summary').innerHTML = statsHTML;

            // Render key players (top 4 by avg points)
            const keyPlayers = allTeamPlayers
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 4);

            const keyPlayersHTML = keyPlayers.map(player => {
                const posColor = getPositionColor(player.position);
                const statLabel = player.position === 'WR' || player.position === 'TE'
                    ? `${(player.totalTargets / player.gamesPlayed).toFixed(1)} tgts/g`
                    : `${(player.totalOpportunities / player.gamesPlayed).toFixed(1)} opps/g`;

                return `
                    <div class="key-player-card" onclick="openPlayerModal('${player.id.replace(/'/g, "\\'")}')">
                        <div class="key-player-position" style="background: ${posColor};">
                            ${player.position}
                        </div>
                        <div class="key-player-info">
                            <div class="key-player-name">${player.name}</div>
                            <div class="key-player-stat">${player.avgPoints.toFixed(1)} PPG · ${statLabel}</div>
                        </div>
                    </div>
                `;
            }).join('');

            document.getElementById('key-players-grid').innerHTML = keyPlayersHTML;

            // Store current team for chart updates
            window.currentTeamModalCode = teamCode;

            // Populate week selector
            const weeks = [...new Set([...wrData, ...rbData, ...(teData || [])].map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);
            const weekSelect = document.getElementById('team-modal-week');
            weekSelect.innerHTML = weeks.map(w => `<option value="${w}">Week ${w}</option>`).join('');
            if (weeks.length > 0) {
                weekSelect.value = weeks[weeks.length - 1]; // Default to latest week
            }

            // Set default timeframe to Season Long
            document.getElementById('team-modal-timeframe').value = 'season';

            // Render charts after modal is fully visible to ensure animations play
            // Using setTimeout ensures the browser has painted the modal and sized the canvas
            setTimeout(() => {
                updateTeamModalCharts();
            }, 50);
        }

        function closeTeamModal() {
            document.getElementById('team-modal').style.display = 'none';
            if (window.teamModalPlayersChart) window.teamModalPlayersChart.destroy();
            if (window.teamModalPositionChart) window.teamModalPositionChart.destroy();
        }

        function updateTeamModalCharts() {
            const teamCode = window.currentTeamModalCode;
            if (!teamCode) return;

            const metric = document.getElementById('team-modal-metric').value;
            const timeframe = document.getElementById('team-modal-timeframe').value;
            const weekSelector = document.getElementById('team-modal-week-selector');
            const selectedWeek = parseInt(document.getElementById('team-modal-week').value);

            // Show/hide week selector based on timeframe
            if (timeframe === 'single') {
                weekSelector.style.display = 'block';
            } else {
                weekSelector.style.display = 'none';
            }

            // Get all weeks available
            const allWeeks = [...new Set([...wrData, ...rbData, ...(teData || [])].map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);
            const latestWeek = Math.max(...allWeeks);

            // Filter data based on timeframe
            let filteredWRData, filteredRBData, filteredTEData;

            if (timeframe === 'single') {
                filteredWRData = wrData.filter(row => row.Team === teamCode && parseInt(row.Week) === selectedWeek);
                filteredRBData = rbData.filter(row => row.Team === teamCode && parseInt(row.Week) === selectedWeek);
                filteredTEData = teData ? teData.filter(row => row.Team === teamCode && parseInt(row.Week) === selectedWeek) : [];
            } else if (timeframe === 'last3') {
                const startWeek = latestWeek - 2;
                filteredWRData = wrData.filter(row => row.Team === teamCode && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek);
                filteredRBData = rbData.filter(row => row.Team === teamCode && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek);
                filteredTEData = teData ? teData.filter(row => row.Team === teamCode && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek) : [];
            } else if (timeframe === 'last5') {
                const startWeek = latestWeek - 4;
                filteredWRData = wrData.filter(row => row.Team === teamCode && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek);
                filteredRBData = rbData.filter(row => row.Team === teamCode && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek);
                filteredTEData = teData ? teData.filter(row => row.Team === teamCode && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek) : [];
            } else { // season or season-avg
                filteredWRData = wrData.filter(row => row.Team === teamCode);
                filteredRBData = rbData.filter(row => row.Team === teamCode);
                filteredTEData = teData ? teData.filter(row => row.Team === teamCode) : [];
            }

            // Aggregate player data based on selected metric
            const playerData = {};

            // Process WRs
            filteredWRData.forEach(row => {
                const player = row.Player;
                if (!playerData[player]) {
                    playerData[player] = { name: player, position: 'WR', totalValue: 0, games: 0 };
                }

                let value = 0;
                if (metric === 'points') {
                    value = parseFloat(row.FPTS || row.Fpts) || 0;
                } else if (metric === 'targets') {
                    value = parseFloat(row.TGT) || 0;
                } else if (metric === 'redzone') {
                    const rzTargets = parseFloat(row.RZ_TGT || row['RZ TGT']) || 0;
                    value = rzTargets; // WRs only have RZ targets
                }

                playerData[player].totalValue += value;
                if (value > 0 || metric === 'points') playerData[player].games++;
            });

            // Process RBs
            filteredRBData.forEach(row => {
                const player = row.Player;
                if (!playerData[player]) {
                    playerData[player] = { name: player, position: 'RB', totalValue: 0, games: 0 };
                }

                let value = 0;
                if (metric === 'points') {
                    value = parseFloat(row.FPTS || row.Fpts) || 0;
                } else if (metric === 'targets') {
                    value = parseFloat(row.TGT) || 0;
                } else if (metric === 'redzone') {
                    const rzAtt = parseFloat(row.RZ_RUSH_ATT || row['RZ RUSH ATT']) || 0;
                    const rzTargets = parseFloat(row.RZ_TGT || row['RZ TGT']) || 0;
                    value = rzAtt + rzTargets;
                }

                playerData[player].totalValue += value;
                if (value > 0 || metric === 'points') playerData[player].games++;
            });

            // Process TEs
            filteredTEData.forEach(row => {
                const player = row.Player;
                if (!playerData[player]) {
                    playerData[player] = { name: player, position: 'TE', totalValue: 0, games: 0 };
                }

                let value = 0;
                if (metric === 'points') {
                    value = parseFloat(row.FPTS || row.Fpts) || 0;
                } else if (metric === 'targets') {
                    value = parseFloat(row.TGT) || 0;
                } else if (metric === 'redzone') {
                    const rzTargets = parseFloat(row.RZ_TGT || row['RZ TGT']) || 0;
                    value = rzTargets; // TEs only have RZ targets
                }

                playerData[player].totalValue += value;
                if (value > 0 || metric === 'points') playerData[player].games++;
            });

            // Convert to array and sort
            let players = Object.values(playerData);

            // If season-avg, calculate per game average
            if (timeframe === 'season-avg') {
                players = players.map(p => ({
                    ...p,
                    displayValue: p.games > 0 ? p.totalValue / p.games : 0
                }));
            } else {
                players = players.map(p => ({
                    ...p,
                    displayValue: p.totalValue
                }));
            }

            // Sort by displayValue and get top 6
            players.sort((a, b) => b.displayValue - a.displayValue);
            const top6Players = players.slice(0, 6);

            // Calculate position totals
            const positionTotals = {
                WR: 0,
                RB: 0,
                TE: 0
            };

            players.forEach(p => {
                if (timeframe === 'season-avg') {
                    positionTotals[p.position] += p.displayValue;
                } else {
                    positionTotals[p.position] += p.totalValue;
                }
            });

            // Update chart headers based on metric
            let metricLabel = '';
            if (metric === 'points') metricLabel = 'Points';
            else if (metric === 'targets') metricLabel = 'Targets';
            else if (metric === 'redzone') metricLabel = 'Red Zone Opps';

            document.getElementById('team-modal-players-chart-header').textContent = `Top 6 Players by ${metricLabel}`;
            document.getElementById('team-modal-position-chart-header').textContent = `${metricLabel} by Position`;

            // Render charts
            renderTeamModalPlayersChart(top6Players, teamCode, timeframe, metric);
            renderTeamModalPositionChart(positionTotals, teamCode, timeframe, metric);
        }

        function renderTeamModalPlayersChart(players, teamCode, timeframe, metric) {
            const ctx = document.getElementById('team-modal-players-chart');
            if (!ctx) return;

            // Destroy existing chart
            if (window.teamModalPlayersChart) {
                window.teamModalPlayersChart.destroy();
            }

            const teamColor = teamColors[teamCode] || '#0a84ff';
            const colorPalette = getColorPalette(teamColor, 6);

            const labels = players.map(p => p.name);
            const data = players.map(p => p.displayValue);
            const positions = players.map(p => p.position);

            const isAvg = timeframe === 'season-avg';
            const yAxisLabel = isAvg ? 'Points Per Game' : 'Total Points';

            window.teamModalPlayersChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colorPalette,
                        borderColor: colorPalette.map(c => c),
                        borderWidth: 0
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const pos = positions[context.dataIndex];
                                    const val = context.parsed.x.toFixed(1);
                                    return `${pos} - ${val} ${isAvg ? 'PPG' : 'pts'}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: yAxisLabel,
                                color: '#8e8e93',
                                font: { size: 11 }
                            },
                            ticks: {
                                color: '#8e8e93',
                                font: { size: 10 }
                            },
                            grid: {
                                color: '#1c1c1e'
                            }
                        },
                        y: {
                            ticks: {
                                color: '#ffffff',
                                font: { size: 11, weight: '600' }
                            },
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });
        }

        function renderTeamModalPositionChart(positionTotals, teamCode, timeframe, metric) {
            const ctx = document.getElementById('team-modal-position-chart');
            if (!ctx) return;

            // Destroy existing chart
            if (window.teamModalPositionChart) {
                window.teamModalPositionChart.destroy();
            }

            const positions = ['WR', 'RB', 'TE'];
            const data = positions.map(pos => positionTotals[pos]);
            const total = data.reduce((sum, val) => sum + val, 0);

            const colors = {
                WR: '#0a84ff',
                RB: '#30d158',
                TE: '#ff9500'
            };

            // Create transparent fills (45% opacity) and solid borders
            const backgroundColors = positions.map(pos => {
                const color = colors[pos];
                const r = parseInt(color.slice(1, 3), 16);
                const g = parseInt(color.slice(3, 5), 16);
                const b = parseInt(color.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, 0.45)`;
            });

            const borderColors = positions.map(pos => colors[pos]);

            const isAvg = timeframe === 'season-avg';

            window.teamModalPositionChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: positions,
                    datasets: [{
                        data: data,
                        backgroundColor: backgroundColors,
                        borderColor: borderColors,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        animateRotate: true,
                        animateScale: true,
                        duration: 1200,
                        easing: 'easeInOutQuart'
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: '#ffffff',
                                padding: 12,
                                font: { size: 12, weight: 'bold' },
                                generateLabels: (chart) => {
                                    const data = chart.data;
                                    return data.labels.map((label, i) => {
                                        const value = data.datasets[0].data[i];
                                        const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                        return {
                                            text: `${label}: ${value.toFixed(1)} ${isAvg ? 'PPG' : 'pts'} (${percentage}%)`,
                                            fillStyle: data.datasets[0].backgroundColor[i],
                                            fontColor: '#ffffff',
                                            hidden: false,
                                            index: i
                                        };
                                    });
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const value = context.parsed;
                                    const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                    return `${context.label}: ${value.toFixed(1)} ${isAvg ? 'PPG' : 'pts'} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        /* OLD TEAM MODAL CHART FUNCTIONS - NO LONGER USED
        function renderTeamModalShareChart(teamCode, position) {
            // Removed - replaced with renderTeamModalPlayersChart and renderTeamModalPositionChart
        }

        function renderTeamModalTrendsChart(teamCode, position) {
            // Removed - replaced with renderTeamModalPlayersChart and renderTeamModalPositionChart
        }
        */

        // 4. CHARTS

        function renderScatterPlots() {
            // Only render team scatter - WR/RB charts are lazy loaded
            renderTeamBalanceScatter();
            initializeTeamAnalysis();
        }

        // Matrix switching functions
        function switchMatrix(matrixType) {
            // Update button states
            document.querySelectorAll('.matrix-tab').forEach(btn => {
                btn.classList.remove('active');
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.color = 'var(--text-secondary)';
            });
            event.target.classList.add('active');
            event.target.style.background = 'var(--positive)';
            event.target.style.color = 'white';

            // Show correct section
            document.querySelectorAll('.matrix-section').forEach(section => {
                section.style.display = 'none';
            });
            document.getElementById(matrixType).style.display = 'block';
        }

        function switchWRMatrix(chartType) {
            // Update button states
            document.querySelectorAll('.wr-matrix-tab').forEach(btn => {
                btn.classList.remove('active');
                btn.style.color = 'var(--text-secondary)';
                btn.style.borderBottomColor = 'transparent';
            });
            event.target.classList.add('active');
            event.target.style.color = 'var(--text-primary)';
            event.target.style.borderBottomColor = 'var(--positive)';

            // Show correct chart with animation
            document.querySelectorAll('.wr-matrix-content').forEach(content => {
                content.style.display = 'none';
            });
            const targetChart = document.getElementById(`wr-matrix-${chartType}`);
            targetChart.style.display = 'block';
            targetChart.style.animation = 'fadeIn 0.3s ease';
        }

        function switchRBMatrix(chartType) {
            // Update button states
            document.querySelectorAll('.rb-matrix-tab').forEach(btn => {
                btn.classList.remove('active');
                btn.style.color = 'var(--text-secondary)';
                btn.style.borderBottomColor = 'transparent';
            });
            event.target.classList.add('active');
            event.target.style.color = 'var(--text-primary)';
            event.target.style.borderBottomColor = 'var(--positive)';

            // Show correct chart with animation
            document.querySelectorAll('.rb-matrix-content').forEach(content => {
                content.style.display = 'none';
            });
            const targetChart = document.getElementById(`rb-matrix-${chartType}`);
            targetChart.style.display = 'block';
            targetChart.style.animation = 'fadeIn 0.3s ease';
        }

        function switchMatrixChart(chartType) {
            // Update button states in current section
            const activeSection = document.querySelector('.matrix-section:not([style*="display: none"])');
            activeSection.querySelectorAll('.matrix-chart-tab').forEach(btn => {
                btn.classList.remove('active');
                btn.style.color = 'var(--text-secondary)';
                btn.style.borderBottomColor = 'transparent';
            });
            event.target.classList.add('active');
            event.target.style.color = 'var(--text-primary)';
            event.target.style.borderBottomColor = 'var(--positive)';

            // Show correct chart
            activeSection.querySelectorAll('.matrix-chart-content').forEach(content => {
                content.style.display = 'none';
            });
            activeSection.querySelector(`#matrix-${chartType}`).style.display = 'block';
        }

        function renderMatrices() {
            // WR Matrices
            renderEfficiencyMatrix('wr');
            renderShareMatrix('wr');
            renderFloorMatrix('wr');
            renderVolumeMonsterMatrix();
            renderCatchRateMatrix();
            renderRedzoneMatrix('wr');

            // RB Matrices
            renderEfficiencyMatrix('rb');
            renderTalentSituationMatrix();
            renderOpportunityEfficiencyMatrix();
            renderShareMatrix('rb');
            renderFloorMatrix('rb');
            renderRedzoneMatrix('rb');
        }

        // Matrix 1: Efficiency vs Volume
        function renderEfficiencyMatrix(position) {
            const canvasId = position === 'wr' ? 'wr-efficiency-matrix' : 'rb-efficiency-matrix';
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;

            const players = position === 'wr' ?
                Object.values(aggregatedWRs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50) :
                Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);

            const data = players.map(player => {
                const volume = position === 'wr' ? player.totalTargets : player.totalOpportunities;
                const efficiency = player.avgPoints / (volume / player.gamesPlayed); // Points per opportunity per game

                return {
                    x: volume,
                    y: efficiency,
                    label: player.name,
                    player: player
                };
            });

            // Calculate medians for quadrant lines
            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];

            const chartVar = position === 'wr' ? 'wrEfficiencyMatrix' : 'rbEfficiencyMatrix';
            if (window[chartVar]) {
                window[chartVar].destroy();
            }

            window[chartVar] = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: position.toUpperCase() + 's',
                            data: data,
                            backgroundColor: data.map(d => {
                                const color = teamColors[d.player.team] || '#666';
                                const r = parseInt(color.slice(1, 3), 16);
                                const g = parseInt(color.slice(3, 5), 16);
                                const b = parseInt(color.slice(5, 7), 16);
                                return `rgba(${r}, ${g}, ${b}, 0.6)`;
                            }),
                            borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                            borderWidth: 2,
                            pointRadius: 8,
                            pointHoverRadius: 10,
                            pointStyle: 'circle',
                            pointBorderWidth: 2,
                            shadowOffsetX: 0,
                            shadowOffsetY: 0,
                            shadowBlur: 12,
                            shadowColor: data.map(d => teamColors[d.player.team] || '#666')
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const player = data[elements[0].index].player;
                            openPlayerModal(player.id);
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const player = context.raw.player;
                                    return [
                                        player.name,
                                        `Volume: ${context.parsed.x.toFixed(0)}`,
                                        `Efficiency: ${context.parsed.y.toFixed(2)} pts/opp`,
                                        `AVG: ${player.avgPoints.toFixed(1)}`
                                    ];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                vLine: {
                                    type: 'line',
                                    xMin: medianX,
                                    xMax: medianX,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                hLine: {
                                    type: 'line',
                                    yMin: medianY,
                                    yMax: medianY,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                topRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: [position === 'wr' ? 'Safe Floor' : 'Volume RBs'],
                                    color: '#FFD60A',
                                    font: { size: 9, weight: 'bold' }
                                },
                                topLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: ['Efficient'],
                                    color: '#0a84ff',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: [''],
                                    color: '#FFD60A',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: [''],
                                    color: '#ff453a',
                                    font: { size: 9, weight: 'bold' }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: position === 'wr' ? 'Total Targets →' : 'Total Opportunities →',
                                color: '#8e8e93',
                                font: { weight: 'bold' }
                            },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianX) < 1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Efficiency (Points per Opportunity) →',
                                color: '#8e8e93',
                                font: { weight: 'bold' }
                            },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianY) < 0.1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }

        // Matrix 2: Share vs Team Strength
        function renderShareMatrix(position) {
            const canvasId = position === 'wr' ? 'wr-share-matrix' : 'rb-share-matrix';
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;

            const players = position === 'wr' ?
                Object.values(aggregatedWRs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50) :
                Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);

            // Calculate team total points
            const teamTotals = {};
            Object.values(allPlayers).forEach(p => {
                if (!teamTotals[p.team]) teamTotals[p.team] = 0;
                teamTotals[p.team] += p.totalPoints;
            });

            const data = players.map(player => ({
                x: player.latestWeekOppShare,
                y: teamTotals[player.team] || 0,
                label: player.name,
                player: player
            }));

            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];

            const chartVar = position === 'wr' ? 'wrShareMatrix' : 'rbShareMatrix';
            if (window[chartVar]) window[chartVar].destroy();

            window[chartVar] = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(d => {
                            const color = teamColors[d.player.team] || '#666';
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, 0.6)`;
                        }),
                        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            openPlayerModal(data[elements[0].index].player.id);
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    return [p.name, `Share: ${context.parsed.x.toFixed(1)}%`, `Team Total: ${context.parsed.y.toFixed(0)}`, `AVG: ${p.avgPoints.toFixed(1)}`];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                vLine: {
                                    type: 'line',
                                    xMin: medianX,
                                    xMax: medianX,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                hLine: {
                                    type: 'line',
                                    yMin: medianY,
                                    yMax: medianY,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                topRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: [position === 'rb' ? 'Elite RB1' : ''],
                                    color: '#30d158',
                                    font: { size: 9, weight: 'bold' }
                                },
                                topLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: [position === 'wr' ? 'Big piece of small pie' : 'Good offense low share'],
                                    color: position === 'wr' ? '#FFD60A' : '#0a84ff',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: [position === 'wr' ? 'Small piece of big pie' : 'Bellcow, bad offense'],
                                    color: position === 'wr' ? '#0a84ff' : '#FFD60A',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: [position === 'wr' ? 'Limited role on bad offense' : 'Avoid'],
                                    color: '#ff453a',
                                    font: { size: 9, weight: 'bold' }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Opportunity Share % →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianX) < 1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: { display: true, text: 'Team Total Points →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianY) < 1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }

        // Matrix 3: Floor vs Ceiling
        function renderFloorMatrix(position) {
            const canvasId = position === 'wr' ? 'wr-floor-matrix' : 'rb-floor-matrix';
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;

            const players = position === 'wr' ?
                Object.values(aggregatedWRs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50) :
                Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);

            const data = players.map(player => {
                const variances = player.weeks.map(w => w.variance);
                const stdDev = Math.sqrt(variances.reduce((sum, v) => sum + Math.pow(v, 2), 0) / variances.length);
                const consistency = 10 / (stdDev + 1); // Higher is more consistent

                return {
                    x: player.avgPoints,
                    y: consistency,
                    label: player.name,
                    player: player,
                    stdDev: stdDev
                };
            });

            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];

            const chartVar = position === 'wr' ? 'wrFloorMatrix' : 'rbFloorMatrix';
            if (window[chartVar]) window[chartVar].destroy();

            window[chartVar] = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(d => {
                            const color = teamColors[d.player.team] || '#666';
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, 0.6)`;
                        }),
                        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            openPlayerModal(data[elements[0].index].player.id);
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const d = data[context.dataIndex];
                                    return [d.player.name, `Ceiling: ${context.parsed.x.toFixed(1)}`, `Floor Score: ${context.parsed.y.toFixed(1)}`, `Std Dev: ${d.stdDev.toFixed(2)}`];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                vLine: {
                                    type: 'line',
                                    xMin: medianX,
                                    xMax: medianX,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                hLine: {
                                    type: 'line',
                                    yMin: medianY,
                                    yMax: medianY,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Average Points (Ceiling) →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianX) < 1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: { display: true, text: 'Consistency Score (Floor) →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianY) < 0.1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }

        // Matrix 4: Red Zone Usage vs Efficiency
        function renderRedzoneMatrix(position) {
            const canvasId = position === 'wr' ? 'wr-redzone-matrix' : 'rb-redzone-matrix';
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;

            const players = position === 'wr' ?
                Object.values(aggregatedWRs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50) :
                Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);

            const data = players.map(player => {
                let xValue, yValue;

                if (position === 'wr') {
                    // NEW: Total Targets (x) vs RZ Targets (y)
                    xValue = player.totalTargets;
                    yValue = player.rzOpportunities;
                } else {
                    // RB: Keep existing (RZ opps per game vs PPG)
                    xValue = player.rzOpportunities / player.gamesPlayed; // RZ opps per game
                    yValue = player.avgPoints / player.gamesPlayed; // Points per game
                }

                return {
                    x: xValue,
                    y: yValue,
                    label: player.name,
                    player: player
                };
            });

            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];

            const chartVar = position === 'wr' ? 'wrRedzoneMatrix' : 'rbRedzoneMatrix';
            if (window[chartVar]) window[chartVar].destroy();

            window[chartVar] = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(d => {
                            const color = teamColors[d.player.team] || '#666';
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, 0.6)`;
                        }),
                        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            openPlayerModal(data[elements[0].index].player.id);
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    if (position === 'wr') {
                                        return [p.name, `Total Targets: ${context.parsed.x}`, `RZ Targets: ${context.parsed.y}`, `AVG: ${p.avgPoints.toFixed(1)}`];
                                    } else {
                                        return [p.name, `RZ/Game: ${context.parsed.x.toFixed(1)}`, `PPG: ${context.parsed.y.toFixed(1)}`, `Total RZ: ${p.rzOpportunities}`];
                                    }
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                vLine: {
                                    type: 'line',
                                    xMin: medianX,
                                    xMax: medianX,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                hLine: {
                                    type: 'line',
                                    yMin: medianY,
                                    yMax: medianY,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                topRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: ['Elite RZ usage'],
                                    color: '#30d158',
                                    font: { size: 13, weight: 'bold' }
                                },
                                topLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.2,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: position === 'wr' ? ['High scoring low RZ'] : ['Efficient but no RZ'],
                                    color: '#0a84ff',
                                    font: { size: 13, weight: 'bold' }
                                },
                                bottomRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.min(...yValues) + (Math.max(...yValues) - Math.min(...yValues)) * 0.15,
                                    content: position === 'rb' ? ['Buy low candidates'] : [''],
                                    color: '#FFD60A',
                                    font: { size: 13, weight: 'bold' }
                                },
                                bottomLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.2,
                                    yValue: Math.min(...yValues) + (Math.max(...yValues) - Math.min(...yValues)) * 0.15,
                                    content: ['Low production'],
                                    color: '#ff453a',
                                    font: { size: 13, weight: 'bold' }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: position === 'wr' ? 'Total Targets →' : 'Red Zone Opportunities per Game →',
                                color: '#8e8e93',
                                font: { weight: 'bold' }
                            },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianX) < 0.1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: position === 'wr' ? 'Red Zone Targets →' : 'Total Fantasy Points per Game →',
                                color: '#8e8e93',
                                font: { weight: 'bold' }
                            },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianY) < 1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }

        // WR-Specific Matrix: Volume Monster (Target Share vs Targets per Game)
        function renderVolumeMonsterMatrix() {
            const ctx = document.getElementById('wr-volume-monster-matrix');
            if (!ctx) return;

            const wrs = Object.values(aggregatedWRs)
                .filter(p => p.gamesPlayed >= 3)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 50);

            const data = wrs.map(player => ({
                x: player.latestWeekOppShare,
                y: player.tgtPerGame,
                label: player.name,
                player: player
            }));

            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];

            if (wrVolumeMonsterMatrix) wrVolumeMonsterMatrix.destroy();

            wrVolumeMonsterMatrix = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(d => {
                            const color = teamColors[d.player.team] || '#666';
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, 0.6)`;
                        }),
                        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
                    onClick: (event, elements) => {
                        if (elements.length > 0) openPlayerModal(data[elements[0].index].player.id);
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    return [p.name, `Target Share: ${context.parsed.x.toFixed(1)}%`, `TGT/G: ${context.parsed.y.toFixed(1)}`, `AVG: ${p.avgPoints.toFixed(1)}`];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                vLine: {
                                    type: 'line',
                                    xMin: medianX,
                                    xMax: medianX,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                hLine: {
                                    type: 'line',
                                    yMin: medianY,
                                    yMax: medianY,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                topRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: ['Volume Monster'],
                                    color: '#30d158',
                                    font: { size: 9, weight: 'bold' }
                                },
                                topLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: ['High Volume, Low Share'],
                                    color: '#0a84ff',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: ['Concentrated Targets'],
                                    color: '#FFD60A',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: ['Limited Role'],
                                    color: '#ff453a',
                                    font: { size: 9, weight: 'bold' }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Target Share % (Latest Week) →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: { display: true, text: 'Targets per Game →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }

        // WR-Specific Matrix: Catch Rate (Air Yards per Game vs Catch Rate)
        function renderCatchRateMatrix() {
            const ctx = document.getElementById('wr-catch-rate-matrix');
            if (!ctx) return;

            const wrs = Object.values(aggregatedWRs)
                .filter(p => p.gamesPlayed >= 3)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 50);

            const data = wrs.map(player => ({
                x: player.airYardsPerGame,
                y: player.catchRate,
                label: player.name,
                player: player
            }));

            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];

            if (wrCatchRateMatrix) wrCatchRateMatrix.destroy();

            wrCatchRateMatrix = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(d => {
                            const color = teamColors[d.player.team] || '#666';
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, 0.6)`;
                        }),
                        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
                    onClick: (event, elements) => {
                        if (elements.length > 0) openPlayerModal(data[elements[0].index].player.id);
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    return [p.name, `Air Yds/G: ${context.parsed.x.toFixed(1)}`, `Catch Rate: ${context.parsed.y.toFixed(1)}%`, `AVG: ${p.avgPoints.toFixed(1)}`];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                vLine: {
                                    type: 'line',
                                    xMin: medianX,
                                    xMax: medianX,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                hLine: {
                                    type: 'line',
                                    yMin: medianY,
                                    yMax: medianY,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                topRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: ['Deep Threats'],
                                    color: '#30d158',
                                    font: { size: 9, weight: 'bold' }
                                },
                                topLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: ['Reliable Hands'],
                                    color: '#0a84ff',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: ['Contested Catches'],
                                    color: '#FFD60A',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: ['Drop Issues'],
                                    color: '#ff453a',
                                    font: { size: 9, weight: 'bold' }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Air Yards per Game →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: { display: true, text: 'Catch Rate % →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }

        // RB-Specific Matrix: Talent vs Situation (YBCON vs YACON)
        function renderTalentSituationMatrix() {
            const ctx = document.getElementById('rb-talent-matrix');
            if (!ctx) return;

            const rbs = Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);

            const data = rbs.map(player => {
                const playerRows = rbData.filter(row => row.Team === player.team && row.Player === player.name);
                let totalYBCON = 0, totalYACON = 0, totalATT = 0;
                playerRows.forEach(row => {
                    totalYBCON += parseFloat(row.YBCON) || 0;
                    totalYACON += parseFloat(row.YACON) || 0;
                    totalATT += parseFloat(row.ATT) || 0;
                });
                return {
                    x: totalATT > 0 ? totalYBCON / totalATT : 0,
                    y: totalATT > 0 ? totalYACON / totalATT : 0,
                    label: player.name,
                    player: player
                };
            });

            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];

            if (rbTalentMatrix) rbTalentMatrix.destroy();

            rbTalentMatrix = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(d => {
                            const color = teamColors[d.player.team] || '#666';
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, 0.6)`;
                        }),
                        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) openPlayerModal(data[elements[0].index].player.id);
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    return [p.name, `YBCON/ATT: ${context.parsed.x.toFixed(2)}`, `YACON/ATT: ${context.parsed.y.toFixed(2)}`, `AVG: ${p.avgPoints.toFixed(1)}`];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Yards Before Contact per Attempt (O-Line Quality) →', color: '#8e8e93' },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: { display: true, text: 'Yards After Contact per Attempt (RB Talent) →', color: '#8e8e93' },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                },
                plugins: [{
                    id: 'quadrantLabels',
                    afterDraw: (chart) => {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const xAxis = chart.scales.x;
                        const yAxis = chart.scales.y;
                        const xMid = xAxis.getPixelForValue(medianX);
                        const yMid = yAxis.getPixelForValue(medianY);

                        // Draw dotted median lines (2px thick)
                        ctx.strokeStyle = '#8e8e93';
                        ctx.setLineDash([5, 5]);
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(xMid, chartArea.top);
                        ctx.lineTo(xMid, chartArea.bottom);
                        ctx.moveTo(chartArea.left, yMid);
                        ctx.lineTo(chartArea.right, yMid);
                        ctx.stroke();
                        ctx.setLineDash([]);

                        // Add corner labels (9px font, colored)
                        ctx.font = 'bold 9px -apple-system, BlinkMacSystemFont, sans-serif';

                        // Top-right: Elite Situation + Talent (GREEN)
                        ctx.fillStyle = '#30d158';
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'top';
                        ctx.fillText('Elite', chartArea.right - 5, chartArea.top + 5);

                        // Top-left: Elite Talent (BLUE)
                        ctx.fillStyle = '#0a84ff';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        ctx.fillText('Elite Talent', chartArea.left + 5, chartArea.top + 5);

                        // Bottom-right: Elite Situation (YELLOW)
                        ctx.fillStyle = '#FFD60A';
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'bottom';
                        ctx.fillText('Elite Situation', chartArea.right - 5, chartArea.bottom - 5);

                        // Bottom-left: Avoid (RED)
                        ctx.fillStyle = '#ff453a';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'bottom';
                        ctx.fillText('Avoid', chartArea.left + 5, chartArea.bottom - 5);
                    }
                }]
            });
        }

        // RB-Specific Matrix: Opportunity vs Efficiency (Touch Share vs YAC)
        function renderOpportunityEfficiencyMatrix() {
            const ctx = document.getElementById('rb-opportunity-matrix');
            if (!ctx) return;

            const rbs = Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);

            const data = rbs.map(player => {
                const playerRows = rbData.filter(row => row.Team === player.team && row.Player === player.name);
                let totalYACON = 0, totalATT = 0;
                playerRows.forEach(row => {
                    totalYACON += parseFloat(row.YACON) || 0;
                    totalATT += parseFloat(row.ATT) || 0;
                });
                return {
                    x: player.latestWeekOppShare,
                    y: totalATT > 0 ? totalYACON / totalATT : 0,
                    label: player.name,
                    player: player
                };
            });

            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];

            if (rbOpportunityMatrix) rbOpportunityMatrix.destroy();

            rbOpportunityMatrix = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(d => {
                            const color = teamColors[d.player.team] || '#666';
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, 0.6)`;
                        }),
                        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) openPlayerModal(data[elements[0].index].player.id);
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    return [p.name, `Touch Share: ${context.parsed.x.toFixed(1)}%`, `YAC/ATT: ${context.parsed.y.toFixed(2)}`, `AVG: ${p.avgPoints.toFixed(1)}`];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Touch Share % →', color: '#8e8e93' },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: { display: true, text: 'Yards After Contact per Attempt →', color: '#8e8e93' },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                },
                plugins: [{
                    id: 'quadrantLabels',
                    afterDraw: (chart) => {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const xAxis = chart.scales.x;
                        const yAxis = chart.scales.y;
                        const xMid = xAxis.getPixelForValue(medianX);
                        const yMid = yAxis.getPixelForValue(medianY);

                        // Draw dotted median lines (2px thick)
                        ctx.strokeStyle = '#8e8e93';
                        ctx.setLineDash([5, 5]);
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(xMid, chartArea.top);
                        ctx.lineTo(xMid, chartArea.bottom);
                        ctx.moveTo(chartArea.left, yMid);
                        ctx.lineTo(chartArea.right, yMid);
                        ctx.stroke();
                        ctx.setLineDash([]);

                        // Add corner labels (9px font, colored)
                        ctx.font = 'bold 9px -apple-system, BlinkMacSystemFont, sans-serif';

                        // Top-right: Elite (GREEN)
                        ctx.fillStyle = '#30d158';
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'top';
                        ctx.fillText('Elite', chartArea.right - 5, chartArea.top + 5);

                        // Top-left: Inefficient Volume (BLUE)
                        ctx.fillStyle = '#0a84ff';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        ctx.fillText('Inefficient', chartArea.left + 5, chartArea.top + 5);

                        // Bottom-right: Boom-Bust (YELLOW)
                        ctx.fillStyle = '#FFD60A';
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'bottom';
                        ctx.fillText('Boom-Bust', chartArea.right - 5, chartArea.bottom - 5);

                        // Bottom-left: Fade (RED)
                        ctx.fillStyle = '#ff453a';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'bottom';
                        ctx.fillText('Fade', chartArea.left + 5, chartArea.bottom - 5);
                    }
                }]
            });
        }

        function renderWRScatter() {
            const ctx = document.getElementById('wr-scatter-chart');
            if (!ctx) return;

            // Get top 36 WRs by avg points
            const wrs = Object.values(aggregatedWRs)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 50);

            const data = wrs.map(player => ({
                x: player.totalTargets,
                y: player.rzOpportunities,
                label: player.name,
                player: player
            }));

            // Calculate linear regression for diagonal trendline
            const regression = calculateLinearRegression(data);
            const minX = Math.min(...data.map(d => d.x));
            const maxX = Math.max(...data.map(d => d.x));
            const trendlineData = [
                { x: minX, y: regression.slope * minX + regression.intercept },
                { x: maxX, y: regression.slope * maxX + regression.intercept }
            ];

            if (wrScatterChart) {
                wrScatterChart.destroy();
            }

            wrScatterChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Wide Receivers',
                            data: data,
                            backgroundColor: data.map(d => {
                                const color = teamColors[d.player.team] || '#666';
                                // Convert hex to rgba with 0.3 opacity
                                const r = parseInt(color.slice(1, 3), 16);
                                const g = parseInt(color.slice(3, 5), 16);
                                const b = parseInt(color.slice(5, 7), 16);
                                return `rgba(${r}, ${g}, ${b}, 0.6)`;
                            }),
                            borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                            borderWidth: 2,
                            pointRadius: 8,
                            pointHoverRadius: 10
                        },
                        {
                            label: 'Trendline',
                            type: 'line',
                            data: trendlineData,
                            borderColor: '#FFD60A',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0 && elements[0].datasetIndex === 0) {
                            const index = elements[0].index;
                            const player = data[index].player;
                            openPlayerModal(player.id);
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.datasetIndex === 1) return 'Trendline';
                                    const player = context.raw.player;
                                    return [
                                        player.name,
                                        `Targets: ${player.totalTargets}`,
                                        `RZ Targets: ${player.rzOpportunities}`,
                                        `AVG: ${player.avgPoints.toFixed(1)}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Total Season Targets',
                                color: '#8e8e93'
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Red Zone Targets',
                                color: '#8e8e93'
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });

            // Add labels for top 8 players
            const chartArea = wrScatterChart.chartArea;
            const ctx2d = wrScatterChart.ctx;

            wrs.slice(0, 8).forEach((player, idx) => {
                const meta = wrScatterChart.getDatasetMeta(0);
                const point = meta.data[idx];
                if (point && chartArea) {
                    ctx2d.save();
                    ctx2d.fillStyle = '#fff';
                    ctx2d.font = '11px -apple-system, sans-serif';
                    ctx2d.textAlign = 'center';
                    ctx2d.fillText(player.name.split(' ').pop(), point.x, point.y - 12);
                    ctx2d.restore();
                }
            });
        }

        function renderRBScatter() {
            const ctx = document.getElementById('rb-scatter-chart');
            if (!ctx) return;

            // Get top 36 RBs by avg points
            const rbs = Object.values(aggregatedRBs)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 50);

            const data = rbs.map(player => ({
                x: player.totalOpportunities,
                y: player.rzOpportunities,
                label: player.name,
                player: player
            }));

            // Calculate linear regression for diagonal trendline
            const regression = calculateLinearRegression(data);
            const minX = Math.min(...data.map(d => d.x));
            const maxX = Math.max(...data.map(d => d.x));
            const trendlineData = [
                { x: minX, y: regression.slope * minX + regression.intercept },
                { x: maxX, y: regression.slope * maxX + regression.intercept }
            ];

            if (rbScatterChart) {
                rbScatterChart.destroy();
            }

            rbScatterChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Running Backs',
                            data: data,
                            backgroundColor: data.map(d => {
                                const color = teamColors[d.player.team] || '#666';
                                // Convert hex to rgba with 0.3 opacity
                                const r = parseInt(color.slice(1, 3), 16);
                                const g = parseInt(color.slice(3, 5), 16);
                                const b = parseInt(color.slice(5, 7), 16);
                                return `rgba(${r}, ${g}, ${b}, 0.6)`;
                            }),
                            borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                            borderWidth: 2,
                            pointRadius: 8,
                            pointHoverRadius: 10
                        },
                        {
                            label: 'Trendline',
                            type: 'line',
                            data: trendlineData,
                            borderColor: '#FFD60A',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0 && elements[0].datasetIndex === 0) {
                            const index = elements[0].index;
                            const player = data[index].player;
                            openPlayerModal(player.id);
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.datasetIndex === 1) return 'Trendline';
                                    const player = context.raw.player;
                                    return [
                                        player.name,
                                        `Opportunities: ${player.totalOpportunities}`,
                                        `RZ Opportunities: ${player.rzOpportunities}`,
                                        `AVG: ${player.avgPoints.toFixed(1)}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Total Season Opportunities',
                                color: '#8e8e93'
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Red Zone Opportunities',
                                color: '#8e8e93'
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });

            // Add labels for top 8 players
            const chartArea = rbScatterChart.chartArea;
            const ctx2d = rbScatterChart.ctx;

            rbs.slice(0, 8).forEach((player, idx) => {
                const meta = rbScatterChart.getDatasetMeta(0);
                const point = meta.data[idx];
                if (point && chartArea) {
                    ctx2d.save();
                    ctx2d.fillStyle = '#fff';
                    ctx2d.font = '11px -apple-system, sans-serif';
                    ctx2d.textAlign = 'center';
                    ctx2d.fillText(player.name.split(' ').pop(), point.x, point.y - 12);
                    ctx2d.restore();
                }
            });
        }

        function renderTeamBalanceScatter(highlightTeam = null) {
            const ctx = document.getElementById('team-balance-scatter');
            if (!ctx) {                return;
            }
            if (!wrData || !rbData) {                return;
            }

            // Destroy existing chart if it exists
            const existingChart = Chart.getChart(ctx);
            if (existingChart) {
                existingChart.destroy();
            }

            // Aggregate team data (all weeks combined for season totals)
            const teamData = {};

            // Calculate total targets and points per team from WR data (exclude FA)
            wrData.forEach(row => {
                const team = row.Team;
                if (team === 'FA' || !team) return;
                if (!teamData[team]) {
                    teamData[team] = { team: team, targets: 0, rushOpps: 0, totalPoints: 0 };
                }
                teamData[team].targets += parseFloat(row.TGT) || 0;
                teamData[team].totalPoints += parseFloat(row.FPTS || row.Fpts) || 0; // Handle both cases
            });

            // Calculate total rush opportunities and points per team from RB data (exclude FA)
            rbData.forEach(row => {
                const team = row.Team;
                if (team === 'FA' || !team) return;
                if (!teamData[team]) {
                    teamData[team] = { team: team, targets: 0, rushOpps: 0, totalPoints: 0 };
                }
                teamData[team].rushOpps += parseFloat(row['RB Opp']) || 0;
                teamData[team].totalPoints += parseFloat(row.FPTS || row.Fpts) || 0; // Handle both cases
            });

            // Calculate total targets and points per team from TE data (exclude FA)
            if (teData) {
                teData.forEach(row => {
                    const team = row.Team;
                    if (team === 'FA' || !team) return;
                    if (!teamData[team]) {
                        teamData[team] = { team: team, targets: 0, rushOpps: 0, totalPoints: 0 };
                    }
                    teamData[team].targets += parseFloat(row.TGT) || 0;
                    teamData[team].totalPoints += parseFloat(row.FPTS || row.Fpts) || 0; // Handle both cases
                });
            }

            const teams = Object.values(teamData);
            // Find min and max points for scaling
            const allPoints = teams.map(t => t.totalPoints);
            const minPoints = Math.min(...allPoints);
            const maxPoints = Math.max(...allPoints);
            // Create scatter data with point-based radius
            const scatterData = teams.map(team => {
                // Scale radius from 8 to 20 based on total points
                const normalizedPoints = (team.totalPoints - minPoints) / (maxPoints - minPoints);
                const radius = 8 + (normalizedPoints * 12); // Range: 8-20

                return {
                    x: team.targets,
                    y: team.rushOpps,
                    r: radius, // For bubble chart
                    team: team.team,
                    totalPoints: team.totalPoints
                };
            });
            // Calculate medians
            const sortedTargets = teams.map(t => t.targets).sort((a, b) => a - b);
            const sortedOpps = teams.map(t => t.rushOpps).sort((a, b) => a - b);
            const medianTargets = sortedTargets[Math.floor(sortedTargets.length / 2)];
            const medianOpps = sortedOpps[Math.floor(sortedOpps.length / 2)];

            // Separate highlighted team from regular teams
            let datasets = [];

            if (highlightTeam) {
                // Regular teams (non-highlighted)
                const regularData = scatterData.filter(d => d.team !== highlightTeam);
                const highlightedData = scatterData.filter(d => d.team === highlightTeam);

                // Regular teams dataset
                datasets.push({
                    data: regularData,
                    backgroundColor: regularData.map(d => {
                        const color = teamColors[d.team] || '#0a84ff';
                        return color + '66'; // 40% opacity for non-highlighted
                    }),
                    borderColor: regularData.map(d => {
                        const color = teamColors[d.team] || '#0a84ff';
                        return color + '99'; // 60% opacity for border
                    }),
                    borderWidth: 2
                });

                // Highlighted team dataset (if found)
                if (highlightedData.length > 0) {
                    const highlightColor = teamColors[highlightTeam] || '#0a84ff';
                    datasets.push({
                        data: highlightedData,
                        backgroundColor: highlightColor,
                        borderColor: '#ffffff',
                        borderWidth: 4,
                        pointRadius: highlightedData.map(d => d.r * 1.3), // 30% larger
                        pointHoverRadius: highlightedData.map(d => d.r * 1.5)
                    });
                }
            } else {
                // No highlight - all teams same style
                datasets.push({
                    data: scatterData,
                    backgroundColor: scatterData.map(d => {
                        const color = teamColors[d.team] || '#0a84ff';
                        return color + '99'; // 60% opacity
                    }),
                    borderColor: scatterData.map(d => teamColors[d.team] || '#0a84ff'),
                    borderWidth: 2
                });
            }

            new Chart(ctx, {
                type: 'bubble',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                layout: {
                    padding: window.innerWidth <= 768
                        ? { left: 20, right: 20, top: 30, bottom: 30 }
                        : { left: 50, right: 50, top: 50, bottom: 50 }
                },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const data = context.raw;
                                    return [
                                        data.team,
                                        `Targets: ${data.x.toFixed(0)}`,
                                        `Rush Opps: ${data.y.toFixed(0)}`,
                                        `Total Points: ${data.totalPoints.toFixed(1)}`
                                    ];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                vLine: {
                                    type: 'line',
                                    xMin: medianTargets,
                                    xMax: medianTargets,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                hLine: {
                                    type: 'line',
                                    yMin: medianOpps,
                                    yMax: medianOpps,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Total Pass Targets',
                                color: '#8e8e93',
                                font: {
                                    size: window.innerWidth <= 768 ? 10 : 12,
                                    weight: 'bold'
                                }
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: {
                                color: '#8e8e93',
                                font: { size: window.innerWidth <= 768 ? 9 : 11 }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Total Rush Opportunities',
                                color: '#8e8e93',
                                font: {
                                    size: window.innerWidth <= 768 ? 10 : 12,
                                    weight: 'bold'
                                }
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: {
                                color: '#8e8e93',
                                font: { size: window.innerWidth <= 768 ? 9 : 11 }
                            }
                        }
                    },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const dataIndex = elements[0].index;
                            const teamCode = scatterData[dataIndex].team;
                            openTeamModal(teamCode);
                        }
                    }
                }
            });
        }

        // TEAM ANALYSIS FUNCTIONS

        // Helper function to generate color variations from team palette
        function generateTeamColorVariations(team, count) {
            const primaryColor = teamColors[team];

            if (!primaryColor) {
                // Fallback for unknown teams - use gray shades
                return Array.from({length: count}, (_, i) => {
                    const lightness = 40 + (i * (70 / count));
                    return `hsl(0, 0%, ${lightness}%)`;
                });
            }

            // Special case: single player uses team primary color
            if (count === 1) {
                return [primaryColor];
            }

            // Convert hex to HSL
            const hexToHSL = (hex) => {
                hex = hex.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16) / 255;
                const g = parseInt(hex.substr(2, 2), 16) / 255;
                const b = parseInt(hex.substr(4, 2), 16) / 255;

                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

                    switch (max) {
                        case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                        case g: h = ((b - r) / d + 2) / 6; break;
                        case b: h = ((r - g) / d + 4) / 6; break;
                    }
                }

                return [h * 360, s * 100, l * 100];
            };

            const [baseHue, baseSat, baseLightness] = hexToHSL(primaryColor);

            // Generate count colors from primary to off-white
            // Start with primary color, progressively lighten and desaturate
            const colors = [];

            for (let i = 0; i < count; i++) {
                const progress = i / (count - 1); // 0 to 1

                // Keep hue constant
                const h = baseHue;

                // Gradually decrease saturation from base to ~20% (near gray)
                const s = baseSat * (1 - progress * 0.7); // Keep some saturation

                // Gradually increase lightness from base to ~85% (off-white)
                const targetLightness = 85;
                const l = baseLightness + (targetLightness - baseLightness) * progress;

                colors.push(`hsl(${h}, ${s}%, ${l}%)`);
            }

            return colors;
        }

        // Initialize Team Analysis
        function initializeTeamAnalysis() {
            if (!wrData || !rbData) return;

            // Populate team selector with placeholder
            const teams = [...new Set([...wrData, ...rbData].map(row => row.Team).filter(t => t && t !== 'FA'))].sort();
            const teamSelect = document.getElementById('team-select');
            teamSelect.innerHTML = '';

            // Add placeholder option
            const placeholderOption = document.createElement('option');
            placeholderOption.value = '';
            placeholderOption.textContent = 'Select a Team';
            placeholderOption.disabled = true;
            placeholderOption.selected = true;
            teamSelect.appendChild(placeholderOption);

            // Add team options
            teams.forEach(team => {
                const option = document.createElement('option');
                option.value = team;
                option.textContent = team;
                teamSelect.appendChild(option);
            });

            // Don't set a default team - user must select
            currentTeamAnalysisTeam = null;

            // Populate week selector
            const weeks = [...new Set([...wrData, ...rbData].map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);
            const weekSelect = document.getElementById('week-select');
            weekSelect.innerHTML = '';
            weeks.forEach(week => {
                const option = document.createElement('option');
                option.value = week;
                option.textContent = `Week ${week}`;
                weekSelect.appendChild(option);
            });

            // Set most recent week as default
            if (weeks.length > 0) {
                weekSelect.value = weeks[weeks.length - 1];
            }

            // Don't render charts initially - show placeholder until user selects a team
        }

        // Toggle League Comparison
        function toggleLeagueComparison() {
            leagueComparisonEnabled = !leagueComparisonEnabled;

            const toggleBtn = document.getElementById('league-comparison-toggle');
            const icon = document.getElementById('league-comparison-icon');

            if (leagueComparisonEnabled) {
                toggleBtn.style.background = 'var(--positive)';
                toggleBtn.style.borderColor = 'var(--positive)';
                toggleBtn.style.color = 'white';
                icon.textContent = '●';
            } else {
                toggleBtn.style.background = 'var(--bg-tertiary)';
                toggleBtn.style.borderColor = 'var(--border-color)';
                toggleBtn.style.color = 'var(--text-secondary)';
                icon.textContent = '○';
            }

            updateTeamAnalysis();
        }

        // Update Team Analysis based on selections
        function updateTeamAnalysis() {
            const team = document.getElementById('team-select').value;
            const position = document.getElementById('position-group-select').value;
            const timeFrame = document.getElementById('time-frame-select').value;
            const week = parseInt(document.getElementById('week-select').value);

            // Get placeholder and chart elements
            const placeholder = document.getElementById('team-chart-placeholder');
            const pieChartWrapper = document.querySelector('#team-charts-container .chart-wrapper:nth-child(2)');
            const secondaryChartWrapper = document.getElementById('team-secondary-chart-wrapper');

            // If no team selected, show placeholder and hide charts
            if (!team || team === '') {
                placeholder.style.display = 'flex';
                pieChartWrapper.style.display = 'none';
                secondaryChartWrapper.style.display = 'none';
                return;
            }

            // Team selected - hide placeholder and show charts
            placeholder.style.display = 'none';
            pieChartWrapper.style.display = 'block';
            secondaryChartWrapper.style.display = 'block';

            currentTeamAnalysisTeam = team;

            // Show/hide week selector based on time frame
            const weekContainer = document.getElementById('week-select-container');
            weekContainer.style.display = timeFrame === 'single' ? 'block' : 'none';

            // Disable/enable league comparison toggle for season long
            const leagueToggleBtn = document.getElementById('league-comparison-toggle');
            if (timeFrame === 'season') {
                leagueToggleBtn.disabled = true;
                leagueToggleBtn.style.opacity = '0.4';
                leagueToggleBtn.style.cursor = 'not-allowed';
            } else {
                leagueToggleBtn.disabled = false;
                leagueToggleBtn.style.opacity = '1';
                leagueToggleBtn.style.cursor = 'pointer';
            }

            // Update title
            const titleEl = document.getElementById('team-chart-title');
            const descEl = document.getElementById('team-chart-description');

            const positionLabel = (position === 'WR' || position === 'TE') ? 'Target' : 'Opportunity';
            let timeLabel = '';

            if (timeFrame === 'single') {
                timeLabel = `Week ${week}`;
            } else if (timeFrame === 'last3') {
                timeLabel = 'Last 3 Weeks';
            } else if (timeFrame === 'last5') {
                timeLabel = 'Last 5 Weeks';
            } else {
                timeLabel = 'Season Long';
            }

            titleEl.textContent = `${team} ${position} ${positionLabel} Distribution - ${timeLabel}`;

            // Add description based on position
            if (position === 'WR' || position === 'TE') {
                descEl.textContent = `Showing top 4 pass catchers (WR/RB/TE) by target share - all positions compete for targets`;
            } else {
                descEl.textContent = `Showing RB opportunity distribution (rush attempts + targets)`;
            }

            // Render appropriate charts with animation
            // Use setTimeout to ensure canvas elements are fully rendered and sized
            setTimeout(() => {
                if (timeFrame === 'season') {
                    renderSeasonLongChart(team, position);
                } else {
                    renderPieAndBarCharts(team, position, timeFrame, week);
                }
            }, 50);

            // Highlight the selected team on the scatter plot
            renderTeamBalanceScatter(team);
        }

        // Render Pie and Bar Charts (for single week, last3, last5)
        function renderPieAndBarCharts(team, position, timeFrame, week) {
            // Reset grid layout to 50/50 for dual charts
            const container = document.getElementById('team-charts-container');
            container.style.gridTemplateColumns = '1fr 1fr';
            document.getElementById('team-secondary-chart-wrapper').style.display = 'block';

            // For WR and TE charts, include ALL pass catchers (WR/RB/TE) for accurate target share
            // For RB charts, use only RB data for opportunities
            let combinedData;
            if (position === 'WR' || position === 'TE') {
                // Include all positions that receive targets
                combinedData = [...wrData, ...rbData];
                if (teData) {
                    combinedData = [...combinedData, ...teData];
                }
            } else {
                combinedData = rbData;
            }

            // Filter data based on time frame
            let filteredData;
            if (timeFrame === 'single') {
                filteredData = combinedData.filter(row => row.Team === team && parseInt(row.Week) === week);
            } else {
                const weeks = [...new Set(combinedData.map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);
                const latestWeek = Math.max(...weeks);
                const weeksToInclude = timeFrame === 'last3' ? 3 : 5;
                const startWeek = latestWeek - weeksToInclude + 1;
                filteredData = combinedData.filter(row => row.Team === team && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek);
            }

            // Calculate player shares
            const playerStats = {};
            filteredData.forEach(row => {
                const player = row.Player;
                if (!playerStats[player]) {
                    playerStats[player] = { targets: 0, opportunities: 0, position: row.Pos };
                }

                if (position === 'WR' || position === 'TE') {
                    // For WR/TE view, count targets for all pass catchers
                    playerStats[player].targets += parseFloat(row.TGT) || 0;
                } else {
                    playerStats[player].opportunities += parseFloat(row['RB Opp']) || 0;
                }
            });

            // Convert to array and sort
            const playerArray = Object.entries(playerStats).map(([name, stats]) => ({
                name,
                value: (position === 'WR' || position === 'TE') ? stats.targets : stats.opportunities,
                position: stats.position
            })).sort((a, b) => b.value - a.value);

            const totalValue = playerArray.reduce((sum, p) => sum + p.value, 0);

            // For WR/TE views (showing all pass catchers), take top 4 players
            // For RB views, take top 5 players
            const topCount = (position === 'WR' || position === 'TE') ? 4 : 5;
            const topPlayers = playerArray.slice(0, topCount);
            const otherValue = playerArray.slice(topCount).reduce((sum, p) => sum + p.value, 0);

            // Build chart data
            let chartData = [...topPlayers];
            if (otherValue > 0) {
                chartData.push({ name: 'Other', value: otherValue, position: 'Other' });
            }

            // Render pie chart
            renderTeamPieChart(chartData, totalValue, position);

            // Render bar chart or league comparison
            if (leagueComparisonEnabled) {
                renderLeagueComparison(team, position, timeFrame, week, totalValue);
            } else {
                renderTeamBarChart(chartData, position);
            }
        }

        // Render Pie Chart
        function renderTeamPieChart(chartData, totalValue, position) {
            const canvas = document.getElementById('team-pie-chart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Destroy existing chart
            if (teamAnalysisCharts.pie) {
                teamAnalysisCharts.pie.destroy();
            }

            const labels = chartData.map(d => d.name);
            const values = chartData.map(d => d.value);
            const percentages = chartData.map(d => ((d.value / totalValue) * 100).toFixed(1));

            // Generate color variations based on team color palette
            const playerCount = chartData.filter(d => d.name !== 'Other').length;
            const teamColorVariations = generateTeamColorVariations(currentTeamAnalysisTeam, playerCount);

            // Create colors with opacity for fills
            // Use higher opacity (85%) for single player so team color is clearly visible
            const opacity = playerCount === 1 ? 0.85 : 0.45;

            const fillColors = chartData.map((d, i) => {
                if (d.name === 'Other') return 'rgba(99, 99, 102, 0.45)';
                const baseColor = teamColorVariations[i];
                // Convert to rgba with appropriate opacity
                if (baseColor.startsWith('#')) {
                    const r = parseInt(baseColor.slice(1, 3), 16);
                    const g = parseInt(baseColor.slice(3, 5), 16);
                    const b = parseInt(baseColor.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                } else if (baseColor.startsWith('hsl')) {
                    return baseColor.replace('hsl', 'hsla').replace(')', `, ${opacity})`);
                }
                return baseColor;
            });

            // Solid colors for borders (same color, 100% opacity)
            const borderColors = chartData.map((d, i) => {
                if (d.name === 'Other') return '#636366';
                return teamColorVariations[i];
            });

            const metric = position === 'WR' ? 'Targets' : 'Opportunities';

            teamAnalysisCharts.pie = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: values,
                        backgroundColor: fillColors,
                        borderColor: borderColors,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        animateRotate: true,
                        animateScale: true,
                        duration: 1400,
                        easing: 'easeInOutQuart'
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: `Total ${metric}: ${totalValue.toFixed(0)}`,
                            color: '#8e8e93',
                            font: { size: 13, weight: '600' },
                            padding: { top: 0, bottom: 10 }
                        },
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: '#ffffff',
                                padding: 15,
                                font: { size: 12, weight: 'bold' },
                                generateLabels: (chart) => {
                                    const data = chart.data;
                                    return data.labels.map((label, i) => ({
                                        text: `${label} (${percentages[i]}%)`,
                                        fillStyle: data.datasets[0].backgroundColor[i],
                                        fontColor: '#ffffff',
                                        hidden: false,
                                        index: i
                                    }));
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const label = context.label || '';
                                    const value = context.parsed;
                                    const percentage = ((value / totalValue) * 100).toFixed(1);
                                    return `${label}: ${value.toFixed(1)} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Render Bar Chart (when league comparison is off)
        function renderTeamBarChart(chartData, position) {
            const canvas = document.getElementById('team-secondary-chart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Destroy existing chart
            if (teamAnalysisCharts.secondary) {
                teamAnalysisCharts.secondary.destroy();
            }

            const labels = chartData.map(d => d.name);
            const values = chartData.map(d => d.value);

            // Generate color variations based on team color palette
            const playerCount = chartData.filter(d => d.name !== 'Other').length;
            const teamColorVariations = generateTeamColorVariations(currentTeamAnalysisTeam, playerCount);

            // Create colors with medium opacity for fills
            const fillColors = chartData.map((d, i) => {
                if (d.name === 'Other') return 'rgba(99, 99, 102, 0.45)';
                const baseColor = teamColorVariations[i];
                // Convert to rgba with 45% opacity
                if (baseColor.startsWith('#')) {
                    const r = parseInt(baseColor.slice(1, 3), 16);
                    const g = parseInt(baseColor.slice(3, 5), 16);
                    const b = parseInt(baseColor.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, 0.45)`;
                } else if (baseColor.startsWith('hsl')) {
                    return baseColor.replace('hsl', 'hsla').replace(')', ', 0.45)');
                }
                return baseColor;
            });

            // Solid colors for borders (same color, 100% opacity)
            const borderColors = chartData.map((d, i) => {
                if (d.name === 'Other') return '#636366';
                return teamColorVariations[i];
            });

            const totalValue = chartData.reduce((sum, d) => sum + d.value, 0);
            const metric = position === 'WR' ? 'Targets' : 'Opportunities';

            teamAnalysisCharts.secondary = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: metric,
                        data: values,
                        backgroundColor: fillColors,
                        borderColor: borderColors,
                        borderWidth: 2
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Total ${metric}: ${totalValue.toFixed(0)}`,
                            color: '#8e8e93',
                            font: { size: 13, weight: '600' },
                            padding: { top: 0, bottom: 10 }
                        },
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    return `${context.parsed.x.toFixed(1)} ${position === 'WR' ? 'targets' : 'opportunities'}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            grid: { display: false },
                            ticks: { color: '#fff' }
                        }
                    }
                }
            });
        }

        // Render League Comparison
        function renderLeagueComparison(team, position, timeFrame, week, teamTotal) {
            // For WR view, include RBs who receive targets; for RB view, use only RB data
            let data;
            if (position === 'WR') {
                data = [...wrData, ...rbData]; // Include RBs in WR league comparison
            } else {
                data = rbData;
            }

            // Calculate totals for all teams
            const teamTotals = {};

            if (timeFrame === 'single') {
                data.filter(row => parseInt(row.Week) === week).forEach(row => {
                    const t = row.Team;
                    if (t && t !== 'FA') {
                        if (!teamTotals[t]) teamTotals[t] = 0;
                        // For WR view, count targets for all positions
                        teamTotals[t] += position === 'WR' ? (parseFloat(row.TGT) || 0) : (parseFloat(row['RB Opp']) || 0);
                    }
                });
            } else {
                const weeks = [...new Set(data.map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);
                const latestWeek = Math.max(...weeks);
                const weeksToInclude = timeFrame === 'last3' ? 3 : 5;
                const startWeek = latestWeek - weeksToInclude + 1;

                data.filter(row => parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek).forEach(row => {
                    const t = row.Team;
                    if (t && t !== 'FA') {
                        if (!teamTotals[t]) teamTotals[t] = 0;
                        // For WR view, count targets for all positions
                        teamTotals[t] += position === 'WR' ? (parseFloat(row.TGT) || 0) : (parseFloat(row['RB Opp']) || 0);
                    }
                });
            }

            // Convert to array and sort
            const leagueData = Object.entries(teamTotals)
                .map(([t, total]) => ({ team: t, total }))
                .sort((a, b) => b.total - a.total);

            const canvas = document.getElementById('team-secondary-chart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Destroy existing chart
            if (teamAnalysisCharts.secondary) {
                teamAnalysisCharts.secondary.destroy();
            }

            const labels = leagueData.map(d => d.team);
            const values = leagueData.map(d => d.total);

            // Get selected team color
            const selectedTeamColor = teamColors[team] || '#666';
            let selectedBgColor, selectedBorderColor;
            if (selectedTeamColor.startsWith('#')) {
                const r = parseInt(selectedTeamColor.slice(1, 3), 16);
                const g = parseInt(selectedTeamColor.slice(3, 5), 16);
                const b = parseInt(selectedTeamColor.slice(5, 7), 16);
                selectedBgColor = `rgba(${r}, ${g}, ${b}, 0.6)`;
                selectedBorderColor = selectedTeamColor;
            }

            // Create colors arrays - different color for selected vs others
            const backgroundColors = leagueData.map(d => {
                if (d.team === team) {
                    return selectedBgColor;
                }
                const color = teamColors[d.team] || '#666';
                if (color.startsWith('#')) {
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, 0.45)`;
                }
                return color;
            });

            const borderColors = leagueData.map(d => {
                if (d.team === team) return selectedBorderColor;
                return teamColors[d.team] || '#666';
            });

            const borderWidths = leagueData.map(d => d.team === team ? 3 : 2);

            const metric = position === 'WR' ? 'Targets' : 'Opportunities';

            teamAnalysisCharts.secondary = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: `Total ${metric}`,
                            data: values,
                            backgroundColor: backgroundColors,
                            borderColor: borderColors,
                            borderWidth: borderWidths,
                            barThickness: 'flex',
                            maxBarThickness: 30
                        }
                    ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    aspectRatio: 0.8,
                    plugins: {
                        title: {
                            display: true,
                            text: `${team} Total ${metric}: ${teamTotal.toFixed(0)}`,
                            color: '#8e8e93',
                            font: { size: 13, weight: '600' },
                            padding: { top: 0, bottom: 10 }
                        },
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const value = context.parsed.x;
                                    if (value === null || value === 0) return null;
                                    return `${value.toFixed(1)} ${position === 'WR' ? 'targets' : 'opportunities'}`;
                                },
                                title: (context) => {
                                    return context[0].label;
                                }
                            },
                            filter: (tooltipItem) => {
                                return tooltipItem.parsed.x !== null && tooltipItem.parsed.x !== 0;
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            grid: { display: false },
                            ticks: {
                                autoSkip: false, // Show all team labels
                                maxRotation: 0,
                                minRotation: 0,
                                color: (context) => {
                                    // Much brighter white for selected team, dimmer for others
                                    return context.tick.label === team ? '#ffffff' : '#8e8e93';
                                },
                                font: (context) => {
                                    const isSelected = context.tick.label === team;

                                    if (isSelected) {
                                        // Selected team is bigger and bolder
                                        return { size: 13, weight: 'bold' };
                                    } else {
                                        // Normal size for others
                                        return { size: 10, weight: 'normal' };
                                    }
                                },
                                // Two-column staggered layout
                                align: (context) => {
                                    // Even indices right-aligned, odd indices left-aligned
                                    return context.index % 2 === 0 ? 'end' : 'start';
                                },
                                crossAlign: 'near',
                                padding: (context) => {
                                    // Add extra padding for odd indices to create column effect
                                    return context.index % 2 === 0 ? 4 : 12;
                                }
                            }
                        }
                    },
                    onClick: (event, elements) => {
                        // If clicked on a bar, open that team's modal
                        if (elements.length > 0) {
                            const index = elements[0].index;
                            const clickedTeam = labels[index];
                            openTeamModal(clickedTeam);
                        } else {
                            // If clicked elsewhere on chart, open current team's modal
                            openTeamModal(team);
                        }
                    }
                }
            });
        }

        // Render Season Long Chart
        function renderSeasonLongChart(team, position) {
            // For WR and TE charts, include ALL pass catchers (WR/RB/TE) for accurate target share
            // For RB charts, use only RB data for opportunities
            let data;
            if (position === 'WR' || position === 'TE') {
                data = [...wrData, ...rbData];
                if (teData) {
                    data = [...data, ...teData];
                }
            } else {
                data = rbData;
            }

            const filteredData = data.filter(row => row.Team === team);

            // Get all weeks
            const weeks = [...new Set(filteredData.map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);

            // Calculate total for the time period
            let seasonTotal = 0;

            // Calculate weekly totals for labels
            const weeklyTotals = {};

            // Calculate weekly shares
            const weeklyShares = {};
            weeks.forEach(week => {
                const weekData = filteredData.filter(row => parseInt(row.Week) === week);
                const totalValue = weekData.reduce((sum, row) => {
                    const val = (position === 'WR' || position === 'TE') ? (parseFloat(row.TGT) || 0) : (parseFloat(row['RB Opp']) || 0);
                    return sum + val;
                }, 0);

                weeklyTotals[week] = totalValue;
                seasonTotal += totalValue;

                weekData.forEach(row => {
                    const player = row.Player;
                    const value = (position === 'WR' || position === 'TE') ? (parseFloat(row.TGT) || 0) : (parseFloat(row['RB Opp']) || 0);
                    const share = totalValue > 0 ? (value / totalValue) * 100 : 0;

                    if (!weeklyShares[player]) {
                        weeklyShares[player] = [];
                    }
                    weeklyShares[player].push({ week, share, value });
                });
            });

            // Get top players by average share
            const playerAverages = Object.entries(weeklyShares).map(([player, shares]) => {
                const avgShare = shares.reduce((sum, s) => sum + s.share, 0) / shares.length;
                return { player, avgShare, shares };
            }).sort((a, b) => b.avgShare - a.avgShare);

            // Take top 4 players (regardless of position for WR/TE views)
            const topPlayers = playerAverages.slice(0, 4);

            // Hide secondary chart wrapper, show full width for season long
            const container = document.getElementById('team-charts-container');
            container.style.gridTemplateColumns = '1fr';
            document.getElementById('team-secondary-chart-wrapper').style.display = 'none';

            const canvas = document.getElementById('team-pie-chart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Destroy existing chart
            if (teamAnalysisCharts.pie) {
                teamAnalysisCharts.pie.destroy();
            }

            const metric = (position === 'WR' || position === 'TE') ? 'Targets' : 'Opportunities';

            if (position === 'WR' || position === 'TE') {
                // Stacked bar chart for WR/TE (showing top 4 pass catchers)
                const teamPalette = teamColorPalettes[team] || ['#666', '#888', '#aaa', '#ccc'];
                const teamColorVariations = generateTeamColorVariations(team, topPlayers.length);

                const datasets = topPlayers.map((p, i) => {
                    const baseColor = teamColorVariations[i];
                    // Convert to rgba with 45% opacity for fills
                    let fillColor = baseColor;
                    if (baseColor.startsWith('#')) {
                        const r = parseInt(baseColor.slice(1, 3), 16);
                        const g = parseInt(baseColor.slice(3, 5), 16);
                        const b = parseInt(baseColor.slice(5, 7), 16);
                        fillColor = `rgba(${r}, ${g}, ${b}, 0.45)`;
                    } else if (baseColor.startsWith('hsl')) {
                        fillColor = baseColor.replace('hsl', 'hsla').replace(')', ', 0.45)');
                    }

                    return {
                        label: p.player,
                        data: weeks.map(week => {
                            const weekShare = p.shares.find(s => s.week === week);
                            return weekShare ? weekShare.share : 0;
                        }),
                        backgroundColor: fillColor,
                        borderColor: baseColor,
                        borderWidth: 2
                    };
                });

                // Add "Other" category
                const otherData = weeks.map(week => {
                    const weekTotal = 100;
                    const topTotal = topPlayers.reduce((sum, p) => {
                        const weekShare = p.shares.find(s => s.week === week);
                        return sum + (weekShare ? weekShare.share : 0);
                    }, 0);
                    return Math.max(0, weekTotal - topTotal);
                });

                datasets.push({
                    label: 'Other',
                    data: otherData,
                    backgroundColor: 'rgba(99, 99, 102, 0.45)',
                    borderColor: '#636366',
                    borderWidth: 2
                });

                teamAnalysisCharts.pie = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: weeks.map(w => `Week ${w} (${Math.round(weeklyTotals[w])})`),
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        aspectRatio: 2.5,
                        animation: {
                            duration: 1400,
                            easing: 'easeInOutQuart'
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `Total ${metric} (Season): ${seasonTotal.toFixed(0)}`,
                                color: '#8e8e93',
                                font: { size: 13, weight: '600' },
                                padding: { top: 5, bottom: 15 }
                            },
                            legend: {
                                position: 'bottom',
                                labels: { color: '#fff', padding: 10, font: { size: 11 } }
                            },
                            tooltip: {
                                mode: 'point',
                                intersect: true,
                                callbacks: {
                                    label: (context) => {
                                        return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                stacked: true,
                                grid: { color: '#2c2c2e' },
                                ticks: { color: '#8e8e93', font: { size: 10 } }
                            },
                            y: {
                                stacked: true,
                                max: 100,
                                grid: { color: '#2c2c2e' },
                                ticks: { color: '#8e8e93' },
                                title: {
                                    display: true,
                                    text: 'Target Share %',
                                    color: '#8e8e93'
                                }
                            }
                        },
                        onClick: (event, elements) => {
                            // Open team modal when clicking anywhere on the chart
                            openTeamModal(team);
                        }
                    }
                });
            } else {
                // Line chart for RBs
                const teamColorVariations = generateTeamColorVariations(team, topPlayers.length);

                const datasets = topPlayers.map((p, i) => {
                    const baseColor = teamColorVariations[i];
                    // Convert to rgba with 45% opacity for fills
                    let fillColor = baseColor + '45';
                    if (baseColor.startsWith('#')) {
                        const r = parseInt(baseColor.slice(1, 3), 16);
                        const g = parseInt(baseColor.slice(3, 5), 16);
                        const b = parseInt(baseColor.slice(5, 7), 16);
                        fillColor = `rgba(${r}, ${g}, ${b}, 0.45)`;
                    } else if (baseColor.startsWith('hsl')) {
                        fillColor = baseColor.replace('hsl', 'hsla').replace(')', ', 0.45)');
                    }

                    return {
                        label: p.player,
                        data: weeks.map(week => {
                            const weekShare = p.shares.find(s => s.week === week);
                            return weekShare ? weekShare.share : null;
                        }),
                        borderColor: baseColor,
                        backgroundColor: fillColor,
                        borderWidth: 3,
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        pointBackgroundColor: fillColor,
                        pointBorderColor: baseColor,
                        pointBorderWidth: 2,
                        tension: 0.3
                    };
                });

                teamAnalysisCharts.pie = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: weeks.map(w => `Week ${w} (${Math.round(weeklyTotals[w])})`),
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        aspectRatio: 2.5,
                        animation: {
                            duration: 1400,
                            easing: 'easeInOutQuart'
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `Total ${metric} (Season): ${seasonTotal.toFixed(0)}`,
                                color: '#8e8e93',
                                font: { size: 13, weight: '600' },
                                padding: { top: 5, bottom: 15 }
                            },
                            legend: {
                                position: 'bottom',
                                labels: { color: '#fff', padding: 10, font: { size: 11 } }
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    label: (context) => {
                                        return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                grid: { color: '#2c2c2e' },
                                ticks: { color: '#8e8e93' }
                            },
                            y: {
                                grid: { color: '#2c2c2e' },
                                ticks: { color: '#8e8e93' },
                                title: {
                                    display: true,
                                    text: 'Opportunity Share %',
                                    color: '#8e8e93'
                                }
                            }
                        },
                        onClick: (event, elements) => {
                            // Open team modal when clicking anywhere on the chart
                            openTeamModal(team);
                        }
                    }
                });
            }
        }

        // Render Collapsible Divisions
        function renderCollapsibleDivisions() {
            if (!wrData || !rbData) return;

            const divisionsContainer = document.getElementById('divisions-grid');
            divisionsContainer.innerHTML = '';

            // Calculate team stats for display
            const teamStatsMap = {};
            const allData = [...wrData, ...rbData];
            allData.forEach(row => {
                const team = row.Team;
                if (team && team !== 'FA') {
                    if (!teamStatsMap[team]) {
                        teamStatsMap[team] = { totalPoints: 0, games: 0 };
                    }
                    teamStatsMap[team].totalPoints += parseFloat(row.FPTS || row.Fpts) || 0;
                }
            });

            // Count games per team
            const uniqueTeamWeeks = {};
            allData.forEach(row => {
                const team = row.Team;
                const week = row.Week;
                if (team && team !== 'FA' && week) {
                    const key = `${team}-${week}`;
                    uniqueTeamWeeks[key] = true;
                }
            });

            Object.keys(uniqueTeamWeeks).forEach(key => {
                const team = key.split('-')[0];
                if (teamStatsMap[team]) {
                    teamStatsMap[team].games++;
                }
            });

            // Render each division
            Object.entries(nflDivisions).forEach(([divisionName, teams]) => {
                const divSection = document.createElement('div');
                divSection.className = 'division-section';

                const header = document.createElement('div');
                header.className = 'division-header';
                header.onclick = () => toggleDivision(divisionName);

                const title = document.createElement('div');
                title.className = 'division-title';
                title.textContent = divisionName;

                const arrow = document.createElement('div');
                arrow.className = 'division-arrow';
                arrow.id = `arrow-${divisionName.replace(/\s+/g, '-')}`;
                arrow.textContent = '▼';

                header.appendChild(title);
                header.appendChild(arrow);

                const content = document.createElement('div');
                content.className = 'division-content';
                content.id = `content-${divisionName.replace(/\s+/g, '-')}`;

                const teamsGrid = document.createElement('div');
                teamsGrid.className = 'division-teams-grid';

                // Add team cards
                teams.forEach(team => {
                    const stats = teamStatsMap[team] || { totalPoints: 0, games: 1 };
                    const ppg = stats.games > 0 ? (stats.totalPoints / stats.games).toFixed(1) : '0.0';

                    const teamCard = document.createElement('div');
                    teamCard.className = 'division-team-card';
                    teamCard.onclick = () => selectTeamFromDivision(team);

                    const logo = document.createElement('div');
                    logo.className = 'division-team-logo';
                    logo.style.background = teamColors[team] || '#666';
                    logo.textContent = team;

                    const info = document.createElement('div');
                    info.className = 'division-team-info';

                    const name = document.createElement('div');
                    name.className = 'division-team-name';
                    name.textContent = team;

                    const statsDiv = document.createElement('div');
                    statsDiv.className = 'division-team-stats';
                    statsDiv.textContent = `${ppg} PPG · ${stats.games} games`;

                    info.appendChild(name);
                    info.appendChild(statsDiv);

                    teamCard.appendChild(logo);
                    teamCard.appendChild(info);

                    teamsGrid.appendChild(teamCard);
                });

                content.appendChild(teamsGrid);

                divSection.appendChild(header);
                divSection.appendChild(content);

                divisionsContainer.appendChild(divSection);
            });
        }

        // Toggle Division Collapse/Expand
        function toggleDivision(divisionName) {
            const contentId = `content-${divisionName.replace(/\s+/g, '-')}`;
            const arrowId = `arrow-${divisionName.replace(/\s+/g, '-')}`;

            const content = document.getElementById(contentId);
            const arrow = document.getElementById(arrowId);

            if (content && arrow) {
                content.classList.toggle('expanded');
                arrow.classList.toggle('expanded');
            }
        }

        // Select Team from Division
        function selectTeamFromDivision(team) {
            const teamSelect = document.getElementById('team-select');
            teamSelect.value = team;
            currentTeamAnalysisTeam = team;
            updateTeamAnalysis();

            // Scroll to Team Analysis section
            document.querySelector('.advanced-analytics-container').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        // 5. INTERACTIONS

        // Sub-Tab Navigation (Rankings vs Advanced Analytics)
        let wrAnalyticsRendered = false;
        let rbAnalyticsRendered = false;

        function switchWRSubTab(tab) {
            // Update button styles
            const tabs = document.querySelectorAll('#wide-receivers .sub-nav-tab');
            tabs.forEach(t => {
                t.style.color = 'var(--text-secondary)';
                t.style.borderBottomColor = 'transparent';
                t.classList.remove('active');
            });

            event.target.classList.add('active');
            event.target.style.color = 'var(--text-primary)';
            event.target.style.borderBottomColor = 'var(--positive)';

            // Show/hide content
            if (tab === 'rankings') {
                document.getElementById('wr-rankings-content').style.display = 'block';
                document.getElementById('wr-analytics-content').style.display = 'none';
            } else if (tab === 'analytics') {
                document.getElementById('wr-rankings-content').style.display = 'none';
                document.getElementById('wr-analytics-content').style.display = 'block';

                // Lazy load charts on first view
                if (!wrAnalyticsRendered) {
                    renderWRScatter();
                    renderMatrices(); // This will render WR matrices

                    // Initialize trend animations for WR eval charts
                    if (Object.keys(evaluationDataWR).length > 0) {
                        initSmoothTrendAnimation('wr-eval-volume-efficiency');
                        initSmoothTrendAnimation('wr-eval-share-rz');
                        initSmoothTrendAnimation('wr-eval-production-volume');
                    }

                    wrAnalyticsRendered = true;
                }
            }
        }

        function switchRBSubTab(tab) {
            // Update button styles
            const tabs = document.querySelectorAll('#running-backs .sub-nav-tab');
            tabs.forEach(t => {
                t.style.color = 'var(--text-secondary)';
                t.style.borderBottomColor = 'transparent';
                t.classList.remove('active');
            });

            event.target.classList.add('active');
            event.target.style.color = 'var(--text-primary)';
            event.target.style.borderBottomColor = 'var(--positive)';

            // Show/hide content
            if (tab === 'rankings') {
                document.getElementById('rb-rankings-content').style.display = 'block';
                document.getElementById('rb-analytics-content').style.display = 'none';
            } else if (tab === 'analytics') {
                document.getElementById('rb-rankings-content').style.display = 'none';
                document.getElementById('rb-analytics-content').style.display = 'block';

                // Lazy load charts on first view
                if (!rbAnalyticsRendered) {
                    renderRBScatter();
                    renderMatrices(); // This will render RB matrices

                    // Initialize trend animations for RB eval charts
                    if (Object.keys(evaluationDataRB).length > 0) {
                        initSmoothTrendAnimation('rb-eval-total-rz');
                        initSmoothTrendAnimation('rb-eval-volume-efficiency');
                        initSmoothTrendAnimation('rb-eval-production-volume');
                    }

                    rbAnalyticsRendered = true;
                }
            }
        }

        // Navigation
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const pageName = this.getAttribute('data-page');

                // Update active tab
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');

                // Show page
                document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
                document.getElementById(pageName).classList.add('active');

                // Render dashboard categories if on dashboard page
                if (pageName === 'top-movers') {
                    setTimeout(() => {
                        renderDashboardCategories();
                        setTimeout(renderMiniScatterPlots, 100);
                    }, 100);
                }

                // Scroll to top of page
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        });

        // Modal Functions
        let currentModalPlayer = null;

        // Open modal with category context
        function openPlayerModalWithCategory(playerId, categoryTitle, explanation, rank, metricLabel, metricValue) {
            // First open the modal normally
            openPlayerModal(playerId);

            // Then add category context
            const contextDiv = document.getElementById('modal-category-context');
            if (contextDiv && categoryTitle) {
                contextDiv.style.display = 'block';
                document.getElementById('modal-category-title').textContent = categoryTitle;
                document.getElementById('modal-category-rank').textContent = `#${rank}`;
                document.getElementById('modal-category-explanation').textContent = explanation;
                document.getElementById('modal-category-metric-label').textContent = metricLabel;
                document.getElementById('modal-category-metric-value').textContent = metricValue;
            }
        }

        function openPlayerModal(playerId) {
            const player = allPlayers[playerId];
            if (!player) return;

            // Hide category context by default
            const contextDiv = document.getElementById('modal-category-context');
            if (contextDiv) {
                contextDiv.style.display = 'none';
            }

            currentModalPlayer = player;

            // Set player info with momentum badge
            const modalNameEl = document.getElementById('modal-player-name');
            modalNameEl.textContent = player.name;

            // Build meta line with injury and momentum badges inline
            const injury = getPlayerInjuryStatus(player.name);
            let metaHTML = `${player.position} · ${player.team} · Rank #${player.rosRank}`;
            
            if (injury) {
                const statusInfo = formatInjuryStatus(injury.status);
                const injuryDetails = `${statusInfo.fullText} - ${injury.injuryBody}`;
                metaHTML += ` <span class="injury-badge ${statusInfo.class}" data-injury-details="${injuryDetails}" style="font-size: 13px; padding: 3px 8px;">${statusInfo.fullText}</span>`;
            }
            
            // Add momentum badge inline if valid
            if (player.momentum && player.momentum.isValid && player.momentum.direction !== 'neutral') {
                metaHTML += ` <span class="momentum-badge ${player.momentum.direction}" data-tooltip="Momentum: ${player.momentum.score > 0 ? '+' : ''}${player.momentum.score.toFixed(1)}% (last 3 vs prev 3 weeks)" style="font-size: 13px; padding: 3px 8px;">${player.momentum.direction === 'up' ? '↑' : '↓'}</span>`;
            }
            
            document.getElementById('modal-player-meta').innerHTML = metaHTML;
            document.getElementById('modal-team-badge').textContent = player.team;
            document.getElementById('modal-team-badge').style.background = teamColors[player.team] || '#666';

            // Get latest week data
            const latestWeek = player.weeks[player.weeks.length - 1];
            const latestWeekNum = latestWeek.week;
            const actualPts = latestWeek.fpts;
            const expectedPts = latestWeek.expectedFpts;
            const diffPct = expectedPts > 0 ? ((actualPts - expectedPts) / expectedPts) * 100 : 0;

            // Get previous week data for comparison
            const prevWeek = player.weeks.length > 1 ? player.weeks[player.weeks.length - 2] : null;

            // Row 1: Points Stats
            document.getElementById('modal-avg-pts').textContent = player.avgPoints.toFixed(1);
            document.getElementById('modal-exp-pts-label').textContent = `EXP PTS (W${latestWeekNum})`;
            document.getElementById('modal-exp-pts').textContent = expectedPts.toFixed(1);
            document.getElementById('modal-actual-pts-label').textContent = `ACTUAL (W${latestWeekNum})`;
            document.getElementById('modal-actual-pts').textContent = actualPts.toFixed(1);

            const diffEl = document.getElementById('modal-diff-pct');
            const diffColor = diffPct >= 0 ? '#30d158' : '#ff453a';
            const diffSymbol = diffPct >= 0 ? '▲' : '▼';
            diffEl.textContent = `${diffSymbol} ${Math.abs(diffPct).toFixed(1)}%`;
            diffEl.style.color = diffColor;

            // Row 2: Opportunity Stats (position-specific)
            if (player.position === 'WR') {
                // Show WR-specific stats
                document.getElementById('modal-stat-opp-this').style.display = 'block';
                document.getElementById('modal-stat-opp-last').style.display = 'block';
                document.getElementById('modal-stat-vs-avg').style.display = 'block';
                document.getElementById('modal-stat-opp-change').style.display = 'block';

                // Update tooltips for WRs
                document.querySelector('#modal-stat-opp-this .stat-tooltip').textContent = 'Percentage of team\'s targets this player received in latest week';
                document.querySelector('#modal-stat-opp-last .stat-tooltip').textContent = 'Percentage of team\'s targets this player received in previous week';
                document.querySelector('#modal-stat-vs-avg .stat-tooltip').textContent = 'Target differential vs Top 24 WR average for this week';
                document.querySelector('#modal-stat-opp-change .stat-tooltip').textContent = 'Week-over-week change in target share percentage';

                const thisWeekShare = latestWeek.teamShare || 0;
                const lastWeekShare = prevWeek ? (prevWeek.teamShare || 0) : 0;
                const shareChange = thisWeekShare - lastWeekShare;
                const thisWeekTargets = latestWeek.targets || 0;

                // Calculate top 24 WR average targets for this week
                const allWRs = Object.values(aggregatedWRs);
                const top24WRs = allWRs
                    .filter(wr => wr.gamesPlayed >= 3)
                    .sort((a, b) => b.avgPoints - a.avgPoints)
                    .slice(0, 24);

                // Get targets for latest week for top 24
                const top24LatestWeekTargets = top24WRs
                    .map(wr => {
                        const wrLatestWeek = wr.weeks.find(w => w.week === latestWeekNum);
                        return wrLatestWeek ? (wrLatestWeek.targets || 0) : 0;
                    })
                    .filter(t => t > 0);

                const avgTop24Targets = top24LatestWeekTargets.length > 0
                    ? top24LatestWeekTargets.reduce((sum, t) => sum + t, 0) / top24LatestWeekTargets.length
                    : 0;

                const vsAvg = thisWeekTargets - avgTop24Targets;

                document.getElementById('modal-opp-this-week').textContent = thisWeekShare.toFixed(1) + '%';
                document.getElementById('modal-opp-last-week').textContent = lastWeekShare.toFixed(1) + '%';

                const vsAvgEl = document.getElementById('modal-vs-avg');
                const vsAvgColor = vsAvg >= 0 ? '#30d158' : '#ff453a';
                const vsAvgSymbol = vsAvg >= 0 ? '+' : '';
                vsAvgEl.textContent = `${vsAvgSymbol}${vsAvg.toFixed(1)}`;
                vsAvgEl.style.color = vsAvgColor;

                // Show actual numbers below
                const vsAvgDetailEl = document.getElementById('modal-vs-avg-detail');
                vsAvgDetailEl.textContent = `${thisWeekTargets.toFixed(1)} / ${avgTop24Targets.toFixed(1)} avg`;

                const shareChangeEl = document.getElementById('modal-share-change');
                const shareChangeColor = shareChange >= 0 ? '#30d158' : '#ff453a';
                const shareChangeSymbol = shareChange >= 0 ? '▲' : '▼';
                shareChangeEl.textContent = `${shareChangeSymbol} ${Math.abs(shareChange).toFixed(1)}%`;
                shareChangeEl.style.color = shareChangeColor;
            } else if (player.position === 'RB') {
                // For RBs, update labels and show RB-specific stats
                document.getElementById('modal-stat-opp-this').style.display = 'block';
                document.getElementById('modal-stat-opp-last').style.display = 'block';
                document.getElementById('modal-stat-vs-avg').style.display = 'block';
                document.getElementById('modal-stat-opp-change').style.display = 'block';

                // Update labels for RBs
                document.querySelector('#modal-stat-opp-this .modal-stat-label').textContent = 'OPP SHARE THIS WK';
                document.querySelector('#modal-stat-opp-last .modal-stat-label').textContent = 'OPP SHARE LAST WK';
                document.querySelector('#modal-stat-vs-avg .modal-stat-label').textContent = 'OPP vs TOP 24 AVG';

                // Update tooltips for RBs
                document.querySelector('#modal-stat-opp-this .stat-tooltip').textContent = 'Number of opportunities (carries + targets) this player received in latest week';
                document.querySelector('#modal-stat-opp-last .stat-tooltip').textContent = 'Number of opportunities (carries + targets) this player received in previous week';
                document.querySelector('#modal-stat-vs-avg .stat-tooltip').textContent = 'Opportunity differential vs Top 24 RB average for this week';
                document.querySelector('#modal-stat-opp-change .stat-tooltip').textContent = 'Week-over-week change in total opportunities';

                const thisWeekOpp = latestWeek.opportunities || 0;
                const lastWeekOpp = prevWeek ? (prevWeek.opportunities || 0) : 0;
                const oppChange = thisWeekOpp - lastWeekOpp;

                // Calculate top 24 RB average opportunities for this week
                const allRBs = Object.values(aggregatedRBs);
                const top24RBs = allRBs
                    .filter(rb => rb.gamesPlayed >= 3)
                    .sort((a, b) => b.avgPoints - a.avgPoints)
                    .slice(0, 24);

                // Get opportunities for latest week for top 24
                const top24LatestWeekOpps = top24RBs
                    .map(rb => {
                        const rbLatestWeek = rb.weeks.find(w => w.week === latestWeekNum);
                        return rbLatestWeek ? (rbLatestWeek.opportunities || 0) : 0;
                    })
                    .filter(o => o > 0);

                const avgTop24Opps = top24LatestWeekOpps.length > 0
                    ? top24LatestWeekOpps.reduce((sum, o) => sum + o, 0) / top24LatestWeekOpps.length
                    : 0;

                const vsAvg = thisWeekOpp - avgTop24Opps;

                document.getElementById('modal-opp-this-week').textContent = thisWeekOpp.toFixed(1);
                document.getElementById('modal-opp-last-week').textContent = lastWeekOpp.toFixed(1);

                const vsAvgEl = document.getElementById('modal-vs-avg');
                const vsAvgColor = vsAvg >= 0 ? '#30d158' : '#ff453a';
                const vsAvgSymbol = vsAvg >= 0 ? '+' : '';
                vsAvgEl.textContent = `${vsAvgSymbol}${vsAvg.toFixed(1)}`;
                vsAvgEl.style.color = vsAvgColor;

                // Show actual numbers below
                const vsAvgDetailEl = document.getElementById('modal-vs-avg-detail');
                vsAvgDetailEl.textContent = `${thisWeekOpp.toFixed(1)} / ${avgTop24Opps.toFixed(1)} avg`;

                const oppChangeEl = document.getElementById('modal-share-change');
                const oppChangeColor = oppChange >= 0 ? '#30d158' : '#ff453a';
                const oppChangeSymbol = oppChange >= 0 ? '▲' : '▼';
                oppChangeEl.textContent = `${oppChangeSymbol} ${Math.abs(oppChange).toFixed(1)}`;
                oppChangeEl.style.color = oppChangeColor;
            } else if (player.position === 'TE') {
                // For TEs, show TE-specific stats
                document.getElementById('modal-stat-opp-this').style.display = 'block';
                document.getElementById('modal-stat-opp-last').style.display = 'block';
                document.getElementById('modal-stat-vs-avg').style.display = 'block';
                document.getElementById('modal-stat-opp-change').style.display = 'block';

                // Update labels for TEs
                document.querySelector('#modal-stat-opp-this .modal-stat-label').textContent = 'TARGETS THIS WK';
                document.querySelector('#modal-stat-opp-last .modal-stat-label').textContent = 'TARGETS LAST WK';
                document.querySelector('#modal-stat-vs-avg .modal-stat-label').textContent = 'TGT vs TOP 12 AVG';

                // Update tooltips for TEs
                document.querySelector('#modal-stat-opp-this .stat-tooltip').textContent = 'Number of targets this player received in latest week';
                document.querySelector('#modal-stat-opp-last .stat-tooltip').textContent = 'Number of targets this player received in previous week';
                document.querySelector('#modal-stat-vs-avg .stat-tooltip').textContent = 'Target differential vs Top 12 TE average for this week';
                document.querySelector('#modal-stat-opp-change .stat-tooltip').textContent = 'Week-over-week change in targets';

                const thisWeekTargets = latestWeek.targets || 0;
                const lastWeekTargets = prevWeek ? (prevWeek.targets || 0) : 0;
                const targetsChange = thisWeekTargets - lastWeekTargets;

                // Calculate top 12 TE average targets for this week
                const allTEs = Object.values(aggregatedTEs);
                const top12TEs = allTEs
                    .filter(te => te.gamesPlayed >= 3)
                    .sort((a, b) => b.avgPoints - a.avgPoints)
                    .slice(0, 12);

                // Get targets for latest week for top 12
                const top12LatestWeekTargets = top12TEs
                    .map(te => {
                        const teLatestWeek = te.weeks.find(w => w.week === latestWeekNum);
                        return teLatestWeek ? (teLatestWeek.targets || 0) : 0;
                    })
                    .filter(t => t > 0);

                const avgTop12Targets = top12LatestWeekTargets.length > 0
                    ? top12LatestWeekTargets.reduce((sum, t) => sum + t, 0) / top12LatestWeekTargets.length
                    : 0;

                const vsAvg = thisWeekTargets - avgTop12Targets;

                document.getElementById('modal-opp-this-week').textContent = thisWeekTargets.toFixed(1);
                document.getElementById('modal-opp-last-week').textContent = lastWeekTargets.toFixed(1);

                const vsAvgEl = document.getElementById('modal-vs-avg');
                const vsAvgColor = vsAvg >= 0 ? '#30d158' : '#ff453a';
                const vsAvgSymbol = vsAvg >= 0 ? '+' : '';
                vsAvgEl.textContent = `${vsAvgSymbol}${vsAvg.toFixed(1)}`;
                vsAvgEl.style.color = vsAvgColor;

                // Show actual numbers below
                const vsAvgDetailEl = document.getElementById('modal-vs-avg-detail');
                vsAvgDetailEl.textContent = `${thisWeekTargets.toFixed(1)} / ${avgTop12Targets.toFixed(1)} avg`;

                const targetsChangeEl = document.getElementById('modal-share-change');
                const targetsChangeColor = targetsChange >= 0 ? '#30d158' : '#ff453a';
                const targetsChangeSymbol = targetsChange >= 0 ? '▲' : '▼';
                targetsChangeEl.textContent = `${targetsChangeSymbol} ${Math.abs(targetsChange).toFixed(1)}`;
                targetsChangeEl.style.color = targetsChangeColor;
            }

            // Update sentiment display
            updateModalSentiment(player.name);

            // Load comments
            loadComments(player.name);

            // Show modal first (important for chart rendering)
            document.getElementById('player-modal').classList.add('active');

            // Initialize swipeable stats for mobile
            if (window.innerWidth <= 768) {
                statsCurrentPage = 0;
                setTimeout(() => {
                    initStatsSwipe();
                    updateStatsPage();
                }, 100);
            }

            // Render charts - outcomes chart needs to wait for modal to be visible
            renderModalVarianceChart(player);
            renderModalSpiderChart(player);

            // Delay outcomes chart rendering to ensure modal is fully visible
            setTimeout(() => {
                renderModalOutcomesChart(player);
            }, 50);

            // Reset to Performance Consistency tab
            document.querySelectorAll('.chart-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.chart-content').forEach(content => content.classList.remove('active'));
            document.querySelector('.chart-tab[onclick*="outcomes"]').classList.add('active');
            document.getElementById('modal-chart-outcomes').classList.add('active');

            // Setup spider explanation section
            const explanation = document.getElementById('spider-explanation');
            const icon = document.getElementById('spider-explanation-icon');
            if (explanation) {
                explanation.style.display = 'none'; // Collapsed by default
                icon.textContent = 'ℹ️';

                // Show correct metrics section based on position
                const wrMetrics = document.getElementById('spider-wr-metrics');
                const rbMetrics = document.getElementById('spider-rb-metrics');
                const teMetrics = document.getElementById('spider-te-metrics');
                if (player.position === 'WR') {
                    wrMetrics.style.display = 'block';
                    rbMetrics.style.display = 'none';
                    teMetrics.style.display = 'none';
                } else if (player.position === 'RB') {
                    wrMetrics.style.display = 'none';
                    rbMetrics.style.display = 'block';
                    teMetrics.style.display = 'none';
                } else if (player.position === 'TE') {
                    wrMetrics.style.display = 'none';
                    rbMetrics.style.display = 'none';
                    teMetrics.style.display = 'block';
                }
            }

            // Scroll modal to top
            setTimeout(() => {
                const modalBody = document.querySelector('#player-modal .modal');
                if (modalBody) {
                    modalBody.scrollTop = 0;
                }
            }, 100);
        }

        function updateModalSentiment(playerName) {
            const sentiment = getSentimentScore(playerName);
            const total = sentiment.total;
            const buyPct = total > 0 ? (sentiment.buy / total * 100) : 0;
            const sellPct = total > 0 ? (sentiment.sell / total * 100) : 0;
            const holdPct = total > 0 ? (sentiment.hold / total * 100) : 0;

            // Update 3-section bar widths and text
            const buySegment = document.getElementById('modal-sentiment-segment-buy');
            const holdSegment = document.getElementById('modal-sentiment-segment-hold');
            const sellSegment = document.getElementById('modal-sentiment-segment-sell');

            if (total > 0) {
                // Show percentages in segments
                buySegment.style.width = buyPct + '%';
                holdSegment.style.width = holdPct + '%';
                sellSegment.style.width = sellPct + '%';

                // Only show percentage text if segment is wide enough (>10%)
                buySegment.textContent = buyPct > 10 ? Math.round(buyPct) + '%' : '';
                holdSegment.textContent = holdPct > 10 ? Math.round(holdPct) + '%' : '';
                sellSegment.textContent = sellPct > 10 ? Math.round(sellPct) + '%' : '';
            } else {
                // No votes - show grey bar with message
                buySegment.style.width = '0%';
                holdSegment.style.width = '100%';
                sellSegment.style.width = '0%';
                buySegment.textContent = '';
                holdSegment.textContent = 'No votes yet';
                sellSegment.textContent = '';
            }

            // Determine dominant sentiment
            const max = Math.max(buyPct, holdPct, sellPct);
            let label, color, icon;

            if (total === 0) {
                label = 'No votes';
                color = 'var(--text-secondary)';
                icon = '—';
            } else if (buyPct === max) {
                label = 'BUY';
                color = '#10b981';
                icon = '▲';
            } else if (sellPct === max) {
                label = 'SELL';
                color = '#ef4444';
                icon = '▼';
            } else {
                label = 'HOLD';
                color = '#6b7280';
                icon = '—';
            }

            // Update compact display (top right)
            const compactEl = document.getElementById('modal-sentiment-compact');
            if (total > 0) {
                compactEl.innerHTML = `<span style="color: ${color};">${icon} ${Math.round(max)}% ${label}</span>`;
            } else {
                compactEl.innerHTML = `<span style="color: ${color};">${icon} ${label}</span>`;
            }

            // Update vote count
            const voteCountEl = document.getElementById('modal-sentiment-vote-count');
            voteCountEl.textContent = total === 1 ? '1 vote' : `${total} votes`;

            // Highlight user's vote if exists
            document.querySelectorAll('.vote-btn').forEach(btn => btn.classList.remove('active'));
            const userVote = localStorage.getItem(`ffse_user_vote_${playerName}`);
            if (userVote) {
                document.querySelector(`.vote-btn.${userVote}-btn`)?.classList.add('active');
            }
        }

        function castVote(voteType) {
            if (!currentModalPlayer) return;

            const playerName = currentModalPlayer.name;

            // Check if user is clicking the same vote (undo)
            const previousVote = localStorage.getItem(`ffse_user_vote_${playerName}`);
            if (previousVote === voteType) {
                // User is undoing their vote
                if (!playerVotes[playerName]) {
                    playerVotes[playerName] = { buy: 0, sell: 0, hold: 0, lastVote: Date.now() };
                }
                playerVotes[playerName][previousVote] = Math.max(0, playerVotes[playerName][previousVote] - 1);

                // Remove user's vote from localStorage
                localStorage.removeItem(`ffse_user_vote_${playerName}`);

                // Save to localStorage
                saveSentimentData();

                // Update display
                updateModalSentiment(playerName);

                // Refresh player cards to show updated sentiment
                if (currentModalPlayer.position === 'WR') {
                    renderWRPlayerCards();
                } else if (currentModalPlayer.position === 'RB') {
                    renderRBPlayerCards();
                } else if (currentModalPlayer.position === 'TE') {
                    renderTEPlayerCards();
                }
                return; // Exit early - vote has been removed
            }

            // User is changing their vote or voting for first time
            // Remove previous vote if exists
            if (previousVote) {
                if (!playerVotes[playerName]) {
                    playerVotes[playerName] = { buy: 0, sell: 0, hold: 0, lastVote: Date.now() };
                }
                playerVotes[playerName][previousVote] = Math.max(0, playerVotes[playerName][previousVote] - 1);
            }

            // Add new vote
            if (!playerVotes[playerName]) {
                playerVotes[playerName] = { buy: 0, sell: 0, hold: 0, lastVote: Date.now() };
            }
            playerVotes[playerName][voteType]++;
            playerVotes[playerName].lastVote = Date.now();

            // Store user's vote
            localStorage.setItem(`ffse_user_vote_${playerName}`, voteType);

            // Save to localStorage
            saveSentimentData();

            // Update display
            updateModalSentiment(playerName);

            // Refresh player cards to show updated sentiment
            if (currentModalPlayer.position === 'WR') {
                renderWRPlayerCards();
            } else if (currentModalPlayer.position === 'RB') {
                renderRBPlayerCards();
            } else if (currentModalPlayer.position === 'TE') {
                renderTEPlayerCards();
            }
        }

        function loadComments(playerName) {
            if (!playerComments[playerName]) {
                playerComments[playerName] = [];
            }

            const commentList = document.getElementById('comment-list');
            const comments = playerComments[playerName].sort((a, b) => b.timestamp - a.timestamp);

            if (comments.length === 0) {
                commentList.innerHTML = '<div style="color: var(--text-secondary); font-size: 13px; text-align: center; padding: 20px;">No comments yet. Be the first!</div>';
                return;
            }

            commentList.innerHTML = comments.slice(0, 10).map(comment => {
                const timeAgo = getTimeAgo(comment.timestamp);
                return `
                    <div class="comment-item">
                        <div>${comment.text}</div>
                        <div class="comment-meta">${timeAgo}</div>
                    </div>
                `;
            }).join('');

            // Add Enter key listener
            const input = document.getElementById('comment-input');
            input.onkeypress = function(e) {
                if (e.key === 'Enter') {
                    submitComment();
                }
            };
        }

        function submitComment() {
            if (!currentModalPlayer) return;

            const input = document.getElementById('comment-input');
            const text = input.value.trim();

            if (!text) return;

            const playerName = currentModalPlayer.name;

            if (!playerComments[playerName]) {
                playerComments[playerName] = [];
            }

            playerComments[playerName].push({
                text: text,
                timestamp: Date.now(),
                user: 'Anonymous' // Could be enhanced with user system
            });

            // Save to localStorage
            localStorage.setItem('ffse_player_comments', JSON.stringify(playerComments));

            // Clear input
            input.value = '';

            // Reload comments
            loadComments(playerName);
        }

        function getTimeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);

            if (seconds < 60) return 'Just now';
            if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
            if (seconds < 86400) return Math.floor(seconds / 3600) + 'h ago';
            return Math.floor(seconds / 86400) + 'd ago';
        }

        function closeModal() {
            document.getElementById('player-modal').classList.remove('active');

            // Destroy charts
            if (modalVarianceChart) modalVarianceChart.destroy();
            if (modalOutcomesChart) modalOutcomesChart.destroy();
            if (modalSpiderChart) modalSpiderChart.destroy();
            if (modalShareChart) modalShareChart.destroy();
            if (modalTrendsChart) modalTrendsChart.destroy();
            
            // Reset stats page to first page
            if (window.innerWidth <= 768) {
                statsCurrentPage = 0;
                updateStatsPage();
            }
        }

        // Swipeable Stats Grid (Mobile Only)
        let statsCurrentPage = 0;
        let statsStartX = 0;
        let statsCurrentX = 0;
        let statsDragging = false;

        function initStatsSwipe() {
            const wrapper = document.getElementById('modal-stats-wrapper');
            if (!wrapper || window.innerWidth > 768) return; // Desktop - no swipe

            // Touch events
            wrapper.addEventListener('touchstart', handleStatsStart, { passive: true });
            wrapper.addEventListener('touchmove', handleStatsMove, { passive: false });
            wrapper.addEventListener('touchend', handleStatsEnd, { passive: true });

            // Mouse events (for testing)
            wrapper.addEventListener('mousedown', handleStatsStart);
            wrapper.addEventListener('mousemove', handleStatsMove);
            wrapper.addEventListener('mouseup', handleStatsEnd);
            wrapper.addEventListener('mouseleave', handleStatsEnd);

            // Dot click events
            document.querySelectorAll('.stats-dot').forEach(dot => {
                dot.addEventListener('click', () => {
                    statsCurrentPage = parseInt(dot.dataset.page);
                    updateStatsPage();
                });
            });
        }

        function handleStatsStart(e) {
            if (window.innerWidth > 768) return;
            statsDragging = true;
            statsStartX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
            statsCurrentX = statsStartX;
        }

        function handleStatsMove(e) {
            if (!statsDragging || window.innerWidth > 768) return;
            e.preventDefault();
            statsCurrentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
            
            const diff = statsCurrentX - statsStartX;
            const wrapper = document.getElementById('modal-stats-wrapper');
            const currentTranslate = -statsCurrentPage * 100;
            const dragPercent = (diff / wrapper.offsetWidth) * 100;
            
            wrapper.style.transform = `translateX(${currentTranslate + dragPercent}%)`;
        }

        function handleStatsEnd(e) {
            if (!statsDragging || window.innerWidth > 768) return;
            statsDragging = false;
            
            const diff = statsCurrentX - statsStartX;
            const threshold = 50; // pixels
            
            if (diff > threshold && statsCurrentPage > 0) {
                statsCurrentPage--;
            } else if (diff < -threshold && statsCurrentPage < 1) {
                statsCurrentPage++;
            }
            
            updateStatsPage();
        }

        function updateStatsPage() {
            const wrapper = document.getElementById('modal-stats-wrapper');
            if (!wrapper) return;
            
            wrapper.style.transform = `translateX(-${statsCurrentPage * 100}%)`;
            
            // Update dots
            document.querySelectorAll('.stats-dot').forEach((dot, index) => {
                dot.classList.toggle('active', index === statsCurrentPage);
            });
        }


        function switchModalChart(chartName) {
            // Update tabs
            document.querySelectorAll('.chart-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');

            // Update content
            document.querySelectorAll('.chart-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`modal-chart-${chartName}`).classList.add('active');

            // Charts are now fully loaded on modal open (no re-rendering needed)
        }

        function toggleSpiderExplanation() {
            const explanation = document.getElementById('spider-explanation');
            const icon = document.getElementById('spider-explanation-icon');

            if (explanation.style.display === 'none') {
                explanation.style.display = 'block';
                icon.textContent = '▼';
            } else {
                explanation.style.display = 'none';
                icon.textContent = 'ℹ️';
            }
        }

        function renderModalVarianceChart(player) {
            const ctx = document.getElementById('modal-variance-chart');

            if (modalVarianceChart) {
                modalVarianceChart.destroy();
            }

            const weeks = player.weeks.map(w => `W${w.week}`);
            const actuals = player.weeks.map(w => w.fpts);
            const expected = player.weeks.map(w => w.expectedFpts);
            const variance = player.weeks.map(w => w.variance);

            modalVarianceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: weeks,
                    datasets: [
                        {
                            type: 'line',
                            label: 'Actual',
                            data: actuals,
                            borderColor: '#fff',
                            borderWidth: 2,
                            fill: false,
                            pointRadius: 4,
                            pointBackgroundColor: '#fff',
                            yAxisID: 'y'
                        },
                        {
                            type: 'line',
                            label: 'Expected',
                            data: expected,
                            borderColor: '#8e8e93',
                            borderDash: [5, 5],
                            borderWidth: 2,
                            fill: false,
                            pointRadius: 4,
                            pointBackgroundColor: '#8e8e93',
                            yAxisID: 'y'
                        },
                        {
                            type: 'bar',
                            label: 'Variance',
                            data: variance,
                            backgroundColor: variance.map(v =>
                                v >= 0 ? 'rgba(48, 209, 88, 0.6)' : 'rgba(255, 69, 58, 0.6)'
                            ),
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            labels: { color: '#8e8e93' }
                        }
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Fantasy Points',
                                color: '#8e8e93'
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Variance',
                                color: '#8e8e93'
                            },
                            grid: { display: false },
                            ticks: { color: '#8e8e93' }
                        },
                        x: {
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }

        function renderModalOutcomesChart(player) {
            const ctx = document.getElementById('modal-outcomes-chart');

            if (modalOutcomesChart) {
                modalOutcomesChart.destroy();
            }

            // Get team color
            const teamColor = teamColors[player.team] || '#0a84ff';
            const teamColorRgba = hexToRgba(teamColor, 0.1);

            // Calculate average variance (how much they beat or miss expectations)
            const variances = player.weeks.map(w => w.variance);
            const avgVariance = variances.reduce((sum, v) => sum + v, 0) / variances.length;
            const weeksOverExpected = variances.filter(v => v > 0).length;
            const consistency = (weeksOverExpected / variances.length * 100).toFixed(0);

            const weeks = player.weeks.map(w => `W${w.week}`);
            const actuals = player.weeks.map(w => w.fpts);
            const expected = player.weeks.map(w => w.expectedFpts);

            modalOutcomesChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: weeks,
                    datasets: [
                        {
                            label: 'Actual',
                            data: actuals,
                            borderColor: teamColor,
                            backgroundColor: teamColorRgba,
                            borderWidth: 3,
                            fill: true,
                            tension: 0.3,
                            pointRadius: 5,
                            pointBackgroundColor: teamColor,
                            pointBorderColor: '#fff',
                            pointBorderWidth: 2
                        },
                        {
                            label: 'Expected',
                            data: expected,
                            borderColor: '#8e8e93',
                            borderDash: [5, 5],
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                            pointRadius: 4,
                            pointBackgroundColor: '#8e8e93'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                color: '#8e8e93',
                                font: { size: 12 },
                                usePointStyle: true,
                                pointStyle: 'line'
                            }
                        },
                        title: {
                            display: true,
                            text: [
                                `Avg ${avgVariance >= 0 ? '+' : ''}${avgVariance.toFixed(1)} vs Expected`,
                                `Beats Expectations: ${consistency}% of weeks (${weeksOverExpected}/${variances.length})`
                            ],
                            color: avgVariance >= 0 ? '#30d158' : '#ff453a',
                            padding: { bottom: 15 },
                            font: { size: 13, weight: '600' }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(1) + ' pts';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Fantasy Points',
                                color: '#8e8e93'
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        x: {
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }

        // Helper function to convert hex to rgba
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function renderModalSpiderChart(player) {
            const ctx = document.getElementById('modal-spider-chart');

            if (modalSpiderChart) {
                modalSpiderChart.destroy();
                modalSpiderChart = null;
            }

            // Get team color
            const teamColor = teamColors[player.team] || '#0a84ff';
            const teamColorRgba = hexToRgba(teamColor, 0.2);

            // Get all players for ranking
            const allPlayers = player.position === 'WR' ?
                Object.values(aggregatedWRs).filter(p => p.gamesPlayed >= 3) :
                player.position === 'RB' ?
                Object.values(aggregatedRBs).filter(p => p.gamesPlayed >= 3) :
                Object.values(aggregatedTEs).filter(p => p.gamesPlayed >= 3);

            // Calculate rankings for each metric (lower rank = better)
            let metrics = {};
            let rankings = {};

            if (player.position === 'WR') {
                // WR: Volume (targets/game), Efficiency (pts/target), Red Zone, Consistency
                const targetsPerGameData = allPlayers.map(p => ({
                    player: p,
                    value: p.totalTargets / p.gamesPlayed
                })).sort((a, b) => b.value - a.value);

                const efficiencyData = allPlayers.map(p => ({
                    player: p,
                    value: p.avgPoints / (p.totalTargets / p.gamesPlayed) // pts per target
                })).sort((a, b) => b.value - a.value);

                const redZoneData = allPlayers.map(p => ({
                    player: p,
                    value: p.rzOpportunities / p.gamesPlayed
                })).sort((a, b) => b.value - a.value);

                const teamShareData = allPlayers.map(p => ({
                    player: p,
                    value: p.latestWeekOppShare || 0
                })).sort((a, b) => b.value - a.value);

                // Catch Rate: Receptions / Targets (%)
                const catchRateData = allPlayers.map(p => {
                    // Calculate from raw data
                    const playerRows = wrData.filter(row => row.Team === p.team && row.Player === p.name);
                    let totalReceptions = 0;
                    let totalTargets = 0;
                    playerRows.forEach(row => {
                        totalReceptions += parseFloat(row.REC) || 0;
                        totalTargets += parseFloat(row.TGT) || 0;
                    });
                    const catchRate = totalTargets > 0 ? (totalReceptions / totalTargets) * 100 : 0;
                    return { player: p, value: catchRate };
                }).sort((a, b) => b.value - a.value);

                // Find player's rank in each category
                rankings = {
                    'Volume': targetsPerGameData.findIndex(p => p.player.id === player.id) + 1,
                    'Efficiency': efficiencyData.findIndex(p => p.player.id === player.id) + 1,
                    'Red Zone': redZoneData.findIndex(p => p.player.id === player.id) + 1,
                    'Team Share': teamShareData.findIndex(p => p.player.id === player.id) + 1,
                    'Catch Rate': catchRateData.findIndex(p => p.player.id === player.id) + 1
                };

            } else if (player.position === 'RB') {
                // RB: Volume (opps/game), Efficiency (pts/opp), Red Zone, Consistency
                const oppsPerGameData = allPlayers.map(p => ({
                    player: p,
                    value: p.totalOpportunities / p.gamesPlayed
                })).sort((a, b) => b.value - a.value);

                const efficiencyData = allPlayers.map(p => ({
                    player: p,
                    value: p.avgPoints / (p.totalOpportunities / p.gamesPlayed) // pts per opp
                })).sort((a, b) => b.value - a.value);

                const redZoneData = allPlayers.map(p => ({
                    player: p,
                    value: p.rzOpportunities / p.gamesPlayed
                })).sort((a, b) => b.value - a.value);

                const teamShareData = allPlayers.map(p => ({
                    player: p,
                    value: p.latestWeekOppShare || 0
                })).sort((a, b) => b.value - a.value);

                // Yards After Contact: YACON per attempt
                const yacData = allPlayers.map(p => {
                    // Calculate from raw data
                    const playerRows = rbData.filter(row => row.Team === p.team && row.Player === p.name);
                    let totalYACON = 0;
                    let totalATT = 0;
                    playerRows.forEach(row => {
                        totalYACON += parseFloat(row.YACON) || 0;
                        totalATT += parseFloat(row.ATT) || 0;
                    });
                    const yacPerAtt = totalATT > 0 ? totalYACON / totalATT : 0;
                    return { player: p, value: yacPerAtt };
                }).sort((a, b) => b.value - a.value);

                // Find player's rank in each category
                rankings = {
                    'Volume': oppsPerGameData.findIndex(p => p.player.id === player.id) + 1,
                    'Efficiency': efficiencyData.findIndex(p => p.player.id === player.id) + 1,
                    'Red Zone': redZoneData.findIndex(p => p.player.id === player.id) + 1,
                    'Team Share': teamShareData.findIndex(p => p.player.id === player.id) + 1,
                    'Yards After Contact': yacData.findIndex(p => p.player.id === player.id) + 1
                };
            } else if (player.position === 'TE') {
                // TE: Volume (targets/game), Efficiency (pts/target), Red Zone, Catch Rate, Team Share
                const targetsPerGameData = allPlayers.map(p => ({
                    player: p,
                    value: p.totalTargets / p.gamesPlayed
                })).sort((a, b) => b.value - a.value);

                const efficiencyData = allPlayers.map(p => ({
                    player: p,
                    value: p.avgPoints / (p.totalTargets / p.gamesPlayed) // pts per target
                })).sort((a, b) => b.value - a.value);

                const redZoneData = allPlayers.map(p => ({
                    player: p,
                    value: p.rzOpportunities / p.gamesPlayed
                })).sort((a, b) => b.value - a.value);

                const teamShareData = allPlayers.map(p => ({
                    player: p,
                    value: p.latestWeekOppShare || 0
                })).sort((a, b) => b.value - a.value);

                // Catch Rate: Receptions / Targets (%)
                const catchRateData = allPlayers.map(p => {
                    // Calculate from raw data
                    const playerRows = teData.filter(row => row.Team === p.team && row.Player === p.name);
                    let totalReceptions = 0;
                    let totalTargets = 0;
                    playerRows.forEach(row => {
                        totalReceptions += parseFloat(row.REC) || 0;
                        totalTargets += parseFloat(row.TGT) || 0;
                    });
                    const catchRate = totalTargets > 0 ? (totalReceptions / totalTargets) * 100 : 0;
                    return { player: p, value: catchRate };
                }).sort((a, b) => b.value - a.value);

                // Find player's rank in each category
                rankings = {
                    'Volume': targetsPerGameData.findIndex(p => p.player.id === player.id) + 1,
                    'Efficiency': efficiencyData.findIndex(p => p.player.id === player.id) + 1,
                    'Red Zone': redZoneData.findIndex(p => p.player.id === player.id) + 1,
                    'Team Share': teamShareData.findIndex(p => p.player.id === player.id) + 1,
                    'Catch Rate': catchRateData.findIndex(p => p.player.id === player.id) + 1
                };
            }

            // Check if player is in top 200 for all metrics
            const isTop200 = Object.values(rankings).every(rank => rank <= 200);

            if (!isTop200) {
                // Don't render chart for players outside top 200
                // Clear the canvas properly
                if (ctx) {
                    const context = ctx.getContext('2d');
                    if (context) {
                        context.clearRect(0, 0, ctx.width, ctx.height);
                        context.fillStyle = '#8e8e93';
                        context.font = '14px -apple-system, BlinkMacSystemFont, SF Pro Display';
                        context.textAlign = 'center';
                        context.fillText('Player Profile Not Available', ctx.width / 2, ctx.height / 2 - 10);
                        context.fillText('Rankings shown for Top 200 players only', ctx.width / 2, ctx.height / 2 + 10);
                    }
                }
                return;
            }

            // Convert rankings to scores (rank 1 = 100, rank 200 = 0.5)
            const labels = Object.keys(rankings);
            const data = labels.map(label => {
                const rank = rankings[label];
                // Linear scale: rank 1 gets 100, rank 200 gets 0.5
                // Formula: 100 - ((rank - 1) / 199 * 99.5)
                return Math.max(0.5, 100 - ((rank - 1) / 199 * 99.5));
            });

            modalSpiderChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: player.name,
                        data: data,
                        backgroundColor: teamColorRgba,
                        borderColor: teamColor,
                        borderWidth: 3,
                        pointBackgroundColor: teamColor,
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: teamColor,
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        pointBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: {
                        legend: { display: false },
                        title: {
                            display: true,
                            text: 'Rankings vs Top 200 (Higher = Better Rank)',
                            color: '#8e8e93',
                            font: { size: 12 }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const rank = rankings[context.label];
                                    const score = context.parsed.r.toFixed(0);
                                    return `${context.label}: #${rank} (Score: ${score}/100)`;
                                }
                            }
                        }
                    },
                    scales: {
                        r: {
                            beginAtZero: true,
                            min: 0,
                            max: 100,
                            ticks: {
                                stepSize: 20,
                                color: '#8e8e93',
                                backdropColor: 'transparent',
                                font: { size: 10 }
                            },
                            grid: {
                                color: '#1c1c1e'
                            },
                            pointLabels: {
                                color: '#fff',
                                font: {
                                    size: 12,
                                    weight: 'bold'
                                }
                            },
                            angleLines: {
                                color: '#1c1c1e'
                            }
                        }
                    }
                }
            });
        }

        function renderModalShareChart(player) {
            const ctx = document.getElementById('modal-share-chart');

            if (modalShareChart) {
                modalShareChart.destroy();
                modalShareChart = null;
            }

            // Get team data from latest week
            const latestWeek = player.latestWeek;
            let teamData = [];

            if (player.position === 'WR') {
                teamData = wrData.filter(row =>
                    row.Team === player.team &&
                    parseInt(row.Week) === latestWeek &&
                    row.Player &&
                    parseFloat(row.TGT) > 0
                );
            } else {
                teamData = rbData.filter(row =>
                    row.Team === player.team &&
                    parseInt(row.Week) === latestWeek &&
                    row.Player &&
                    parseFloat(row['RB Opp']) > 0
                );
            }

            // Calculate shares for each player
            const playerShares = teamData.map(row => {
                let share = 0;
                if (player.position === 'WR') {
                    share = parseFloat(row['% TM']) || 0;
                } else {
                    // Calculate RB share
                    const playerOpp = parseFloat(row['RB Opp']) || 0;
                    const teamTotal = teamData.reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);
                    share = teamTotal > 0 ? (playerOpp / teamTotal) * 100 : 0;
                }

                return {
                    name: row.Player,
                    share: share,
                    isTarget: row.Player === player.name
                };
            });

            // Sort by share
            playerShares.sort((a, b) => b.share - a.share);

            // Get top 3 (including our player) + everyone else
            const top3 = playerShares.slice(0, 3);
            const others = playerShares.slice(3);
            const othersTotal = others.reduce((sum, p) => sum + p.share, 0);

            const labels = top3.map(p => p.name);
            const data = top3.map(p => p.share);

            // Generate color palette from team color
            const teamColor = teamColors[player.team] || '#0a84ff';
            const colorPalette = getColorPalette(teamColor, 3);
            const colors = colorPalette.slice(0, top3.length);

            if (othersTotal > 0) {
                labels.push('Everyone Else');
                data.push(othersTotal);
                colors.push('#1c1c1e');
            }

            modalShareChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colors,
                        borderColor: '#0a0a0a',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        animateRotate: true,
                        animateScale: true,
                        duration: 1200,
                        easing: 'easeInOutQuart'
                    },
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                color: '#8e8e93',
                                font: { weight: 'bold' }
                            },
                            position: 'bottom'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.label}: ${context.parsed.toFixed(1)}%`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function renderModalTrendsChart(player) {
            const ctx = document.getElementById('modal-trends-chart');

            if (modalTrendsChart) {
                modalTrendsChart.destroy();
            }

            if (player.position === 'RB') {
                // For RBs: Show line chart with all team RBs' opportunity shares

                // Get all RBs from this team
                const teamRBs = Object.values(aggregatedRBs).filter(rb => rb.team === player.team);

                // Get all weeks that have been played
                const allWeeks = [...new Set(player.weeks.map(w => w.week))].sort((a, b) => a - b);

                // Calculate total opportunities per week
                const weekTotals = {};
                allWeeks.forEach(weekNum => {
                    const weekData = rbData.filter(row =>
                        row.Team === player.team &&
                        parseInt(row.Week) === weekNum &&
                        parseFloat(row['RB Opp']) > 0
                    );
                    weekTotals[weekNum] = weekData.reduce((sum, row) => sum + (parseFloat(row['RB Opp']) || 0), 0);
                });

                // Calculate total opportunity share for each RB across all weeks to rank them
                const rbTotalShares = teamRBs.map(rb => {
                    const totalShare = allWeeks.reduce((sum, weekNum) => {
                        const weekData = rbData.filter(row =>
                            row.Team === rb.team &&
                            parseInt(row.Week) === weekNum &&
                            parseFloat(row['RB Opp']) > 0
                        );
                        const rbWeek = weekData.find(row => row.Player === rb.name);
                        const totalOpp = weekData.reduce((sum, row) => sum + (parseFloat(row['RB Opp']) || 0), 0);
                        const weekShare = rbWeek && totalOpp > 0 ? (parseFloat(rbWeek['RB Opp']) / totalOpp * 100) : 0;
                        return sum + weekShare;
                    }, 0);
                    return { rb, totalShare };
                });

                // Sort by total share and get top 3
                rbTotalShares.sort((a, b) => b.totalShare - a.totalShare);
                const top3RBs = rbTotalShares.slice(0, 3).map(item => item.rb);

                // Generate color palette from team color for top 3
                const teamColor = teamColors[player.team] || '#0a84ff';
                const colorPalette = getColorPalette(teamColor, 3);

                // Create datasets for top 3 RBs
                const datasets = top3RBs.map((rb, index) => {
                    const rbColor = colorPalette[index];

                    // Calculate opportunity share for each week
                    const shareData = allWeeks.map(weekNum => {
                        const weekData = rbData.filter(row =>
                            row.Team === rb.team &&
                            parseInt(row.Week) === weekNum &&
                            parseFloat(row['RB Opp']) > 0
                        );
                        const rbWeek = weekData.find(row => row.Player === rb.name);
                        const totalOpp = weekData.reduce((sum, row) => sum + (parseFloat(row['RB Opp']) || 0), 0);
                        return rbWeek && totalOpp > 0 ? (parseFloat(rbWeek['RB Opp']) / totalOpp * 100) : null;
                    });

                    return {
                        label: rb.name,
                        data: shareData,
                        borderColor: rbColor,  // Use full color for all top 3
                        backgroundColor: 'transparent',
                        borderWidth: rb.id === player.id ? 4 : 2,  // Only thickness varies
                        tension: 0.3,
                        pointRadius: rb.id === player.id ? 6 : 3,  // Point size varies
                        pointBackgroundColor: rbColor,
                        pointBorderColor: '#0a0a0a',
                        pointBorderWidth: 2,
                        spanGaps: true
                    };
                });

                // Add "Everyone Else" line if there are more than 3 RBs
                if (teamRBs.length > 3) {
                    const everyoneElseData = allWeeks.map(weekNum => {
                        // Calculate share for everyone else
                        const weekData = rbData.filter(row =>
                            row.Team === player.team &&
                            parseInt(row.Week) === weekNum &&
                            parseFloat(row['RB Opp']) > 0
                        );
                        const totalOpp = weekData.reduce((sum, row) => sum + (parseFloat(row['RB Opp']) || 0), 0);

                        // Calculate top 3 share
                        const top3Share = top3RBs.reduce((sum, rb) => {
                            const rbWeek = weekData.find(row => row.Player === rb.name);
                            const rbOpp = rbWeek ? parseFloat(rbWeek['RB Opp']) || 0 : 0;
                            return sum + (totalOpp > 0 ? (rbOpp / totalOpp * 100) : 0);
                        }, 0);

                        return totalOpp > 0 ? Math.max(0, 100 - top3Share) : null;
                    });

                    datasets.push({
                        label: 'Everyone Else',
                        data: everyoneElseData,
                        borderColor: '#1c1c1e',
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 2,
                        pointBackgroundColor: '#1c1c1e',
                        pointBorderColor: '#0a0a0a',
                        pointBorderWidth: 2,
                        spanGaps: true,
                        borderDash: [5, 5]
                    });
                }

                modalTrendsChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: allWeeks.map(w => `Week ${w}`),
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'bottom',
                                labels: {
                                    color: '#8e8e93',
                                    font: { size: 12 },
                                    boxWidth: 15,
                                    padding: 10
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    title: (context) => {
                                        const weekNum = allWeeks[context[0].dataIndex];
                                        const totalOpps = weekTotals[weekNum];
                                        return `Week ${weekNum} (${totalOpps.toFixed(0)} Total RB Opps)`;
                                    },
                                    label: (context) => `${context.dataset.label}: ${context.parsed.y ? context.parsed.y.toFixed(1) : '0'}% share`
                                }
                            }
                        },
                        scales: {
                            x: {
                                grid: { color: '#2c2c2e' },
                                ticks: { color: '#8e8e93' }
                            },
                            y: {
                                beginAtZero: true,
                                max: 100,
                                title: {
                                    display: true,
                                    text: 'Opportunity Share %',
                                    color: '#8e8e93'
                                },
                                grid: { color: '#2c2c2e' },
                                ticks: {
                                    color: '#8e8e93',
                                    callback: (value) => value + '%'
                                }
                            }
                        }
                    }
                });
            } else {
                // For WRs: Keep stacked bar chart

                // Get all weeks that player played
                const weeks = player.weeks.map(w => w.week);

                // For each week, get team data and calculate shares
                const weeklyShares = {};
                const weekTotals = {};

                weeks.forEach(weekNum => {
                    const teamData = wrData.filter(row =>
                        row.Team === player.team &&
                        parseInt(row.Week) === weekNum &&
                        row.Player &&
                        parseFloat(row.TGT) > 0
                    );

                    // Calculate total targets for this week
                    weekTotals[weekNum] = teamData.reduce((sum, row) => sum + (parseFloat(row.TGT) || 0), 0);

                    // Calculate shares for this week
                    const playerShares = teamData.map(row => {
                        const share = parseFloat(row['% TM']) || 0;
                        return {
                            name: row.Player,
                            share: share
                        };
                    });

                    // Sort by share
                    playerShares.sort((a, b) => b.share - a.share);

                    weeklyShares[weekNum] = playerShares;
                });

                // Identify consistent top 3 players across all weeks
                const allPlayers = new Map();
                Object.values(weeklyShares).forEach(weekData => {
                    weekData.forEach(p => {
                        if (!allPlayers.has(p.name)) {
                            allPlayers.set(p.name, 0);
                        }
                        allPlayers.set(p.name, allPlayers.get(p.name) + p.share);
                    });
                });

                // Get top 3 by total share across all weeks
                const sortedPlayers = Array.from(allPlayers.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3)
                    .map(entry => entry[0]);

                // Build datasets for stacked bar chart
                const labels = weeks.map(w => `W${w}`);
                const datasets = [];

                // Generate color palette from team color
                const teamColor = teamColors[player.team] || '#0a84ff';
                const colorPalette = getColorPalette(teamColor, 3);

                // Use color palette for each player
                sortedPlayers.forEach((playerName, idx) => {
                    const color = colorPalette[idx];

                    const weeklyData = weeks.map(weekNum => {
                        const weekData = weeklyShares[weekNum];
                        const playerWeekData = weekData.find(p => p.name === playerName);
                        return playerWeekData ? playerWeekData.share : 0;
                    });

                    datasets.push({
                        label: playerName,
                        data: weeklyData,
                        backgroundColor: color,
                        borderColor: '#0a0a0a',
                        borderWidth: 1
                    });
                });

                // Everyone else
                const othersData = weeks.map(weekNum => {
                    const weekData = weeklyShares[weekNum];
                    const top3Total = weekData
                        .filter(p => sortedPlayers.includes(p.name))
                        .reduce((sum, p) => sum + p.share, 0);
                    return Math.max(0, 100 - top3Total);
                });

                datasets.push({
                    label: 'Everyone Else',
                    data: othersData,
                    backgroundColor: '#1c1c1e',
                    borderColor: '#0a0a0a',
                    borderWidth: 1
                });

                modalTrendsChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                labels: { color: '#8e8e93' },
                                position: 'bottom'
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(context) {
                                        const weekNum = weeks[context[0].dataIndex];
                                        const totalTargets = weekTotals[weekNum];
                                        return `W${weekNum} (${totalTargets.toFixed(0)} Total Targets)`;
                                    },
                                    label: function(context) {
                                        return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                stacked: true,
                                grid: { color: '#2c2c2e' },
                                ticks: { color: '#8e8e93' }
                            },
                            y: {
                                stacked: true,
                                beginAtZero: true,
                                max: 100,
                                title: {
                                    display: true,
                                    text: 'Opportunity Share %',
                                    color: '#8e8e93'
                                },
                                grid: { color: '#2c2c2e' },
                                ticks: { color: '#8e8e93' }
                            }
                        }
                    }
                });
            }
        }

        /* ============================================
           New: Evaluation Chart Rendering + Trend Animation
           ============================================ */
        /**
 * Render WR Evaluation Chart 1: Volume vs Efficiency
 * X = Targets per Game, Y = Fantasy Points per Target
 */
function renderWREvalVolumeEfficiency(week = null) {
    const ctx = document.getElementById('wr-eval-volume-efficiency');
    if (!ctx) return;

    const weekData = getEvaluationWeekData(evaluationDataWR, week);

    // Filter by total fantasy points
    const topPlayers = weekData
        .filter(p => p.aggregate.gamesPlayed >= 3)
        .sort((a, b) => b.aggregate.totalFpts - a.aggregate.totalFpts)
        .slice(0, 50);

    const data = topPlayers.map(player => ({
        x: player.targetsPerGame || player.targets || 0,
        y: player.fptsPerTarget || 0,
        label: player.player,
        player: player
    }));

    // Calculate medians for quadrant lines
    const xValues = data.map(d => d.x).filter(x => x > 0).sort((a, b) => a - b);
    const yValues = data.map(d => d.y).filter(y => y > 0).sort((a, b) => a - b);
    const medianX = xValues[Math.floor(xValues.length / 2)] || 5;
    const medianY = yValues[Math.floor(yValues.length / 2)] || 1.5;

    if (wrEvalVolumeEfficiencyChart) wrEvalVolumeEfficiencyChart.destroy();

    wrEvalVolumeEfficiencyChart = new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: [{
                data: data,
                backgroundColor: data.map(d => {
                    const color = teamColors[d.player.team] || '#666';
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, 0.7)`;
                }),
                borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                borderWidth: 2,
                pointRadius: 8,
                pointHoverRadius: 12
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: (context) => {
                            const p = context.raw.player;
                            return [
                                p.player,
                                `Tgts/G: ${context.parsed.x.toFixed(1)}`,
                                `Pts/Tgt: ${context.parsed.y.toFixed(2)}`,
                                `Total: ${p.aggregate.totalFpts.toFixed(1)} pts`
                            ];
                        }
                    }
                },
                annotation: {
                    annotations: {
                        vLine: {
                            type: 'line',
                            xMin: medianX,
                            xMax: medianX,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        hLine: {
                            type: 'line',
                            yMin: medianY,
                            yMax: medianY,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        topRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['Reliable Studs', '(Hold)'],
                            color: '#30d158',
                            font: { size: 13, weight: 'bold' }
                        },
                        topLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.5,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['Efficient Sleepers', '(Buy Low)'],
                            color: '#0a84ff',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.min(...yValues) * 2.0,
                            content: ['Volume, Poor Efficiency', '(Sell Window)'],
                            color: '#FFD60A',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.5,
                            yValue: Math.min(...yValues) * 2.0,
                            content: ['Bench Fodder'],
                            color: '#ff453a',
                            font: { size: 13, weight: 'bold' }
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: 'Targets per Game →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' }
                },
                y: {
                    title: { display: true, text: 'Fantasy Points per Target →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' }
                }
            }
        }
    });
}

/**
 * Render WR Evaluation Chart 2: Target Share vs RZ Share
 * X = Target Share %, Y = Red Zone Target Share %
 */
function renderWREvalShareRZ(week = null) {
    const ctx = document.getElementById('wr-eval-share-rz');
    if (!ctx) return;

    const weekData = getEvaluationWeekData(evaluationDataWR, week);

    // Filter by total fantasy points
    const topPlayers = weekData
        .filter(p => p.aggregate.gamesPlayed >= 3)
        .sort((a, b) => b.aggregate.totalFpts - a.aggregate.totalFpts)
        .slice(0, 50);

    const data = topPlayers.map(player => ({
        x: player.targetShare || 0,
        y: player.rzTargetShare || 0,
        label: player.player,
        player: player
    }));

    // Calculate medians
    const xValues = data.map(d => d.x).filter(x => x > 0).sort((a, b) => a - b);
    const yValues = data.map(d => d.y).filter(y => y > 0).sort((a, b) => a - b);
    const medianX = xValues[Math.floor(xValues.length / 2)] || 20;
    const medianY = yValues[Math.floor(yValues.length / 2)] || 20;

    if (wrEvalShareRZChart) wrEvalShareRZChart.destroy();

    wrEvalShareRZChart = new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: [{
                data: data,
                backgroundColor: data.map(d => {
                    const color = teamColors[d.player.team] || '#666';
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, 0.7)`;
                }),
                borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                borderWidth: 2,
                pointRadius: 8,
                pointHoverRadius: 12
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: (context) => {
                            const p = context.raw.player;
                            return [
                                p.player,
                                `Tgt Share: ${context.parsed.x.toFixed(1)}%`,
                                `RZ Share: ${context.parsed.y.toFixed(1)}%`,
                                `Total: ${p.aggregate.totalFpts.toFixed(1)} pts`
                            ];
                        }
                    }
                },
                annotation: {
                    annotations: {
                        vLine: {
                            type: 'line',
                            xMin: medianX,
                            xMax: medianX,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        hLine: {
                            type: 'line',
                            yMin: medianY,
                            yMax: medianY,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        topRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['Alpha WR1s'],
                            color: '#30d158',
                            font: { size: 13, weight: 'bold' }
                        },
                        topLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.3,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['TD-Dependent', 'Boom/Busts'],
                            color: '#FFD60A',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.min(...yValues) * 2.0,
                            content: ['Chain Movers'],
                            color: '#0a84ff',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.3,
                            yValue: Math.min(...yValues) * 2.0,
                            content: ['Background Noise'],
                            color: '#ff453a',
                            font: { size: 13, weight: 'bold' }
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: 'Target Share (% of Team) →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93', callback: (value) => value + '%' }
                },
                y: {
                    title: { display: true, text: 'Red Zone Target Share (% of Team) →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93', callback: (value) => value + '%' }
                }
            }
        }
    });
}

/**
 * Render RB Evaluation Chart 1: Total vs Red Zone Opportunities
 * X = Opportunities per Game, Y = RZ Opportunities per Game
 */
function renderRBEvalTotalRZ(week = null) {
    const ctx = document.getElementById('rb-eval-total-rz');
    if (!ctx) return;

    const weekData = getEvaluationWeekData(evaluationDataRB, week);

    // Filter by total fantasy points
    const topPlayers = weekData
        .filter(p => p.aggregate.gamesPlayed >= 3)
        .sort((a, b) => b.aggregate.totalFpts - a.aggregate.totalFpts)
        .slice(0, 50);

    const data = topPlayers.map(player => ({
        x: player.opportunitiesPerGame || 0,
        y: player.rzOpportunitiesPerGame || 0,
        label: player.player,
        player: player
    }));

    // Calculate medians
    const xValues = data.map(d => d.x).filter(x => x > 0).sort((a, b) => a - b);
    const yValues = data.map(d => d.y).filter(y => y > 0).sort((a, b) => a - b);
    const medianX = xValues[Math.floor(xValues.length / 2)] || 12;
    const medianY = yValues[Math.floor(yValues.length / 2)] || 2;

    if (rbEvalTotalRZChart) rbEvalTotalRZChart.destroy();

    rbEvalTotalRZChart = new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: [{
                data: data,
                backgroundColor: data.map(d => {
                    const color = teamColors[d.player.team] || '#666';
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, 0.7)`;
                }),
                borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                borderWidth: 2,
                pointRadius: 8,
                pointHoverRadius: 12
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: (context) => {
                            const p = context.raw.player;
                            return [
                                p.player,
                                `Opps/G: ${context.parsed.x.toFixed(1)}`,
                                `RZ Opps/G: ${context.parsed.y.toFixed(1)}`,
                                `Total: ${p.aggregate.totalFpts.toFixed(1)} pts`
                            ];
                        }
                    }
                },
                annotation: {
                    annotations: {
                        vLine: {
                            type: 'line',
                            xMin: medianX,
                            xMax: medianX,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        hLine: {
                            type: 'line',
                            yMin: medianY,
                            yMax: medianY,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        topRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['True Workhorses', '(Buy/Hold)'],
                            color: '#30d158',
                            font: { size: 13, weight: 'bold' }
                        },
                        topLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.2,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['TD Vultures', '(Sell High)'],
                            color: '#FFD60A',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.min(...yValues) * 1.5,
                            content: ['Between-the-20s Backs', '(Neutral)'],
                            color: '#0a84ff',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.2,
                            yValue: Math.min(...yValues) * 1.5,
                            content: ['Irrelevant Depth'],
                            color: '#ff453a',
                            font: { size: 13, weight: 'bold' }
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: 'Opportunities per Game (Rush + Targets) →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' }
                },
                y: {
                    title: { display: true, text: 'Red Zone Opportunities per Game →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' }
                }
            }
        }
    });
}

/**
 * Render RB Evaluation Chart 2: Volume vs Efficiency
 * X = Opportunities per Game, Y = Efficiency (Pts per Opp)
 */
function renderRBEvalVolumeEfficiency(week = null) {
    const ctx = document.getElementById('rb-eval-volume-efficiency');
    if (!ctx) return;

    const weekData = getEvaluationWeekData(evaluationDataRB, week);

    // Filter by total fantasy points
    const topPlayers = weekData
        .filter(p => p.aggregate.gamesPlayed >= 3)
        .sort((a, b) => b.aggregate.totalFpts - a.aggregate.totalFpts)
        .slice(0, 50);

    const data = topPlayers.map(player => ({
        x: player.opportunitiesPerGame || 0,
        y: player.efficiency || 0,
        label: player.player,
        player: player
    }));

    // Calculate medians
    const xValues = data.map(d => d.x).filter(x => x > 0).sort((a, b) => a - b);
    const yValues = data.map(d => d.y).filter(y => y > 0).sort((a, b) => a - b);
    const medianX = xValues[Math.floor(xValues.length / 2)] || 12;
    const medianY = yValues[Math.floor(yValues.length / 2)] || 1;

    if (rbEvalVolumeEfficiencyChart) rbEvalVolumeEfficiencyChart.destroy();

    rbEvalVolumeEfficiencyChart = new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: [{
                data: data,
                backgroundColor: data.map(d => {
                    const color = teamColors[d.player.team] || '#666';
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, 0.7)`;
                }),
                borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                borderWidth: 2,
                pointRadius: 8,
                pointHoverRadius: 12
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: (context) => {
                            const p = context.raw.player;
                            return [
                                p.player,
                                `Opps/G: ${context.parsed.x.toFixed(1)}`,
                                `Efficiency: ${context.parsed.y.toFixed(2)} pts/opp`,
                                `Total: ${p.aggregate.totalFpts.toFixed(1)} pts`
                            ];
                        }
                    }
                },
                annotation: {
                    annotations: {
                        vLine: {
                            type: 'line',
                            xMin: medianX,
                            xMax: medianX,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        hLine: {
                            type: 'line',
                            yMin: medianY,
                            yMax: medianY,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        topRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['Elite Dual Threats'],
                            color: '#30d158',
                            font: { size: 13, weight: 'bold' }
                        },
                        topLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.2,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['Breakout Candidates'],
                            color: '#0a84ff',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.min(...yValues) * 2.0,
                            content: ['Inefficient', 'Workhorses'],
                            color: '#FFD60A',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.2,
                            yValue: Math.min(...yValues) * 2.0,
                            content: ['Bench Fodder'],
                            color: '#ff453a',
                            font: { size: 13, weight: 'bold' }
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: 'Opportunities per Game (Rush + Targets) →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' }
                },
                y: {
                    title: { display: true, text: 'Efficiency (Fantasy Points per Opportunity) →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' }
                }
            }
        }
    });
}
/* ============================================
   Player Evaluation Matrix | Smooth Trend Animation + Week Scrubber
   Features: Linear interpolation, fading trails, interactive scrubber
   ============================================ */

// Smooth animation state
let smoothTrendState = {};
let smoothTrendAnimationFrames = {};
let smoothTrendPlayerTrails = {};
let smoothTrendMoversFilter = {};  // Track movers filter state for each chart

/**
 * Initialize smooth trend animation for a chart
 */
/**
 * Initialize smooth trend animation for a chart (v7: SEGMENT VERSION)
 */
function initSmoothTrendAnimation(chartId) {
    const isWR = chartId.includes('wr-eval');
    const segmentData = isWR ? segmentDataWR : segmentDataRB;  // v7: use segmentData
    const segments = getAvailableSegments(segmentData);         // v7: use segments

    if (segments.length === 0) return;

    // Initialize state
    smoothTrendState[chartId] = {
        isPlaying: false,
        currentSegmentFloat: segments[segments.length - 1],    // v7: segment instead of week
        segments: segments,                                    // v7: segments instead of weeks
        fps: 30,
        speedMultiplier: 0.01,  // Segments per frame (500% slower - was 0.05)
        maxTrailLength: 20      // Longer trail (was 5)
    };

    // Initialize trail data
    smoothTrendPlayerTrails[chartId] = {};

    // Setup scrubber
    const scrubber = document.getElementById(`${chartId}-scrubber`);
    if (scrubber) {
        scrubber.min = segments[0];
        scrubber.max = segments[segments.length - 1];
        scrubber.value = segments[segments.length - 1];

        // Scrubber input handler
        scrubber.addEventListener('input', (e) => {
            const segmentFloat = parseFloat(e.target.value);   // v7: segment naming
            smoothTrendState[chartId].currentSegmentFloat = segmentFloat;
            smoothTrendState[chartId].isPlaying = false;
            updatePlayButton(chartId, false);
            renderSmoothTrendFrame(chartId, segmentFloat);     // v7: pass segment
            updateSegmentLabel(chartId, segmentFloat);         // v7: update segment label
        });
    }

    // Render initial frame (latest segment)
    renderSmoothTrendFrame(chartId, smoothTrendState[chartId].currentSegmentFloat);
    updateSegmentLabel(chartId, smoothTrendState[chartId].currentSegmentFloat);
}

/**
 * Toggle playback for smooth trend animation
 */
function toggleSmoothTrendPlayback(chartId) {
    if (!smoothTrendState[chartId]) {
        initSmoothTrendAnimation(chartId);
    }

    const state = smoothTrendState[chartId];
    state.isPlaying = !state.isPlaying;

    updatePlayButton(chartId, state.isPlaying);

    if (state.isPlaying) {
        startSmoothAnimation(chartId);
    } else {
        stopSmoothAnimation(chartId);
    }
}

/**
 * Toggle movers filter for a chart
 * @param {string} chartId - Chart identifier
 * @param {string} mode - 'all' or 'movers'
 */
/**
 * Toggle movers filter for a chart
 * @param {string} chartId - Chart identifier
 * @param {string} mode - 'all', 'positive', or 'negative'
 */
function toggleMoversFilter(chartId, mode) {
    // Update filter state
    smoothTrendMoversFilter[chartId] = mode;

    // Update button styles
    const allBtn = document.getElementById(`${chartId}-filter-all`);
    const positiveBtn = document.getElementById(`${chartId}-filter-positive`);
    const negativeBtn = document.getElementById(`${chartId}-filter-negative`);

    // Reset all buttons to inactive style
    [allBtn, positiveBtn, negativeBtn].forEach(btn => {
        if (btn) {
            btn.style.background = 'var(--bg-elevated)';
            btn.style.color = 'var(--text-primary)';
            btn.style.border = '1px solid var(--border-color)';
        }
    });

    // Set active button to active style
    let activeBtn;
    if (mode === 'all') activeBtn = allBtn;
    else if (mode === 'positive') activeBtn = positiveBtn;
    else if (mode === 'negative') activeBtn = negativeBtn;

    if (activeBtn) {
        activeBtn.style.background = 'var(--positive)';
        activeBtn.style.color = '#000';
        activeBtn.style.border = 'none';
    }

    // Re-render current frame
    if (smoothTrendState[chartId]) {
        renderSmoothTrendFrame(chartId, smoothTrendState[chartId].currentSegmentFloat);
    }
}

/**
 * Calculate top movers between first and last segment
 * @param {Array} allPlayers - All players with data
 * @param {Object} segmentData - Segment data
 * @param {Array} segments - Available segment indices
 * @param {string} chartId - Chart ID to determine axes
 * @returns {Object} Object with topPositive and topNegative movers
 */
function calculateTopMovers(allPlayers, segmentData, segments, chartId) {
    if (segments.length < 2) return { topPositive: [], topNegative: [] };

    const firstSegment = segments[0];
    const lastSegment = segments[segments.length - 1];

    const firstData = getEvaluationSegmentData(segmentData, firstSegment);
    const lastData = getEvaluationSegmentData(segmentData, lastSegment);

    // Calculate movement for each player
    const movements = [];

    allPlayers.forEach(player => {
        const playerFirst = firstData.find(p => p.player === player.player);
        const playerLast = lastData.find(p => p.player === player.player);

        if (!playerFirst || !playerLast) return;

        // Calculate movement based on chart type
        let xFirst, yFirst, xLast, yLast;

        if (chartId === 'wr-eval-volume-efficiency') {
            xFirst = playerFirst.targets || 0;
            yFirst = playerFirst.fptsPerTarget || 0;
            xLast = playerLast.targets || 0;
            yLast = playerLast.fptsPerTarget || 0;
        } else if (chartId === 'wr-eval-share-rz') {
            xFirst = playerFirst.targetShare || 0;
            yFirst = playerFirst.rzTargetShare || 0;
            xLast = playerLast.targetShare || 0;
            yLast = playerLast.rzTargetShare || 0;
        } else if (chartId === 'rb-eval-total-rz') {
            xFirst = playerFirst.opportunities || 0;
            yFirst = playerFirst.rzOpportunities || 0;
            xLast = playerLast.opportunities || 0;
            yLast = playerLast.rzOpportunities || 0;
        } else if (chartId === 'rb-eval-volume-efficiency') {
            xFirst = playerFirst.opportunities || 0;
            yFirst = playerFirst.efficiency || 0;
            xLast = playerLast.opportunities || 0;
            yLast = playerLast.efficiency || 0;
        } else if (chartId === 'wr-eval-production-volume') {
            xFirst = (playerFirst.targets || 0) / (playerFirst.weeksInSegment || 1);
            yFirst = (playerFirst.fpts || 0) / (playerFirst.weeksInSegment || 1);
            xLast = (playerLast.targets || 0) / (playerLast.weeksInSegment || 1);
            yLast = (playerLast.fpts || 0) / (playerLast.weeksInSegment || 1);
        } else if (chartId === 'rb-eval-production-volume') {
            xFirst = (playerFirst.opportunities || 0) / (playerFirst.weeksInSegment || 1);
            yFirst = (playerFirst.fpts || 0) / (playerFirst.weeksInSegment || 1);
            xLast = (playerLast.opportunities || 0) / (playerLast.weeksInSegment || 1);
            yLast = (playerLast.fpts || 0) / (playerLast.weeksInSegment || 1);
        }

        // Calculate Euclidean distance moved (with Y weighted 2x)
        const xChange = xLast - xFirst;
        const yChange = yLast - yFirst;
        const distance = Math.sqrt(xChange * xChange + (yChange * yChange * 4)); // Y weighted more

        // Determine if positive or negative mover (upward/rightward = positive)
        const direction = (xChange + yChange * 2) >= 0 ? 1 : -1;
        const signedDistance = distance * direction;

        movements.push({
            player: player.player,
            distance: signedDistance,
            absDistance: Math.abs(signedDistance)
        });
    });

    // Sort and get top 5 positive and top 5 negative
    movements.sort((a, b) => b.distance - a.distance);

    const topPositive = movements.slice(0, 5).map(m => m.player);
    const topNegative = movements.slice(-5).reverse().map(m => m.player);

    return { topPositive, topNegative };
}

/**
 * Start smooth animation loop (v7: SEGMENT VERSION)
 */
function startSmoothAnimation(chartId) {
    const state = smoothTrendState[chartId];

    // If at end, restart from beginning and clear trails
    if (state.currentSegmentFloat >= state.segments[state.segments.length - 1]) {
        state.currentSegmentFloat = state.segments[0];
        smoothTrendPlayerTrails[chartId] = {};  // Clear trails on restart
    }

    // Animation loop using requestAnimationFrame
    function animationLoop() {
        if (!state.isPlaying) return;

        // Increment segment position
        state.currentSegmentFloat += state.speedMultiplier;

        // Stop at end (don't loop automatically)
        if (state.currentSegmentFloat >= state.segments[state.segments.length - 1]) {
            state.currentSegmentFloat = state.segments[state.segments.length - 1];
            state.isPlaying = false;
            updatePlayButton(chartId, false);

            // Render final frame with full trails
            renderSmoothTrendFrame(chartId, state.currentSegmentFloat, true);  // Pass showFullTrail flag
            updateSegmentLabel(chartId, state.currentSegmentFloat);
            updateScrubberPosition(chartId, state.currentSegmentFloat);
            return;  // Stop animation
        }

        // Render frame
        renderSmoothTrendFrame(chartId, state.currentSegmentFloat);

        // Update UI
        updateSegmentLabel(chartId, state.currentSegmentFloat);
        updateScrubberPosition(chartId, state.currentSegmentFloat);

        // Continue loop
        smoothTrendAnimationFrames[chartId] = requestAnimationFrame(animationLoop);
    }

    smoothTrendAnimationFrames[chartId] = requestAnimationFrame(animationLoop);
}

/**
 * Stop smooth animation
 */
function stopSmoothAnimation(chartId) {
    const state = smoothTrendState[chartId];
    state.isPlaying = false;

    if (smoothTrendAnimationFrames[chartId]) {
        cancelAnimationFrame(smoothTrendAnimationFrames[chartId]);
        delete smoothTrendAnimationFrames[chartId];
    }
}

/**
/**
 * Render a single frame with interpolation (v7: SEGMENT VERSION)
 * segmentFloat can be a decimal (e.g., 3.5 for halfway between segment 3 and 4)
 * @param {string} chartId - Chart identifier
 * @param {number} segmentFloat - Current segment position (can be fractional)
 * @param {boolean} showFullTrail - If true, show full trail from start to finish
 */
function renderSmoothTrendFrame(chartId, segmentFloat, showFullTrail = false) {
    const isWR = chartId.includes('wr-eval');
    const segmentData = isWR ? segmentDataWR : segmentDataRB;  // v7: use segmentData
    const state = smoothTrendState[chartId];

    // Determine which segments to interpolate between
    const segmentBefore = Math.floor(segmentFloat);
    const segmentAfter = Math.ceil(segmentFloat);
    const interpolationFactor = segmentFloat - segmentBefore;

    // Get data for both segments
    const dataBefore = getEvaluationSegmentData(segmentData, segmentBefore);  // v7: use segment function
    const dataAfter = segmentBefore !== segmentAfter ?
                     getEvaluationSegmentData(segmentData, segmentAfter) :
                     dataBefore;

    // Collect all unique players from both segments
    const playerSet = new Set();
    dataBefore.forEach(p => playerSet.add(p.player));
    dataAfter.forEach(p => playerSet.add(p.player));

    const allPlayers = Array.from(playerSet).map(playerName => {
        const pBefore = dataBefore.find(p => p.player === playerName);
        const pAfter = dataAfter.find(p => p.player === playerName);
        return pBefore || pAfter;
    });

    // Filter by total fantasy points OR top 5 positive/negative movers if filter is active
    let topPlayers;

    if (smoothTrendMoversFilter[chartId] === 'positive' || smoothTrendMoversFilter[chartId] === 'negative') {
        // Calculate top movers
        const segments = getAvailableSegments(segmentData);
        const movers = calculateTopMovers(allPlayers, segmentData, segments, chartId);

        // Get the appropriate set of movers
        let moverNames;
        if (smoothTrendMoversFilter[chartId] === 'positive') {
            moverNames = movers.topPositive;  // Top 5 positive movers
        } else {
            moverNames = movers.topNegative;  // Top 5 negative movers
        }

        // Filter to only selected movers
        topPlayers = allPlayers.filter(p =>
            p && p.aggregate && p.aggregate.gamesPlayed >= 3 && moverNames.includes(p.player)
        );
    } else {
        // Default: filter by fantasy points
        topPlayers = allPlayers
            .filter(p => p && p.aggregate && p.aggregate.gamesPlayed >= 3)
            .sort((a, b) => b.aggregate.totalFpts - a.aggregate.totalFpts)
            .slice(0, 50);
    }

    // Build interpolated data points with trails
    const interpolatedData = topPlayers.map(player => {
        const pBefore = dataBefore.find(p => p.player === player.player);
        const pAfter = dataAfter.find(p => p.player === player.player);

        // Get coordinates for interpolation
        let xBefore, yBefore, xAfter, yAfter;

        // Determine axes based on chart type
        if (chartId === 'wr-eval-volume-efficiency') {
            xBefore = pBefore ? (pBefore.targets || 0) : 0;
            yBefore = pBefore ? (pBefore.fptsPerTarget || 0) : 0;
            xAfter = pAfter ? (pAfter.targets || 0) : xBefore;
            yAfter = pAfter ? (pAfter.fptsPerTarget || 0) : yBefore;
        } else if (chartId === 'wr-eval-share-rz') {
            xBefore = pBefore ? (pBefore.targetShare || 0) : 0;
            yBefore = pBefore ? (pBefore.rzTargetShare || 0) : 0;
            xAfter = pAfter ? (pAfter.targetShare || 0) : xBefore;
            yAfter = pAfter ? (pAfter.rzTargetShare || 0) : yBefore;
        } else if (chartId === 'rb-eval-total-rz') {
            xBefore = pBefore ? (pBefore.opportunities || 0) : 0;
            yBefore = pBefore ? (pBefore.rzOpportunities || 0) : 0;
            xAfter = pAfter ? (pAfter.opportunities || 0) : xBefore;
            yAfter = pAfter ? (pAfter.rzOpportunities || 0) : yBefore;
        } else if (chartId === 'rb-eval-volume-efficiency') {
            xBefore = pBefore ? (pBefore.opportunities || 0) : 0;
            yBefore = pBefore ? (pBefore.efficiency || 0) : 0;
            xAfter = pAfter ? (pAfter.opportunities || 0) : xBefore;
            yAfter = pAfter ? (pAfter.efficiency || 0) : yBefore;
        } else if (chartId === 'wr-eval-production-volume') {
            xBefore = pBefore ? ((pBefore.targets || 0) / (pBefore.weeksInSegment || 1)) : 0;
            yBefore = pBefore ? ((pBefore.fpts || 0) / (pBefore.weeksInSegment || 1)) : 0;
            xAfter = pAfter ? ((pAfter.targets || 0) / (pAfter.weeksInSegment || 1)) : xBefore;
            yAfter = pAfter ? ((pAfter.fpts || 0) / (pAfter.weeksInSegment || 1)) : yBefore;
        } else if (chartId === 'rb-eval-production-volume') {
            xBefore = pBefore ? ((pBefore.opportunities || 0) / (pBefore.weeksInSegment || 1)) : 0;
            yBefore = pBefore ? ((pBefore.fpts || 0) / (pBefore.weeksInSegment || 1)) : 0;
            xAfter = pAfter ? ((pAfter.opportunities || 0) / (pAfter.weeksInSegment || 1)) : xBefore;
            yAfter = pAfter ? ((pAfter.fpts || 0) / (pAfter.weeksInSegment || 1)) : yBefore;
        }

        // Linear interpolation (lerp)
        const x = xBefore + (xAfter - xBefore) * interpolationFactor;
        const y = yBefore + (yAfter - yBefore) * interpolationFactor;

        // Store trail data
        if (!smoothTrendPlayerTrails[chartId][player.player]) {
            smoothTrendPlayerTrails[chartId][player.player] = [];
        }
        const trail = smoothTrendPlayerTrails[chartId][player.player];
        trail.push({ x, y, segment: segmentFloat });  // v7: segment instead of week

        // Keep only last N positions (unless showing full trail at end)
        if (!showFullTrail && trail.length > state.maxTrailLength) {
            trail.shift();
        }

        return {
            x: x,
            y: y,
            label: player.player,
            player: player,
            trail: [...trail] // Copy trail for rendering
        };
    });

    // Render the chart with trails
    renderSmoothTrendChart(chartId, interpolatedData);
}

/**
 * Render chart with smooth data and trails
 */
function renderSmoothTrendChart(chartId, data) {
    const ctx = document.getElementById(chartId);
    if (!ctx) return;

    // v7: Calculate fixed axis ranges from ALL segments (not just current frame)
    const isWR = chartId.includes('wr-eval');
    const segmentData = isWR ? segmentDataWR : segmentDataRB;  // v7: use segmentData
    const segments = getAvailableSegments(segmentData);         // v7: use segments

    let allXValues = [];
    let allYValues = [];

    segments.forEach(segment => {                               // v7: iterate segments
        const segmentPlayers = getEvaluationSegmentData(segmentData, segment);  // v7: get segment data
        segmentPlayers.forEach(player => {
            if (chartId === 'wr-eval-volume-efficiency') {
                allXValues.push(player.targets || 0);
                allYValues.push(player.fptsPerTarget || 0);
            } else if (chartId === 'wr-eval-share-rz') {
                allXValues.push(player.targetShare || 0);
                allYValues.push(player.rzTargetShare || 0);
            } else if (chartId === 'rb-eval-total-rz') {
                allXValues.push(player.opportunities || 0);
                allYValues.push(player.rzOpportunities || 0);
            } else if (chartId === 'rb-eval-volume-efficiency') {
                allXValues.push(player.opportunities || 0);
                allYValues.push(player.efficiency || 0);
            } else if (chartId === 'wr-eval-production-volume') {
                allXValues.push((player.targets || 0) / (player.weeksInSegment || 1));
                allYValues.push((player.fpts || 0) / (player.weeksInSegment || 1));
            } else if (chartId === 'rb-eval-production-volume') {
                allXValues.push((player.opportunities || 0) / (player.weeksInSegment || 1));
                allYValues.push((player.fpts || 0) / (player.weeksInSegment || 1));
            }
        });
    });

    const xMin = Math.min(...allXValues.filter(v => v > 0));
    const xMax = Math.max(...allXValues);
    const yMin = Math.min(...allYValues.filter(v => v > 0));
    const yMax = Math.max(...allYValues);

    // Calculate medians for quadrant lines
    const xValues = allXValues.filter(v => v > 0).sort((a, b) => a - b);
    const yValues = allYValues.filter(v => v > 0).sort((a, b) => a - b);
    const medianX = xValues[Math.floor(xValues.length / 2)] || 5;
    const medianY = yValues[Math.floor(yValues.length / 2)] || 1.5;

    // Get existing chart
    let chart = window[`${chartId}Chart`];

    if (!chart) {
        // Create new chart with fixed axes
        chart = createSmoothTrendChart(ctx, chartId, medianX, medianY, xMin, xMax, yMin, yMax);
        window[`${chartId}Chart`] = chart;
    }

    // Update chart data (points + trails)
    const datasets = [];

    // Add trail datasets (one per player with trail)
    data.forEach(point => {
        if (point.trail && point.trail.length > 1) {
            const trailData = point.trail.map((t, idx) => ({
                x: t.x,
                y: t.y
            }));

            const teamColor = teamColors[point.player.team] || '#666';
            const r = parseInt(teamColor.slice(1, 3), 16);
            const g = parseInt(teamColor.slice(3, 5), 16);
            const b = parseInt(teamColor.slice(5, 7), 16);

            datasets.push({
                type: 'line',
                data: trailData,
                borderColor: `rgba(${r}, ${g}, ${b}, 0.6)`,  // More opaque (was 0.4)
                backgroundColor: 'transparent',
                borderWidth: 4,  // Thicker trail (was 2)
                pointRadius: 0,
                showLine: true,
                tension: 0.4
            });
        }
    });

    // Add main data points (current positions)
    datasets.push({
        type: 'scatter',
        data: data.map(d => ({ x: d.x, y: d.y, label: d.label, player: d.player })),
        backgroundColor: data.map(d => {
            const color = teamColors[d.player.team] || '#666';
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, 0.85)`;
        }),
        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
        borderWidth: 2,
        pointRadius: 8,
        pointHoverRadius: 12
    });

    chart.data.datasets = datasets;
    chart.update('none'); // No animation for smooth movement
}

/**
 * Create a new chart with fixed configuration
 */
function createSmoothTrendChart(ctx, chartId, medianX, medianY, xMin, xMax, yMin, yMax) {
    // Determine labels based on chart type
    let xLabel, yLabel, quadrantLabels;

    if (chartId === 'wr-eval-volume-efficiency') {
        xLabel = 'Targets per Game →';
        yLabel = 'Fantasy Points per Target →';
        quadrantLabels = {
            topRight: ['Reliable Studs', '(Hold)'],
            topLeft: ['Efficient Sleepers', '(Buy Low)'],
            bottomRight: ['Volume, Poor Efficiency', '(Sell Window)'],
            bottomLeft: ['Bench Fodder']
        };
    } else if (chartId === 'wr-eval-share-rz') {
        xLabel = 'Target Share (% of Team) →';
        yLabel = 'Red Zone Target Share (% of Team) →';
        quadrantLabels = {
            topRight: ['Alpha WR1s'],
            topLeft: ['TD-Dependent', 'Boom/Busts'],
            bottomRight: ['Chain Movers'],
            bottomLeft: ['Background Noise']
        };
    } else if (chartId === 'rb-eval-total-rz') {
        xLabel = 'Opportunities per Game (Rush + Targets) →';
        yLabel = 'Red Zone Opportunities per Game →';
        quadrantLabels = {
            topRight: ['True Workhorses', '(Buy/Hold)'],
            topLeft: ['TD Vultures', '(Sell High)'],
            bottomRight: ['Between-the-20s Backs', '(Neutral)'],
            bottomLeft: ['Irrelevant Depth']
        };
    } else if (chartId === 'rb-eval-volume-efficiency') {
        xLabel = 'Opportunities per Game (Rush + Targets) →';
        yLabel = 'Efficiency (Fantasy Points per Opportunity) →';
        quadrantLabels = {
            topRight: ['Elite Dual Threats'],
            topLeft: ['Breakout Candidates'],
            bottomRight: ['Inefficient', 'Workhorses'],
            bottomLeft: ['Bench Fodder']
        };
    } else if (chartId === 'wr-eval-production-volume') {
        xLabel = 'Targets per Game →';
        yLabel = 'Fantasy Points per Game (FPPG) →';
        quadrantLabels = {
            topRight: ['Elite WR1s'],
            topLeft: ['Efficient Sleepers'],
            bottomRight: ['Volume Drags'],
            bottomLeft: ['Irrelevant']
        };
    } else if (chartId === 'rb-eval-production-volume') {
        xLabel = 'Opportunities per Game →';
        yLabel = 'Fantasy Points per Game (FPPG) →';
        quadrantLabels = {
            topRight: ['Elite Bellcows'],
            topLeft: ['Efficient Backups'],
            bottomRight: ['Plodding Workhorses'],
            bottomLeft: ['Irrelevant']
        };
    }

    return new Chart(ctx, {
        type: 'scatter',
        data: { datasets: [] },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false, // Disable default animations
            layout: {
                padding: {
                    left: 50,
                    right: 50,
                    top: 50,
                    bottom: 50
                }
            },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: (context) => {
                            const p = context.raw.player;
                            if (!p) return '';
                            return [
                                p.player,
                                `X: ${context.parsed.x.toFixed(1)}`,
                                `Y: ${context.parsed.y.toFixed(2)}`,
                                `Total: ${p.aggregate.totalFpts.toFixed(1)} pts`
                            ];
                        }
                    }
                },
                annotation: {
                    annotations: {
                        vLine: {
                            type: 'line',
                            xMin: medianX,
                            xMax: medianX,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        hLine: {
                            type: 'line',
                            yMin: medianY,
                            yMax: medianY,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        topRight: {
                            type: 'label',
                            xValue: xMax * 0.70,  // Much closer to center (was 0.82)
                            yValue: yMax * 0.70,  // Much closer to center (was 0.82)
                            content: quadrantLabels.topRight,
                            color: '#30d158',
                            font: { size: 13, weight: 'bold' }  // Larger (was 10)
                        },
                        topLeft: {
                            type: 'label',
                            xValue: xMin * 1.5,   // Much closer to center (was 1.3)
                            yValue: yMax * 0.70,  // Much closer to center (was 0.82)
                            content: quadrantLabels.topLeft,
                            color: '#0a84ff',
                            font: { size: 13, weight: 'bold' }  // Larger (was 10)
                        },
                        bottomRight: {
                            type: 'label',
                            xValue: xMax * 0.70,  // Much closer to center (was 0.82)
                            yValue: yMin * 2.0,   // Much closer to center (was 1.5)
                            content: quadrantLabels.bottomRight,
                            color: '#FFD60A',
                            font: { size: 13, weight: 'bold' }  // Larger (was 10)
                        },
                        bottomLeft: {
                            type: 'label',
                            xValue: xMin * 1.5,   // Much closer to center (was 1.3)
                            yValue: yMin * 2.0,   // Much closer to center (was 1.5)
                            content: quadrantLabels.bottomLeft,
                            color: '#ff453a',
                            font: { size: 13, weight: 'bold' }  // Larger (was 10)
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: xLabel, color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' },
                    min: xMin * 0.9,
                    max: xMax * 1.1
                },
                y: {
                    title: { display: true, text: yLabel, color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' },
                    min: yMin * 0.9,
                    max: chartId === 'wr-eval-share-rz' ? 110 : yMax * 1.1  // Special case for WR RZ Share
                }
            }
        }
    });
}

/**
 * Update UI helpers
 */
function updatePlayButton(chartId, isPlaying) {
    const btn = document.getElementById(`${chartId}-play-btn`);
    if (btn) {
        if (isPlaying) {
            btn.classList.add('playing');
            btn.querySelector('.play-icon').textContent = '⏸';
        } else {
            btn.classList.remove('playing');
            btn.querySelector('.play-icon').textContent = '▶';
        }
    }
}

/**
 * Update segment label display (v7: NEW FUNCTION)
 */
function updateSegmentLabel(chartId, segmentFloat) {
    const label = document.getElementById(`${chartId}-week-label`);
    if (label && smoothTrendState[chartId]) {
        const isWR = chartId.includes('wr-eval');
        const segmentData = isWR ? segmentDataWR : segmentDataRB;

        // Format the segment label
        const segmentIndex = Math.floor(segmentFloat);
        const weeks = getSegmentWeekRange(segmentData, segmentIndex);

        if (weeks.length > 0) {
            const firstWeek = weeks[0];
            const lastWeek = weeks[weeks.length - 1];
            label.textContent = `Segments ${firstWeek}-${lastWeek}`;
        } else {
            label.textContent = `Segment ${segmentIndex}`;
        }
    }
}

/**
 * Legacy week label function (kept for compatibility)
 */
function updateWeekLabel(chartId, weekFloat) {
    // Redirect to segment label
    updateSegmentLabel(chartId, weekFloat);
}

function updateScrubberPosition(chartId, segmentFloat) {
    const scrubber = document.getElementById(`${chartId}-scrubber`);
    if (scrubber) {
        scrubber.value = segmentFloat;
    }
}



                // Sort table function (now re-renders card tiers)
        function sortTable(position, column) {
            // Re-render player cards (tiers are always sorted by avg points)
            if (position === 'wr') {
                renderWRPlayerCards();
            } else {
                renderRBPlayerCards();
            }
        }

        // Close modal on click outside
        document.getElementById('player-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeModal();
            }
        });

        document.getElementById('team-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeTeamModal();
            }
        });

        // Close modal on ESC key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeModal();
                closeTeamModal();
            }
        });

        // 6. INITIALIZATION

        window.addEventListener('DOMContentLoaded', function() {
            // Load sentiment data
            loadSentimentData();

            // Load comments
            const storedComments = localStorage.getItem('ffse_player_comments');
            if (storedComments) {
                playerComments = JSON.parse(storedComments);
            }

            // Check if localStorage has data
            const hasLocalData = localStorage.getItem('wrData') &&
                                 localStorage.getItem('rbData') &&
                                 localStorage.getItem('teData');

            if (hasLocalData) {
                // Load from localStorage first (instant load)
                loadStoredData();

                // Render dashboard if it's the active page
                setTimeout(() => {
                    const dashboardPage = document.getElementById('top-movers');
                    if (dashboardPage && dashboardPage.classList.contains('active')) {
                        renderDashboardCategories();
                        setTimeout(renderMiniScatterPlots, 100);
                    }
                }, 200);

                // Silently fetch updates in background (user can keep using the app)
                fetchDataFromGitHub().catch(err => {                });
            } else {
                // No local data - show loading and fetch from GitHub
                showLoadingIndicator();
                fetchDataFromGitHub();
            }
        });

        // PAGE VISIBILITY API - Pause Animations
        document.addEventListener('visibilitychange', function() {
            // Only run if animationStates is defined (for WR/RB analytics pages)
            if (typeof animationStates === 'undefined') return;

            if (document.hidden) {
                // Page is hidden - pause all animations
                Object.keys(animationStates).forEach(chartId => {
                    if (animationStates[chartId].isPlaying) {
                        // Store that it was playing
                        animationStates[chartId].wasPlayingBeforeHidden = true;
                        // Pause the animation
                        pauseSmoothTrendAnimation(chartId);
                    }
                });
            } else {
                // Page is visible again - resume animations that were playing
                Object.keys(animationStates).forEach(chartId => {
                    if (animationStates[chartId].wasPlayingBeforeHidden) {
                        // Resume the animation
                        playSmoothTrendAnimation(chartId);
                        animationStates[chartId].wasPlayingBeforeHidden = false;
                    }
                });
            }
        });

        // DASHBOARD CATEGORIES SYSTEM

        // Helper: Calculate averages for last 3 games
        function getLast3GamesAvg(player) {
            if (!player.weeks || player.weeks.length === 0) return null;

            // Find the global maximum week across ALL WRs, RBs, and TEs (the current week of the season)
            let globalMaxWeek = 0;

            // Check all WRs
            Object.values(aggregatedWRs).forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });

            // Check all RBs
            Object.values(aggregatedRBs).forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });

            // Check all TEs
            Object.values(aggregatedTEs).forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });

            if (globalMaxWeek === 0) return null;

            // The last 3 weeks are based on the GLOBAL max week (current week of season)
            const last3ActualWeeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
            const prior3ActualWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];

            // Filter to only games within the last 3 actual weeks where player had fantasy points
            let last3WeeksGames = player.weeks.filter(w =>
                last3ActualWeeks.includes(w.week) && w.fpts > 0
            );

            // NEW LOGIC: If player only has 1 game in last 3 weeks (e.g., injured/bye most recent week)
            // but has 2+ games in weeks 2-3 of the window, use those 2 weeks
            let usedAlternateWeeks = false;
            if (last3WeeksGames.length === 1) {
                // Check if they have data from weeks globalMaxWeek-1 and globalMaxWeek-2
                const weeks2and3 = player.weeks.filter(w =>
                    [globalMaxWeek - 1, globalMaxWeek - 2].includes(w.week) && w.fpts > 0
                );

                if (weeks2and3.length >= 2) {
                    // Use these 2 weeks for "last 3"
                    last3WeeksGames = weeks2and3;
                    usedAlternateWeeks = true;
                }
            }

            // If still less than 2 games, try getting most recent games regardless of week
            if (last3WeeksGames.length < 2) {
                // Get all games with points, sorted by week descending
                const allGamesWithPoints = player.weeks
                    .filter(w => w.fpts > 0)
                    .sort((a, b) => b.week - a.week);

                if (allGamesWithPoints.length >= 2) {
                    last3WeeksGames = allGamesWithPoints.slice(0, Math.min(3, allGamesWithPoints.length));
                    usedAlternateWeeks = true;
                }
            }

            // Filter for prior 3 weeks
            let prior3WeeksGames = player.weeks.filter(w =>
                prior3ActualWeeks.includes(w.week) && w.fpts > 0
            );

            // If we used alternate weeks for last 3, adjust prior weeks accordingly
            if (usedAlternateWeeks && last3WeeksGames.length > 0) {
                const oldestRecentWeek = Math.min(...last3WeeksGames.map(w => w.week));
                // Get 3 games before the oldest recent week
                prior3WeeksGames = player.weeks
                    .filter(w => w.week < oldestRecentWeek && w.fpts > 0)
                    .sort((a, b) => b.week - a.week)
                    .slice(0, 3);
            }

            // Count how many of the last 3 weeks the player actually played with points
            const gamesPlayed = last3WeeksGames.length;

            // Player must have played at least 2 games
            if (gamesPlayed < 2) return null;

            const totalPoints = last3WeeksGames.reduce((sum, w) => sum + w.fpts, 0);
            const avgPoints = totalPoints / gamesPlayed;

            let avgVolume = 0;
            if (player.position === 'WR' || player.position === 'TE') {
                avgVolume = last3WeeksGames.reduce((sum, w) => sum + (w.targets || 0), 0) / gamesPlayed;
            } else {
                avgVolume = last3WeeksGames.reduce((sum, w) => sum + (w.opportunities || 0), 0) / gamesPlayed;
            }

            const efficiency = avgVolume > 0 ? avgPoints / avgVolume : 0;

            // Calculate prior 3 weeks metrics for comparison
            let priorAvgVolume = 0;
            let priorEfficiency = 0;
            let priorRzOppsPerGame = 0;

            if (prior3WeeksGames.length >= 2) {
                if (player.position === 'WR' || player.position === 'TE') {
                    priorAvgVolume = prior3WeeksGames.reduce((sum, w) => sum + (w.targets || 0), 0) / prior3WeeksGames.length;
                } else {
                    priorAvgVolume = prior3WeeksGames.reduce((sum, w) => sum + (w.opportunities || 0), 0) / prior3WeeksGames.length;
                }
                priorEfficiency = priorAvgVolume > 0 ? prior3WeeksGames.reduce((sum, w) => sum + w.fpts, 0) / prior3WeeksGames.length / priorAvgVolume : 0;

                // Calculate prior RZ opps
                const rawData = player.position === 'WR' ? wrData : (player.position === 'TE' ? teData : rbData);
                if (rawData) {
                    let priorTotalRzOpps = 0;
                    prior3WeeksGames.forEach(weekData => {
                        const weekNum = weekData.week;
                        const weekRow = rawData.find(row =>
                            row.Team === player.team &&
                            row.Player === player.name &&
                            parseInt(row.Week) === weekNum
                        );
                        if (weekRow) {
                            if (player.position === 'WR' || player.position === 'TE') {
                                priorTotalRzOpps += parseFloat(weekRow.RZTGT) ||
                                                  parseFloat(weekRow['RZ TGT']) ||
                                                  parseFloat(weekRow.RZ_TGT) ||
                                                  parseFloat(weekRow['Red Zone Targets']) ||
                                                  0;
                            } else {
                                const rzAtt = parseFloat(weekRow.RZ_RUSH_ATT) ||
                                             parseFloat(weekRow['RZ_RUSH_ATT']) ||
                                             parseFloat(weekRow.RZATT) ||
                                             parseFloat(weekRow['RZ ATT']) ||
                                             parseFloat(weekRow.RZ_ATT) ||
                                             0;
                                const rzTgt = parseFloat(weekRow['RZ TGT']) ||
                                             parseFloat(weekRow.RZ_TGT) ||
                                             parseFloat(weekRow.RZTGT) ||
                                             0;
                                priorTotalRzOpps += rzAtt + rzTgt;
                            }
                        }
                    });
                    priorRzOppsPerGame = priorTotalRzOpps / prior3WeeksGames.length;
                }
            }

            // Calculate RZ opportunities from last 3 weeks
            let totalRzOpps = 0;
            const rawData = player.position === 'WR' ? wrData : (player.position === 'TE' ? teData : rbData);
            if (rawData) {
                last3WeeksGames.forEach(weekData => {
                    const weekNum = weekData.week;
                    const weekRow = rawData.find(row =>
                        row.Team === player.team &&
                        row.Player === player.name &&
                        parseInt(row.Week) === weekNum
                    );
                    if (weekRow) {
                        if (player.position === 'WR' || player.position === 'TE') {
                            // Try multiple column name variations for WR/TE red zone targets
                            totalRzOpps += parseFloat(weekRow.RZTGT) ||
                                          parseFloat(weekRow['RZ TGT']) ||
                                          parseFloat(weekRow.RZ_TGT) ||
                                          parseFloat(weekRow['Red Zone Targets']) ||
                                          0;
                        } else {
                            // For RBs: Red zone attempts + red zone targets
                            const rzAtt = parseFloat(weekRow.RZ_RUSH_ATT) ||
                                         parseFloat(weekRow['RZ_RUSH_ATT']) ||
                                         parseFloat(weekRow.RZATT) ||
                                         parseFloat(weekRow['RZ ATT']) ||
                                         parseFloat(weekRow.RZ_ATT) ||
                                         0;
                            const rzTgt = parseFloat(weekRow['RZ TGT']) ||
                                         parseFloat(weekRow.RZ_TGT) ||
                                         parseFloat(weekRow.RZTGT) ||
                                         0;
                            totalRzOpps += rzAtt + rzTgt;
                        }
                    }
                });
            }

            return {
                avgPoints,
                avgVolume,
                efficiency,
                gamesPlayed,
                rzOppsPerGame: totalRzOpps / gamesPlayed,
                globalMaxWeek,  // Include for debugging if needed
                // Prior 3 weeks for comparison
                priorAvgVolume,
                priorEfficiency,
                priorRzOppsPerGame
            };
        }

        function calculateDashboardCategories() {
            // Combine WR, RB, and TE players with minimum 3 games played
            const allEligiblePlayers = [
                ...Object.values(aggregatedWRs).filter(p => p.gamesPlayed >= 3),
                ...Object.values(aggregatedRBs).filter(p => p.gamesPlayed >= 3),
                ...Object.values(aggregatedTEs).filter(p => p.gamesPlayed >= 3)
            ];

            if (allEligiblePlayers.length === 0) return null;

            // Helper function: Check if player should be excluded due to inactivity
            // Returns true if player should be EXCLUDED (hasn't played in 3+ weeks without 2 games back)
            function shouldExcludePlayerForInactivity(player) {
                if (!player.weeks || player.weeks.length === 0) return true;

                // Find global max week (current week)
                let globalMaxWeek = 0;
                [...Object.values(aggregatedWRs), ...Object.values(aggregatedRBs), ...Object.values(aggregatedTEs)].forEach(p => {
                    if (p.weeks && p.weeks.length > 0) {
                        const maxWeek = Math.max(...p.weeks.map(w => w.week));
                        if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                    }
                });

                // Get player's games with points
                const gamesWithPoints = player.weeks.filter(w => w.fpts > 0).sort((a, b) => b.week - a.week);
                if (gamesWithPoints.length === 0) return true;

                const mostRecentGame = gamesWithPoints[0];
                const weeksAgo = globalMaxWeek - mostRecentGame.week;

                // If player's last game was 3+ weeks ago
                if (weeksAgo >= 3) {
                    // Check if they have 2+ games since coming back
                    // "Coming back" means any games after a 3+ week absence
                    // Count games in the last 3 weeks
                    const recentGames = player.weeks.filter(w =>
                        w.week >= (globalMaxWeek - 2) && w.fpts > 0
                    );

                    // If they don't have at least 2 recent games, exclude them
                    if (recentGames.length < 2) {
                        return true; // EXCLUDE
                    }
                }

                return false; // INCLUDE
            }

            // Add last 3 games data to each player and filter by 7+ PPG and activity
            const playersWithLast3 = allEligiblePlayers
                .filter(p => !shouldExcludePlayerForInactivity(p)) // NEW: Filter out inactive players
                .map(p => {
                    const last3 = getLast3GamesAvg(p);
                    return { ...p, last3 };
                })
                .filter(p => {
                    // getLast3GamesAvg returns null if player hasn't played 2 of last 3 weeks
                    if (!p.last3) return false;
                    // MIN 7 PPG filter
                    return p.last3.avgPoints >= 7.0;
                });

            const categories = {
                volumeMonsters: calculateVolumeMonsters(playersWithLast3),
                efficiencyElites: calculateEfficiencyElites(playersWithLast3),
                redZoneKingsWR: calculateRedZoneKingsWR(playersWithLast3),
                redZoneBacks: calculateRedZoneBacks(playersWithLast3),
                rbEfficiency: calculateRBEfficiency(playersWithLast3),
                consistentFloor: calculateConsistentFloor(playersWithLast3),
                airYardsLeaders: calculateAirYardsLeaders(playersWithLast3),
                passCatchingBacks: calculatePassCatchingBacks(playersWithLast3),
                targetLeadersTE: calculateTargetLeadersTE(playersWithLast3),
                redZoneDominanceTE: calculateRedZoneDominanceTE(playersWithLast3),
                totalTouchdownLeadersWR: calculateTotalTouchdownLeadersWR(playersWithLast3)
            };

            return categories;
        }

        // Category 1: Volume Monsters (Last 3 Games) - RBs Only
        function calculateVolumeMonsters(players) {
            // Filter to only RBs
            const rbPlayers = players.filter(p => p.position === 'RB');

            const volumeData = rbPlayers.map(p => {
                const volume = p.last3.avgVolume; // Use last 3 games average
                const priorVolume = p.last3.priorAvgVolume || 0;
                const change = priorVolume > 0 ? volume - priorVolume : 0;
                return { player: p, value: volume, change: change };
            }).sort((a, b) => b.value - a.value);

            // Get 75th percentile threshold
            const threshold = volumeData[Math.floor(volumeData.length * 0.25)]?.value || 0;

            return volumeData
                .filter(d => d.value >= threshold)
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'Opps/Game (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'High touch volume (last 3 games) - workhouse usage',
                    scatterKey: 'volume-efficiency'
                }));
        }

        // Category 2: Efficiency Elites (Last 3 Games)
        function calculateEfficiencyElites(players) {
            const efficiencyData = players
                .filter(p => p.avgPoints >= 7) // Only players with 7+ PPG
                .map(p => {
                    const efficiency = p.last3.efficiency; // Use last 3 games efficiency
                    const priorEfficiency = p.last3.priorEfficiency || 0;
                    const change = priorEfficiency > 0 ? efficiency - priorEfficiency : 0;
                    return { player: p, value: efficiency, change: change };
                }).sort((a, b) => b.value - a.value);

            // Top 20%
            return efficiencyData
                .slice(0, Math.ceil(efficiencyData.length * 0.2))
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(2),
                    metricLabel: d.player.position === 'WR' ? 'Pts/Tgt (L3)' : 'Pts/Opp (L3)',
                    change: d.change.toFixed(2),
                    explanation: 'Elite production per touch (last 3 games) - league winner upside if volume increases',
                    scatterKey: 'volume-efficiency'
                }));
        }

        // Category 3: Red Zone Kings WR (Last 3 Games) - WRs Only
        function calculateRedZoneKingsWR(players) {
            // Filter to only WRs
            const wrPlayers = players.filter(p => p.position === 'WR');

            const redZoneData = wrPlayers.map(p => {
                const rzPerGame = p.last3.rzOppsPerGame; // Use last 3 games RZ opps
                const priorRzPerGame = p.last3.priorRzOppsPerGame || 0;
                const change = priorRzPerGame > 0 ? rzPerGame - priorRzPerGame : 0;
                return { player: p, value: rzPerGame, change: change };
            })
            .filter(d => d.value > 0) // Only players with RZ opportunities
            .sort((a, b) => b.value - a.value);

            // Take top 8 WRs
            return redZoneData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'RZ Tgt/G (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'WRs with highest red zone target rate (last 3 games) - weekly TD upside',
                    scatterKey: 'redzone'
                }));
        }

        // Category 4: Red Zone Backs (Last 3 Games) - RBs Only
        function calculateRedZoneBacks(players) {
            // Filter to only RBs
            const rbPlayers = players.filter(p => p.position === 'RB');

            const redZoneData = rbPlayers.map(p => {
                const rzPerGame = p.last3.rzOppsPerGame; // Use last 3 games RZ opps (rush + targets)
                const priorRzPerGame = p.last3.priorRzOppsPerGame || 0;
                const change = priorRzPerGame > 0 ? rzPerGame - priorRzPerGame : 0;
                return { player: p, value: rzPerGame, change: change };
            })
            .filter(d => d.value > 0) // Only players with RZ opportunities
            .sort((a, b) => b.value - a.value);

            // Take top 8 RBs
            return redZoneData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'RZ Opps/G (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'RBs with highest red zone usage (last 3 games) - carries + targets in scoring position',
                    scatterKey: 'redzone'
                }));
        }

        // Category 5: RB Efficiency (Last 3 Games) - Rushing Yards Per Attempt
        function calculateRBEfficiency(players) {
            // Filter to only RBs
            const rbPlayers = players.filter(p => p.position === 'RB');

            const efficiencyData = rbPlayers.map(p => {
                // Calculate yards per attempt from last 3 games
                let totalYards = 0;
                let totalAttempts = 0;
                let priorTotalYards = 0;
                let priorTotalAttempts = 0;

                if (p.weeks && p.weeks.length > 0) {
                    // Get the global max week
                    let globalMaxWeek = 0;
                    Object.values(aggregatedRBs).forEach(rb => {
                        if (rb.weeks && rb.weeks.length > 0) {
                            const maxWeek = Math.max(...rb.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });

                    const last3Weeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
                    const prior3Weeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];

                    // Sum yards and attempts from last 3 weeks
                    p.weeks.forEach(w => {
                        if (last3Weeks.includes(w.week)) {
                            // Get raw data for this week
                            const weekRow = rbData.find(row =>
                                row.Player === p.name &&
                                row.Team === p.team &&
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow) {
                                totalYards += parseFloat(weekRow.YDS) || 0;
                                totalAttempts += parseFloat(weekRow.ATT) || 0;
                            }
                        }
                        // Calculate prior 3 weeks for comparison
                        if (prior3Weeks.includes(w.week)) {
                            const weekRow = rbData.find(row =>
                                row.Player === p.name &&
                                row.Team === p.team &&
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow) {
                                priorTotalYards += parseFloat(weekRow.YDS) || 0;
                                priorTotalAttempts += parseFloat(weekRow.ATT) || 0;
                            }
                        }
                    });
                }

                const yardsPerAttempt = totalAttempts > 0 ? totalYards / totalAttempts : 0;
                const priorYardsPerAttempt = priorTotalAttempts > 0 ? priorTotalYards / priorTotalAttempts : 0;
                const change = priorYardsPerAttempt > 0 ? yardsPerAttempt - priorYardsPerAttempt : 0;

                return {
                    player: p,
                    value: yardsPerAttempt,
                    totalAttempts: totalAttempts,
                    change: change
                };
            })
            .filter(d => d.totalAttempts >= 20) // Minimum 20 attempts over last 3 games
            .sort((a, b) => b.value - a.value);

            // Take top 8 RBs
            return efficiencyData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(2),
                    metricLabel: 'Yds/Att (L3)',
                    change: d.change,
                    explanation: 'RBs with highest yards per carry (last 3 games) - explosive rushing efficiency',
                    scatterKey: 'volume-efficiency'
                }));
        }

        // Category 4: Buy Low Gems (Last 3 Games Performance)
        function calculateBuyLowGems(players) {
            const buyLowData = players.map(p => {
                // High opportunity share on good offense, but underperforming recently
                const oppShare = p.latestWeekOppShare || 0;
                const teamPts = p.latestWeekTeamPoints || 0;
                const situationScore = oppShare * (teamPts / 30); // Normalize team points
                const actualPPG = p.last3.avgPoints; // Use last 3 games average
                const expectedPPG = situationScore * 2; // Rough expected
                const underperformance = expectedPPG - actualPPG;

                return {
                    player: p,
                    value: underperformance,
                    situationScore: situationScore,
                    actualPPG: actualPPG
                };
            })
            .filter(d => d.underperformance > 0 && d.situationScore > 15)
            .sort((a, b) => b.value - a.value);

            return buyLowData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.actualPPG.toFixed(1),
                    metricLabel: 'PPG (L3)',
                    score: d.situationScore.toFixed(0),
                    explanation: 'Good situation + volume, recent production should improve',
                    scatterKey: 'opportunity-share'
                }));
        }

        // Category 5: Sell High Alerts (Last 3 Games Variance)
        function calculateSellHighAlerts(players) {
            const sellHighData = players.map(p => {
                // Calculate variance from last 3 games
                const last3Weeks = [...p.weeks].sort((a, b) => b.week - a.week).slice(0, 3);
                const variances = last3Weeks.map(w => {
                    const weekAvg = w.fpts;
                    return Math.pow(weekAvg - p.last3.avgPoints, 2);
                });
                const variance = variances.reduce((sum, v) => sum + v, 0) / variances.length;
                const stdDev = Math.sqrt(variance);
                const consistency = 10 / (stdDev + 1);

                const ppg = p.last3.avgPoints; // Use last 3 games average

                return {
                    player: p,
                    value: ppg,
                    consistency: consistency,
                    stdDev: stdDev
                };
            })
            .filter(d => d.value > 12) // High recent PPG
            .sort((a, b) => a.consistency - b.consistency); // Low consistency (high variance)

            return sellHighData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'PPG (L3)',
                    score: d.consistency.toFixed(1),
                    explanation: 'Boom/bust scoring recently - sell while value is high',
                    scatterKey: 'floor-ceiling'
                }));
        }

        // Category 6: Bellcows / Target Hogs (Recent Performance)
        function calculateBellcowsTargetHogs(players) {
            const bellcowData = players.map(p => {
                // Calculate average opportunity share over last 3 weeks
                const last3Weeks = [...p.weeks].sort((a, b) => b.week - a.week).slice(0, 3);
                let totalShare = 0;
                let weekCount = 0;

                last3Weeks.forEach(weekData => {
                    const rawData = p.position === 'WR' ? wrData : rbData;
                    if (rawData) {
                        const weekRow = rawData.find(row =>
                            row.Team === p.team &&
                            row.Player === p.name &&
                            parseInt(row.Week) === weekData.week
                        );
                        if (weekRow && weekRow['Opp Share']) {
                            totalShare += parseFloat(weekRow['Opp Share']) || 0;
                            weekCount++;
                        }
                    }
                });

                const avgShare = weekCount > 0 ? totalShare / weekCount : 0;
                const threshold = p.position === 'WR' ? 28 : 70; // WR: 28% target share, RB: 70% opp share

                return { player: p, value: avgShare, threshold: threshold };
            })
            .filter(d => d.value >= d.threshold)
            .sort((a, b) => b.value - a.value);

            return bellcowData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1) + '%',
                    metricLabel: d.player.position === 'WR' ? 'Tgt Share (L3)' : 'Opp Share (L3)',
                    score: d.player.last3.avgPoints.toFixed(1),
                    explanation: d.player.position === 'WR' ?
                        'Target hog over last 3 games - will get volume in any game script' :
                        'Bellcow back over last 3 games - elite workload share',
                    scatterKey: 'opportunity-share'
                }));
        }

        // Category 7: High-Volume Alphas (Last 3 Games) - WRs Only, Based on Targets
        function calculateConsistentFloor(players) {
            // Filter to only WRs
            const wrPlayers = players.filter(p => p.position === 'WR');

            const consistentData = wrPlayers.map(p => {
                // Use targets per game as the consistency metric for WRs
                const targetsPerGame = p.last3.avgVolume; // For WRs, avgVolume is targets
                const ppg = p.last3.avgPoints;
                const priorTargetsPerGame = p.last3.priorAvgVolume || 0;
                const change = priorTargetsPerGame > 0 ? targetsPerGame - priorTargetsPerGame : 0;

                return {
                    player: p,
                    value: targetsPerGame,
                    ppg: ppg,
                    change: change
                };
            })
            .filter(d => d.ppg > 8 && d.value >= 6) // Decent production and minimum target volume
            .sort((a, b) => b.value - a.value); // Sort by targets per game

            return consistentData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'Tgt/Game (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'Consistent target volume recently - reliable PPR floor',
                    scatterKey: 'volume-efficiency'
                }));
        }

        // Category 8: Air Yards Leaders (Last 3 Games) - WRs Only
        function calculateAirYardsLeaders(players) {
            // Filter to only WRs
            const wrPlayers = players.filter(p => p.position === 'WR');

            const airYardsData = wrPlayers.map(p => {
                // Calculate air yards per game from last 3 games
                let totalAirYards = 0;
                let gameCount = 0;

                if (p.weeks && p.weeks.length > 0) {
                    // Get the global max week
                    let globalMaxWeek = 0;
                    Object.values(aggregatedWRs).forEach(wr => {
                        if (wr.weeks && wr.weeks.length > 0) {
                            const maxWeek = Math.max(...wr.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });

                    const last3Weeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];

                    // Sum air yards from last 3 weeks
                    p.weeks.forEach(w => {
                        if (last3Weeks.includes(w.week)) {
                            // Get raw data for this week
                            const weekRow = wrData.find(row =>
                                row.Team === p.team &&
                                row.Player === p.name &&
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow && weekRow['Air Yards']) {
                                totalAirYards += parseFloat(weekRow['Air Yards']) || 0;
                                gameCount++;
                            }
                        }
                    });
                }

                const airYardsPerGame = gameCount > 0 ? totalAirYards / gameCount : 0;

                // Calculate prior weeks for change
                let priorAirYards = 0;
                let priorGameCount = 0;

                if (p.weeks && p.weeks.length > 0) {
                    let globalMaxWeek = 0;
                    Object.values(aggregatedWRs).forEach(wr => {
                        if (wr.weeks && wr.weeks.length > 0) {
                            const maxWeek = Math.max(...wr.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });

                    const priorWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];

                    p.weeks.forEach(w => {
                        if (priorWeeks.includes(w.week)) {
                            const weekRow = wrData.find(row =>
                                row.Team === p.team &&
                                row.Player === p.name &&
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow && weekRow['Air Yards']) {
                                priorAirYards += parseFloat(weekRow['Air Yards']) || 0;
                                priorGameCount++;
                            }
                        }
                    });
                }

                const priorAirYardsPerGame = priorGameCount > 0 ? priorAirYards / priorGameCount : 0;
                const change = priorAirYardsPerGame > 0 ? airYardsPerGame - priorAirYardsPerGame : 0;

                return { player: p, value: airYardsPerGame, change: change };
            })
            .filter(d => d.value > 0)
            .sort((a, b) => b.value - a.value);

            return airYardsData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'Air Yds/G (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'Deep threat potential - high air yards signal downfield usage',
                    scatterKey: 'volume-efficiency'
                }));
        }

        // Category 9: Pass-Catching Backs (Last 3 Games) - RBs Only
        function calculatePassCatchingBacks(players) {
            // Filter to only RBs
            const rbPlayers = players.filter(p => p.position === 'RB');

            const receivingData = rbPlayers.map(p => {
                // Calculate targets per game from last 3 games
                let totalTargets = 0;
                let gameCount = 0;

                if (p.weeks && p.weeks.length > 0) {
                    // Get the global max week
                    let globalMaxWeek = 0;
                    Object.values(aggregatedRBs).forEach(rb => {
                        if (rb.weeks && rb.weeks.length > 0) {
                            const maxWeek = Math.max(...rb.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });

                    const last3Weeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];

                    // Sum targets from last 3 weeks
                    p.weeks.forEach(w => {
                        if (last3Weeks.includes(w.week)) {
                            // Get raw data for this week
                            const weekRow = rbData.find(row =>
                                row.Team === p.team &&
                                row.Player === p.name &&
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow && weekRow.TGT) {
                                totalTargets += parseFloat(weekRow.TGT) || 0;
                                gameCount++;
                            }
                        }
                    });
                }

                const targetsPerGame = gameCount > 0 ? totalTargets / gameCount : 0;

                // Calculate prior weeks for change
                let priorTargets = 0;
                let priorGameCount = 0;

                if (p.weeks && p.weeks.length > 0) {
                    let globalMaxWeek = 0;
                    Object.values(aggregatedRBs).forEach(rb => {
                        if (rb.weeks && rb.weeks.length > 0) {
                            const maxWeek = Math.max(...rb.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });

                    const priorWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];

                    p.weeks.forEach(w => {
                        if (priorWeeks.includes(w.week)) {
                            const weekRow = rbData.find(row =>
                                row.Team === p.team &&
                                row.Player === p.name &&
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow && weekRow.TGT) {
                                priorTargets += parseFloat(weekRow.TGT) || 0;
                                priorGameCount++;
                            }
                        }
                    });
                }

                const priorTargetsPerGame = priorGameCount > 0 ? priorTargets / priorGameCount : 0;
                const change = priorTargetsPerGame > 0 ? targetsPerGame - priorTargetsPerGame : 0;

                return { player: p, value: targetsPerGame, change: change };
            })
            .filter(d => d.value >= 2.0) // Minimum 2 targets per game
            .sort((a, b) => b.value - a.value);

            return receivingData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'Tgt/Game (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'Pass-catching backs - PPR gold with receiving volume',
                    scatterKey: 'volume-efficiency'
                }));
        }

        // NEW Category 9: TE Target Leaders (Last 3 Games) - TEs Only
        function calculateTargetLeadersTE(players) {
            // Filter to only TEs
            const tePlayers = players.filter(p => p.position === 'TE');

            const targetData = tePlayers.map(p => {
                const targetsPerGame = p.last3.avgVolume; // For TEs, avgVolume is targets per game
                const priorTargetsPerGame = p.last3.priorAvgVolume || 0;
                const change = priorTargetsPerGame > 0 ? targetsPerGame - priorTargetsPerGame : 0;
                return { player: p, value: targetsPerGame, change: change };
            })
            .filter(d => d.value > 0) // Only TEs with targets
            .sort((a, b) => b.value - a.value);

            // Take top 8 TEs
            return targetData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'Tgt/Game (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'TEs with highest target volume (last 3 games) - consistent fantasy floor',
                    scatterKey: 'volume-efficiency'
                }));
        }

        // NEW Category 10: TE Red Zone Dominance (Last 3 Games) - TEs Only
        function calculateRedZoneDominanceTE(players) {
            // Filter to only TEs
            const tePlayers = players.filter(p => p.position === 'TE');

            const redZoneData = tePlayers.map(p => {
                // Calculate combined RZ targets and TDs per game from last 3 games
                let rzTargets = 0;
                let rzTDs = 0;
                let gameCount = 0;

                if (p.weeks && p.weeks.length > 0) {
                    // Get the global max week
                    let globalMaxWeek = 0;
                    Object.values(aggregatedTEs).forEach(te => {
                        if (te.weeks && te.weeks.length > 0) {
                            const maxWeek = Math.max(...te.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });

                    const last3Weeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];

                    // Sum RZ data from last 3 weeks
                    p.weeks.forEach(w => {
                        if (last3Weeks.includes(w.week)) {
                            const weekRow = teData.find(row =>
                                row.Player === p.name &&
                                row.Team === p.team &&
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow) {
                                rzTargets += parseFloat(weekRow.RZ_TGT) || 0;
                                rzTDs += parseFloat(weekRow.RZ_TD) || 0;
                                gameCount++;
                            }
                        }
                    });
                }

                // Weight: RZ targets + (RZ TDs * 3) - TDs are more valuable
                const rzScore = gameCount > 0 ? (rzTargets + (rzTDs * 3)) / gameCount : 0;

                // Calculate prior weeks for change
                let priorRzTargets = 0;
                let priorRzTDs = 0;
                let priorGameCount = 0;

                if (p.weeks && p.weeks.length > 0) {
                    let globalMaxWeek = 0;
                    Object.values(aggregatedTEs).forEach(te => {
                        if (te.weeks && te.weeks.length > 0) {
                            const maxWeek = Math.max(...te.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });

                    const priorWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];

                    p.weeks.forEach(w => {
                        if (priorWeeks.includes(w.week)) {
                            const weekRow = teData.find(row =>
                                row.Player === p.name &&
                                row.Team === p.team &&
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow) {
                                priorRzTargets += parseFloat(weekRow.RZ_TGT) || 0;
                                priorRzTDs += parseFloat(weekRow.RZ_TD) || 0;
                                priorGameCount++;
                            }
                        }
                    });
                }

                const priorRzScore = priorGameCount > 0 ? (priorRzTargets + (priorRzTDs * 3)) / priorGameCount : 0;
                const change = priorRzScore > 0 ? rzScore - priorRzScore : 0;

                return { player: p, value: rzScore, change: change, rzTargets: rzTargets, rzTDs: rzTDs, gameCount: gameCount };
            })
            .filter(d => d.value > 0) // Only TEs with RZ involvement
            .sort((a, b) => b.value - a.value);

            return redZoneData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'RZ Score (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'TEs with most RZ targets + TDs (last 3 games) - weekly TD upside',
                    scatterKey: 'redzone'
                }));
        }

        // NEW Category 11: WR Total Touchdown Leaders (Last 3 Games) - WRs Only
        function calculateTotalTouchdownLeadersWR(players) {
            // Filter to only WRs
            const wrPlayers = players.filter(p => p.position === 'WR');

            const tdData = wrPlayers.map(p => {
                // Calculate total TDs per game from last 3 games (receiving + rushing)
                let recTDs = 0;
                let rushTDs = 0;
                let gameCount = 0;

                if (p.weeks && p.weeks.length > 0) {
                    // Get the global max week
                    let globalMaxWeek = 0;
                    Object.values(aggregatedWRs).forEach(wr => {
                        if (wr.weeks && wr.weeks.length > 0) {
                            const maxWeek = Math.max(...wr.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });

                    const last3Weeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];

                    // Sum TDs from last 3 weeks
                    p.weeks.forEach(w => {
                        if (last3Weeks.includes(w.week)) {
                            const weekRow = wrData.find(row =>
                                row.Player === p.name &&
                                row.Team === p.team &&
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow) {
                                recTDs += parseFloat(weekRow.REC_TD) || 0;
                                rushTDs += parseFloat(weekRow.RUSH_TD) || 0;
                                gameCount++;
                            }
                        }
                    });
                }

                const totalTDs = recTDs + rushTDs;
                const tdsPerGame = gameCount > 0 ? totalTDs / gameCount : 0;

                // Calculate prior weeks for change
                let priorRecTDs = 0;
                let priorRushTDs = 0;
                let priorGameCount = 0;

                if (p.weeks && p.weeks.length > 0) {
                    let globalMaxWeek = 0;
                    Object.values(aggregatedWRs).forEach(wr => {
                        if (wr.weeks && wr.weeks.length > 0) {
                            const maxWeek = Math.max(...wr.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });

                    const priorWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];

                    p.weeks.forEach(w => {
                        if (priorWeeks.includes(w.week)) {
                            const weekRow = wrData.find(row =>
                                row.Player === p.name &&
                                row.Team === p.team &&
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow) {
                                priorRecTDs += parseFloat(weekRow.REC_TD) || 0;
                                priorRushTDs += parseFloat(weekRow.RUSH_TD) || 0;
                                priorGameCount++;
                            }
                        }
                    });
                }

                const priorTotalTDs = priorRecTDs + priorRushTDs;
                const priorTdsPerGame = priorGameCount > 0 ? priorTotalTDs / priorGameCount : 0;
                const change = priorTdsPerGame > 0 ? tdsPerGame - priorTdsPerGame : 0;

                return { player: p, value: tdsPerGame, change: change, recTDs: recTDs, rushTDs: rushTDs, totalTDs: totalTDs };
            })
            .filter(d => d.totalTDs > 0) // Only WRs who scored TDs
            .sort((a, b) => b.value - a.value);

            return tdData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(2),
                    metricLabel: 'TDs/Game (L3)',
                    change: d.change.toFixed(2),
                    explanation: 'WRs scoring the most TDs (receiving + rushing) in last 3 games',
                    scatterKey: 'redzone'
                }));
        }

        // Category 8: Boom/Bust DFS (Last 3 Games Volatility)
        function calculateBoomBustDFS(players) {
            const boomBustData = players.map(p => {
                // High ceiling, low floor based on last 3 games
                const last3Weeks = [...p.weeks].sort((a, b) => b.week - a.week).slice(0, 3);
                const variances = last3Weeks.map(w => {
                    const weekAvg = w.fpts;
                    return Math.pow(weekAvg - p.last3.avgPoints, 2);
                });
                const variance = variances.reduce((sum, v) => sum + v, 0) / variances.length;
                const stdDev = Math.sqrt(variance);
                const consistency = 10 / (stdDev + 1);

                const ppg = p.last3.avgPoints; // Use last 3 games average
                const ceiling = ppg; // Simplified ceiling

                return {
                    player: p,
                    value: ceiling,
                    consistency: consistency,
                    stdDev: stdDev
                };
            })
            .filter(d => d.value > 10) // Decent recent ceiling
            .sort((a, b) => a.consistency - b.consistency) // Low consistency (high variance)
            .slice(0, 8);

            return boomBustData
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'PPG (L3)',
                    score: d.stdDev.toFixed(1),
                    explanation: 'High recent variance - tournament play, avoid cash games',
                    scatterKey: 'floor-ceiling'
                }));
        }

        // Key Insights state management
        let keyInsightsState = {
            currentIndex: 0,
            insights: [],
            autoRotateInterval: null
        };

        // Render Key Insights widget with dynamic data
        function renderStatOfTheWeek() {
            const statContainer = document.getElementById('stat-of-week');
            if (!statContainer) return;

            const allWRs = Object.values(aggregatedWRs).filter(p => p.gamesPlayed >= 3);
            const allRBs = Object.values(aggregatedRBs).filter(p => p.gamesPlayed >= 3);

            if (allWRs.length === 0 && allRBs.length === 0) return;

            // Create 4 insights - one for each leaderboard category
            const stats = [];

            // Insight 1: High-Volume Alphas (WR) - Tied to leaderboard
            const highTargetWRs = allWRs
                .map(p => ({
                    player: p,
                    targetsPerGame: p.totalTargets / p.gamesPlayed
                }))
                .filter(d => d.targetsPerGame >= 8)
                .sort((a, b) => b.targetsPerGame - a.targetsPerGame);

            if (highTargetWRs.length > 0) {
                const avgHighTarget = highTargetWRs.reduce((sum, p) => sum + p.player.avgPoints, 0) / highTargetWRs.length;
                const avgAllWRs = allWRs.reduce((sum, p) => sum + p.avgPoints, 0) / allWRs.length;
                const difference = avgHighTarget - avgAllWRs;

                stats.push({
                    value: '8+',
                    label: `High-Volume Alphas (${highTargetWRs.length} WRs)`,
                    text: `WRs commanding <strong>8+ targets/game</strong> are averaging <strong>+${difference.toFixed(1)} PPG</strong> over the field. Target these alpha receivers dominating their team's passing offense.`,
                    category: 'High-Volume Alphas'
                });
            }

            // Insight 2: Volume Monsters (RB) - Tied to leaderboard
            const volumeRBs = allRBs
                .map(p => ({
                    player: p,
                    oppsPerGame: p.totalOpportunities / p.gamesPlayed
                }))
                .filter(d => d.oppsPerGame >= 18)
                .sort((a, b) => b.oppsPerGame - a.oppsPerGame);

            if (volumeRBs.length > 0) {
                const avgVolRBPts = volumeRBs.reduce((sum, p) => sum + p.player.avgPoints, 0) / volumeRBs.length;
                const avgAllRBs = allRBs.reduce((sum, p) => sum + p.avgPoints, 0) / allRBs.length;
                const rbDiff = avgVolRBPts - avgAllRBs;

                stats.push({
                    value: '18+',
                    label: `Volume Monsters (${volumeRBs.length} RBs)`,
                    text: `RBs seeing <strong>18+ opportunities/game</strong> average <strong>+${rbDiff.toFixed(1)} PPG</strong> vs the field. Bell-cow backs deliver consistent RB1 production—prioritize workload.`,
                    category: 'Volume Monsters'
                });
            }

            // Insight 3: Efficiency Elites - Players with 2.76+ PPT
            const allPlayers = [...allWRs, ...allRBs];
            const efficiencyThreshold = 2.76;
            const efficiencyPlayers = allPlayers
                .map(p => {
                    const touches = p.position === 'WR'
                        ? p.totalTargets
                        : (p.totalRushAttempts || 0) + (p.totalTargets || 0);
                    const ppt = touches > 0 ? p.totalPoints / touches : 0;
                    return { player: p, ppt: ppt, touches: touches };
                })
                .filter(d => d.ppt >= efficiencyThreshold && d.touches >= 30)
                .sort((a, b) => b.ppt - a.ppt);

            if (efficiencyPlayers.length > 0) {
                const avgEfficientPPG = efficiencyPlayers.reduce((sum, p) => sum + p.player.avgPoints, 0) / efficiencyPlayers.length;
                const count = efficiencyPlayers.length;

                stats.push({
                    value: efficiencyThreshold.toFixed(2),
                    label: `Efficiency Elites (${count} players)`,
                    text: `Players with <strong>${efficiencyThreshold.toFixed(2)}+ points per touch</strong> average <strong>${avgEfficientPPG.toFixed(1)} PPG</strong>. Elite efficiency often signals quality over quantity—target these players in trades.`,
                    category: 'Efficiency Elites'
                });
            }

            // Insight 4: Red Zone Kings - Players with 2+ RZ opps/game
            const rzThresholdPerGame = 2.0;
            const rzPlayers = allPlayers
                .map(p => ({
                    player: p,
                    rzOppsPerGame: p.rzOpportunities / p.gamesPlayed
                }))
                .filter(d => d.rzOppsPerGame >= rzThresholdPerGame)
                .sort((a, b) => b.rzOppsPerGame - a.rzOppsPerGame);

            if (rzPlayers.length > 0) {
                const avgRZPlayerPPG = rzPlayers.reduce((sum, p) => sum + p.player.avgPoints, 0) / rzPlayers.length;
                const avgAllPlayersPPG = allPlayers.reduce((sum, p) => sum + p.avgPoints, 0) / allPlayers.length;
                const rzAdvantage = avgRZPlayerPPG - avgAllPlayersPPG;
                const count = rzPlayers.length;

                stats.push({
                    value: `${rzThresholdPerGame.toFixed(1)}+`,
                    label: `Red Zone Kings (${count} players)`,
                    text: `Players averaging <strong>${rzThresholdPerGame.toFixed(1)}+ red zone opportunities/game</strong> score <strong>+${rzAdvantage.toFixed(1)} PPG</strong> more than the field. RZ usage = TD equity—target these scoring threats.`,
                    category: 'Red Zone Kings'
                });
            }

            // Store insights and initialize
            keyInsightsState.insights = stats;
            keyInsightsState.currentIndex = 0;

            // Display first insight
            displayInsight(0);

            // Start auto-rotation (15 seconds)
            startInsightRotation();
        }

        // Display a specific insight with fade effect
        function displayInsight(index) {
            const statContainer = document.getElementById('stat-of-week');
            const indicator = document.getElementById('insight-indicator');

            if (!statContainer || keyInsightsState.insights.length === 0) return;

            // Ensure index is within bounds
            index = ((index % keyInsightsState.insights.length) + keyInsightsState.insights.length) % keyInsightsState.insights.length;
            keyInsightsState.currentIndex = index;

            const insight = keyInsightsState.insights[index];

            // Fade out
            statContainer.style.opacity = '0';

            setTimeout(() => {
                // Update content
                statContainer.innerHTML = `
                    <div class="stat-highlight-value">${insight.value}</div>
                    <div class="stat-highlight-content">
                        <div class="stat-highlight-label">${insight.label}</div>
                        <div class="stat-highlight-text">
                            ${insight.text}
                        </div>
                    </div>
                `;

                // Update indicator
                if (indicator) {
                    indicator.textContent = `${index + 1}/${keyInsightsState.insights.length}`;
                }

                // Fade in
                statContainer.style.opacity = '1';
            }, 300);
        }

        // Navigate to next insight
        function nextInsight() {
            stopInsightRotation();
            displayInsight(keyInsightsState.currentIndex + 1);
            startInsightRotation();
        }

        // Navigate to previous insight
        function previousInsight() {
            stopInsightRotation();
            displayInsight(keyInsightsState.currentIndex - 1);
            startInsightRotation();
        }

        // Start auto-rotation every 15 seconds
        function startInsightRotation() {
            stopInsightRotation(); // Clear any existing interval
            keyInsightsState.autoRotateInterval = setInterval(() => {
                displayInsight(keyInsightsState.currentIndex + 1);
            }, 15000); // 15 seconds
        }

        // Stop auto-rotation
        function stopInsightRotation() {
            if (keyInsightsState.autoRotateInterval) {
                clearInterval(keyInsightsState.autoRotateInterval);
                keyInsightsState.autoRotateInterval = null;
            }
        }

        // DASHBOARD TREND CHARTS

        let dashboardTrendState = {
            wr: {
                isPlaying: false,
                currentTranche: 3,  // Start at final position
                chart: null,
                trails: {},
                fixedAxes: null,
                medianX: null,
                medianY: null,
                filter: 'all'  // 'all', 'positive', 'negative'
            },
            rb: {
                isPlaying: false,
                currentTranche: 3,  // Start at final position
                chart: null,
                trails: {},
                fixedAxes: null,
                medianX: null,
                medianY: null,
                filter: 'all'  // 'all', 'positive', 'negative'
            }
        };

        // Toggle chart expand/collapse
        function toggleChartExpand(position) {
            const wrWidget = document.getElementById('wr-trend-widget');
            const rbWidget = document.getElementById('rb-trend-widget');
            const wrBtn = document.getElementById('wr-expand-btn');
            const rbBtn = document.getElementById('rb-expand-btn');

            if (position === 'wr') {
                if (wrWidget.classList.contains('expanded')) {
                    // Collapse - show both
                    wrWidget.classList.remove('expanded');
                    rbWidget.classList.remove('collapsed');
                    wrBtn.textContent = '⛶';
                    wrBtn.title = 'Expand';
                } else {
                    // Expand WR, hide RB
                    wrWidget.classList.add('expanded');
                    rbWidget.classList.add('collapsed');
                    wrBtn.textContent = '⛶';
                    wrBtn.title = 'Collapse';
                }
            } else {
                if (rbWidget.classList.contains('expanded')) {
                    // Collapse - show both
                    rbWidget.classList.remove('expanded');
                    wrWidget.classList.remove('collapsed');
                    rbBtn.textContent = '⛶';
                    rbBtn.title = 'Expand';
                } else {
                    // Expand RB, hide WR
                    rbWidget.classList.add('expanded');
                    wrWidget.classList.add('collapsed');
                    rbBtn.textContent = '⛶';
                    rbBtn.title = 'Collapse';
                }
            }

            // Re-render charts after expansion animation
            setTimeout(() => {
                if (position === 'wr' || !wrWidget.classList.contains('collapsed')) {
                    renderDashboardWRTrend();
                }
                if (position === 'rb' || !rbWidget.classList.contains('collapsed')) {
                    renderDashboardRBTrend();
                }
            }, 100);
        }

        // Set dashboard filter for movers
        function setDashboardFilter(position, filter) {
            dashboardTrendState[position].filter = filter;

            // Update button states for this position's filter buttons
            ['all', 'positive', 'negative'].forEach(f => {
                const btn = document.getElementById(`${position}-filter-${f}`);
                if (btn) {
                    if (f === filter) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
            });

            // Re-render the chart for this position
            if (position === 'wr') {
                renderDashboardWRTrend();
            } else {
                renderDashboardRBTrend();
            }
        }

        // Calculate 3-week tranche averages and total movement
        function calculateTrancheData(players, position) {
            // Find the global maximum week across all players
            let globalMaxWeek = 0;
            players.forEach(player => {
                if (player.weeks && player.weeks.length > 0) {
                    const maxWeek = Math.max(...player.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });

            // Dynamically create tranches based on current max week
            // Tranche 1: Weeks 1-3
            // Tranche 2: Weeks 4-6
            // Tranche 3: Latest weeks (will be 7-8 for Week 8 data, 7-9 for Week 9 data, etc.)
            const tranche3Start = 7;
            const tranche3Weeks = [];
            for (let w = tranche3Start; w <= globalMaxWeek; w++) {
                tranche3Weeks.push(w);
            }

            const tranches = [
                { name: 'Weeks 1-3', weeks: [1, 2, 3] },
                { name: 'Weeks 4-6', weeks: [4, 5, 6] },
                { name: `Weeks ${tranche3Start}-${globalMaxWeek}`, weeks: tranche3Weeks }
            ];

            return players.map(player => {
                const trancheData = tranches.map((tranche, idx) => {
                    const weeksInTranche = player.weeks.filter(w => tranche.weeks.includes(w.week));

                    if (weeksInTranche.length === 0) return null;

                    let volume, efficiency;

                    if (position === 'WR') {
                        // Volume = avg targets per game in tranche
                        volume = weeksInTranche.reduce((sum, w) => sum + (w.targets || 0), 0) / weeksInTranche.length;
                        // Efficiency = points per target
                        const totalTargets = weeksInTranche.reduce((sum, w) => sum + (w.targets || 0), 0);
                        const totalPoints = weeksInTranche.reduce((sum, w) => sum + w.fpts, 0);
                        efficiency = totalTargets > 0 ? totalPoints / totalTargets : 0;
                    } else {
                        // RB: Volume = avg RB opportunities (rush att + targets) per game
                        volume = weeksInTranche.reduce((sum, w) => sum + ((w.rushAttempts || 0) + (w.targets || 0)), 0) / weeksInTranche.length;
                        // Efficiency = points per RB opportunity
                        const totalOpps = weeksInTranche.reduce((sum, w) => sum + ((w.rushAttempts || 0) + (w.targets || 0)), 0);
                        const totalPoints = weeksInTranche.reduce((sum, w) => sum + w.fpts, 0);
                        efficiency = totalOpps > 0 ? totalPoints / totalOpps : 0;
                    }

                    return {
                        tranche: idx + 1,
                        trancheName: tranche.name,
                        volume: volume,
                        efficiency: efficiency,
                        gamesPlayed: weeksInTranche.length
                    };
                }).filter(t => t !== null);

                // Calculate total distance traveled
                let totalDistance = 0;
                if (trancheData.length >= 2) {
                    for (let i = 1; i < trancheData.length; i++) {
                        const dx = trancheData[i].volume - trancheData[i-1].volume;
                        const dy = trancheData[i].efficiency - trancheData[i-1].efficiency;
                        totalDistance += Math.sqrt(dx*dx + dy*dy);
                    }
                }

                return {
                    player: player,
                    tranches: trancheData,
                    totalDistance: totalDistance
                };
            }).filter(p => p.tranches.length > 0);
        }

        // Calculate fixed axis ranges for locked axes and median values
        function calculateFixedAxesAndMedian(trancheData) {
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let allX = [], allY = [];

            // Also collect current week (tranche 3) data separately
            let currentWeekX = [], currentWeekY = [];

            trancheData.forEach(playerData => {
                playerData.tranches.forEach(t => {
                    minX = Math.min(minX, t.volume);
                    maxX = Math.max(maxX, t.volume);
                    minY = Math.min(minY, t.efficiency);
                    maxY = Math.max(maxY, t.efficiency);
                    allX.push(t.volume);
                    allY.push(t.efficiency);

                    // Collect tranche 3 (current week) data
                    if (t.tranche === 3) {
                        currentWeekX.push(t.volume);
                        currentWeekY.push(t.efficiency);
                    }
                });
            });

            // Calculate CURRENT WEEK medians (tranche 3) - this is what we'll use for the lines
            currentWeekX.sort((a, b) => a - b);
            currentWeekY.sort((a, b) => a - b);
            const currentMedianX = currentWeekX.length > 0 ? currentWeekX[Math.floor(currentWeekX.length / 2)] : 0;
            const currentMedianY = currentWeekY.length > 0 ? currentWeekY[Math.floor(currentWeekY.length / 2)] : 0;

            // Calculate overall medians for axis centering
            allX.sort((a, b) => a - b);
            allY.sort((a, b) => a - b);
            const medianX = allX[Math.floor(allX.length / 2)];
            const medianY = allY[Math.floor(allY.length / 2)];
            // Zoom in: center on overall median, show ±60% of range on each side
            const rangeX = maxX - minX;
            const rangeY = maxY - minY;
            const zoomedMinX = medianX - (rangeX * 0.6);
            const zoomedMaxX = medianX + (rangeX * 0.6);
            const zoomedMinY = medianY - (rangeY * 0.6);
            const zoomedMaxY = medianY + (rangeY * 0.6);

            return {
                axes: {
                    x: { min: zoomedMinX, max: zoomedMaxX },
                    y: { min: zoomedMinY, max: zoomedMaxY }
                },
                median: { x: currentMedianX, y: currentMedianY } // Return CURRENT week median
            };
        }

        // Render the combined dashboard trend chart (routes to WR or RB based on currentPosition)
        function renderDashboardCombinedTrend() {
            // Render both charts independently
            renderDashboardWRTrend();
            renderDashboardRBTrend();
        }

        // Render dashboard WR trend chart
        function renderDashboardWRTrend() {
            const canvas = document.getElementById('wr-trend-chart');
            if (!canvas) {                return;
            }

            // Check if we have data
            if (!aggregatedWRs || Object.keys(aggregatedWRs).length === 0) {                return;
            }

            const wrs = Object.values(aggregatedWRs)
                .filter(p => p.gamesPlayed >= 3)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 36);

            const trancheData = calculateTrancheData(wrs, 'WR');

            // Update tranche label based on current position (not last tranche)
            updateTrancheLabel('wr', dashboardTrendState.wr.currentTranche);

            // Calculate fixed axes and median if not set
            if (!dashboardTrendState.wr.fixedAxes) {
                const result = calculateFixedAxesAndMedian(trancheData);
                dashboardTrendState.wr.fixedAxes = result.axes;
                dashboardTrendState.wr.medianX = result.median.x;
                dashboardTrendState.wr.medianY = result.median.y;
            }

            // Find top movers (by distance traveled)
            const sortedByDistance = [...trancheData].sort((a, b) => b.totalDistance - a.totalDistance);
            const topMovers = new Set(sortedByDistance.slice(0, 5).map(d => d.player.id));

            // Calculate movement direction (efficiency change from tranche 2 to 3 - previous to current)
            const movementData = trancheData.map(pd => {
                const effT2 = pd.tranches.find(t => t.tranche === 2)?.efficiency || 0;
                const effT3 = pd.tranches.find(t => t.tranche === 3)?.efficiency || 0;
                const volT2 = pd.tranches.find(t => t.tranche === 2)?.volume || 0;
                const volT3 = pd.tranches.find(t => t.tranche === 3)?.volume || 0;

                // Calculate combined movement (efficiency change + volume change normalized)
                const effChange = effT3 - effT2;
                const volChange = (volT3 - volT2) / 10; // Normalize volume change
                const movement = effChange + volChange;

                return { playerId: pd.player.id, movement };
            });

            // Apply filter based on selection
            const filter = dashboardTrendState.wr.filter;
            let filteredPlayerIds = new Set(trancheData.map(d => d.player.id));

            if (filter === 'positive') {
                // Top 10 positive movers
                const topPositive = movementData
                    .filter(m => m.movement > 0)
                    .sort((a, b) => b.movement - a.movement)
                    .slice(0, 10)
                    .map(m => m.playerId);
                filteredPlayerIds = new Set(topPositive);
            } else if (filter === 'negative') {
                // Top 10 negative movers
                const topNegative = movementData
                    .filter(m => m.movement < 0)
                    .sort((a, b) => a.movement - b.movement)
                    .slice(0, 10)
                    .map(m => m.playerId);
                filteredPlayerIds = new Set(topNegative);
            }

            // Destroy existing chart
            if (dashboardTrendState.wr.chart) {
                dashboardTrendState.wr.chart.destroy();
            }

            // Get current tranche (interpolated)
            const currentTranche = dashboardTrendState.wr.currentTranche;
            let currentData = interpolateTranchePlayers(trancheData, currentTranche, 'wr');

            // Filter data based on selection
            currentData = currentData.filter(d => filteredPlayerIds.has(d.player.id));

            // Build trail data with gradient fade - optimized for performance
            const trailDatasets = [];
            if (currentTranche > 0) {
                // Track current phase (0-1, 1-2, 2-3) and clear trails when phase changes
                const currentPhase = Math.floor(currentTranche);
                if (!dashboardTrendState.wr.lastPhase) {
                    dashboardTrendState.wr.lastPhase = 0;
                }

                // Clear trails when entering a new phase
                if (currentPhase > dashboardTrendState.wr.lastPhase) {
                    dashboardTrendState.wr.trails = {};
                    dashboardTrendState.wr.lastPhase = currentPhase;
                }

                currentData.forEach(point => {
                    const playerId = point.player.id;

                    // Add to trail history
                    if (!dashboardTrendState.wr.trails[playerId]) {
                        dashboardTrendState.wr.trails[playerId] = [];
                    }
                    dashboardTrendState.wr.trails[playerId].push({ x: point.x, y: point.y });

                    // Keep trail length reasonable (max 30 points for better performance)
                    if (dashboardTrendState.wr.trails[playerId].length > 30) {
                        dashboardTrendState.wr.trails[playerId].shift();
                    }

                    // Create trail as a single line dataset with gradient effect
                    const trail = dashboardTrendState.wr.trails[playerId];
                    if (trail.length > 2) {
                        const teamColor = teamColors[point.player.team] || '#666';
                        const r = parseInt(teamColor.slice(1, 3), 16);
                        const g = parseInt(teamColor.slice(3, 5), 16);
                        const b = parseInt(teamColor.slice(5, 7), 16);

                        // Create a single line dataset with all trail points
                        trailDatasets.push({
                            type: 'line',
                            data: trail,
                            borderColor: `rgba(${r}, ${g}, ${b}, 0.3)`,
                            borderWidth: 2.5, // Thicker trail for better visibility
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            tension: 0.4, // Smooth curve
                            segment: {
                                borderColor: ctx => {
                                    // Gradient along the line - fade from transparent to more visible
                                    const progress = ctx.p0DataIndex / (trail.length - 1);
                                    const opacity = 0.1 + (progress * 0.3);
                                    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                                }
                            }
                        });
                    }
                });
            }

            const ctx = canvas.getContext('2d');
            dashboardTrendState.wr.chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        ...trailDatasets,
                        {
                            data: currentData,
                            backgroundColor: currentData.map(d => {
                                const isTopMover = topMovers.has(d.player.id);
                                const color = teamColors[d.player.team] || '#666';
                                const r = parseInt(color.slice(1, 3), 16);
                                const g = parseInt(color.slice(3, 5), 16);
                                const b = parseInt(color.slice(5, 7), 16);
                                return isTopMover ? `rgba(${r}, ${g}, ${b}, 0.9)` : `rgba(${r}, ${g}, ${b}, 0.6)`;
                            }),
                            borderColor: currentData.map(d => {
                                const isTopMover = topMovers.has(d.player.id);
                                const color = teamColors[d.player.team] || '#666';
                                return isTopMover ? color : color;
                            }),
                            borderWidth: 2,
                            pointRadius: 6,
                            pointHoverRadius: 8
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const lastDataset = dashboardTrendState.wr.chart.data.datasets.length - 1;
                            if (elements[0].datasetIndex === lastDataset) {
                                const index = elements[0].index;
                                openPlayerModal(currentData[index].player.id);
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            filter: (tooltipItem) => {
                                // Only show tooltips for main scatter dataset
                                return tooltipItem.datasetIndex === dashboardTrendState.wr.chart.data.datasets.length - 1;
                            },
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    return [
                                        p.name,
                                        `Targets/G: ${context.parsed.x.toFixed(1)}`,
                                        `Pts/Target: ${context.parsed.y.toFixed(2)}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            min: dashboardTrendState.wr.fixedAxes.x.min,
                            max: dashboardTrendState.wr.fixedAxes.x.max,
                            title: { display: true, text: 'Targets per Game', color: '#8e8e93', font: { size: 11 } },
                            grid: {
                                color: '#2c2c2e',
                                drawTicks: true
                            },
                            ticks: {
                                color: '#8e8e93',
                                font: { size: 10 },
                                stepSize: 2
                            }
                        },
                        y: {
                            min: dashboardTrendState.wr.fixedAxes.y.min,
                            max: dashboardTrendState.wr.fixedAxes.y.max,
                            title: { display: true, text: 'Points per Target', color: '#8e8e93', font: { size: 11 } },
                            grid: {
                                color: '#2c2c2e',
                                drawTicks: true
                            },
                            ticks: {
                                color: '#8e8e93',
                                font: { size: 10 },
                                stepSize: 0.5
                            }
                        }
                    }
                },
                plugins: [{
                    id: 'quadrantLines',
                    afterDatasetsDraw: (chart) => {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const xAxis = chart.scales.x;
                        const yAxis = chart.scales.y;

                        // Use stored median values
                        const xMid = dashboardTrendState.wr.medianX;
                        const yMid = dashboardTrendState.wr.medianY;

                        // Draw dotted median lines
                        ctx.strokeStyle = 'rgba(142, 142, 147, 0.5)';
                        ctx.setLineDash([3, 3]);
                        ctx.lineWidth = 1;

                        // Vertical line
                        ctx.beginPath();
                        ctx.moveTo(xAxis.getPixelForValue(xMid), chartArea.top);
                        ctx.lineTo(xAxis.getPixelForValue(xMid), chartArea.bottom);
                        ctx.stroke();

                        // Horizontal line
                        ctx.beginPath();
                        ctx.moveTo(chartArea.left, yAxis.getPixelForValue(yMid));
                        ctx.lineTo(chartArea.right, yAxis.getPixelForValue(yMid));
                        ctx.stroke();

                        ctx.setLineDash([]);

                        // Add quadrant labels - WR Chart
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.textAlign = 'center';

                        const xMidPixel = xAxis.getPixelForValue(xMid);
                        const yMidPixel = yAxis.getPixelForValue(yMid);

                        // Top-right: High Volume + High Efficiency
                        ctx.fillStyle = '#30d158';
                        ctx.fillText('ELITE', (xMidPixel + chartArea.right) / 2, (chartArea.top + yMidPixel) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('High Vol + Efficiency', (xMidPixel + chartArea.right) / 2, (chartArea.top + yMidPixel) / 2 + 8);

                        // Top-left: Low Volume + High Efficiency
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillStyle = '#0a84ff';
                        ctx.fillText('SLEEPER', (chartArea.left + xMidPixel) / 2, (chartArea.top + yMidPixel) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('Efficient, Low Vol', (chartArea.left + xMidPixel) / 2, (chartArea.top + yMidPixel) / 2 + 8);

                        // Bottom-right: High Volume + Low Efficiency
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillStyle = '#FFD60A';
                        ctx.fillText('HOLD', (xMidPixel + chartArea.right) / 2, (yMidPixel + chartArea.bottom) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('Volume, Poor Efficiency', (xMidPixel + chartArea.right) / 2, (yMidPixel + chartArea.bottom) / 2 + 8);

                        // Bottom-left: Low Volume + Low Efficiency
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillStyle = '#ff453a';
                        ctx.fillText('FADE', (chartArea.left + xMidPixel) / 2, (yMidPixel + chartArea.bottom) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('Low Vol + Efficiency', (chartArea.left + xMidPixel) / 2, (yMidPixel + chartArea.bottom) / 2 + 8);
                    }
                }]
            });
        }

        // Render dashboard RB trend chart (similar to WR)
        function renderDashboardRBTrend() {
            const canvas = document.getElementById('rb-trend-chart');
            if (!canvas) {                return;
            }

            // Check if we have data
            if (!aggregatedRBs || Object.keys(aggregatedRBs).length === 0) {                return;
            }

            const rbs = Object.values(aggregatedRBs)
                .filter(p => p.gamesPlayed >= 3)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 36);

            const trancheData = calculateTrancheData(rbs, 'RB');

            // Update tranche label based on current position (not last tranche)
            updateTrancheLabel('rb', dashboardTrendState.rb.currentTranche);

            // Calculate fixed axes and median if not set
            if (!dashboardTrendState.rb.fixedAxes) {
                const result = calculateFixedAxesAndMedian(trancheData);
                dashboardTrendState.rb.fixedAxes = result.axes;
                dashboardTrendState.rb.medianX = result.median.x;
                dashboardTrendState.rb.medianY = result.median.y;
            }

            // Find top movers (by distance traveled)
            const sortedByDistance = [...trancheData].sort((a, b) => b.totalDistance - a.totalDistance);
            const topMovers = new Set(sortedByDistance.slice(0, 5).map(d => d.player.id));

            // Calculate movement direction (efficiency change from tranche 2 to 3 - previous to current)
            const movementData = trancheData.map(pd => {
                const effT2 = pd.tranches.find(t => t.tranche === 2)?.efficiency || 0;
                const effT3 = pd.tranches.find(t => t.tranche === 3)?.efficiency || 0;
                const volT2 = pd.tranches.find(t => t.tranche === 2)?.volume || 0;
                const volT3 = pd.tranches.find(t => t.tranche === 3)?.volume || 0;

                // Calculate combined movement (efficiency change + volume change normalized)
                const effChange = effT3 - effT2;
                const volChange = (volT3 - volT2) / 10; // Normalize volume change
                const movement = effChange + volChange;

                return { playerId: pd.player.id, movement };
            });

            // Apply filter based on selection
            const filter = dashboardTrendState.rb.filter;
            let filteredPlayerIds = new Set(trancheData.map(d => d.player.id));

            if (filter === 'positive') {
                // Top 10 positive movers
                const topPositive = movementData
                    .filter(m => m.movement > 0)
                    .sort((a, b) => b.movement - a.movement)
                    .slice(0, 10)
                    .map(m => m.playerId);
                filteredPlayerIds = new Set(topPositive);
            } else if (filter === 'negative') {
                // Top 10 negative movers
                const topNegative = movementData
                    .filter(m => m.movement < 0)
                    .sort((a, b) => a.movement - b.movement)
                    .slice(0, 10)
                    .map(m => m.playerId);
                filteredPlayerIds = new Set(topNegative);
            }

            // Destroy existing chart
            if (dashboardTrendState.rb.chart) {
                dashboardTrendState.rb.chart.destroy();
            }

            // Get current tranche (interpolated)
            const currentTranche = dashboardTrendState.rb.currentTranche;
            let currentData = interpolateTranchePlayers(trancheData, currentTranche, 'rb');

            // Filter data based on selection
            currentData = currentData.filter(d => filteredPlayerIds.has(d.player.id));

            // Build trail data with gradient fade - optimized for performance
            const trailDatasets = [];
            if (currentTranche > 0) {
                // Track current phase (0-1, 1-2, 2-3) and clear trails when phase changes
                const currentPhase = Math.floor(currentTranche);
                if (!dashboardTrendState.rb.lastPhase) {
                    dashboardTrendState.rb.lastPhase = 0;
                }

                // Clear trails when entering a new phase
                if (currentPhase > dashboardTrendState.rb.lastPhase) {
                    dashboardTrendState.rb.trails = {};
                    dashboardTrendState.rb.lastPhase = currentPhase;
                }

                currentData.forEach(point => {
                    const playerId = point.player.id;

                    // Add to trail history
                    if (!dashboardTrendState.rb.trails[playerId]) {
                        dashboardTrendState.rb.trails[playerId] = [];
                    }
                    dashboardTrendState.rb.trails[playerId].push({ x: point.x, y: point.y });

                    // Keep trail length reasonable (max 30 points for better performance)
                    if (dashboardTrendState.rb.trails[playerId].length > 30) {
                        dashboardTrendState.rb.trails[playerId].shift();
                    }

                    // Create trail as a single line dataset with gradient effect
                    const trail = dashboardTrendState.rb.trails[playerId];
                    if (trail.length > 2) {
                        const teamColor = teamColors[point.player.team] || '#666';
                        const r = parseInt(teamColor.slice(1, 3), 16);
                        const g = parseInt(teamColor.slice(3, 5), 16);
                        const b = parseInt(teamColor.slice(5, 7), 16);

                        // Create a single line dataset with all trail points
                        trailDatasets.push({
                            type: 'line',
                            data: trail,
                            borderColor: `rgba(${r}, ${g}, ${b}, 0.3)`,
                            borderWidth: 2.5, // Thicker trail for better visibility
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            tension: 0.4, // Smooth curve
                            segment: {
                                borderColor: ctx => {
                                    // Gradient along the line - fade from transparent to more visible
                                    const progress = ctx.p0DataIndex / (trail.length - 1);
                                    const opacity = 0.1 + (progress * 0.3);
                                    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                                }
                            }
                        });
                    }
                });
            }

            const ctx = canvas.getContext('2d');
            dashboardTrendState.rb.chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        ...trailDatasets,
                        {
                            data: currentData,
                            backgroundColor: currentData.map(d => {
                                const isTopMover = topMovers.has(d.player.id);
                                const color = teamColors[d.player.team] || '#666';
                                const r = parseInt(color.slice(1, 3), 16);
                                const g = parseInt(color.slice(3, 5), 16);
                                const b = parseInt(color.slice(5, 7), 16);
                                return isTopMover ? `rgba(${r}, ${g}, ${b}, 0.9)` : `rgba(${r}, ${g}, ${b}, 0.6)`;
                            }),
                            borderColor: currentData.map(d => {
                                const color = teamColors[d.player.team] || '#666';
                                return color;
                            }),
                            borderWidth: 2,
                            pointRadius: 6,
                            pointHoverRadius: 8
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const lastDataset = dashboardTrendState.rb.chart.data.datasets.length - 1;
                            if (elements[0].datasetIndex === lastDataset) {
                                const index = elements[0].index;
                                openPlayerModal(currentData[index].player.id);
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            filter: (tooltipItem) => {
                                return tooltipItem.datasetIndex === dashboardTrendState.rb.chart.data.datasets.length - 1;
                            },
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    return [
                                        p.name,
                                        `Opps/G: ${context.parsed.x.toFixed(1)}`,
                                        `Pts/Opp: ${context.parsed.y.toFixed(2)}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            min: dashboardTrendState.rb.fixedAxes.x.min,
                            max: dashboardTrendState.rb.fixedAxes.x.max,
                            title: { display: true, text: 'RB Opportunities per Game', color: '#8e8e93', font: { size: 11 } },
                            grid: {
                                color: '#2c2c2e',
                                drawTicks: true
                            },
                            ticks: {
                                color: '#8e8e93',
                                font: { size: 10 },
                                stepSize: 2
                            }
                        },
                        y: {
                            min: dashboardTrendState.rb.fixedAxes.y.min,
                            max: dashboardTrendState.rb.fixedAxes.y.max,
                            title: { display: true, text: 'Points per Opportunity', color: '#8e8e93', font: { size: 11 } },
                            grid: {
                                color: '#2c2c2e',
                                drawTicks: true
                            },
                            ticks: {
                                color: '#8e8e93',
                                font: { size: 10 },
                                stepSize: 0.2
                            }
                        }
                    }
                },
                plugins: [{
                    id: 'quadrantLines',
                    afterDatasetsDraw: (chart) => {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const xAxis = chart.scales.x;
                        const yAxis = chart.scales.y;

                        // Use stored median values
                        const xMid = dashboardTrendState.rb.medianX;
                        const yMid = dashboardTrendState.rb.medianY;

                        // Draw dotted median lines
                        ctx.strokeStyle = 'rgba(142, 142, 147, 0.5)';
                        ctx.setLineDash([3, 3]);
                        ctx.lineWidth = 1;

                        // Vertical line
                        ctx.beginPath();
                        ctx.moveTo(xAxis.getPixelForValue(xMid), chartArea.top);
                        ctx.lineTo(xAxis.getPixelForValue(xMid), chartArea.bottom);
                        ctx.stroke();

                        // Horizontal line
                        ctx.beginPath();
                        ctx.moveTo(chartArea.left, yAxis.getPixelForValue(yMid));
                        ctx.lineTo(chartArea.right, yAxis.getPixelForValue(yMid));
                        ctx.stroke();

                        ctx.setLineDash([]);

                        // Add quadrant labels - RB Chart
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.textAlign = 'center';

                        const xMidPixel = xAxis.getPixelForValue(xMid);
                        const yMidPixel = yAxis.getPixelForValue(yMid);

                        // Top-right: High Volume + High Efficiency
                        ctx.fillStyle = '#30d158';
                        ctx.fillText('ELITE', (xMidPixel + chartArea.right) / 2, (chartArea.top + yMidPixel) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('High Vol + Efficiency', (xMidPixel + chartArea.right) / 2, (chartArea.top + yMidPixel) / 2 + 8);

                        // Top-left: Low Volume + High Efficiency
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillStyle = '#0a84ff';
                        ctx.fillText('SLEEPER', (chartArea.left + xMidPixel) / 2, (chartArea.top + yMidPixel) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('Efficient, Low Vol', (chartArea.left + xMidPixel) / 2, (chartArea.top + yMidPixel) / 2 + 8);

                        // Bottom-right: High Volume + Low Efficiency
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillStyle = '#FFD60A';
                        ctx.fillText('HOLD', (xMidPixel + chartArea.right) / 2, (yMidPixel + chartArea.bottom) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('Volume, Poor Efficiency', (xMidPixel + chartArea.right) / 2, (yMidPixel + chartArea.bottom) / 2 + 8);

                        // Bottom-left: Low Volume + Low Efficiency
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillStyle = '#ff453a';
                        ctx.fillText('FADE', (chartArea.left + xMidPixel) / 2, (yMidPixel + chartArea.bottom) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('Low Vol + Efficiency', (chartArea.left + xMidPixel) / 2, (yMidPixel + chartArea.bottom) / 2 + 8);
                    }
                }]
            });
        }

        // Easing function for smooth transitions (ease-in-out cubic)
        function easeInOutCubic(t) {
            return t < 0.5
                ? 4 * t * t * t
                : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // Interpolate player positions between tranches
        function interpolateTranchePlayers(trancheData, currentTranche, position) {
            // Get position-specific median for center point
            const medianX = dashboardTrendState[position].medianX;
            const medianY = dashboardTrendState[position].medianY;

            return trancheData.map(playerData => {
                // Handle tranche 0 - all at center
                if (currentTranche === 0) {
                    return {
                        x: medianX,
                        y: medianY,
                        player: playerData.player
                    };
                }

                // For tranches 0-1, interpolate from center to tranche 1
                if (currentTranche < 1) {
                    const data1 = playerData.tranches.find(t => t.tranche === 1);
                    if (!data1) return null;

                    const t = easeInOutCubic(currentTranche); // Apply easing
                    return {
                        x: medianX + (data1.volume - medianX) * t,
                        y: medianY + (data1.efficiency - medianY) * t,
                        player: playerData.player
                    };
                }

                // For tranches >= 1, use existing logic with easing
                const tranche1 = Math.floor(currentTranche);
                const tranche2 = Math.ceil(currentTranche);
                const rawT = currentTranche - tranche1; // interpolation factor (0 to 1)
                const t = easeInOutCubic(rawT); // Apply easing for smooth transitions

                const data1 = playerData.tranches.find(t => t.tranche === tranche1);
                const data2 = playerData.tranches.find(t => t.tranche === tranche2);

                if (!data1 && !data2) return null;
                if (!data2 || tranche1 === tranche2) {
                    return data1 ? {
                        x: data1.volume,
                        y: data1.efficiency,
                        player: playerData.player
                    } : null;
                }
                if (!data1) {
                    return {
                        x: data2.volume,
                        y: data2.efficiency,
                        player: playerData.player
                    };
                }

                // Eased interpolation for rounded transitions
                return {
                    x: data1.volume + (data2.volume - data1.volume) * t,
                    y: data1.efficiency + (data2.efficiency - data1.efficiency) * t,
                    player: playerData.player
                };
            }).filter(d => d !== null);
        }

        // Toggle dashboard trend animation - single run only
        function toggleDashboardTrend(positionParam) {
            // If called with 'combined', use the current position
            const position = positionParam === 'combined' ? dashboardTrendState.currentPosition : positionParam;
            const state = dashboardTrendState[position];

            if (state.isPlaying) {
                // Stop if already playing
                state.isPlaying = false;
                const btn = document.getElementById(`${position}-play-btn`);
                btn.textContent = '▶';
                btn.classList.remove('playing');
                return;
            }

            // Reset to start
            state.currentTranche = 0;
            state.trails = {}; // Clear trails
            state.lastPhase = 0; // Reset phase tracker
            state.isPlaying = true;

            const btn = document.getElementById(`${position}-play-btn`);
            btn.textContent = '⏸';
            btn.classList.add('playing');

            const scrubber = document.getElementById(`${position}-tranche-scrubber`);
            scrubber.value = 0;

            updateTrancheLabel(position, 0);

            animateDashboardTrend(position);
        }

        // Animate dashboard trend - smoother animation
        function animateDashboardTrend(position) {
            const state = dashboardTrendState[position];
            if (!state.isPlaying) return;

            state.currentTranche += 0.0325; // Slowed down by 35% for better visual clarity

            if (state.currentTranche >= 3) {
                state.currentTranche = 3;
                state.isPlaying = false;

                const btn = document.getElementById(`${position}-play-btn`);
                btn.textContent = '▶';
                btn.classList.remove('playing');
            }

            // Update scrubber
            const scrubber = document.getElementById(`${position}-tranche-scrubber`);
            scrubber.value = state.currentTranche;

            // Update label
            updateTrancheLabel(position, state.currentTranche);

            // Re-render appropriate chart
            if (position === 'wr') {
                renderDashboardWRTrend();
            } else {
                renderDashboardRBTrend();
            }

            // Continue animation if still playing
            if (state.isPlaying) {
                requestAnimationFrame(() => animateDashboardTrend(position));
            }
        }

        // Update tranche label
        function updateTrancheLabel(position, tranche) {
            const label = document.getElementById(`${position}-tranche-label`);
            if (!label) return;

            // Find max week dynamically from the data
            let globalMaxWeek = 0;
            const players = position === 'wr' ? aggregatedWRs : aggregatedRBs;
            Object.values(players).forEach(player => {
                if (player.weeks && player.weeks.length > 0) {
                    const maxWeek = Math.max(...player.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });

            // Handle tranche 0 (center position)
            if (tranche === 0) {
                label.textContent = 'Start';
                return;
            }

            // Interpolate between positions for smooth label updates
            if (tranche < 1) {
                label.textContent = 'Start → Weeks 1-3';
                return;
            }

            // Create dynamic tranche names based on actual max week
            const trancheNames = [
                'Start',           // 0
                'Weeks 1-3',       // 1
                'Weeks 4-6',       // 2
                `Weeks 7-${globalMaxWeek}` // 3
            ];

            // For values between tranches, show transition
            if (tranche % 1 !== 0) {
                const idx1 = Math.floor(tranche);
                const idx2 = Math.ceil(tranche);
                label.textContent = `${trancheNames[idx1]} → ${trancheNames[idx2]}`;
            } else {
                // Exact tranche
                const idx = Math.round(tranche);
                label.textContent = trancheNames[idx] || trancheNames[3];
            }
        }

        // Setup scrubber listeners
        function setupDashboardTrendScrubbers() {
            // Setup WR scrubber
            const wrScrubber = document.getElementById('wr-tranche-scrubber');
            if (wrScrubber) {
                wrScrubber.addEventListener('input', (e) => {
                    const tranche = parseFloat(e.target.value);
                    dashboardTrendState.wr.currentTranche = tranche;
                    dashboardTrendState.wr.isPlaying = false;
                    dashboardTrendState.wr.lastPhase = Math.floor(tranche); // Update phase tracker

                    const btn = document.getElementById('wr-play-btn');
                    btn.textContent = '▶';
                    btn.classList.remove('playing');

                    updateTrancheLabel('wr', tranche);
                    renderDashboardWRTrend();
                });
            }

            // Setup RB scrubber
            const rbScrubber = document.getElementById('rb-tranche-scrubber');
            if (rbScrubber) {
                rbScrubber.addEventListener('input', (e) => {
                    const tranche = parseFloat(e.target.value);
                    dashboardTrendState.rb.currentTranche = tranche;
                    dashboardTrendState.rb.isPlaying = false;
                    dashboardTrendState.rb.lastPhase = Math.floor(tranche); // Update phase tracker

                    const btn = document.getElementById('rb-play-btn');
                    btn.textContent = '▶';
                    btn.classList.remove('playing');

                    updateTrancheLabel('rb', tranche);
                    renderDashboardRBTrend();
                });
            }
        }

        // Render Dashboard Categories
        function renderDashboardCategories() {
            const container = document.getElementById('dashboard-categories');
            if (!container) {                return;
            }

            const categories = calculateDashboardCategories();
            if (!categories) {                container.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 40px;">Loading categories...</p>';
                return;
            }

            // Log each category's data
            // Also update stat of the week
            renderStatOfTheWeek();

            // Render dashboard trend chart (both WR and RB)
            renderDashboardCombinedTrend();

            const categoryConfigs = [
                { key: 'volumeMonsters', title: 'Volume Monsters (RB)', color: '#ff453a', tooltip: 'RBs with the highest opportunities (carries + targets) per game in last 3 weeks. High volume = reliable fantasy production.' },
                { key: 'efficiencyElites', title: 'Efficiency Elites', color: '#FFD60A', tooltip: 'Players scoring the most fantasy points per touch in last 3 weeks. High efficiency = doing more with less. League-winner upside if volume increases.' },
                { key: 'redZoneKingsWR', title: 'Red Zone Kings (WR)', color: '#bf5af2', tooltip: 'WRs with the most red zone targets per game in last 3 weeks. More RZ targets = higher TD upside.' },
                { key: 'redZoneBacks', title: 'Red Zone Backs (RB)', color: '#ff453a', tooltip: 'RBs with the most red zone opportunities (carries + targets) per game in last 3 weeks. Dominant in scoring position.' },
                { key: 'rbEfficiency', title: 'RB Efficiency (Yds/Att)', color: '#30d158', tooltip: 'RBs with highest yards per carry in last 3 weeks. Explosive runners who maximize every touch.' },
                { key: 'consistentFloor', title: 'High-Volume Alphas (WR)', color: '#64d2ff', tooltip: 'WRs with the most targets per game in last 3 weeks. Commanding volume = alpha status in their offense.' },
                { key: 'airYardsLeaders', title: 'Air Yards Leaders (WR)', color: '#0a84ff', tooltip: 'WRs with highest air yards per game in last 3 weeks. Deep threats with explosive upside potential.' },
                { key: 'passCatchingBacks', title: 'Pass-Catching Backs (RB)', color: '#5e5ce6', tooltip: 'RBs with highest target share in last 3 weeks. PPR gold with receiving work in the passing game.' },
                { key: 'targetLeadersTE', title: 'Target Leaders (TE)', color: '#30d158', tooltip: 'TEs with the most targets per game in last 3 weeks. High volume = consistent TE production.' },
                { key: 'redZoneDominanceTE', title: 'Red Zone Dominance (TE)', color: '#bf5af2', tooltip: 'TEs with most red zone production in last 3 weeks. RZ Score = (RZ Targets + RZ TDs × 3) per game. TDs weighted 3x because they\'re more valuable than targets.' },
                { key: 'totalTouchdownLeadersWR', title: 'Total TD Leaders (WR)', color: '#ff453a', tooltip: 'WRs scoring the most total touchdowns (receiving + rushing) in last 3 weeks. Elite scorers.' }
            ];

            let html = '';
            html += '<div class="categories-carousel-container">';
            html += '<div class="categories-carousel-scroll" id="categories-carousel">';

            let hasAnyData = false;
            let categoriesHTML = ''; // Build categories first

            categoryConfigs.forEach(config => {
                const categoryData = categories[config.key];
                if (!categoryData || categoryData.length === 0) {                    return;
                }

                hasAnyData = true;
                categoriesHTML += `
                    <div class="category-carousel-item">
                        <div class="category-header">
                            <div class="category-title" style="position: relative;">
                                ${config.title}
                                <div class="leaderboard-info-icon" onclick="toggleLeaderboardTooltip(event)">
                                    i
                                    <div class="leaderboard-tooltip">
                                        ${config.tooltip}
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="category-cards-container" id="category-${config.key}">
                `;

                // Show all 8 players
                categoryData.forEach((item, idx) => {
                    categoriesHTML += renderCategoryCard(item, config.color, config.key, config.title);
                });

                categoriesHTML += `
                        </div>
                    </div>
                `;
            });

            // Duplicate categories for infinite scroll (like ticker)
            html += categoriesHTML + categoriesHTML;

            html += '</div>';
            html += '</div>';

            // Add pagination dots for mobile
            const categoryCount = categoryConfigs.filter(config => categories[config.key] && categories[config.key].length > 0).length;
            html += '<div class="carousel-dots" id="carousel-dots">';
            for (let i = 0; i < categoryCount; i++) {
                html += `<div class="carousel-dot ${i === 0 ? 'active' : ''}" data-index="${i}"></div>`;
            }
            html += '</div>';

            if (!hasAnyData) {                container.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 40px;">No category data available. Please upload player data.</p>';
            } else {
                container.innerHTML = html;
                // CSS animation handles the infinite scroll automatically

                // Add scroll listener for mobile dots
                initializeCarouselDots();
            }
        }

        // Initialize carousel dot tracking
        function initializeCarouselDots() {
            const carouselContainer = document.querySelector('.categories-carousel-container');
            const carousel = document.getElementById('categories-carousel');
            const dots = document.querySelectorAll('.carousel-dot');

            if (!carouselContainer || !carousel || dots.length === 0) return;

            // Add click handlers to dots (works on any screen size where carousel is visible)
            dots.forEach((dot, dotIndex) => {
                dot.addEventListener('click', () => {
                    const itemWidth = carousel.querySelector('.category-carousel-item')?.offsetWidth || 0;
                    const gap = 20;
                    const scrollPosition = dotIndex * (itemWidth + gap);

                    carouselContainer.scrollTo({
                        left: scrollPosition,
                        behavior: 'smooth'
                    });
                });
            });

            let scrollTimeout;
            carouselContainer.addEventListener('scroll', () => {
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    const scrollLeft = carouselContainer.scrollLeft;
                    const itemWidth = carousel.querySelector('.category-carousel-item')?.offsetWidth || 0;
                    const gap = 20;
                    const currentIndex = Math.round(scrollLeft / (itemWidth + gap));

                    // Update active dot
                    dots.forEach((dot, index) => {
                        if (index === currentIndex) {
                            dot.classList.add('active');
                        } else {
                            dot.classList.remove('active');
                        }
                    });
                }, 50);
            });
        }

        // Render all leaderboards in a static 2x2 grid for the all-leaderboards page
        function renderAllLeaderboards() {
            const container = document.getElementById('all-leaderboards-grid');
            if (!container) {                return;
            }

            const categories = calculateDashboardCategories();

            if (!categories) {                container.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 40px;">Loading categories...</p>';
                return;
            }

            const categoryConfigs = [
                { key: 'volumeMonsters', title: 'Volume Monsters (RB)', color: '#ff453a', tooltip: 'RBs with the highest opportunities (carries + targets) per game in last 3 weeks.' },
                { key: 'consistentFloor', title: 'High-Volume Alphas (WR)', color: '#64d2ff', tooltip: 'WRs with the most targets per game in last 3 weeks.' },
                { key: 'redZoneKingsWR', title: 'Red Zone Kings (WR)', color: '#bf5af2', tooltip: 'WRs with the most red zone targets per game in last 3 weeks.' },
                { key: 'redZoneBacks', title: 'Red Zone Backs (RB)', color: '#ff453a', tooltip: 'RBs with the most red zone opportunities per game in last 3 weeks.' },
                { key: 'efficiencyElites', title: 'Efficiency Elites', color: '#FFD60A', tooltip: 'Players scoring the most fantasy points per touch in last 3 weeks.' },
                { key: 'rbEfficiency', title: 'RB Efficiency (Yds/Att)', color: '#30d158', tooltip: 'RBs with highest yards per carry in last 3 weeks.' },
                { key: 'airYardsLeaders', title: 'Air Yards Leaders (WR)', color: '#0a84ff', tooltip: 'WRs with highest air yards per game in last 3 weeks.' },
                { key: 'passCatchingBacks', title: 'Pass-Catching Backs (RB)', color: '#5e5ce6', tooltip: 'RBs with highest target share in last 3 weeks.' },
                { key: 'targetLeadersTE', title: 'Target Leaders (TE)', color: '#30d158', tooltip: 'TEs with the most targets per game in last 3 weeks.' },
                { key: 'redZoneDominanceTE', title: 'Red Zone Dominance (TE)', color: '#bf5af2', tooltip: 'TEs with most red zone production in last 3 weeks. RZ Score = (RZ Targets + RZ TDs × 3) per game. TDs weighted 3x.' },
                { key: 'totalTouchdownLeadersWR', title: 'Total TD Leaders (WR)', color: '#ff453a', tooltip: 'WRs with the most total touchdowns (receiving + rushing) in last 3 weeks.' }
            ];

            let html = '';

            categoryConfigs.forEach(config => {
                const categoryData = categories[config.key];
                if (!categoryData || categoryData.length === 0) {
                    return;
                }

                html += `
                    <div style="background: var(--bg-secondary); border-radius: 12px; padding: 20px; border: 1px solid var(--border-color);">
                        <div class="category-header" style="margin-bottom: 16px;">
                            <div class="category-title" style="position: relative; font-size: 16px; font-weight: 700; color: var(--text-primary);">
                                ${config.title}
                                <div class="leaderboard-info-icon" onclick="toggleLeaderboardTooltip(event)">
                                    i
                                    <div class="leaderboard-tooltip">
                                        ${config.tooltip}
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr; gap: 8px;">
                `;

                // Show all 8 players with compact cards
                const maxMetricValue = Math.max(...categoryData.map(item => parseFloat(item.metric) || 0));

                categoryData.forEach((item, idx) => {
                    html += renderCompactCategoryCard(item, config.color, config.key, config.title, maxMetricValue);
                });

                html += `
                        </div>
                    </div>
                `;
            });

            if (html === '') {
                container.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 40px; grid-column: 1 / -1;">No leaderboard data available. Please upload player data.</p>';
            } else {
                // Wrap in grid container
                container.innerHTML = `<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(450px, 1fr)); gap: 24px; width: 100%;">${html}</div>`;
            }
        }

        // Render compact category card for all-leaderboards page (single line, no grey labels)
        function renderCompactCategoryCard(item, color, categoryKey, categoryTitle, maxMetricValue) {
            const player = item.player;
            const teamColor = teamColors[player.team] || '#666';
            const escapedId = player.id.replace(/'/g, "\\'");
            const escapedCategory = (categoryTitle || '').replace(/'/g, "\\'");
            const escapedExplanation = (item.explanation || '').replace(/'/g, "\\'");

            // Calculate bar width percentage
            const metricValue = parseFloat(item.metric) || 0;
            const barWidthPercent = maxMetricValue > 0 ? (metricValue / maxMetricValue) * 100 : 0;

            // Determine if change should be shown and its direction
            const change = parseFloat(item.change || 0);
            const changeClass = change > 0 ? 'comparison-up' : change < 0 ? 'comparison-down' : '';
            const changeIcon = change > 0 ? '▲' : change < 0 ? '▼' : '';
            const showChange = Math.abs(change) >= 0.1; // Only show if change is meaningful

            return `
                <div class="compact-player-card" onclick="openPlayerModalWithCategory('${escapedId}', '${escapedCategory}', '${escapedExplanation}', '${item.rank}', '${item.metricLabel}', '${item.metric}')" style="
                    background: var(--bg-tertiary);
                    border: 1px solid var(--border-color);
                    border-radius: 8px;
                    padding: 10px 14px;
                    display: flex;
                    align-items: center;
                    gap: 12px;
                    cursor: pointer;
                    transition: all 0.2s ease;
                ">
                    <div style="
                        background: ${teamColor};
                        color: white;
                        font-size: 10px;
                        font-weight: 700;
                        padding: 4px 6px;
                        border-radius: 4px;
                        min-width: 32px;
                        text-align: center;
                    ">${player.team}</div>

                    <div style="
                        flex: 1;
                        display: flex;
                        flex-direction: column;
                        gap: 4px;
                    ">
                        <div style="
                            font-size: 13px;
                            font-weight: 600;
                            color: var(--text-primary);
                            white-space: nowrap;
                            overflow: hidden;
                            text-overflow: ellipsis;
                        ">${player.name}</div>
                        <div class="metric-bar-container" style="width: 150px;">
                            <div class="metric-bar" style="width: ${barWidthPercent}%; background: ${teamColor};"></div>
                        </div>
                    </div>

                    <div style="
                        font-size: 11px;
                        color: var(--text-tertiary);
                        min-width: 24px;
                    ">${player.position}</div>

                    <div style="
                        font-size: 13px;
                        color: var(--text-secondary);
                        min-width: 28px;
                        text-align: center;
                    ">#${item.rank}</div>

                    <div style="
                        display: flex;
                        align-items: center;
                        gap: 6px;
                        position: relative;
                    ">
                        <span class="compact-metric-value"
                            style="
                            font-size: 14px;
                            font-weight: 700;
                            color: var(--text-primary);
                            position: relative;
                        ">
                            ${item.metric}
                        </span>
                        ${showChange ? `
                            <span class="player-comparison ${changeClass}" style="
                                display: flex;
                                align-items: center;
                                gap: 2px;
                                font-size: 11px;
                                white-space: nowrap;
                                position: relative;
                            ">
                                <span class="comparison-icon">${changeIcon}</span>
                                ${Math.abs(change).toFixed(item.metric.includes('.') && item.metric.split('.')[1].length > 1 ? 2 : 1)}
                                <span class="change-tooltip" style="
                                    position: absolute;
                                    bottom: 100%;
                                    right: 0;
                                    transform: translateY(0);
                                    margin-bottom: 8px;
                                    background: var(--bg-elevated);
                                    border: 1px solid var(--border-color-light);
                                    border-radius: 8px;
                                    padding: 8px 12px;
                                    font-size: 10px;
                                    white-space: nowrap;
                                    opacity: 0;
                                    pointer-events: none;
                                    transition: opacity 0.2s ease;
                                    z-index: 2001;
                                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
                                ">vs prior 3 weeks</span>
                            </span>
                        ` : `
                            <span style="
                                display: flex;
                                align-items: center;
                                gap: 2px;
                                font-size: 11px;
                                color: var(--text-tertiary);
                                min-width: 40px;
                                justify-content: center;
                            ">—</span>
                        `}
                    </div>
                </div>
            `;
        }

        // Manual scroll function for arrow buttons (optional - can be removed if arrows removed)
        function scrollCategories(direction) {
            const carousel = document.getElementById('categories-carousel');
            if (!carousel) return;

            // Temporarily disable animation for manual scroll
            carousel.style.animation = 'none';

            const scrollAmount = carousel.offsetWidth / 2; // Scroll by width of 2 items

            if (direction === 1) {
                carousel.scrollLeft += scrollAmount;
            } else {
                carousel.scrollLeft -= scrollAmount;
            }

            // Re-enable animation after a short delay
            setTimeout(() => {
                carousel.style.animation = '';
            }, 500);
        }

        // Render Individual Category Card
        function renderCategoryCard(item, color, categoryKey, categoryTitle) {
            const player = item.player;
            const teamColor = teamColors[player.team] || '#666';
            const escapedId = player.id.replace(/'/g, "\\'");
            const escapedCategory = (categoryTitle || '').replace(/'/g, "\\'");
            const escapedExplanation = (item.explanation || '').replace(/'/g, "\\'");

            // Determine if change should be shown and its direction
            const change = parseFloat(item.change || 0);
            const changeClass = change > 0 ? 'comparison-up' : change < 0 ? 'comparison-down' : '';
            const changeIcon = change > 0 ? '▲' : change < 0 ? '▼' : '';
            const showChange = Math.abs(change) >= 0.1; // Only show if change is meaningful

            // Create tooltip text based on metric type
            let tooltipText = '';
            if (item.metricLabel.includes('Opps/Game')) {
                tooltipText = `Average opportunities (rush attempts + targets) per game in last 3 weeks. Change vs weeks 4-6 back.`;
            } else if (item.metricLabel.includes('Pts/Tgt')) {
                tooltipText = `Fantasy points per target in last 3 weeks. Higher = more efficient. Change vs weeks 4-6 back.`;
            } else if (item.metricLabel.includes('Pts/Opp')) {
                tooltipText = `Fantasy points per opportunity in last 3 weeks. Higher = more efficient. Change vs weeks 4-6 back.`;
            } else if (item.metricLabel.includes('RZ')) {
                tooltipText = `Red zone opportunities per game in last 3 weeks. More = higher TD potential. Change vs weeks 4-6 back.`;
            } else if (item.metricLabel.includes('Tgt/Game') || item.metricLabel.includes('Tgt/G')) {
                tooltipText = `Average targets per game in last 3 weeks. Higher = more consistent volume. Change vs weeks 4-6 back.`;
            } else if (item.metricLabel.includes('Yds/Att')) {
                tooltipText = `Yards per carry in last 3 weeks. Higher = more explosive running. Change vs weeks 4-6 back.`;
            } else if (item.metricLabel.includes('Air Yds')) {
                tooltipText = `Air yards (depth of target) per game in last 3 weeks. Higher = deep threat. Change vs weeks 4-6 back.`;
            } else if (item.metricLabel.includes('Tgt Share')) {
                tooltipText = `Target share percentage in last 3 weeks. Higher = more passing game involvement. Change vs weeks 4-6 back.`;
            } else {
                tooltipText = `${item.metricLabel} in last 3 weeks. Change vs weeks 4-6 back.`;
            }

            // Create simplified tooltip for main stat value
            let mainStatTooltip = '';
            if (item.metricLabel.includes('Opps/Game')) {
                mainStatTooltip = 'Opportunities per game (Rush Att + Targets)';
            } else if (item.metricLabel.includes('Pts/Tgt')) {
                mainStatTooltip = 'Fantasy points per target';
            } else if (item.metricLabel.includes('Pts/Opp')) {
                mainStatTooltip = 'Fantasy points per opportunity';
            } else if (item.metricLabel.includes('RZ')) {
                mainStatTooltip = 'Red zone opportunities per game';
            } else if (item.metricLabel.includes('Tgt/Game') || item.metricLabel.includes('Tgt/G')) {
                mainStatTooltip = 'Targets per game';
            } else if (item.metricLabel.includes('Yds/Att')) {
                mainStatTooltip = 'Yards per carry';
            } else if (item.metricLabel.includes('Air Yds')) {
                mainStatTooltip = 'Air yards per game';
            } else if (item.metricLabel.includes('Tgt Share')) {
                mainStatTooltip = 'Target share %';
            } else {
                mainStatTooltip = `${item.metricLabel} (Avg Last 3 games)`;
            }

            return `
                <div class="player-card" onclick="openPlayerModalWithCategory('${escapedId}', '${escapedCategory}', '${escapedExplanation}', '${item.rank}', '${item.metricLabel}', '${item.metric}')">
                    <div class="player-card-header" style="margin-bottom: 0;">
                        <div class="category-rank-simple" style="margin-right: 12px;">#${item.rank}</div>
                        <div class="player-card-badge" style="background: ${teamColor};">
                            ${player.team}
                        </div>
                        <div style="flex: 1; display: flex; flex-direction: column; gap: 2px;">
                            <div class="player-card-name">${player.name}</div>
                            <div class="player-card-team">${player.position}</div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 4px; position: relative;">
                            <span class="player-stat-value" style="white-space: nowrap; font-size: 12px; font-weight: 700;">
                                ${item.metric}
                            </span>
                            ${showChange ? `
                                <span class="player-comparison ${changeClass}" style="white-space: nowrap; font-size: 12px;">
                                    <span class="comparison-icon">${changeIcon}</span>
                                    ${Math.abs(change).toFixed(item.metric.includes('.') && item.metric.split('.')[1].length > 1 ? 2 : 1)}
                                </span>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `;
        }

        // Toggle footnote visibility
        function toggleFootnote() {
            const content = document.getElementById('footnote-content');
            const icon = document.getElementById('footnote-icon');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.textContent = '✕';
            } else {
                content.style.display = 'none';
                icon.textContent = 'ⓘ';
            }
        }

        // Toggle Category Expand/Collapse

        // Render mini scatter plots for category cards
        function renderMiniScatterPlots() {
            // This will be called after categories are rendered
            // For now, we'll render simple placeholder charts
            // In a full implementation, you'd create mini scatter plots with the player highlighted

            document.querySelectorAll('.category-card-chart canvas').forEach(canvas => {
                if (!canvas.id) return;

                // Simple placeholder - you can enhance this to show actual mini scatter plots
                const ctx = canvas.getContext('2d');
                if (!ctx) return;

                canvas.width = canvas.offsetWidth;
                canvas.height = 100;

                // Draw simple gradient background
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, 'rgba(48, 209, 88, 0.1)');
                gradient.addColorStop(1, 'rgba(10, 132, 255, 0.1)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw a simple trend line or indicator
                ctx.strokeStyle = 'rgba(48, 209, 88, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height * 0.7);
                ctx.lineTo(canvas.width * 0.5, canvas.height * 0.4);
                ctx.lineTo(canvas.width, canvas.height * 0.3);
                ctx.stroke();
            });
        }

        // ADVANCED ANALYTICS

        let advancedScatterChart = null;
        let highlightedPlayerIds = []; // Now supports up to 2 players
        let selectedWeekRange = 'all';
        let advancedCurrentPosition = 'WR';
        let currentQuadrantExplanation = '';

        // Preset scatterplot configurations
        const scatterPresets = {
            WR: [
                {
                    name: 'Volume vs Efficiency',
                    xAxis: 'targets',
                    yAxis: 'catch_rate',
                    description: 'High-volume receivers with strong catch rates',
                    quadrantExplanation: 'Top-right = High volume + reliable hands. Bottom-right = Volume without efficiency. Top-left = Efficient but limited opportunities.'
                },
                {
                    name: 'Volume vs Production',
                    xAxis: 'targets',
                    yAxis: 'fantasy_points',
                    description: 'Target share translating to fantasy points',
                    quadrantExplanation: 'Top-right = Elite fantasy assets (volume + production). Bottom-right = High volume underperformers. Top-left = Efficient scorers with limited volume.'
                },
                {
                    name: 'Target Share vs Production',
                    xAxis: 'target_share',
                    yAxis: 'fantasy_points',
                    description: 'Team involvement vs fantasy output',
                    quadrantExplanation: 'Top-right = Offensive centerpieces. Bottom-right = High target share not converting. Top-left = Boom/bust players or red zone specialists.'
                },
                {
                    name: 'Red Zone Usage',
                    xAxis: 'rz_targets',
                    yAxis: 'fantasy_points',
                    description: 'Red zone opportunities vs scoring',
                    quadrantExplanation: 'Top-right = TD-dependent scorers. Bottom-right = Red zone targets not converting. Top-left = Yardage-based scorers with limited red zone work.'
                },
                {
                    name: 'More with Less',
                    xAxis: 'targets',
                    yAxis: 'receiving_yards',
                    description: 'Target efficiency and big-play ability',
                    quadrantExplanation: 'Top-right = High volume + yards. Top-left = Explosive playmakers doing more with fewer touches. Bottom-right = Volume without yards.'
                },
                {
                    name: 'Team Dominance',
                    xAxis: 'target_share',
                    yAxis: 'team_points',
                    description: 'Target share in high/low-scoring offenses',
                    quadrantExplanation: 'Top-right = Alpha WRs on elite offenses. Bottom-right = Dominant share on bad offenses. Top-left = Supporting cast on great offenses.'
                }
            ],
            RB: [
                {
                    name: 'Talent Indicator',
                    xAxis: 'ybc_per_att',
                    yAxis: 'yac_per_att',
                    description: 'Vision vs power/elusiveness',
                    quadrantExplanation: 'Top-right = Elite talent (vision + contact balance). Bottom-right = Great vision, poor after contact. Top-left = Contact breakers relying on line.'
                },
                {
                    name: 'Volume vs Production',
                    xAxis: 'opportunities',
                    yAxis: 'fantasy_points',
                    description: 'Opportunity share vs fantasy output',
                    quadrantExplanation: 'Top-right = Workhorse RBs producing. Bottom-right = High volume underperformers. Top-left = Efficient, limited-touch backs.'
                },
                {
                    name: 'Red Zone Usage',
                    xAxis: 'rz_opportunities',
                    yAxis: 'fantasy_points',
                    description: 'Red zone touches vs scoring',
                    quadrantExplanation: 'Top-right = Goal-line backs. Bottom-right = Red zone work not converting. Top-left = Yardage scorers with limited red zone role.'
                },
                {
                    name: 'Carries vs Opportunities',
                    xAxis: 'carries',
                    yAxis: 'opportunities',
                    description: 'Rushing role vs total touches',
                    quadrantExplanation: 'Top-right = Three-down backs (high carries + targets). Bottom-right = Pure rushers with minimal pass work. Top-left = Pass-catching specialists.'
                },
                {
                    name: 'Rushing Efficiency',
                    xAxis: 'carries',
                    yAxis: 'rushing_yards',
                    description: 'Rushing volume vs yards produced',
                    quadrantExplanation: 'Top-right = Bell-cow rushers. Bottom-right = High volume, low efficiency. Top-left = Explosive runners with limited carries.'
                },
                {
                    name: 'Team Context',
                    xAxis: 'opportunities',
                    yAxis: 'team_points',
                    description: 'Workload in high/low-scoring offenses',
                    quadrantExplanation: 'Top-right = Lead backs on elite offenses. Bottom-right = Workhorse on bad offenses. Top-left = Committee backs on great offenses.'
                }
            ],
            TE: [
                {
                    name: 'Volume vs Efficiency',
                    xAxis: 'targets',
                    yAxis: 'catch_rate',
                    description: 'High-volume tight ends with strong catch rates',
                    quadrantExplanation: 'Top-right = High volume + reliable hands. Bottom-right = Volume without efficiency. Top-left = Efficient but limited opportunities.'
                },
                {
                    name: 'Volume vs Production',
                    xAxis: 'targets',
                    yAxis: 'fantasy_points',
                    description: 'Target share translating to fantasy points',
                    quadrantExplanation: 'Top-right = Elite fantasy assets (volume + production). Bottom-right = High volume underperformers. Top-left = Efficient scorers with limited volume.'
                },
                {
                    name: 'Target Share vs Production',
                    xAxis: 'target_share',
                    yAxis: 'fantasy_points',
                    description: 'Team involvement vs fantasy output',
                    quadrantExplanation: 'Top-right = Offensive centerpieces. Bottom-right = High target share not converting. Top-left = Boom/bust players or red zone specialists.'
                },
                {
                    name: 'Red Zone Usage',
                    xAxis: 'rz_targets',
                    yAxis: 'fantasy_points',
                    description: 'Red zone opportunities vs scoring',
                    quadrantExplanation: 'Top-right = TD-dependent scorers. Bottom-right = Red zone targets not converting. Top-left = Yardage-based scorers with limited red zone work.'
                },
                {
                    name: 'More with Less',
                    xAxis: 'targets',
                    yAxis: 'receiving_yards',
                    description: 'Target efficiency and big-play ability',
                    quadrantExplanation: 'Top-right = High volume + yards. Top-left = Explosive playmakers doing more with fewer touches. Bottom-right = Volume without yards.'
                },
                {
                    name: 'Team Dominance',
                    xAxis: 'target_share',
                    yAxis: 'team_points',
                    description: 'Target share in high/low-scoring offenses',
                    quadrantExplanation: 'Top-right = Alpha TEs on elite offenses. Bottom-right = Dominant share on bad offenses. Top-left = Supporting cast on great offenses.'
                }
            ]
        };

        // Populate preset buttons
        // Player Search Functions
        function filterPlayerSearch() {
            const input = document.getElementById('player-search-input');
            const searchTerm = input.value.toLowerCase().trim();
            const dropdown = document.getElementById('player-search-dropdown');

            if (searchTerm.length === 0) {
                dropdown.style.display = 'none';
                return;
            }

            // Get all players for current position
            const players = Object.values(allPlayers).filter(p =>
                p.position === advancedCurrentPosition && p.gamesPlayed >= 3
            );

            // Filter players by search term
            const matches = players.filter(p =>
                p.name.toLowerCase().includes(searchTerm)
            ).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 10);

            if (matches.length === 0) {
                dropdown.innerHTML = '<div style="padding: 12px; color: var(--text-secondary); font-size: 13px;">No players found</div>';
                dropdown.style.display = 'block';
                return;
            }

            // Build dropdown HTML
            let html = '';
            matches.forEach(player => {
                html += `
                    <div onclick="selectPlayerHighlight('${player.id.replace(/'/g, "\\'")}', '${player.name.replace(/'/g, "\\'")}', '${player.team}')"
                         style="padding: 10px 12px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-color); transition: background 0.2s;"
                         onmouseover="this.style.background='var(--bg-tertiary)'"
                         onmouseout="this.style.background='transparent'">
                        <div>
                            <div style="font-weight: 600; color: var(--text-primary); font-size: 13px;">${player.name}</div>
                            <div style="font-size: 11px; color: var(--text-secondary);">${player.team} · ${player.avgPoints.toFixed(1)} PPG</div>
                        </div>
                        <div style="width: 24px; height: 24px; border-radius: 4px; background: ${teamColors[player.team] || '#666'}; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: 700; color: white;">
                            ${player.team}
                        </div>
                    </div>
                `;
            });

            dropdown.innerHTML = html;
            dropdown.style.display = 'block';
        }

        function showPlayerSearchDropdown() {
            const input = document.getElementById('player-search-input');
            if (input.value.length > 0) {
                filterPlayerSearch();
            }
        }

        function selectPlayerHighlight(playerId, playerName, team) {
            // Check if player is already highlighted
            if (highlightedPlayerIds.includes(playerId)) {
                return; // Don't add duplicates
            }

            // Add player (max 4 players)
            if (highlightedPlayerIds.length < 4) {
                highlightedPlayerIds.push(playerId);
            } else {
                // Replace oldest player if already at max
                highlightedPlayerIds.shift();
                highlightedPlayerIds.push(playerId);
            }

            // Update selected players display
            updateSelectedPlayersDisplay();

            // Clear the input for next selection
            const input = document.getElementById('player-search-input');
            input.value = '';

            const dropdown = document.getElementById('player-search-dropdown');
            dropdown.style.display = 'none';

            const clearBtn = document.getElementById('clear-player-btn');
            clearBtn.style.display = highlightedPlayerIds.length > 0 ? 'block' : 'none';

            updateAdvancedScatter();
        }

        function updateSelectedPlayersDisplay() {
            const container = document.getElementById('selected-players-container');

            if (highlightedPlayerIds.length === 0) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'flex';

            let html = '';
            highlightedPlayerIds.forEach((playerId, index) => {
                const player = allPlayers[playerId];
                if (player) {
                    // Use white border for all highlighted players
                    html += `
                        <div style="
                            display: flex;
                            align-items: center;
                            gap: 6px;
                            padding: 4px 8px;
                            background: var(--bg-elevated);
                            border: 2px solid #fff;
                            border-radius: 6px;
                            font-size: 12px;
                            font-weight: 600;
                        ">
                            <span>${player.name} (${player.team})</span>
                            <button onclick="removePlayerHighlight('${playerId}')" style="
                                background: transparent;
                                border: none;
                                color: var(--text-secondary);
                                cursor: pointer;
                                font-size: 16px;
                                padding: 0;
                                width: 16px;
                                height: 16px;
                                line-height: 1;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            ">×</button>
                        </div>
                    `;
                }
            });

            container.innerHTML = html;
        }

        function removePlayerHighlight(playerId) {
            highlightedPlayerIds = highlightedPlayerIds.filter(id => id !== playerId);
            updateSelectedPlayersDisplay();

            const clearBtn = document.getElementById('clear-player-btn');
            clearBtn.style.display = highlightedPlayerIds.length > 0 ? 'block' : 'none';

            updateAdvancedScatter();
        }

        function clearPlayerHighlight() {
            highlightedPlayerIds = [];

            const input = document.getElementById('player-search-input');
            input.value = '';

            updateSelectedPlayersDisplay();

            const clearBtn = document.getElementById('clear-player-btn');
            clearBtn.style.display = 'none';

            const dropdown = document.getElementById('player-search-dropdown');
            dropdown.style.display = 'none';

            updateAdvancedScatter();
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            const input = document.getElementById('player-search-input');
            const dropdown = document.getElementById('player-search-dropdown');
            if (input && dropdown && !input.contains(e.target) && !dropdown.contains(e.target)) {
                dropdown.style.display = 'none';
            }
        });

        // Week Range Filter Function
        function getWeekFilteredData(player, weekRange) {
            if (weekRange === 'all') {
                return player.weeks;
            }

            // Find global max week
            let globalMaxWeek = 0;
            Object.values(allPlayers).forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });

            if (weekRange === 'last3') {
                const targetWeeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
                return player.weeks.filter(w => targetWeeks.includes(w.week));
            } else if (weekRange === 'last5') {
                const targetWeeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2, globalMaxWeek - 3, globalMaxWeek - 4];
                return player.weeks.filter(w => targetWeeks.includes(w.week));
            } else if (weekRange.includes('-')) {
                const [start, end] = weekRange.split('-').map(Number);
                return player.weeks.filter(w => w.week >= start && w.week <= end);
            } else if (!isNaN(weekRange)) {
                return player.weeks.filter(w => w.week == weekRange);
            }

            return player.weeks;
        }

        function populatePresetButtons() {
            const container = document.getElementById('preset-buttons-container');
            if (!container) return;

            const presets = scatterPresets[advancedCurrentPosition];

            container.innerHTML = presets.map(preset => `
                <button class="preset-btn" onclick="applyPreset('${preset.xAxis}', '${preset.yAxis}')" title="${preset.description}">
                    ${preset.name}
                </button>
            `).join('');
        }

        // Apply a preset configuration
        function applyPreset(xAxis, yAxis) {
            const xSelect = document.getElementById('x-axis-select');
            const ySelect = document.getElementById('y-axis-select');

            if (xSelect && ySelect) {
                xSelect.value = xAxis;
                ySelect.value = yAxis;

                // Find the preset to get its quadrant explanation
                const presets = scatterPresets[advancedCurrentPosition];
                const preset = presets.find(p => p.xAxis === xAxis && p.yAxis === yAxis);

                // Store the quadrant explanation for use in rendering
                currentQuadrantExplanation = preset ? preset.quadrantExplanation : '';

                updateAdvancedScatter();
            }
        }

        // Stat definitions with calculation functions
        const advancedStatDefinitions = {
            WR: [
                {
                    id: 'fantasy_points',
                    label: 'Fantasy Points per Game',
                    calculate: (player) => player.avgPoints || 0
                },
                {
                    id: 'targets',
                    label: 'Targets per Game',
                    calculate: (player) => player.totalTargets / player.gamesPlayed
                },
                {
                    id: 'receptions',
                    label: 'Receptions per Game',
                    calculate: (player) => player.totalRec / player.gamesPlayed
                },
                {
                    id: 'receiving_yards',
                    label: 'Receiving Yards per Game',
                    calculate: (player) => player.totalYDS / player.gamesPlayed
                },
                {
                    id: 'catch_rate',
                    label: 'Catch Rate (%)',
                    calculate: (player) => player.catchRate || 0
                },
                {
                    id: 'target_share',
                    label: 'Target Share (%)',
                    calculate: (player) => {
                        // Calculate average team share across all weeks
                        if (!player.weeks || player.weeks.length === 0) return 0;
                        const totalShare = player.weeks.reduce((sum, w) => sum + (w.teamShare || 0), 0);
                        return totalShare / player.weeks.length;
                    }
                },
                {
                    id: 'rz_targets',
                    label: 'Red Zone Targets per Game',
                    calculate: (player) => (player.rzOpportunities || 0) / player.gamesPlayed
                },
                {
                    id: 'air_yards',
                    label: 'Air Yards per Game',
                    calculate: (player) => player.airYardsPerGame || 0
                },
                {
                    id: 'yac_per_rec',
                    label: 'Yards After Catch per Reception',
                    calculate: (player) => player.yacPerRec || 0
                },
                {
                    id: 'team_points',
                    label: 'Team Points per Game',
                    calculate: (player) => {
                        // Get team's average points from teamStats
                        if (!teamStats || !teamStats[player.team]) return 0;
                        return teamStats[player.team].avgPoints || 0;
                    }
                },
                {
                    id: 'receiving_tds',
                    label: 'Receiving TDs per Game',
                    calculate: (player) => (player.totalRecTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'rushing_tds',
                    label: 'Rushing TDs per Game',
                    calculate: (player) => (player.totalRushTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'total_tds',
                    label: 'Total TDs per Game',
                    calculate: (player) => ((player.totalRecTDs || 0) + (player.totalRushTDs || 0)) / player.gamesPlayed
                },
                {
                    id: 'rz_tds',
                    label: 'Red Zone TDs per Game',
                    calculate: (player) => (player.rzTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'yards_per_touch',
                    label: 'Yards per Touch',
                    calculate: (player) => {
                        const totalYards = (player.totalYDS || 0) + (player.totalRushYards || 0);
                        const totalTouches = (player.totalRec || 0) + (player.totalCarries || 0);
                        return totalTouches > 0 ? totalYards / totalTouches : 0;
                    }
                },
                {
                    id: 'td_rate',
                    label: 'TD Rate (per Touch)',
                    calculate: (player) => {
                        const totalTDs = (player.totalRecTDs || 0) + (player.totalRushTDs || 0);
                        const totalTouches = (player.totalRec || 0) + (player.totalCarries || 0);
                        return totalTouches > 0 ? (totalTDs / totalTouches) * 100 : 0;
                    }
                },
                {
                    id: 'total_yards',
                    label: 'Total Yards per Game',
                    calculate: (player) => {
                        const totalYards = (player.totalYDS || 0) + (player.totalRushYards || 0);
                        return totalYards / player.gamesPlayed;
                    }
                },
                {
                    id: 'rushing_yards',
                    label: 'Rushing Yards per Game',
                    calculate: (player) => (player.totalRushYards || 0) / player.gamesPlayed
                }
            ],
            RB: [
                {
                    id: 'fantasy_points',
                    label: 'Fantasy Points per Game',
                    calculate: (player) => player.avgPoints || 0
                },
                {
                    id: 'opportunities',
                    label: 'Opportunities per Game',
                    calculate: (player) => player.totalOpportunities / player.gamesPlayed
                },
                {
                    id: 'rushing_yards',
                    label: 'Rushing Yards per Game',
                    calculate: (player) => (player.totalRushYards || 0) / player.gamesPlayed
                },
                {
                    id: 'ybc_per_att',
                    label: 'Yards Before Contact per Att',
                    calculate: (player) => {
                        const carries = player.totalCarries || 0;
                        return carries > 0 ? (player.totalYBCON || 0) / carries : 0;
                    }
                },
                {
                    id: 'yac_per_att',
                    label: 'Yards After Contact per Att',
                    calculate: (player) => {
                        const carries = player.totalCarries || 0;
                        return carries > 0 ? (player.totalYACON || 0) / carries : 0;
                    }
                },
                {
                    id: 'rz_opportunities',
                    label: 'Red Zone Opportunities per Game',
                    calculate: (player) => (player.rzOpportunities || 0) / player.gamesPlayed
                },
                {
                    id: 'carries',
                    label: 'Carries per Game',
                    calculate: (player) => (player.totalCarries || 0) / player.gamesPlayed
                },
                {
                    id: 'targets',
                    label: 'Targets per Game',
                    calculate: (player) => (player.totalTargets || 0) / player.gamesPlayed
                },
                {
                    id: 'team_points',
                    label: 'Team Points per Game',
                    calculate: (player) => {
                        // Get team's average points from teamStats
                        if (!teamStats || !teamStats[player.team]) return 0;
                        return teamStats[player.team].avgPoints || 0;
                    }
                },
                {
                    id: 'receiving_tds',
                    label: 'Receiving TDs per Game',
                    calculate: (player) => (player.totalRecTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'rushing_tds',
                    label: 'Rushing TDs per Game',
                    calculate: (player) => (player.totalRushTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'total_tds',
                    label: 'Total TDs per Game',
                    calculate: (player) => ((player.totalRecTDs || 0) + (player.totalRushTDs || 0)) / player.gamesPlayed
                },
                {
                    id: 'rz_tds',
                    label: 'Red Zone TDs per Game',
                    calculate: (player) => (player.rzTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'yards_per_touch',
                    label: 'Yards per Touch',
                    calculate: (player) => {
                        const totalYards = (player.totalRushYards || 0) + (player.totalRecYards || 0);
                        const totalTouches = (player.totalCarries || 0) + (player.totalRec || 0);
                        return totalTouches > 0 ? totalYards / totalTouches : 0;
                    }
                },
                {
                    id: 'td_rate',
                    label: 'TD Rate (per Touch)',
                    calculate: (player) => {
                        const totalTDs = (player.totalRecTDs || 0) + (player.totalRushTDs || 0);
                        const totalTouches = (player.totalCarries || 0) + (player.totalRec || 0);
                        return totalTouches > 0 ? (totalTDs / totalTouches) * 100 : 0;
                    }
                },
                {
                    id: 'total_yards',
                    label: 'Total Yards per Game',
                    calculate: (player) => {
                        const totalYards = (player.totalRushYards || 0) + (player.totalRecYards || 0);
                        return totalYards / player.gamesPlayed;
                    }
                },
                {
                    id: 'receiving_yards',
                    label: 'Receiving Yards per Game',
                    calculate: (player) => (player.totalRecYards || 0) / player.gamesPlayed
                }
            ],
            TE: [
                {
                    id: 'fantasy_points',
                    label: 'Fantasy Points per Game',
                    calculate: (player) => player.avgPoints || 0
                },
                {
                    id: 'targets',
                    label: 'Targets per Game',
                    calculate: (player) => player.totalTargets / player.gamesPlayed
                },
                {
                    id: 'receptions',
                    label: 'Receptions per Game',
                    calculate: (player) => player.totalRec / player.gamesPlayed
                },
                {
                    id: 'receiving_yards',
                    label: 'Receiving Yards per Game',
                    calculate: (player) => player.totalYDS / player.gamesPlayed
                },
                {
                    id: 'catch_rate',
                    label: 'Catch Rate (%)',
                    calculate: (player) => player.catchRate || 0
                },
                {
                    id: 'target_share',
                    label: 'Target Share (%)',
                    calculate: (player) => {
                        // Calculate average team share across all weeks
                        if (!player.weeks || player.weeks.length === 0) return 0;
                        const totalShare = player.weeks.reduce((sum, w) => sum + (w.teamShare || 0), 0);
                        return totalShare / player.weeks.length;
                    }
                },
                {
                    id: 'rz_targets',
                    label: 'Red Zone Targets per Game',
                    calculate: (player) => (player.rzOpportunities || 0) / player.gamesPlayed
                },
                {
                    id: 'air_yards',
                    label: 'Air Yards per Game',
                    calculate: (player) => player.airYardsPerGame || 0
                },
                {
                    id: 'yac_per_rec',
                    label: 'Yards After Catch per Reception',
                    calculate: (player) => player.yacPerRec || 0
                },
                {
                    id: 'team_points',
                    label: 'Team Points per Game',
                    calculate: (player) => {
                        // Get team's average points from teamStats
                        if (!teamStats || !teamStats[player.team]) return 0;
                        return teamStats[player.team].avgPoints || 0;
                    }
                },
                {
                    id: 'receiving_tds',
                    label: 'Receiving TDs per Game',
                    calculate: (player) => (player.totalRecTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'rz_tds',
                    label: 'Red Zone TDs per Game',
                    calculate: (player) => (player.rzTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'yards_per_touch',
                    label: 'Yards per Reception',
                    calculate: (player) => {
                        return player.totalRec > 0 ? (player.totalYDS || 0) / player.totalRec : 0;
                    }
                },
                {
                    id: 'td_rate',
                    label: 'TD Rate (per Target)',
                    calculate: (player) => {
                        const totalTDs = player.totalRecTDs || 0;
                        return player.totalTargets > 0 ? (totalTDs / player.totalTargets) * 100 : 0;
                    }
                }
            ]
        };

        // Switch position in Advanced Analytics
        // Toggle axis control collapse/expand
        function toggleAxisControl(axisId) {
            const content = document.getElementById(`${axisId}-content`);
            const icon = document.getElementById(`${axisId}-icon`);

            if (content && icon) {
                if (content.classList.contains('collapsed')) {
                    content.classList.remove('collapsed');
                    icon.classList.remove('collapsed');
                } else {
                    content.classList.add('collapsed');
                    icon.classList.add('collapsed');
                }
            }
        }

        function switchAdvancedPosition(position) {
            advancedCurrentPosition = position;

            // Clear quadrant explanation when switching positions
            currentQuadrantExplanation = '';

            // Clear player highlight when switching positions
            clearPlayerHighlight();

            // Update button states
            document.getElementById('advanced-wr-btn').classList.toggle('active', position === 'WR');
            document.getElementById('advanced-rb-btn').classList.toggle('active', position === 'RB');
            document.getElementById('advanced-te-btn').classList.toggle('active', position === 'TE');

            // Populate preset buttons for new position
            populatePresetButtons();

            // Populate dropdowns with new stats
            populateAdvancedDropdowns();

            // Update scatter plot
            updateAdvancedScatter();
        }

        // Populate stat dropdowns
        function populateAdvancedDropdowns() {
            const stats = advancedStatDefinitions[advancedCurrentPosition];
            const xSelect = document.getElementById('x-axis-select');
            const ySelect = document.getElementById('y-axis-select');

            // Store current selections
            const currentX = xSelect.value;
            const currentY = ySelect.value;

            // Clear and populate
            xSelect.innerHTML = '';
            ySelect.innerHTML = '';

            stats.forEach(stat => {
                const xOption = document.createElement('option');
                xOption.value = stat.id;
                xOption.textContent = stat.label;
                xSelect.appendChild(xOption);

                const yOption = document.createElement('option');
                yOption.value = stat.id;
                yOption.textContent = stat.label;
                ySelect.appendChild(yOption);
            });

            // Set default selections or restore previous
            if (currentX && stats.find(s => s.id === currentX)) {
                xSelect.value = currentX;
            } else {
                // Default X-axis: Targets for WR, Opportunities for RB
                xSelect.value = advancedCurrentPosition === 'WR' ? 'targets' : 'opportunities';
            }

            if (currentY && stats.find(s => s.id === currentY)) {
                ySelect.value = currentY;
            } else {
                // Default Y-axis: Fantasy Points for both
                ySelect.value = 'fantasy_points';
            }
        }

        // Calculate stat value for a player
        function calculateAdvancedStat(player, statId, weekFilteredWeeks = null) {
            const stats = advancedStatDefinitions[advancedCurrentPosition];
            const stat = stats.find(s => s.id === statId);
            if (!stat) return 0;

            // Create a temporary player object with filtered weeks if provided
            const playerForCalc = weekFilteredWeeks ? {
                ...player,
                weeks: weekFilteredWeeks,
                gamesPlayed: weekFilteredWeeks.length,
                totalTargets: weekFilteredWeeks.reduce((sum, w) => sum + (w.targets || 0), 0),
                totalOpportunities: weekFilteredWeeks.reduce((sum, w) => sum + ((w.rushAttempts || 0) + (w.targets || 0)), 0),
                totalPoints: weekFilteredWeeks.reduce((sum, w) => sum + w.fpts, 0),
                avgPoints: weekFilteredWeeks.length > 0 ? weekFilteredWeeks.reduce((sum, w) => sum + w.fpts, 0) / weekFilteredWeeks.length : 0
            } : player;

            const value = stat.calculate(playerForCalc);
            return isFinite(value) ? value : 0;
        }

        // Get stat label
        function getAdvancedStatLabel(statId) {
            const stats = advancedStatDefinitions[advancedCurrentPosition];
            const stat = stats.find(s => s.id === statId);
            return stat ? stat.label : '';
        }

        // Generate intelligent quadrant explanations for custom stat combinations
        function generateQuadrantExplanation(xStatId, yStatId, xLabel, yLabel) {
            // Define stat categories
            const volumeStats = ['targets_per_game', 'opportunities_per_game', 'team_share', 'air_yards_per_game'];
            const efficiencyStats = ['yards_per_target', 'yards_per_reception', 'yards_per_touch', 'catch_rate', 'points_per_target', 'points_per_opportunity'];
            const productionStats = ['fantasy_ppg', 'yards_per_game', 'receiving_yards_per_game', 'rushing_yards_per_game'];
            const scoringStats = ['rz_targets_per_game', 'rz_opportunities_per_game', 'td_rate'];

            const xIsVolume = volumeStats.includes(xStatId);
            const xIsEfficiency = efficiencyStats.includes(xStatId);
            const xIsProduction = productionStats.includes(xStatId);
            const xIsScoring = scoringStats.includes(xStatId);

            const yIsVolume = volumeStats.includes(yStatId);
            const yIsEfficiency = efficiencyStats.includes(yStatId);
            const yIsProduction = productionStats.includes(yStatId);
            const yIsScoring = scoringStats.includes(yStatId);

            let explanation = '';

            // Volume vs Efficiency
            if ((xIsVolume && yIsEfficiency) || (xIsEfficiency && yIsVolume)) {
                explanation = `<strong>What to look for:</strong> Top-right = elite players with high volume AND efficiency (studs). Bottom-right = volume without efficiency (sell high). Top-left = efficient with low volume (buy low candidates).`;
            }
            // Volume vs Production
            else if ((xIsVolume && yIsProduction) || (xIsProduction && yIsVolume)) {
                explanation = `<strong>What to look for:</strong> Top-right = workhorses producing (league winners). Bottom-right = volume hogs underperforming (regression candidates). Top-left = efficient producers lacking volume (breakout potential if usage increases).`;
            }
            // Volume vs Scoring
            else if ((xIsVolume && yIsScoring) || (xIsScoring && yIsVolume)) {
                explanation = `<strong>What to look for:</strong> Top-right = high-volume goal-line threats (must-starts with TD upside). Bottom-right = volume without scoring opportunities (TD-dependent floor). Top-left = goal-line specialists (boom/bust).`;
            }
            // Efficiency vs Production
            else if ((xIsEfficiency && yIsProduction) || (xIsProduction && yIsEfficiency)) {
                explanation = `<strong>What to look for:</strong> Top-right = efficient producers (sustainable performers). Bottom-right = producing despite inefficiency (volume-driven, regression risk). Top-left = efficient low producers (need more volume).`;
            }
            // Efficiency vs Scoring
            else if ((xIsEfficiency && yIsScoring) || (xIsScoring && yIsEfficiency)) {
                explanation = `<strong>What to look for:</strong> Top-right = efficient players with TD equity (high ceiling). Bottom-right = TD-dependent without efficiency (volatility). Top-left = efficient players without scoring (steady floor, limited ceiling).`;
            }
            // Production vs Scoring
            else if ((xIsProduction && yIsScoring) || (xIsScoring && yIsProduction)) {
                explanation = `<strong>What to look for:</strong> Top-right = elite producers with scoring equity (championship upside). Bottom-right = big producers without TDs (high floor). Top-left = TD-dependent scorers (boom/bust weekly).`;
            }
            // Same category (e.g., two volume stats)
            else if ((xIsVolume && yIsVolume) || (xIsEfficiency && yIsEfficiency) || (xIsProduction && yIsProduction) || (xIsScoring && yIsScoring)) {
                explanation = `<strong>What to look for:</strong> Top-right = elite in both ${xLabel.includes('Opp') || yLabel.includes('Opp') ? 'opportunity metrics' : 'metrics'} (target these players). Bottom-left = struggling in both areas (avoid). Diagonal = trade-offs between the two stats.`;
            }
            // Generic fallback
            else {
                explanation = `<strong>What to look for:</strong> Top-right = above median in both ${xLabel} and ${yLabel} (target these players). Bottom-left = below median in both (avoid). <span style="color: var(--text-tertiary);">Grey dotted lines show median values.</span>`;
            }

            return explanation;
        }

        // Update scatter plot
        function updateAdvancedScatter() {
            if (!allPlayers || Object.keys(allPlayers).length === 0) {                return;
            }

            const xStatId = document.getElementById('x-axis-select').value;
            const yStatId = document.getElementById('y-axis-select').value;
            const weekRange = document.getElementById('week-range-select').value;

            const xLabel = getAdvancedStatLabel(xStatId);
            const yLabel = getAdvancedStatLabel(yStatId);

            // Update title with week range info
            const weekRangeText = weekRange === 'all' ? '' : ` (${document.getElementById('week-range-select').selectedOptions[0].text})`;
            document.getElementById('scatter-title').textContent = `${yLabel} vs ${xLabel}${weekRangeText}`;

            // Generate intelligent quadrant explanation based on stat combination
            const descriptionEl = document.getElementById('scatter-description');
            if (currentQuadrantExplanation) {
                descriptionEl.innerHTML =
                    `<strong>What to look for:</strong> ${currentQuadrantExplanation}`;
            } else {
                // Generate smart explanation based on metrics
                let explanation = generateQuadrantExplanation(xStatId, yStatId, xLabel, yLabel);
                descriptionEl.innerHTML = explanation;
            }

            // Convert allPlayers object to array and filter by position and games played
            const players = Object.values(allPlayers).filter(p =>
                p.position === advancedCurrentPosition &&
                p.gamesPlayed >= 3
            );

            // Calculate stats for each player with week filtering
            const scatterData = players.map(player => {
                const weekFilteredWeeks = getWeekFilteredData(player, weekRange);

                // Skip if no data in the selected week range
                if (weekFilteredWeeks.length === 0) return null;

                const x = calculateAdvancedStat(player, xStatId, weekFilteredWeeks);
                const y = calculateAdvancedStat(player, yStatId, weekFilteredWeeks);

                return {
                    x: x,
                    y: y,
                    player: player
                };
            }).filter(d => d && isFinite(d.x) && isFinite(d.y));

            // Render chart
            renderAdvancedScatter(scatterData, xLabel, yLabel);
        }

        // Render the scatter plot
        function renderAdvancedScatter(data, xLabel, yLabel) {
            const canvas = document.getElementById('advanced-scatter-chart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Destroy existing chart
            if (advancedScatterChart) {
                advancedScatterChart.destroy();
            }

            // Calculate medians
            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);

            const xMedian = xValues.length > 0 ? xValues[Math.floor(xValues.length / 2)] : 0;
            const yMedian = yValues.length > 0 ? yValues[Math.floor(yValues.length / 2)] : 0;

            // Calculate axis ranges with padding
            const xMin = Math.min(...xValues);
            const xMax = Math.max(...xValues);
            const yMin = Math.min(...yValues);
            const yMax = Math.max(...yValues);

            const xRange = xMax - xMin;
            const yRange = yMax - yMin;

            // Ensure minimum range to prevent overly zoomed charts
            const minRange = 0.1;
            const xPadding = Math.max(xRange * 0.1, minRange); // 10% padding or minimum
            const yPadding = Math.max(yRange * 0.1, minRange);

            // Handle edge case where all values are identical
            const xAxisMin = xRange > 0 ? xMin - xPadding : xMin - 1;
            const xAxisMax = xRange > 0 ? xMax + xPadding : xMax + 1;
            const yAxisMin = yRange > 0 ? yMin - yPadding : yMin - 1;
            const yAxisMax = yRange > 0 ? yMax + yPadding : yMax + 1;

            // Prepare datasets - separate highlighted players from others
            let datasets = [];

            // Regular players dataset (exclude any highlighted players)
            const regularData = highlightedPlayerIds.length > 0
                ? data.filter(d => !highlightedPlayerIds.includes(d.player.id))
                : data;

            datasets.push({
                label: advancedCurrentPosition,
                data: regularData,
                backgroundColor: regularData.map(d => {
                    const color = teamColors[d.player.team] || '#666';
                    return color + '99'; // Add transparency
                }),
                borderColor: regularData.map(d => teamColors[d.player.team] || '#666'),
                borderWidth: 2,
                pointRadius: 8,
                pointHoverRadius: 12,
                pointHoverBorderWidth: 3
            });

            // Highlighted players datasets (up to 4 players, all with white borders)
            if (highlightedPlayerIds.length > 0) {
                highlightedPlayerIds.forEach((playerId, index) => {
                    const highlightedData = data.filter(d => d.player.id === playerId);
                    if (highlightedData.length > 0) {
                        const player = highlightedData[0].player;
                        const color = teamColors[player.team] || '#666';

                        datasets.push({
                            label: `Highlighted ${index + 1}`,
                            data: highlightedData,
                            backgroundColor: color,
                            borderColor: '#fff',
                            borderWidth: 4,
                            pointRadius: 16,
                            pointHoverRadius: 20,
                            pointHoverBorderWidth: 5,
                            pointStyle: 'circle'
                        });
                    }
                });
            }

            // Create chart with median annotations
            advancedScatterChart = new Chart(ctx, {
                type: 'scatter',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: '#30d158',
                            borderWidth: 1,
                            padding: 12,
                            displayColors: false,
                            callbacks: {
                                title: (context) => {
                                    const point = context[0].raw;
                                    return `${point.player.name} (${point.player.team})`;
                                },
                                label: (context) => {
                                    const point = context.raw;
                                    return [
                                        `${xLabel}: ${point.x.toFixed(1)}`,
                                        `${yLabel}: ${point.y.toFixed(1)}`
                                    ];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                xMedianLine: {
                                    type: 'line',
                                    xMin: xMedian,
                                    xMax: xMedian,
                                    borderColor: 'rgba(142, 142, 147, 0.4)',
                                    borderWidth: 2,
                                    borderDash: [8, 4],
                                    label: {
                                        display: false
                                    }
                                },
                                yMedianLine: {
                                    type: 'line',
                                    yMin: yMedian,
                                    yMax: yMedian,
                                    borderColor: 'rgba(142, 142, 147, 0.4)',
                                    borderWidth: 2,
                                    borderDash: [8, 4],
                                    label: {
                                        display: false
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: xLabel,
                                color: '#8e8e93',
                                font: {
                                    size: 14,
                                    weight: '600'
                                }
                            },
                            min: xAxisMin,
                            max: xAxisMax,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)'
                            },
                            ticks: {
                                color: '#8e8e93',
                                font: {
                                    size: 12
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: yLabel,
                                color: '#8e8e93',
                                font: {
                                    size: 14,
                                    weight: '600'
                                }
                            },
                            min: yAxisMin,
                            max: yAxisMax,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)'
                            },
                            ticks: {
                                color: '#8e8e93',
                                font: {
                                    size: 12
                                }
                            }
                        }
                    },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const dataIndex = elements[0].index;
                            const player = data[dataIndex].player;
                            openPlayerModal(player.id);
                        }
                    }
                }
            });
        }

        // Initialize Advanced Analytics when page loads
        function initializeAdvancedAnalytics() {
            populatePresetButtons();
            populateAdvancedDropdowns();
            populateWeekSelector();
            updateAdvancedScatter();
        }

        // Populate week selector with dynamic week options
        function populateWeekSelector() {
            const select = document.getElementById('week-range-select');
            if (!select) return;

            // Find global max week
            let globalMaxWeek = 0;
            Object.values(allPlayers).forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });

            // Keep existing options and add individual week options
            let html = `
                <option value="all">All Weeks</option>
                <option value="last3">Last 3 Weeks</option>
                <option value="last5">Last 5 Weeks</option>
                <option value="1-4">Weeks 1-4</option>
                <option value="5-8">Weeks 5-8</option>
            `;

            // Add individual week options
            if (globalMaxWeek > 0) {
                html += `<option disabled>──────────</option>`;
                for (let week = 1; week <= globalMaxWeek; week++) {
                    html += `<option value="${week}">Week ${week} Only</option>`;
                }
            }

            select.innerHTML = html;
        }

        // FOOTER & AUTH FUNCTIONS

        // Google Sheets Integration for Waitlist
        const GOOGLE_SHEETS_URL = 'https://script.google.com/macros/s/AKfycbxgIp_XJLI1rc8g3cH4V6mQhXOQRE80vNyIQU18JiFRSInJwjjPfI5Qjj2i_3XgqRbSUg/exec';

        // Debug: Log that this script is loaded
        function submitWaitlist(event) {            event.preventDefault();
            event.stopPropagation();

            const emailInput = document.getElementById('waitlist-email');
            const successMsg = document.getElementById('waitlist-success');

            if (!emailInput || !successMsg) {                showWaitlistModal(false, 'Error: Form not properly initialized');
                return false;
            }

            const email = emailInput.value.trim();
            // Enhanced email validation
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!email || !emailRegex.test(email)) {                alert('⚠️ Please enter a valid email address');
                emailInput.focus();
                return false;
            }
            // Disable button and show loading state
            const submitBtn = event.target.querySelector('button[type="submit"]');
            if (submitBtn) {
                const originalBtnText = submitBtn.textContent;
                submitBtn.disabled = true;
                submitBtn.textContent = 'Submitting...';

                // Send to Google Sheets
                const payload = {
                    email: email,
                    timestamp: new Date().toISOString()
                };
                fetch(GOOGLE_SHEETS_URL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                }).then(() => {
                    // Show modal
                    showWaitlistModal(true);
                    emailInput.value = '';

                    // Re-enable button
                    submitBtn.disabled = false;
                    submitBtn.textContent = originalBtnText;

                }).catch(err => {
                    // Show modal anyway (no-cors mode doesn't return errors reliably)
                    showWaitlistModal(true);
                    emailInput.value = '';

                    // Re-enable button
                    submitBtn.disabled = false;
                    submitBtn.textContent = originalBtnText;
                });
            }

            return false;
        }

        // Make submitWaitlist globally available
        window.submitWaitlist = submitWaitlist;

        // Show waitlist confirmation modal
        function showWaitlistModal(success, customMessage) {
            const modal = document.getElementById('waitlist-modal');
            if (modal) {
                if (!success && customMessage) {
                    alert(customMessage);
                    return;
                }
                modal.classList.add('show');
            }
        }

        // Close waitlist modal
        function closeWaitlistModal() {
            const modal = document.getElementById('waitlist-modal');
            if (modal) {
                modal.classList.remove('show');
            }
        }

        // Login Modal Functions
        function showLoginModal() {
            document.getElementById('login-modal').style.display = 'flex';
            document.getElementById('login-error').classList.remove('show');
        }

        function closeLoginModal() {
            document.getElementById('login-modal').style.display = 'none';
            document.getElementById('login-email').value = '';
            document.getElementById('login-password').value = '';
            document.getElementById('login-error').classList.remove('show');
        }

        // Privacy Modal Functions
        function showPrivacyModal() {
            document.getElementById('privacy-modal').style.display = 'flex';
        }

        function closePrivacyModal() {
            document.getElementById('privacy-modal').style.display = 'none';
        }

        // Login handler - make it globally accessible
        window.handleLogin = function(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            const emailEl = document.getElementById('login-email');
            const passwordEl = document.getElementById('login-password');

            if (!emailEl || !passwordEl) {                alert('Error: Login form not properly initialized');
                return false;
            }

            const email = emailEl.value.trim();
            const password = passwordEl.value;
            const ADMIN_EMAIL = 'aryi3025@gmail.com';
            const ADMIN_PASSWORD = 'admin051213!';

            if (email === ADMIN_EMAIL && password === ADMIN_PASSWORD) {
                // Successful login                localStorage.setItem('ffse_admin_logged_in', 'true');
                closeLoginModal();
                updateUIForAdmin(true);

                // Navigate to admin panel
                setTimeout(() => {
                    navigateToPage('admin-panel');
                }, 100);

                alert('Login successful! Welcome back.');
            } else {
                // Failed login
                const errorMsg = document.getElementById('login-error');
                if (errorMsg) {
                    errorMsg.classList.add('show');

                    setTimeout(() => {
                        errorMsg.classList.remove('show');
                    }, 3000);
                } else {
                    alert('Invalid credentials. Please try again.');
                }
            }

            return false;
        };

        // Check if user is logged in on page load
        function checkAdminStatus() {
            const isLoggedIn = localStorage.getItem('ffse_admin_logged_in') === 'true';
            if (isLoggedIn) {                updateUIForAdmin(true);
            } else {
                updateUIForAdmin(false);
            }
            updateLastUpdatedDisplay();
        }

        // Function to navigate to a page (used by footer links)
        // MOBILE MENU FUNCTIONS

        function toggleMobileMenu() {
            const menuButton = document.querySelector('.mobile-menu-button');
            const menuOverlay = document.getElementById('mobile-menu-overlay');
            const menu = document.getElementById('mobile-menu');

            menuButton.classList.toggle('active');
            menuOverlay.classList.toggle('active');
            menu.classList.toggle('active');

            // Prevent body scroll when menu is open
            if (menu.classList.contains('active')) {
                document.body.style.overflow = 'hidden';
            } else {
                document.body.style.overflow = '';
            }
        }

        function closeMobileMenu() {
            const menuButton = document.querySelector('.mobile-menu-button');
            const menuOverlay = document.getElementById('mobile-menu-overlay');
            const menu = document.getElementById('mobile-menu');

            menuButton.classList.remove('active');
            menuOverlay.classList.remove('active');
            menu.classList.remove('active');
            document.body.style.overflow = '';
        }

        function navigateFromMobileMenu(pageName) {
            // Update mobile menu active state
            document.querySelectorAll('.mobile-menu-item').forEach(item => {
                item.classList.remove('active');
            });
            const activeMenuItem = document.querySelector(`.mobile-menu-item[data-page="${pageName}"]`);
            if (activeMenuItem) activeMenuItem.classList.add('active');

            // Close menu
            closeMobileMenu();

            // Navigate to page
            navigateToPage(pageName);

            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // NAVIGATION FUNCTIONS

        function navigateToPage(pageName) {
            // Update active tab
            document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
            const activeTab = document.querySelector(`.nav-tab[data-page="${pageName}"]`);
            if (activeTab) activeTab.classList.add('active');

            // Show page
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            const targetPage = document.getElementById(pageName);
            if (targetPage) targetPage.classList.add('active');

            // Expand all tiers IMMEDIATELY when navigating to WR, RB, or TE pages
            if (['wide-receivers', 'running-backs', 'tight-ends'].includes(pageName)) {
                expandAllTiers();
                // Also call again after a short delay to ensure everything is rendered
                setTimeout(() => {
                    expandAllTiers();
                }, 100);
            }

            // Render dashboard categories if on dashboard page
            if (pageName === 'top-movers') {
                setTimeout(() => {
                    renderDashboardCategories();
                    setTimeout(renderMiniScatterPlots, 100);
                }, 100);
            }

            // Render team analysis charts if on teams page (so animations play)
            if (pageName === 'teams') {
                setTimeout(() => {
                    updateTeamAnalysis();
                }, 100);
            }

            // Render all leaderboards if on all-leaderboards page
            if (pageName === 'all-leaderboards') {
                setTimeout(() => {
                    renderAllLeaderboards();
                }, 100);
            }

            // Scroll to top of page
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Set scoring format and reprocess all data
        function setScoringFormat(format) {
            // Show scoring format details
            if (format === 'std') {            } else if (format === 'half') {            } else {            }

            // Update global variable
            currentScoringFormat = format;

            // Save to localStorage
            localStorage.setItem('ffse_scoring_format', format);

            // Update UI - toggle buttons
            document.querySelectorAll('.scoring-option').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.format === format) {
                    btn.classList.add('active');
                }
            });

            // Add fade animation to main content
            const mainContent = document.querySelector('.main-content');
            if (mainContent) {
                mainContent.classList.add('updating-values');
                setTimeout(() => {
                    mainContent.classList.remove('updating-values');
                }, 600);
            }

            // Reprocess all data with new scoring format
            if (wrData && rbData) {                // Small delay to let fade animation start
                setTimeout(() => {
                    processAllData();
                }, 100);
            }
        }

        // Initialize scoring format on page load
        function initializeScoringFormat() {
            const savedFormat = localStorage.getItem('ffse_scoring_format') || 'ppr';
            currentScoringFormat = savedFormat;

            // Update UI to match saved format
            document.querySelectorAll('.scoring-option').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.format === savedFormat) {
                    btn.classList.add('active');
                }
            });

            // Update header dropdown
            updateHeaderScoringDropdown(savedFormat);            if (savedFormat === 'std') {            } else if (savedFormat === 'half') {            } else {            }
        }

        // Toggle header scoring dropdown
        function toggleHeaderScoringDropdown() {
            const dropdown = document.getElementById('header-scoring-dropdown');
            dropdown.classList.toggle('open');

            // Close dropdown when clicking outside
            if (dropdown.classList.contains('open')) {
                setTimeout(() => {
                    document.addEventListener('click', closeHeaderDropdownOutside);
                }, 0);
            } else {
                document.removeEventListener('click', closeHeaderDropdownOutside);
            }
        }

        function closeHeaderDropdownOutside(e) {
            const dropdown = document.getElementById('header-scoring-dropdown');
            if (!dropdown.contains(e.target)) {
                dropdown.classList.remove('open');
                document.removeEventListener('click', closeHeaderDropdownOutside);
            }
        }

        // Set scoring format from header dropdown
        function setHeaderScoringFormat(format) {
            // Close dropdown
            document.getElementById('header-scoring-dropdown').classList.remove('open');
            document.removeEventListener('click', closeHeaderDropdownOutside);

            // Update header dropdown UI
            updateHeaderScoringDropdown(format);

            // Call existing setScoringFormat function
            setScoringFormat(format);
        }

        // Update header dropdown display
        function updateHeaderScoringDropdown(format) {
            const label = document.getElementById('header-scoring-label');
            const buttons = document.querySelectorAll('.header-scoring-menu button');

            // Update label text
            if (format === 'ppr') {
                label.textContent = 'PPR';
            } else if (format === 'half') {
                label.textContent = 'Half-PPR';
            } else {
                label.textContent = 'Standard';
            }

            // Update active state
            buttons.forEach(btn => {
                btn.classList.remove('active');
                if ((format === 'ppr' && btn.textContent === 'PPR') ||
                    (format === 'half' && btn.textContent === 'Half-PPR') ||
                    (format === 'std' && btn.textContent === 'Standard')) {
                    btn.classList.add('active');
                }
            });
        }

        // Scroll to waitlist section
        function scrollToWaitlist() {
            const footer = document.querySelector('.footer');
            if (footer) {
                footer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                setTimeout(() => {
                    const emailInput = document.getElementById('waitlist-email');
                    if (emailInput) emailInput.focus();
                }, 500);
            }
        }

        // Update last updated date display
        function updateLastUpdatedDisplay() {
            const lastUpdated = localStorage.getItem('ffse_last_updated');
            const displayEl = document.getElementById('last-updated-date');

            if (displayEl) {
                if (lastUpdated) {
                    const date = new Date(lastUpdated);
                    const options = { month: 'short', day: 'numeric', year: 'numeric' };
                    displayEl.textContent = date.toLocaleDateString('en-US', options);
                } else {
                    displayEl.textContent = 'No data uploaded';
                }
            }
        }

        // Set last updated date
        function setLastUpdatedDate() {
            const now = new Date().toISOString();
            localStorage.setItem('ffse_last_updated', now);
            updateLastUpdatedDisplay();
        }

        // Update UI based on admin status
        function updateUIForAdmin(isAdmin) {
            const adminLoginLink = document.getElementById('admin-login-link');
            const adminTab = document.getElementById('admin-tab');
            const mobileAdminTab = document.getElementById('mobile-admin-tab');

            if (isAdmin) {
                // Show admin tab (desktop and mobile)
                if (adminTab) adminTab.style.display = 'block';
                if (mobileAdminTab) mobileAdminTab.style.display = 'block';

                // Update footer link
                if (adminLoginLink) {
                    adminLoginLink.textContent = 'Admin Panel';
                    adminLoginLink.onclick = (e) => {
                        e.preventDefault();
                        navigateToPage('admin-panel');
                        return false;
                    };
                }
            } else {
                // Hide admin tab (desktop and mobile)
                if (adminTab) adminTab.style.display = 'none';
                if (mobileAdminTab) mobileAdminTab.style.display = 'none';

                // Update footer link
                if (adminLoginLink) {
                    adminLoginLink.textContent = 'Admin Login';
                    adminLoginLink.onclick = (e) => {
                        e.preventDefault();
                        showLoginModal();
                        return false;
                    };
                }
            }

            // Update admin panel display if on that page
            updateAdminPanelDisplay();
        }

        // Logout admin
        function logoutAdmin() {
            localStorage.removeItem('ffse_admin_logged_in');
            updateUIForAdmin(false);
            // Navigate to dashboard if currently on admin panel
            if (document.getElementById('admin-panel').classList.contains('active')) {
                navigateToPage('top-movers');
            }
            alert('Logged out successfully');
        }

        // Update admin panel display with current data info
        function updateAdminPanelDisplay() {
            const lastUpdatedEl = document.getElementById('admin-last-updated');
            if (lastUpdatedEl) {
                const lastUpdated = localStorage.getItem('ffse_last_updated');
                if (lastUpdated) {
                    const date = new Date(lastUpdated);
                    const options = { month: 'short', day: 'numeric', year: 'numeric', hour: 'numeric', minute: '2-digit' };
                    lastUpdatedEl.textContent = date.toLocaleDateString('en-US', options);
                } else {
                    lastUpdatedEl.textContent = 'No data uploaded';
                }
            }
        }

        // Admin upload handlers
        function handleAdminWRUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const statusEl = document.getElementById('admin-wr-status');
                if (statusEl) statusEl.textContent = 'Processing...';
                if (statusEl) statusEl.style.color = 'var(--text-secondary)';

                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        wrData = results.data.filter(row => row.Player && row.Week);
                        localStorage.setItem('wrData', JSON.stringify(wrData));

                        if (statusEl) statusEl.textContent = '✓ WR data uploaded successfully';
                        if (statusEl) statusEl.style.color = 'var(--positive)';

                        if (rbData && teData) {
                            processAllData();
                            updateAdminPanelDisplay();
                        }
                    },
                    error: function(error) {
                        if (statusEl) statusEl.textContent = '✗ Error uploading WR data';
                        if (statusEl) statusEl.style.color = 'var(--negative)';                    }
                });
            }
        }

        function handleAdminRBUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const statusEl = document.getElementById('admin-rb-status');
                if (statusEl) statusEl.textContent = 'Processing...';
                if (statusEl) statusEl.style.color = 'var(--text-secondary)';

                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        rbData = results.data.filter(row => row.Player && row.Week);
                        localStorage.setItem('rbData', JSON.stringify(rbData));

                        if (statusEl) statusEl.textContent = '✓ RB data uploaded successfully';
                        if (statusEl) statusEl.style.color = 'var(--positive)';

                        if (wrData && teData) {
                            processAllData();
                            updateAdminPanelDisplay();
                        }
                    },
                    error: function(error) {
                        if (statusEl) statusEl.textContent = '✗ Error uploading RB data';
                        if (statusEl) statusEl.style.color = 'var(--negative)';                    }
                });
            }
        }

        function handleAdminTEUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const statusEl = document.getElementById('admin-te-status');
                if (statusEl) statusEl.textContent = 'Processing...';
                if (statusEl) statusEl.style.color = 'var(--text-secondary)';

                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        teData = results.data.filter(row => row.Player && row.Week);
                        localStorage.setItem('teData', JSON.stringify(teData));

                        if (statusEl) statusEl.textContent = '✓ TE data uploaded successfully';
                        if (statusEl) statusEl.style.color = 'var(--positive)';

                        if (wrData && rbData) {
                            processAllData();
                            updateAdminPanelDisplay();
                        }
                    },
                    error: function(error) {
                        if (statusEl) statusEl.textContent = '✗ Error uploading TE data';
                        if (statusEl) statusEl.style.color = 'var(--negative)';                    }
                });
            }
        }

        // Ticker tooltip toggle function (mobile-friendly)
        function toggleTickerTooltip(event) {
            event.stopPropagation();
            const icon = event.currentTarget;
            const tooltip = icon.querySelector('.ticker-tooltip');

            // Close all other ticker tooltips
            document.querySelectorAll('.ticker-tooltip.active').forEach(otherTooltip => {
                if (otherTooltip !== tooltip) {
                    otherTooltip.classList.remove('active');
                }
            });

            // Toggle this tooltip
            tooltip.classList.toggle('active');
        }

        // Close ticker tooltips when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.ticker-info-icon')) {
                document.querySelectorAll('.ticker-tooltip.active').forEach(tooltip => {
                    tooltip.classList.remove('active');
                });
            }
        });

        // Leaderboard tooltip toggle function (mobile-friendly)
        function toggleLeaderboardTooltip(event) {
            event.stopPropagation();
            const icon = event.currentTarget;
            const tooltip = icon.querySelector('.leaderboard-tooltip');

            // Close all other leaderboard tooltips
            document.querySelectorAll('.leaderboard-tooltip.active').forEach(otherTooltip => {
                if (otherTooltip !== tooltip) {
                    otherTooltip.classList.remove('active');
                }
            });

            // Toggle this tooltip
            tooltip.classList.toggle('active');
        }

        // Close leaderboard tooltips when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.leaderboard-info-icon')) {
                document.querySelectorAll('.leaderboard-tooltip.active').forEach(tooltip => {
                    tooltip.classList.remove('active');
                });
            }
        });

        // Portal tooltip system for leaderboard metrics
        function initializePortalTooltip() {
            // Create tooltip element if it doesn't exist
            let tooltip = document.getElementById('portal-tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'portal-tooltip';
                document.body.appendChild(tooltip);
            }

            // Add event listeners using delegation
            document.addEventListener('mouseover', function(e) {
                const target = e.target.closest('.compact-metric-value');
                if (target && target.hasAttribute('data-tooltip-text')) {
                    const tooltipText = target.getAttribute('data-tooltip-text');
                    const rect = target.getBoundingClientRect();

                    // Set tooltip content
                    tooltip.innerHTML = tooltipText + '<span class="tooltip-secondary">Bar shows relative performance vs. #1</span>';

                    // Make visible but transparent to measure
                    tooltip.style.opacity = '0';
                    tooltip.style.display = 'block';

                    // Get dimensions after content is set
                    const tooltipWidth = tooltip.offsetWidth;
                    const tooltipHeight = tooltip.offsetHeight;

                    // Position tooltip to the left of the element
                    let left = rect.left - tooltipWidth - 12;
                    let top = rect.top + (rect.height / 2) - (tooltipHeight / 2);

                    // If tooltip goes off left edge, show on right instead
                    if (left < 10) {
                        left = rect.right + 12;
                    }

                    // Keep tooltip within viewport vertically
                    if (top < 10) {
                        top = 10;
                    } else if (top + tooltipHeight > window.innerHeight - 10) {
                        top = window.innerHeight - tooltipHeight - 10;
                    }

                    tooltip.style.left = left + 'px';
                    tooltip.style.top = top + 'px';
                    tooltip.style.opacity = '';
                    tooltip.style.display = '';
                    tooltip.classList.add('visible');
                }
            });

            document.addEventListener('mouseout', function(e) {
                const target = e.target.closest('.compact-metric-value');
                if (target && target.hasAttribute('data-tooltip-text')) {
                    tooltip.classList.remove('visible');
                }
            });
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', () => {
            initializeScoringFormat();
            checkAdminStatus();
            initializePortalTooltip();

            // Fetch injury data from Sleeper API (runs in background)
            fetchInjuryData().then(() => {
                // Re-render pages if injury data affects display
                const activePage = document.querySelector('.page.active');
                if (activePage && activePage.id === 'wr-page' && wrData) {
                    renderWRPlayerCards();
                } else if (activePage && activePage.id === 'rb-page' && rbData) {
                    renderRBPlayerCards();
                } else if (activePage && activePage.id === 'te-page' && teData) {
                    renderTEPlayerCards();
                }
            });

            // Expand all tiers on page load
            setTimeout(() => {
                expandAllTiers();
            }, 100);
        });

    </script>
</body>
</html>
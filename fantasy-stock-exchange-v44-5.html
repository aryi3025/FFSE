<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FFSE - Fantasy Football Stock Exchange</title>
    <!-- 
    Version: 44.5 - Default Page Change
    
    UPDATES FROM V44.4:
    - CHANGED: Page now opens to WR Rankings by default (was Dashboard)
    - IMPROVED: Users land directly on player rankings when visiting the site
    
    PREVIOUS UPDATES (V44.4):
    - FIXED: TE Receiving Yards now has fallback logic - tries REC_YDS column first, then falls back to YDS column
    - NOTE: This ensures TEs display receiving yards data in Advanced Analytics scatterplot regardless of CSV column naming
    
    PREVIOUS UPDATES (V44.3):
    - FIXED: Target Leaders (TE) leaderboard now properly calculates data (TEs were excluded from globalMaxWeek calculation)
    - FIXED: getLast3GamesAvg function now includes aggregatedTEs when finding current week
    - FIXED: avgVolume for TEs now uses 'targets' (like WRs) instead of 'opportunities' (like RBs)
    - FIXED: RZ opportunities calculation now includes teData for TE position
    - IMPROVED: RZ Dominance (TE) tooltip now explains the scoring formula: "RZ Score = (RZ Targets + RZ TDs × 3) per game"
    - CONFIRMED: TE Receiving Yards per Game uses correct property (totalYDS) in Advanced Analytics
    - NOTE: Target Leaders (TE) should now appear in both carousel and All Leaderboards page
    
    PREVIOUS UPDATES (V44.2):
    - FIXED: All 3 new leaderboards now appear in BOTH the dashboard carousel AND "All Leaderboards" page
    - FIXED: RZ TDs per game now correctly calculates as RZ_REC_TD + RZ_RUSH_TD (was looking for wrong column)
    - FEATURE: Dashboard carousel now shows 11 total leaderboards (added Target Leaders TE, RZ Dominance TE, Total TD Leaders WR)
    - IMPROVED: RZ TD data will now properly populate in Advanced Analytics scatterplots
    
    PREVIOUS UPDATES (V44.1):
    - FIXED: Removed pulse animation from non-clickable boxes (Highlight Player, Week Range) - only X/Y axis labels animate now
    - FIXED: RZ_TD column now supports multiple naming variations (RZ_TD, 'RZ TD') for better CSV compatibility
    - CONFIRMED: Target Leaders (TE) leaderboard is present and functional
    - IMPROVED: Cleaner UI - only clickable axis selectors have visual feedback
    
    PREVIOUS UPDATES (V44):
    - FEATURE: Added TD stats to Advanced Analytics (all stats already in code, now aggregated properly):
      * WR: Receiving TDs/g, Rushing TDs/g, Total TDs/g, RZ TDs/g, Yards per Touch, TD Rate, Total Yards/g, Rushing Yards/g
      * RB: Receiving TDs/g, Rushing TDs/g, Total TDs/g, RZ TDs/g, Yards per Touch, TD Rate, Total Yards/g, Receiving Yards/g
      * TE: Receiving TDs/g, RZ TDs/g, Yards per Reception, TD Rate (per Target)
    - FEATURE: Three new leaderboards (all based on last 3 games, sorted by per-game avg):
      * Target Leaders (TE): TEs with highest targets per game
      * Red Zone Dominance (TE): TEs with most RZ targets + TDs combined (weighted: RZ_TDs × 3 + RZ_Tgt)
      * Total TD Leaders (WR): WRs with most total touchdowns (receiving + rushing)
    - DATA: All TD stats now properly aggregated from CSV (totalRecTDs, totalRushTDs, rzTDs)
    - DATA: WR rushing stats now tracked (totalRushYards, totalCarries from RUSH_YDS and CARRIES columns)
    - IMPROVED: Smart TD display pattern ready (combined by default, split in tooltips - future implementation)
    - LEADERBOARDS: All three new leaderboards fully functional and displaying in All Leaderboards page
    - ANALYTICS: Chart defaults unchanged (Opportunity Share vs Avg Points remains default)
    
    PREVIOUS UPDATES (V43):
    - NOTE: Player cards unchanged - focus remains on core stats (Avg Points & Targets/Opps)
    
    PREVIOUS UPDATES (V43):
    - FIXED: Tucker Kraft now marked as inactive and displays his actual average points
    - LOGIC: Kraft no longer artificially capped at 10.9 ppg, shows real avg but stays below elite TEs
    
    PREVIOUS UPDATES (V42):
    - FIXED: TE player card charts now render correctly (matches WR/RB chart rendering pattern)
    - FIXED: Leaderboard carousel layout - ranking now appears first (left-aligned), then team, player, metrics
    - FEATURE: Full TE Rankings page with 6-tier system (Elite TE1, High-End TE1, Solid TE1, TE2, Flex/Streamer, Depth)
    - FEATURE: Rank-based top 3 tiers (max 3, 3-5, 6-8 players per tier)
    - FEATURE: 1-game players capped at tier 4 (10+ pts) or tier 5 (<10 pts) until more games played
    - FEATURE: Players who haven't played in 2+ weeks demoted by 1 tier (~3.5 ppg penalty)
    - FEATURE: Darren Waller specifically capped at TE2 tier max until he returns
    - FEATURE: Charts displayed for tiers 1-5 only (tier 6 no charts)
    - FEATURE: TE Top Movers widgets (opportunity share + fantasy points momentum)
    - FEATURE: Player card comparisons vs Top 12 TEs (not Top 24)
    - FEATURE: Full TE tag support (Buy Low, Sell High, RZ Trend Up, Momentum badges)
    - FEATURE: TEs included in momentum calculations using WR-style metrics
    - IMPROVED: All tooltips work for TEs on both player cards and modals
    - STATS: Avg Points & Targets/Game displayed on TE cards
    
    PREVIOUS UPDATES (V41):
    - FIXED: Updated receiving yards column from "YDS" to "REC_YDS" to match new data format
    - FIXED: TE metrics now calculate properly (catch rate, air yards/game, YAC/reception)
    - FEATURE: Full TE support in Advanced Analytics
    - IMPROVED: Cleaner presentation for lower-tier RBs without visual clutter
    - LOGIC: Prevents one-game wonders from ranking above established players
    - CONSISTENCY: Matches WR 1-2 game restriction logic (both positions now have sample size protection)
    
    PREVIOUS UPDATES (V39):
    - FEATURE: Added "Solid WR2" tier between High Upside WR2 (14.5-17 ppg) and Mid WR2 (10-12 ppg)
    - FEATURE: Players with only 1-2 games played are capped at WR3/Flex tier max (7.9 ppg)
    - REMOVED: Player card charts no longer render for Low WR2/Flex and below tiers
    - IMPROVED: Chart rendering based on tier settings rather than arbitrary top 50 cutoff
    - IMPROVED: Cleaner presentation for lower-tier players without visual clutter
    - Previous v38 features maintained (rank-based top tiers, Solid WR1 tier)
    
    PREVIOUS UPDATES (V38):
    - CHANGED: WR tier structure to rank-based for top two tiers
    - FEATURE: "Elite WR1" tier now capped at exactly 4 players (top 4 by avg points)
    - FEATURE: "High-End WR1" tier now capped at exactly 4 players (ranks 5-8)
    - FEATURE: "Solid WR1" tier captures remaining WR1s (17+ ppg after top 8)
    - RENAMED: "Solid WR2" → "High Upside WR2" (13-17 ppg)
    - IMPROVED: Prevents tier bloat at the top, ensures cleaner tier distribution
    - Previous v37 features maintained (removed TE from position group)
    
    PREVIOUS UPDATES (V37):
    - REMOVED: TE option from position group dropdown in Team Analysis
    - NOTE: TEs still included in WR pie charts, stacked bars, and league comparison totals
    - Previous v36 features maintained (collapsible axis controls, 4-player highlighting)
    
    PREVIOUS UPDATES (V36):
    - FEATURE: X-Axis and Y-Axis stat boxes are now collapsible on Advanced Analytics page
    - FEATURE: Stat boxes start in collapsed state for cleaner initial view
    - FEATURE: Increased max highlighted players from 2 to 4
    - IMPROVED: All highlighted players shown with clean white circle borders (simplified)
    - IMPROVED: Placeholder text updated to "Search to highlight players (Max 4)"
    - Previous v35 fixes maintained (pie chart colors, carousel alignment)
    
    PREVIOUS UPDATES (V35):
    - FIXED: Single player pie charts now use 85% opacity (was 45%) so team colors are visible
    - FIXED: Carousel left edge now aligns with page content (Dashboard title)
    - FIXED: Carousel right edge cuts off cleanly at content boundary
    - Previous v34 features maintained (community sentiment, streamlined modals, etc.)
    
    PREVIOUS UPDATES (V34):
    - REMOVED: AI Analysis section from player modals
    - REMOVED: "Last Game Share" chart tab
    - REMOVED: "Share Trends" chart tab
    - REMOVED: Tooltips from dashboard carousel (clean design)
    - FEATURE: New compact horizontal community sentiment bar between stats and charts
    - FEATURE: Horizontal sentiment shows dominant vote percentage, visual bar, counts, and voting buttons
    - IMPROVED: Player modals now focus on Performance Consistency and Player Profile charts only
    - IMPROVED: Cleaner modal layout with sentiment integrated into main flow
    - IMPROVED: Both top-right sentiment card and horizontal bar stay in sync
    - All previous v33 features maintained (tooltips on modal stats, simplified colors, etc.)
    
    PREVIOUS UPDATES (V31):
    - FIXED: Bar alignment issue - now using single dataset instead of two overlapping datasets
    - FIXED: Pittsburgh (PIT) primary color changed from yellow to black (#000000)
    - FEATURE: ALL 32 team labels now visible with two-column staggered layout
    - FEATURE: Two-column stagger - even teams right-aligned, odd teams left-aligned with extra padding
    - FEATURE: Simplified color system - uses only primary team color with progressive shades to off-white
    - FEATURE: Redesigned modal sentiment card - visual display with large percentage, badge, and vote breakdown
    - FEATURE: Modal sentiment card positioned in top-right corner with elevated card design
    - FEATURE: Comprehensive tooltips on ALL modal stat boxes (WR & RB specific)
    - FEATURE: Dynamic tooltip updates based on position - WR shows target-based explanations, RB shows opportunity-based
    - FEATURE: Enhanced dashboard leaderboard tooltips covering all metric types
    - IMPROVED: Selected team label is bright white (#ffffff), bold, and larger (13px vs 10px)
    - IMPROVED: Other team labels are dimmed to secondary gray (#8e8e93)
    - IMPROVED: Community sentiment badges on player cards sized at 10px (optimized)
    - IMPROVED: Modal sentiment shows dominant vote (Buy/Hold/Sell) with large visual indicator
    - IMPROVED: Dashboard metric tooltips explain Opps/Game, Pts/Tgt, Pts/Opp, RZ, Yds/Att, Air Yards, Target Share
    - IMPROVED: Default modal labels use "OPP SHARE" for consistency across positions
    - IMPROVED: Dummy sentiment data flows through to modal for top 10 players
    - IMPROVED: Pie charts and stacked bars use consistent shading from primary color
    - IMPROVED: "Other" category always displays in gray across all charts
    - REMOVED: Hover zoom on league comparison chart (not needed with visible labels)
    
    PREVIOUS UPDATES (V31):
    
    PREVIOUS UPDATES (V31):
    - UPDATED: All team color palettes to match official team branding (dark UI optimized)
    - FEATURE: RBs now included in WR pie charts and season-long stacked bars based on target share
    - FEATURE: Total targets/opportunities displayed on all team analysis charts  
    - IMPROVED: Season-long charts now take full horizontal width of container
    - FIXED: League comparison properly disabled when season-long is selected
    - IMPROVED: Color generation for 5+ players uses sensible team-aligned colors
    
    PREVIOUS UPDATES (V30):
    - ADDED: Comprehensive Team Analysis section below scatter plot on Team Outlook page
    - FEATURE: Team selector, position group (WR/RB), and time frame controls (single week, last 3/5, season)
    - CHARTS: Pie chart showing top 5 players' share distribution (rest in "Other")
    - CHARTS: Bar chart showing total targets/opportunities by player
    - CHARTS: League comparison chart showing team volume vs all other teams (toggle on/off)
    - CHARTS: Season long view with stacked bar (WR) or line chart (RB) showing weekly trends
    - FEATURE: Collapsible divisions grid - all 8 NFL divisions with team cards (start collapsed)
    - UI: Click any team card to select it in Team Analysis
    - LOGIC: Smart "Other" category - if 5th player < 3% share, moved to "Other"
    - LOGIC: Dynamic top 4-5 players per week for season long view
    - STYLING: Matches Advanced Analytics dark theme with matte cards and team colors
    - DEFAULT: First team alphabetically selected, league comparison ON, divisions collapsed
    - IMPROVED: Team Outlook scatter plot "What to look for" text with proper capitalization
    - REMOVED: Scatter plot quadrant labels for cleaner visualization
    
    PREVIOUS UPDATES (V29):
    - REMOVED: Voting display from All Leaderboards page (was showing dummy data)
    - MOVED: Voting now displays on player cards in WR and RB pages ONLY
    - ADDED: Ability to highlight TWO players at once in Advanced Analytics (within same position)
    - IMPROVED: Multi-player comparison on scatter plots
    
    PREVIOUS UPDATES (V28):
    - REMOVED: Market Intelligence section entirely (HTML, CSS, JS, function calls)
    - IMPROVED: Change calculation now handles players with only 2 weeks of data (uses last 2 weeks vs prior 3)
    - ADDED: Dummy voting data for top 10 WRs and RBs (10k total votes, 60-75% buy, 10-20% sell, remainder hold)
    - REORDERED: "See All" leaderboards page - volume together, red zone together, efficiency together
      1. Volume Monsters (RB) + High-Volume Alphas (WR)
      2. Red Zone Kings (WR) + Red Zone Backs (RB)
      3. Efficiency Elites + RB Efficiency
      4. Air Yards Leaders (WR) + Pass-Catching Backs (RB) at end
    
    PREVIOUS FEATURES (V27):
    - Simplified change tooltip to "vs prior 3 weeks"
    - Added change metric calculation for RB Efficiency
    - Created "All Leaderboards" page with compact card design
    - Custom tooltips on All Leaderboards page
    - Placeholder hyphen for missing change data
    
    PREVIOUS FEATURES (V25-26):
    - 8 Total Leaderboards on Dashboard
    - Red Zone Kings (WR) and Red Zone Backs (RB)
    - RB Efficiency, Air Yards Leaders, Pass-Catching Backs
    - Compact single-line cards on All Leaderboards page
    - Waitlist submission with modal confirmation
    
    GOOGLE SHEETS SETUP INSTRUCTIONS:
    1. Go to your Google Sheet: https://docs.google.com/spreadsheets/d/18Val4APmsHsoGXPYJg3gAD-lbfx-_9n7UULn_dQs6Zg/edit
    2. Click Extensions > Apps Script
    3. Delete any existing code and paste this:
    
    function doPost(e) {
      var sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Sheet1'); // Change if needed
      var data = JSON.parse(e.postData.contents);
      sheet.appendRow([data.email, data.timestamp]);
      return ContentService.createTextOutput(JSON.stringify({result: 'success'}))
        .setMimeType(ContentService.MimeType.JSON);
    }
    
    4. Click Deploy > New deployment
    5. Select "Web app" as deployment type
    6. Set "Execute as" to your account
    7. Set "Who has access" to "Anyone"
    8. Click Deploy and copy the Web app URL
    9. Replace YOUR_SCRIPT_ID in line 13630 with your deployment URL
    10. Make sure your Google Sheet has "Sheet1" or update the code above
    -->
    
    <!-- External Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    
    <style>
        /* ============================================
           1. BASE & RESET
           ============================================ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Background Colors */
            --bg-primary: #000;
            --bg-secondary: #0a0a0a;
            --bg-tertiary: #1c1c1e;
            --bg-elevated: #2c2c2e;
            
            /* Text Colors */
            --text-primary: #fff;
            --text-secondary: #8e8e93;
            --text-tertiary: #636366;
            
            /* Accent Colors */
            --positive: #30d158;
            --positive-bg: rgba(48, 209, 88, 0.15);
            --negative: #ff453a;
            --negative-bg: rgba(255, 69, 58, 0.15);
            
            /* UI Elements */
            --border-color: #1c1c1e;
            --border-color-light: #2c2c2e;
            
            /* Spacing */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', system-ui, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow-x: hidden;
        }

        /* ============================================
           2. LAYOUT
           ============================================ */
        .app-container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .main-content {
            flex: 1;
            padding: var(--spacing-lg);
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        .page {
            display: none;
            animation: fadeIn 0.3s ease-in;
        }

        .page.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* ============================================
           3. HEADER
           ============================================ */
        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .ticker-section {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            overflow: hidden;
            position: sticky;
            top: 73px; /* Below header */
            z-index: 99;
            margin-bottom: 24px;
            border-radius: 0; /* Remove border radius when sticky */
        }
        
        .ticker-header {
            padding: 8px 24px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .ticker-content {
            overflow: hidden;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: var(--spacing-md) var(--spacing-lg);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 24px;
            font-weight: 700;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #30d158, #0a84ff);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            font-size: 22px;
            font-weight: 900;
            color: white;
            box-shadow: 0 0 20px rgba(48, 209, 88, 0.4),
                        0 0 40px rgba(10, 132, 255, 0.2);
            transition: all 0.3s ease;
        }
        
        .logo-icon:hover {
            animation: logoPulse 2s ease-in-out infinite;
        }
        
        @keyframes logoPulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(48, 209, 88, 0.4),
                            0 0 40px rgba(10, 132, 255, 0.2);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 30px rgba(48, 209, 88, 0.6),
                            0 0 60px rgba(10, 132, 255, 0.4);
                transform: scale(1.05);
            }
        }
        
        .logo-icon::before {
            content: '>';
            transform: scaleX(1.3);
        }

        .nav-tabs {
            display: flex;
            gap: var(--spacing-sm);
        }

        .nav-tab {
            padding: var(--spacing-sm) var(--spacing-md);
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .nav-tab:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .nav-tab.active {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            position: relative;
        }
        
        .nav-tab.active::after {
            content: '';
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 2px;
            background: var(--positive);
            border-radius: 2px;
        }

        .upload-btn {
            padding: var(--spacing-sm) var(--spacing-md);
            background: var(--positive);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .upload-btn:hover {
            background: #28c149;
            transform: translateY(-1px);
        }

        /* ============================================
           4. TICKER
           ============================================ */
        
        /* Header Scoring Dropdown */
        .header-scoring-dropdown {
            position: relative;
            display: inline-block;
        }
        
        .header-scoring-button {
            padding: 6px 16px;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-primary);
            background: var(--bg-tertiary);
            border: none;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 6px;
            position: relative;
        }
        
        .header-scoring-button::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 50%;
            transform: translateX(-50%);
            width: 16px;
            height: 2px;
            background: var(--positive);
            border-radius: 2px;
        }
        
        .header-scoring-button:hover {
            background: var(--bg-elevated);
        }
        
        .header-scoring-button .arrow {
            font-size: 10px;
            transition: transform 0.2s ease;
        }
        
        .header-scoring-dropdown.open .header-scoring-button .arrow {
            transform: rotate(180deg);
        }
        
        .header-scoring-menu {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: var(--bg-elevated);
            border-radius: 12px;
            padding: 6px;
            min-width: 140px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.2s ease;
            z-index: 1000;
        }
        
        .header-scoring-dropdown.open .header-scoring-menu {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        
        .header-scoring-menu button {
            width: 100%;
            padding: 10px 16px;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .header-scoring-menu button:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
        }
        
        .header-scoring-menu button.active {
            background: var(--positive);
            color: white;
        }
        
        .ticker-container {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            overflow: hidden;
            height: 40px;
            display: flex;
            align-items: center;
        }

        .ticker-track {
            display: flex;
            animation: scroll 60s linear infinite;
            white-space: nowrap;
        }

        @keyframes scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        
        @keyframes scrollReverse {
            0% { transform: translateX(-50%); }
            100% { transform: translateX(0%); }
        }
        
        .ticker-track {
            animation-duration: 540s !important;
        }

        .ticker-item {
            padding: 0 var(--spacing-lg);
            font-size: 13px;
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .ticker-item .player-name {
            font-weight: 600;
            color: var(--text-primary);
        }

        .ticker-item .avg-pts {
            color: var(--text-secondary);
        }

        .ticker-item .change {
            font-weight: 600;
        }

        .ticker-item .change.positive {
            color: var(--positive);
        }

        .ticker-item .change.negative {
            color: var(--negative);
        }

        /* ============================================
           SCORING FORMAT TOGGLE (Legacy - now in header)
           ============================================ */
        .scoring-toggle-container {
            display: none; /* Moved to header */
        }

        .scoring-toggle {
            display: inline-flex;
            background: var(--bg-tertiary);
            border-radius: 20px;
            padding: 4px;
            gap: 4px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .scoring-option {
            padding: 8px 20px;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            background: transparent;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
        }

        .scoring-option:hover {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.05);
        }

        .scoring-option.active {
            background: var(--bg-elevated);
            color: var(--text-primary);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .scoring-option.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 2px;
            background: var(--positive);
            border-radius: 2px;
        }

        /* Value update animation */
        @keyframes fadeUpdate {
            0% { opacity: 1; }
            50% { opacity: 0.4; }
            100% { opacity: 1; }
        }

        .updating-values {
            animation: fadeUpdate 0.6s ease-in-out;
        }

        /* ============================================
           5. TABLES
           ============================================ */
        .player-table {
            background: var(--bg-secondary);
            border-radius: 12px;
            overflow: hidden;
            margin-top: var(--spacing-lg);
        }

        .table-header {
            display: grid;
            grid-template-columns: 50px 60px 1fr 80px 80px 80px 100px 120px;
            gap: var(--spacing-md);
            padding: var(--spacing-md) var(--spacing-lg);
            background: var(--bg-tertiary);
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid var(--border-color);
        }

        .table-header > div {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .table-header > div:hover {
            color: var(--text-primary);
        }

        .player-row {
            display: grid;
            grid-template-columns: 50px 60px 1fr 80px 80px 80px 100px 120px;
            gap: var(--spacing-md);
            padding: var(--spacing-md) var(--spacing-lg);
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .mini-chart {
            width: 100%;
            height: 30px;
            position: relative;
        }
        
        .mini-chart canvas {
            width: 100% !important;
            height: 30px !important;
        }

        .player-row:hover {
            background: var(--bg-tertiary);
        }

        .player-row:last-child {
            border-bottom: none;
        }

        .player-rank {
            font-weight: 700;
            color: var(--text-secondary);
            font-size: 14px;
        }

        .team-badge {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 700;
            color: white;
        }

        .player-info {
            display: flex;
            flex-direction: column;
        }

        .player-name-text {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* New Feature: Player Headshots */
        .player-headshot {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--bg-elevated);
            border: 2px solid var(--border-color);
            object-fit: cover;
            flex-shrink: 0;
        }
        
        .player-headshot.loading {
            background: linear-gradient(90deg, var(--bg-elevated) 25%, var(--bg-tertiary) 50%, var(--bg-elevated) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }
        
        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .player-position {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .player-stat {
            font-weight: 600;
            font-size: 14px;
        }

        .stat-change {
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 600;
            font-size: 14px;
        }

        .stat-change.positive {
            color: var(--positive);
        }

        .stat-change.negative {
            color: var(--negative);
        }

        /* ============================================
           6. CARDS
           ============================================ */
        .cards-grid {
            display: grid;
            grid-template-columns: repeat(4, minmax(250px, 300px));
            gap: var(--spacing-md);
            margin-top: var(--spacing-lg);
            justify-content: center;
        }

        .team-card {
            width: 100%;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: var(--spacing-md);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
        }

        .team-card:hover {
            transform: translateY(-2px);
            border-color: var(--border-color-light);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }

        .team-card-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-sm);
        }

        .team-card-badge {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            color: white;
        }

        .team-card-name {
            font-size: 16px;
            font-weight: 700;
        }

        .team-card-stats {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-xs);
            margin-bottom: var(--spacing-sm);
        }

        .team-stat {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            position: relative;
        }
        
        .team-stat:hover .stat-tooltip {
            opacity: 1;
        }

        .team-stat-label {
            color: var(--text-secondary);
            font-size: 8px;
        }

        .team-stat-value {
            font-weight: 600;
            font-size: 12px;
        }
        
        .team-card-chart {
            height: 140px;
            margin-top: auto;
            position: relative;
        }
        
        .team-card-chart canvas {
            max-height: 140px;
        }

        /* Player Cards (similar to team cards) */
        .player-card {
            width: 100%;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: var(--spacing-lg);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
        }
        
        /* Player cards grid layout */
        .player-cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 20px;
            overflow: visible; /* Prevent clipping of hovered cards */
        }

        .player-card:hover {
            transform: translateY(-2px);
            border-color: var(--border-color-light);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            z-index: 10; /* Ensure hovered card appears above others */
            position: relative; /* Required for z-index to work */
        }

        .player-card-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .player-card-badge {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 700;
            color: white;
            text-align: center;
        }

        .player-card-name {
            font-size: 16px;
            font-weight: 700;
        }

        .player-card-team {
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .player-tags {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 6px;
        }
        
        .player-tag {
            font-size: 10px;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            position: relative;
            cursor: help;
        }
        
        .player-tag:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            font-size: 11px;
            font-weight: 500;
            border-radius: 6px;
            white-space: nowrap;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.1);
            letter-spacing: 0;
            text-transform: none;
        }
        
        .player-tag:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 2px;
            border: 4px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.95);
            z-index: 1000;
        }
        
        .player-tag.buy-low {
            background: rgba(48, 209, 88, 0.15);
            color: #30d158;
            border: 1px solid rgba(48, 209, 88, 0.3);
        }
        
        .player-tag.sell-high {
            background: rgba(255, 69, 58, 0.15);
            color: #ff453a;
            border: 1px solid rgba(255, 69, 58, 0.3);
        }
        
        .player-tag.rz-up {
            background: rgba(255, 214, 10, 0.15);
            color: #FFD60A;
            border: 1px solid rgba(255, 214, 10, 0.3);
        }

        .player-card-stats {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
        }

        .player-stat {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            position: relative;
        }

        /* Only show stat tooltip when hovering the label specifically */
        .player-stat-label:hover + .stat-tooltip,
        .player-stat-label:hover ~ .stat-tooltip {
            opacity: 1;
        }
        
        /* Alternative: show on stat hover but hide when hovering comparison area */
        .player-stat:hover .stat-tooltip {
            opacity: 1;
        }
        
        .player-stat:hover .player-stat-with-comparison:hover ~ .stat-tooltip,
        .player-stat-with-comparison:hover ~ .stat-tooltip {
            opacity: 0 !important; /* Hide stat tooltip when hovering comparison */
        }

        .stat-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .player-stat-label {
            color: var(--text-secondary);
        }

        .player-stat-value {
            font-weight: 600;
        }
        
        .player-comparison {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .comparison-icon {
            font-size: 10px;
        }

        .comparison-up {
            color: var(--positive);
        }

        .comparison-down {
            color: var(--negative);
        }

        .player-stat-with-comparison {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            position: relative;
        }

        .comparison-tooltip {
            position: absolute;
            bottom: 100%;
            right: 0; /* Position relative to comparison element */
            transform: translateY(0);
            margin-bottom: 8px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1001; /* Higher than stat-tooltip */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        /* Only show comparison tooltip when hovering the comparison element itself */
        .player-comparison:hover + .comparison-tooltip,
        .player-comparison:hover ~ .comparison-tooltip {
            opacity: 1;
        }

        .tooltip-label {
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .tooltip-data {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .player-card-chart {
            height: 120px;
            margin-top: auto;
            position: relative;
        }
        
        .player-card-chart canvas {
            max-height: 120px;
        }

        .tier-section {
            margin-bottom: var(--spacing-xl);
        }

        .tier-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
            padding-bottom: var(--spacing-md);
            border-bottom: 2px solid var(--border-color);
        }

        .tier-badge {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tier-badge.elite {
            background: rgba(48, 209, 88, 0.2);
            color: #30d158;
        }

        .tier-badge.wr2 {
            background: rgba(10, 132, 255, 0.2);
            color: #0a84ff;
        }

        .tier-badge.flex {
            background: rgba(255, 214, 10, 0.2);
            color: #FFD60A;
        }

        .tier-badge.depth {
            background: rgba(142, 142, 147, 0.2);
            color: #8e8e93;
        }

        .tier-title {
            font-size: 20px;
            font-weight: 700;
        }

        .tier-count {
            font-size: 14px;
            color: var(--text-secondary);
            margin-left: auto;
        }

        /* ============================================
           MOMENTUM BADGES & TOP MOVERS
           ============================================ */
        
        /* Momentum badge next to player name */
        .momentum-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 700;
            margin-left: 8px;
            cursor: help;
            transition: all 0.2s ease;
            vertical-align: middle;
        }

        .momentum-badge.up {
            background: rgba(40, 233, 138, 0.15);
            color: #28E98A;
        }

        .momentum-badge.down {
            background: rgba(255, 92, 92, 0.15);
            color: #FF5C5C;
        }

        .momentum-badge.neutral {
            display: none; /* Hide neutral badges */
        }

        .momentum-badge:hover {
            transform: scale(1.1);
        }

        /* Tooltip for momentum badge */
        .momentum-badge::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            font-size: 11px;
            font-weight: 500;
            border-radius: 6px;
            white-space: nowrap;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .momentum-badge:hover::after {
            opacity: 1;
        }

        .momentum-badge::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 2px;
            border: 4px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .momentum-badge:hover::before {
            opacity: 1;
        }

        /* Top Movers Sidebar Widgets */
        .top-movers-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
        }

        .top-movers-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 24px;
        }

        .top-movers-widget {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid var(--border-color);
            animation: fadeInUp 0.4s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .top-movers-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .top-movers-title {
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .top-movers-widget.risers .top-movers-title {
            color: #28E98A;
        }

        .top-movers-widget.fallers .top-movers-title {
            color: #FF5C5C;
        }

        .top-movers-icon {
            font-size: 16px;
        }

        .top-movers-list {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .top-mover-item {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
            padding: 10px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .top-mover-item:hover {
            background: var(--bg-elevated);
            transform: translateY(-2px);
        }

        .top-mover-rank {
            font-size: 11px;
            font-weight: 700;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .top-mover-arrow {
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 14px;
            flex-shrink: 0;
        }

        .top-movers-widget.risers .top-mover-arrow {
            color: #28E98A;
        }

        .top-movers-widget.fallers .top-mover-arrow {
            color: #FF5C5C;
        }

        .top-mover-info {
            flex: 1;
            min-width: 0;
            width: 100%;
        }

        .top-mover-name {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 2px;
        }

        .top-mover-team {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .top-mover-score {
            font-size: 13px;
            font-weight: 700;
            flex-shrink: 0;
        }

        .top-movers-widget.risers .top-mover-score {
            color: #28E98A;
        }

        .top-movers-widget.fallers .top-mover-score {
            color: #FF5C5C;
        }

        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .top-movers-list {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 900px) {
            .top-movers-container {
                grid-template-columns: 1fr;
            }
            .top-movers-list {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (max-width: 600px) {
            .top-movers-list {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Make player cards container position relative for absolute badges */
        .player-card {
            position: relative;
        }

        /* ============================================
           7. CHARTS
           ============================================ */
        .charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: var(--spacing-lg);
            margin-top: var(--spacing-lg);
        }

        .chart-card {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: var(--spacing-lg);
        }
        
        .chart-card canvas {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
        }

        .chart-header {
            margin-bottom: var(--spacing-md);
        }

        .chart-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: var(--spacing-xs);
        }

        .chart-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .chart-wrapper {
            position: relative;
            height: 400px;
        }
        
        .chart-insight {
            background: var(--bg-tertiary);
            border-left: 3px solid var(--positive);
            padding: 12px 16px;
            margin-bottom: 16px;
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-secondary);
        }
        
        .chart-insight strong {
            color: var(--text-primary);
            font-weight: 600;
        }
        
        /* New Feature: Trend Toggle Button */
        .trend-toggle-container {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 12px;
        }
        
        .trend-toggle-btn {
            padding: 6px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .trend-toggle-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        
        .trend-toggle-btn.active {
            background: var(--positive-bg);
            border-color: var(--positive);
            color: var(--positive);
        }
        
        .trend-toggle-icon {
            font-size: 14px;
        }
        
        /* New: Week Indicator for Trend Animation */
        .week-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 700;
            z-index: 20;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        
        /* Player Evaluation Matrix | Week Scrubber Styles */
        .week-scrubber-container {
            margin-top: 16px;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        .scrubber-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .scrubber-label {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .playback-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .playback-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .playback-btn:hover {
            background: var(--positive-bg);
            border-color: var(--positive);
            color: var(--positive);
        }
        
        .playback-btn.playing {
            background: var(--positive-bg);
            border-color: var(--positive);
            color: var(--positive);
        }
        
        .play-icon {
            font-size: 12px;
        }
        
        .week-scrubber {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, var(--positive) 0%, var(--positive) 100%, var(--bg-elevated) 100%);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }
        
        .week-scrubber::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--positive);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(48, 209, 88, 0.4);
            transition: all 0.15s ease;
        }
        
        .week-scrubber::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 3px 10px rgba(48, 209, 88, 0.6);
        }
        
        .week-scrubber::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--positive);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(48, 209, 88, 0.4);
            transition: all 0.15s ease;
        }
        
        .week-scrubber::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 3px 10px rgba(48, 209, 88, 0.6);
        }
        
        /* New Feature: Quadrant Highlighting */
        .quadrant-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .quadrant-highlight {
            position: absolute;
            border: 2px solid var(--positive);
            border-radius: 8px;
            background: rgba(48, 209, 88, 0.05);
            animation: pulseHighlight 2s infinite;
            pointer-events: none;
        }
        
        @keyframes pulseHighlight {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.02); }
        }
        
        .highlighted-player {
            filter: drop-shadow(0 0 8px var(--positive));
            animation: glowPlayer 2s infinite;
        }
        
        @keyframes glowPlayer {
            0%, 100% { filter: drop-shadow(0 0 6px var(--positive)); }
            50% { filter: drop-shadow(0 0 12px var(--positive)); }
        }
        
        .chart-wrapper {
            position: relative;
        }
        
        /* Quadrant labels removed - now using chart annotations */
        
        /* ============================================
           7. SENTIMENT & VOTING
           ============================================ */
        .sentiment-bar-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
        }
        
        .sentiment-bar {
            flex: 1;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
            display: flex;
        }
        
        .sentiment-bar-fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        .sentiment-bar-buy {
            background: var(--positive);
        }
        
        .sentiment-bar-sell {
            background: var(--negative);
        }
        
        .sentiment-label {
            font-size: 11px;
            color: var(--text-secondary);
            min-width: 45px;
            text-align: right;
        }
        
        .vote-buttons {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }
        
        .vote-btn {
            flex: 1;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        
        .vote-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        
        .vote-btn.active {
            border-color: currentColor;
        }
        
        .vote-btn.buy-btn {
            color: var(--positive);
        }
        
        .vote-btn.buy-btn.active {
            background: var(--positive-bg);
        }
        
        .vote-btn.sell-btn {
            color: var(--negative);
        }
        
        .vote-btn.sell-btn.active {
            background: var(--negative-bg);
        }
        
        .vote-btn.hold-btn.active {
            background: rgba(142, 142, 147, 0.15);
        }
        
        .vote-count {
            font-size: 11px;
            opacity: 0.7;
        }
        
        .signal-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .signal-tag.positive {
            background: var(--positive-bg);
            color: var(--positive);
        }
        
        .signal-tag.neutral {
            background: rgba(142, 142, 147, 0.15);
            color: var(--text-secondary);
        }
        
        .signal-tag.opportunity {
            background: rgba(10, 132, 255, 0.15);
            color: #0a84ff;
        }
        
        .comment-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }
        
        .comment-header {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-primary);
        }
        
        .comment-input-container {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }
        
        .comment-input {
            flex: 1;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
            font-family: inherit;
        }
        
        .comment-input:focus {
            outline: none;
            border-color: var(--positive);
        }
        
        .comment-submit {
            padding: 8px 16px;
            background: var(--positive);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
        }
        
        .comment-submit:hover {
            background: #28c149;
        }
        
        .comment-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .comment-item {
            padding: 10px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 13px;
            line-height: 1.4;
        }
        
        .comment-meta {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        /* ============================================
           8. MODAL
           ============================================ */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.2s ease;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: 16px;
            width: 90%;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .modal-header {
            padding: var(--spacing-lg);
            border-bottom: 1px solid var(--border-color);
        }

        .modal-player-info {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .modal-team-badge {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 700;
            color: white;
        }

        .modal-player-details {
            flex: 1;
        }

        .modal-player-name {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .modal-player-meta {
            font-size: 14px;
            color: var(--text-secondary);
        }

        .modal-close {
            background: var(--bg-tertiary);
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            color: var(--text-secondary);
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        .modal-stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--spacing-md);
        }

        .modal-stat-box {
            background: var(--bg-tertiary);
            padding: var(--spacing-md);
            border-radius: 8px;
            text-align: center;
            position: relative;
            cursor: help;
        }
        
        .modal-stat-box:hover {
            background: var(--bg-elevated);
        }
        
        .modal-stat-box:hover .stat-tooltip {
            opacity: 1;
        }
        
        .modal-stat-box .stat-tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 8px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            color: var(--text-primary);
            min-width: 200px;
            white-space: normal;
            text-align: center;
            line-height: 1.4;
        }

        .modal-stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .modal-stat-value {
            font-size: 24px;
            font-weight: 700;
        }
        
        .modal-stat-subvalue {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 2px;
            font-weight: 400;
        }

        .modal-body {
            padding: var(--spacing-lg);
        }

        .chart-tabs {
            display: flex;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-lg);
            border-bottom: 1px solid var(--border-color);
        }

        .chart-tab {
            padding: var(--spacing-md);
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s ease;
        }

        .chart-tab:hover {
            color: var(--text-primary);
        }

        .chart-tab.active {
            color: var(--text-primary);
            border-bottom-color: var(--positive);
        }

        .chart-content {
            display: none;
        }

        .chart-content.active {
            display: block;
        }

        .modal-chart-wrapper {
            position: relative;
            height: 350px;
        }


        /* ============================================
           10. UPLOAD SECTION
           ============================================ */
        .upload-section {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: var(--spacing-xl);
            text-align: center;
            margin-top: var(--spacing-lg);
        }

        .upload-title {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
        }

        .upload-subtitle {
            color: var(--text-secondary);
            margin-bottom: var(--spacing-lg);
        }

        .upload-buttons {
            display: flex;
            gap: var(--spacing-md);
            justify-content: center;
            flex-wrap: wrap;
        }

        .upload-file-btn {
            padding: var(--spacing-md) var(--spacing-lg);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 2px dashed var(--border-color-light);
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 14px;
        }

        .upload-file-btn:hover {
            border-color: var(--positive);
            background: var(--bg-elevated);
        }

        input[type="file"] {
            display: none;
        }

        .data-status {
            margin-top: var(--spacing-lg);
            padding: var(--spacing-md);
            background: var(--positive-bg);
            border-radius: 8px;
            color: var(--positive);
            font-weight: 600;
        }

        /* ============================================
           11. RESPONSIVE
           ============================================ */
        @media (max-width: 768px) {
            .nav-tabs {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .table-header,
            .player-row {
                grid-template-columns: 40px 50px 1fr 70px;
                font-size: 12px;
            }

            .table-header > div:nth-child(5),
            .table-header > div:nth-child(6),
            .table-header > div:nth-child(7),
            .table-header > div:nth-child(8),
            .player-row > div:nth-child(5),
            .player-row > div:nth-child(6),
            .player-row > div:nth-child(7),
            .player-row > div:nth-child(8) {
                display: none;
            }

            .modal-stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .charts-container {
                grid-template-columns: 1fr;
            }

            .movers-container {
                grid-template-columns: 1fr;
            }

            .cards-grid {
                grid-template-columns: 1fr;
            }
            
            /* REFACTORED: Better mobile support for new features */
            .player-headshot {
                width: 28px;
                height: 28px;
                font-size: 10px;
            }
            
            .chart-wrapper {
                height: 300px !important; /* Shorter charts on mobile */
            }
            
            .trend-toggle-btn {
                font-size: 11px;
                padding: 4px 8px;
            }
            
            .signal-tag {
                font-size: 9px;
                padding: 3px 6px;
            }
        }

        /* ============================================
           COLLAPSIBLE DIVISIONS
           ============================================ */
        .division-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            margin-bottom: 16px;
            overflow: hidden;
        }
        
        .division-header {
            padding: 16px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background 0.2s ease;
            user-select: none;
        }
        
        .division-header:hover {
            background: var(--bg-tertiary);
        }
        
        .division-title {
            font-size: 15px;
            font-weight: 700;
            color: var(--text-primary);
        }
        
        .division-arrow {
            font-size: 12px;
            color: var(--text-secondary);
            transition: transform 0.3s ease;
        }
        
        .division-arrow.expanded {
            transform: rotate(180deg);
        }
        
        .division-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }
        
        .division-content.expanded {
            max-height: 1000px;
            padding: 0 20px 20px 20px;
        }
        
        .division-teams-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 12px;
        }
        
        .division-team-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .division-team-card:hover {
            background: var(--bg-elevated);
            border-color: var(--positive);
        }
        
        .division-team-logo {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--bg-elevated);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 14px;
            color: white;
        }
        
        .division-team-info {
            flex: 1;
        }
        
        .division-team-name {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
        }
        
        .division-team-stats {
            font-size: 11px;
            color: var(--text-secondary);
        }

        /* ============================================
           12. UTILITIES
           ============================================ */
        .hidden {
            display: none !important;
        }

        .loading {
            text-align: center;
            padding: var(--spacing-xl);
            color: var(--text-secondary);
        }

        .empty-state {
            text-align: center;
            padding: var(--spacing-xl);
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: var(--spacing-md);
        }

        .empty-state-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: var(--spacing-sm);
        }

        .empty-state-subtitle {
            color: var(--text-secondary);
        }
        
        /* Matrix tabs styling */
        .matrix-tab {
            transition: all 0.2s ease;
        }
        
        .matrix-tab:hover {
            background: var(--bg-elevated) !important;
        }
        
        .matrix-tab.active {
            background: var(--positive) !important;
            color: white !important;
        }
        
        .matrix-chart-tab {
            transition: all 0.2s ease;
        }
        
        .matrix-chart-tab:hover {
            color: var(--text-primary) !important;
        }
        
        .matrix-chart-tab.active {
            color: var(--text-primary) !important;
            border-bottom-color: var(--positive) !important;
        }
        
        .matrix-section {
            animation: fadeIn 0.3s ease;
        }
        
        .matrix-chart-content {
            animation: fadeIn 0.3s ease;
        }
        /* ============================================
           CATEGORY CARDS (Dashboard)
           ============================================ */
        /* Dashboard Header Widgets */
        .dashboard-header-widgets {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 16px;
        }
        
        .dashboard-widget {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            overflow: hidden;
        }
        
        .widget-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            background: var(--bg-tertiary);
        }
        
        .mover-filter-btns {
            display: flex;
            gap: 4px;
        }
        
        .filter-btn {
            padding: 6px 12px;
            font-size: 11px;
            font-weight: 600;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .filter-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        
        .filter-btn.active {
            background: var(--positive);
            color: white;
            border-color: var(--positive);
        }
        
        .widget-title {
            font-size: 13px;
            font-weight: 700;
            color: var(--text-primary);
        }
        
        /* Expand button */
        .expand-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            line-height: 1;
        }
        
        .expand-btn:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
            border-color: var(--positive);
        }
        
        /* Expanded state for charts */
        .dashboard-widget.expanded {
            grid-column: span 2 !important;
        }
        
        .dashboard-widget.collapsed {
            display: none;
        }
        
        .dashboard-widget.expanded .expand-btn {
            background: var(--positive);
            color: white;
            border-color: var(--positive);
        }
        
        .widget-body {
            padding: 16px;
        }
        
        /* Full Width Stat of the Week Widget */
        .stat-widget-full {
            margin-bottom: 24px;
        }
        
        .stat-widget-full .widget-body {
            padding: 16px 24px;
        }
        
        .stat-highlight-horizontal {
            display: flex;
            align-items: center;
            gap: 24px;
        }
        
        .stat-highlight-horizontal .stat-highlight-value {
            font-size: 48px;
            font-weight: 900;
            background: linear-gradient(135deg, #30d158, #0a84ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            flex-shrink: 0;
        }
        
        .stat-highlight-content {
            flex: 1;
        }
        
        .stat-highlight-horizontal .stat-highlight-label {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }
        
        .stat-highlight-horizontal .stat-highlight-text {
            font-size: 13px;
            line-height: 1.5;
            color: var(--text-secondary);
        }
        
        .stat-highlight-horizontal .stat-highlight-text strong {
            color: var(--positive);
            font-weight: 700;
        }
        
        /* Insight Navigation Buttons */
        .insight-nav-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            width: 28px;
            height: 28px;
            border-radius: 6px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            padding: 0;
            line-height: 1;
        }
        
        .insight-nav-btn:hover {
            background: var(--bg-elevated);
            border-color: var(--text-tertiary);
            transform: translateY(-1px);
        }
        
        .insight-nav-btn:active {
            transform: translateY(0);
        }
        
        /* Legacy vertical stat styling */
        .stat-highlight {
            text-align: center;
        }
        
        .stat-highlight-value {
            font-size: 32px;
            font-weight: 900;
            background: linear-gradient(135deg, #30d158, #0a84ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 4px;
        }
        
        .stat-highlight-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }
        
        .stat-highlight-text {
            font-size: 11px;
            line-height: 1.5;
            color: var(--text-secondary);
        }
        
        .stat-highlight-text strong {
            color: var(--positive);
            font-weight: 700;
        }
        
        /* Trend Widget */
        .trend-widget {
            display: flex;
            flex-direction: column;
        }
        
        .trend-widget .widget-body {
            padding: 12px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .dashboard-chart-wrapper {
            flex: 1;
            min-height: 220px;
            position: relative;
        }
        
        .dashboard-chart-wrapper canvas {
            width: 100% !important;
            height: 100% !important;
        }
        
        .dashboard-scrubber {
            margin-top: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .scrubber-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            min-width: 80px;
        }
        
        .dashboard-scrubber .week-scrubber {
            flex: 1;
        }
        
        .playback-btn-small {
            width: 28px;
            height: 28px;
            background: var(--positive);
            border: none;
            border-radius: 4px;
            color: #000;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .playback-btn-small:hover {
            background: #28c149;
        }
        
        .playback-btn-small.playing {
            background: var(--negative);
        }
        
        /* Categories Section */
        .categories-section {
            margin: 16px 0;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            max-height: none; /* Remove height restriction */
            overflow: visible; /* Allow full height */
            padding-right: 8px;
        }
        
        /* Override grid when carousel is present */
        .categories-section:has(.categories-carousel-container) {
            display: block;
            padding-right: 0;
        }
        
        /* Custom scrollbar for categories section */
        .categories-section::-webkit-scrollbar {
            width: 8px;
        }
        
        .categories-section::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 4px;
        }
        
        .categories-section::-webkit-scrollbar-thumb {
            background: var(--bg-elevated);
            border-radius: 4px;
        }
        
        .categories-section::-webkit-scrollbar-thumb:hover {
            background: var(--border-color-light);
        }
        
        .category-row {
            margin-bottom: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
        }
        
        /* Categories Carousel */
        .categories-carousel-container {
            position: relative;
            margin-bottom: 0;
            margin-top: -24px; /* Closer to header */
            min-height: 500px; /* Adjusted for compact cards */
            overflow: hidden; /* Clip carousel to container width - critical for alignment */
            width: 100%; /* Stay within parent container */
            max-width: 100%; /* Enforce boundary */
        }
        
        .categories-carousel-scroll {
            display: flex;
            gap: 20px;
            overflow: visible; /* Allow items to exist but container clips them */
            scrollbar-width: none;
            -ms-overflow-style: none;
            padding: 20px 0;  /* Vertical padding only - no horizontal padding */
            margin: 0;        /* No margins that could push beyond bounds */
            animation: scrollReverse 240s linear infinite;
            white-space: nowrap;
            width: fit-content; /* Only as wide as content */
        }
        
        .categories-carousel-scroll:hover {
            animation-play-state: paused; /* Pause animation on hover */
        }
        
        .categories-carousel-scroll::-webkit-scrollbar {
            display: none;
        }
        
        .category-carousel-item {
            flex: 0 0 calc(50% - 10px);
            scroll-snap-align: start;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 12px;
            min-width: 360px;
            max-width: 400px;
            min-height: 460px; /* Further reduced to fit 8 cards snugly */
            overflow: visible; /* Show all content */
        }
        
        .carousel-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color);
            width: 48px;
            height: 48px;
            border-radius: 50%;
            font-size: 28px;
            font-weight: 600;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .carousel-nav:hover {
            background: var(--text-primary);
            color: var(--bg-primary);
            transform: translateY(-50%) scale(1.1);
        }
        
        .carousel-nav-left {
            left: 10px;
        }
        
        .carousel-nav-right {
            right: 10px;
        }
        
        /* Category Footnote */
        .category-footnote {
            margin-top: 16px;
            text-align: center;
        }
        
        .footnote-toggle {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 16px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .footnote-toggle:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }
        
        .footnote-content {
            margin-top: 12px;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 11px;
            line-height: 1.6;
            color: var(--text-secondary);
            text-align: left;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        
        /* Team Modal Enhancements */
        .team-stat-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            transition: all 0.2s ease;
        }
        
        .team-stat-card:hover {
            transform: translateY(-2px);
            border-color: var(--border-color-light);
        }
        
        .team-stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        
        .team-stat-label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .key-player-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .key-player-card:hover {
            transform: translateY(-2px);
            border-color: var(--positive);
            background: var(--bg-elevated);
        }
        
        .key-player-position {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            color: white;
            flex-shrink: 0;
        }
        
        .key-player-info {
            flex: 1;
        }
        
        .key-player-name {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
        }
        
        .key-player-stat {
            font-size: 11px;
            color: var(--text-secondary);
        }
        
        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            padding-bottom: 6px;
            border-bottom: 2px solid var(--border-color);
        }
        
        .category-title {
            font-size: 16px;
            font-weight: 700;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 6px;
            letter-spacing: 0.3px;
        }
        
        .category-icon {
            font-size: 18px;
            filter: brightness(1.2);
        }
        
        .category-expand-btn {
            padding: 6px 12px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .category-expand-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-color: var(--border-color-light);
        }
        
        .category-cards-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 4px;
            margin-top: 6px;
            max-height: none; /* Remove any height restrictions */
            overflow: visible; /* Ensure all cards are visible */
        }
        
        /* Category rank - simple text on right */
        .category-rank-simple {
            font-size: 14px;
            font-weight: 700;
            color: var(--text-secondary);
            flex-shrink: 0;
        }
        
        /* Make dashboard category cards very compact */
        .category-cards-container .player-card {
            padding: 8px;
            position: relative;
        }
        
        .category-cards-container .player-card-header {
            margin-bottom: 0;
            gap: 8px;
        }
        
        .category-cards-container .player-card-badge {
            width: 28px;
            height: 28px;
            font-size: 9px;
        }
        
        .category-cards-container .player-card-name {
            font-size: 12px;
            line-height: 1.2;
        }
        
        .category-cards-container .player-card-team {
            font-size: 10px;
            margin-top: 0;
        }
        
        .category-cards-container .player-card-stats {
            gap: 4px;
            margin-bottom: 0;
            display: grid;
            grid-template-columns: 1fr 1fr;
        }
        
        .category-cards-container .player-stat {
            font-size: 10px;
            justify-content: flex-start;
            gap: 2px;
            position: relative;
        }
        
        /* Show tooltip only when hovering over the info icon */
        .category-info-icon:hover .stat-tooltip {
            opacity: 1;
        }
        
        /* Show tooltip when hovering over stat value */
        .category-cards-container .player-stat-value:hover .stat-tooltip {
            opacity: 1;
        }
        
        /* Show change tooltip when hovering over comparison */
        .category-cards-container .player-comparison:hover .change-tooltip {
            opacity: 1;
        }
        
        /* Also show tooltip on hover of comparison span inside */
        .category-cards-container .player-comparison span:hover .change-tooltip {
            opacity: 1;
        }
        
        .category-cards-container .player-stat-label {
            font-size: 8px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        .category-cards-container .player-stat-value {
            font-size: 12px;
            font-weight: 700;
        }
        
        .category-cards-container .player-comparison {
            font-size: 12px;
        }
        
        .category-cards-container .player-card-chart {
            display: none;
        }
        
        /* Enable tooltips on category cards with proper styling */
        .category-cards-container .stat-tooltip {
            font-size: 10px;
            white-space: normal;
            max-width: 200px;
            z-index: 2000;
            line-height: 1.4;
        }
        
        .category-cards-container .comparison-tooltip {
            display: none; /* Keep comparison tooltips hidden for cleaner UI */
        }
        
        /* Change tooltip for leaderboard cards */
        .change-tooltip {
            position: absolute;
            bottom: 100%;
            right: 0;
            transform: translateY(0);
            margin-bottom: 8px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 10px;
            white-space: normal;
            max-width: 180px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 2001;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            line-height: 1.4;
        }
        
        .player-comparison:hover .change-tooltip {
            opacity: 1;
        }
        
        /* Compact player cards for all-leaderboards page */
        .compact-player-card:hover {
            background: var(--bg-elevated);
            border-color: var(--border-color-light);
            transform: translateY(-1px);
        }
        
        .compact-player-card .player-comparison:hover .change-tooltip {
            opacity: 1;
        }
        
        .compact-metric-value:hover .stat-tooltip {
            opacity: 1;
        }
        
        /* Portal-style tooltip */
        #portal-tooltip {
            position: fixed;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 11px;
            line-height: 1.5;
            color: var(--text-primary);
            max-width: 280px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s ease;
            z-index: 99999;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
        }
        
        #portal-tooltip.visible {
            opacity: 1;
        }
        
        #portal-tooltip .tooltip-secondary {
            color: var(--text-tertiary);
            margin-top: 6px;
            display: block;
            font-size: 10px;
        }
        
        /* Horizontal bar for leaderboard metrics */
        .metric-bar-container {
            position: relative;
            width: 100%;
            height: 10px;
            margin-top: 4px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.05);
            overflow: hidden;
        }
        
        .metric-bar {
            height: 100%;
            border-radius: 5px;
            transition: width 0.6s ease;
        }
        
        /* Category card specific styles - Using player-card base styles */
        /* Rank badges handled inline in renderCategoryCard */
        
        /* Expanded state */
        .category-cards-expanded {
            grid-template-columns: 1fr;
        }
        
        .category-card-hidden {
            display: none;
        }

        /* ============================================
           ADVANCED ANALYTICS STYLES
           ============================================ */
        .advanced-analytics-container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .advanced-header {
            margin-bottom: 32px;
        }
        
        .advanced-title {
            font-size: 18px;
            font-weight: 700;
            margin-bottom: 8px;
        }
        
        .advanced-subtitle {
            font-size: 13px;
            color: var(--text-secondary);
        }
        
        .position-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 24px;
            padding: 4px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            width: fit-content;
        }
        
        .position-toggle-btn {
            padding: 10px 24px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
        }
        
        .position-toggle-btn.active {
            background: var(--bg-secondary);
            color: var(--text-primary);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .preset-section {
            margin-bottom: 24px;
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }
        
        .preset-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }
        
        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 8px;
        }
        
        .preset-btn {
            padding: 10px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color-light);
            color: var(--text-primary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
            white-space: nowrap;
            text-align: center;
        }
        
        .preset-btn:hover {
            background: var(--bg-elevated);
            border-color: var(--positive);
            transform: translateY(-1px);
        }
        
        .preset-btn:active {
            transform: translateY(0);
        }
        
        .axis-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-bottom: 32px;
        }
        
        .axis-control {
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }
        
        /* Subtle pulse animation for axis labels */
        @keyframes subtle-pulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(10, 132, 255, 0);
            }
            50% {
                box-shadow: 0 0 8px 2px rgba(10, 132, 255, 0.3);
            }
        }
        
        .axis-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
            padding: 8px 12px;
            margin: -8px -12px 4px -12px;
            border-radius: 8px;
            transition: all 0.3s ease;
            animation: subtle-pulse 3s ease-in-out infinite;
        }
        
        .axis-label:hover {
            background: var(--bg-secondary);
            color: var(--accent);
            animation: none;
        }
        
        /* Non-clickable labels (for Highlight Player, Week Range) - no animations */
        .axis-label-static {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
        }
        
        .axis-label-text {
            flex: 1;
        }
        
        .axis-collapse-icon {
            font-size: 14px;
            transition: transform 0.2s ease;
            color: var(--text-tertiary);
        }
        
        .axis-collapse-icon.collapsed {
            transform: rotate(-90deg);
        }
        
        .axis-control-content {
            max-height: 200px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 1;
        }
        
        .axis-control-content.collapsed {
            max-height: 0;
            opacity: 0;
        }
        
        .axis-select {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color-light);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .axis-select:hover {
            border-color: var(--positive);
        }
        
        .axis-select:focus {
            outline: none;
            border-color: var(--positive);
            box-shadow: 0 0 0 3px rgba(48, 209, 88, 0.1);
        }
        
        .scatter-chart-card {
            background: var(--bg-tertiary);
            border-radius: 16px;
            padding: 24px;
            border: 1px solid var(--border-color);
        }
        
        .scatter-chart-header {
            margin-bottom: 20px;
        }
        
        .scatter-chart-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 4px;
        }
        
        .scatter-chart-description {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.5;
        }
        
        .scatter-chart-description strong {
            color: var(--text-primary);
            font-weight: 600;
        }
        
        .scatter-chart-wrapper {
            position: relative;
            height: 600px;
        }
        
        /* ============================================
           FOOTER
           ============================================ */
        .footer {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 48px 24px 24px;
            margin-top: 80px;
        }

        .footer-content {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 2fr 1fr 1fr;
            gap: 48px;
        }

        .footer-section h3 {
            font-size: 14px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 16px;
            letter-spacing: 0.5px;
        }

        .footer-section p {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 16px;
        }

        .waitlist-form {
            display: flex;
            gap: 8px;
            margin-top: 16px;
        }

        .waitlist-input {
            flex: 1;
            padding: 10px 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 13px;
            transition: all 0.2s ease;
        }

        .waitlist-input:focus {
            outline: none;
            border-color: #0a84ff;
            background: var(--bg-elevated);
        }

        .waitlist-input::placeholder {
            color: var(--text-tertiary);
        }

        .waitlist-btn {
            padding: 10px 20px;
            background: var(--positive);
            border: none;
            border-radius: 8px;
            color: #fff;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .waitlist-btn:hover {
            background: #2dc14e;
            transform: translateY(-1px);
        }

        .waitlist-btn:active {
            transform: translateY(0);
        }

        .footer-links {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .footer-link {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 13px;
            transition: color 0.2s ease;
        }

        .footer-link:hover {
            color: var(--text-primary);
        }

        .footer-bottom {
            max-width: 1400px;
            margin: 32px auto 0;
            padding-top: 24px;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 12px;
            color: var(--text-tertiary);
        }

        .success-message {
            padding: 10px 14px;
            background: var(--positive-bg);
            border: 1px solid var(--positive);
            border-radius: 8px;
            color: var(--positive);
            font-size: 13px;
            margin-top: 8px;
            display: none;
        }

        .success-message.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        /* Waitlist Confirmation Modal */
        .waitlist-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(4px);
        }

        .waitlist-modal.show {
            display: flex;
            animation: fadeIn 0.3s ease;
        }

        .waitlist-modal-content {
            background: var(--bg-elevated);
            border-radius: 16px;
            padding: 32px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            border: 1px solid var(--border-color-light);
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .waitlist-modal-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .waitlist-modal-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .waitlist-modal-message {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 24px;
            line-height: 1.5;
        }

        .waitlist-modal-btn {
            padding: 12px 32px;
            background: var(--positive);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .waitlist-modal-btn:hover {
            background: #28c149;
            transform: translateY(-1px);
        }

        @media (max-width: 768px) {
            .footer-content {
                grid-template-columns: 1fr;
                gap: 32px;
            }
            
            .category-carousel-item {
                flex: 0 0 calc(100% - 60px);
                min-width: 280px;
                max-width: none;
            }
        }
        
        @media (min-width: 769px) {
            .category-carousel-item {
                flex: 0 0 calc(50% - 10px);
                min-width: 360px;
                max-width: 400px;
            }
        }

        /* ============================================
           MOBILE RESPONSIVE
           ============================================ */
        @media (max-width: 1024px) {
            .main-content {
                padding: var(--spacing-md);
            }
            
            .player-cards-grid {
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            }
        }

        @media (max-width: 768px) {
            .header {
                padding: 12px 16px;
            }
            
            .logo {
                font-size: 18px;
            }
            
            .nav-tabs {
                overflow-x: auto;
                gap: 8px;
                -webkit-overflow-scrolling: touch;
            }
            
            .nav-tab {
                padding: 8px 12px;
                font-size: 12px;
                flex-shrink: 0;
            }
            
            .upload-btn {
                padding: 8px 14px;
                font-size: 12px;
            }
            
            .main-content {
                padding: 16px;
            }
            
            .page-title {
                font-size: 20px;
            }
            
            .page-subtitle {
                font-size: 13px;
            }
            
            .player-cards-grid {
                grid-template-columns: 1fr;
                gap: 12px;
            }
            
            .player-card {
                padding: 14px;
            }
            
            .teams-grid {
                grid-template-columns: 1fr;
            }
            
            .categories-grid {
                grid-template-columns: 1fr;
            }
            
            .scatter-plots {
                grid-template-columns: 1fr;
            }
            
            .modal {
                width: 95%;
                max-width: 95%;
                margin: 20px;
                max-height: 90vh;
            }
            
            .modal-charts-grid {
                grid-template-columns: 1fr !important;
            }
            
            .axis-controls {
                grid-template-columns: 1fr;
            }
            
            .preset-buttons {
                grid-template-columns: 1fr;
            }
            
            .footer {
                padding: 32px 16px 16px;
            }
            
            .footer-content {
                grid-template-columns: 1fr;
                gap: 24px;
            }
            
            .waitlist-form {
                flex-direction: column;
            }
            
            .waitlist-btn {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            .logo span {
                display: none;
            }
            
            .nav-tab {
                padding: 6px 10px;
                font-size: 11px;
            }
            
            .page-title {
                font-size: 18px;
            }
            
            /* Top Movers - Stack on mobile */
            #wide-receivers > div[style*="grid-template-columns"],
            #running-backs > div[style*="grid-template-columns"] {
                grid-template-columns: 1fr !important;
            }
            
            #wr-top-movers-sidebar,
            #rb-top-movers-sidebar {
                position: static !important;
                margin-top: 20px;
            }
        }

    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="header-content">
                <div class="logo" onclick="
                    document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                    document.querySelector('.nav-tab[data-page=\'top-movers\']').classList.add('active');
                    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
                    document.getElementById('top-movers').classList.add('active');
                    setTimeout(() => {
                        renderDashboardCategories();
                        setTimeout(renderMiniScatterPlots, 100);
                    }, 100);
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                " style="cursor: pointer;">
                    <div class="logo-icon"></div>
                    <span>FFSE</span>
                </div>
                <nav class="nav-tabs">
                    <button class="nav-tab" data-page="top-movers">Dashboard</button>
                    <button class="nav-tab active" data-page="wide-receivers">WR</button>
                    <button class="nav-tab" data-page="running-backs">RB</button>
                    <button class="nav-tab" data-page="tight-ends">TE</button>
                    <button class="nav-tab" data-page="teams">Team Outlook</button>
                    <button class="nav-tab" data-page="advanced-analytics">Advanced Analytics</button>
                    <button class="nav-tab" id="admin-tab" data-page="admin-panel" style="display: none;">Admin</button>
                </nav>
                <div style="display: flex; align-items: center; gap: 16px;">
                    <!-- Header Scoring Dropdown -->
                    <div class="header-scoring-dropdown" id="header-scoring-dropdown">
                        <button class="header-scoring-button" onclick="toggleHeaderScoringDropdown()">
                            <span id="header-scoring-label">PPR</span>
                            <span class="arrow">▼</span>
                        </button>
                        <div class="header-scoring-menu">
                            <button class="active" onclick="setHeaderScoringFormat('ppr')">PPR</button>
                            <button onclick="setHeaderScoringFormat('half')">Half-PPR</button>
                            <button onclick="setHeaderScoringFormat('std')">Standard</button>
                        </div>
                    </div>
                    <button class="upload-btn" onclick="scrollToWaitlist()">Join Waitlist</button>
                </div>
            </div>
        </header>

        <!-- Scoring Format Toggle -->
        <div class="scoring-toggle-container">
            <div class="scoring-toggle">
                <button class="scoring-option active" data-format="ppr" onclick="setScoringFormat('ppr')">PPR</button>
                <button class="scoring-option" data-format="half" onclick="setScoringFormat('half')">Half-PPR</button>
                <button class="scoring-option" data-format="std" onclick="setScoringFormat('std')">Standard</button>
            </div>
        </div>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Wide Receivers Page -->
            <div id="wide-receivers" class="page active">
                <!-- WR Ticker -->
                <div class="ticker-section" id="wr-ticker-section">
                    <div class="ticker-header">
                        <span>Wide Receivers - Top 50 by Avg Points</span>
                    </div>
                    <div class="ticker-content" id="wr-ticker-content">
                        <div class="ticker-container">
                            <div class="ticker-track" id="wr-ticker-track" style="animation-duration: 720s !important;">
                                <!-- WR ticker items will be inserted here -->
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Sub Navigation - Removed -->
                <div style="margin: 24px 0;">
                    <!-- Sub-navigation removed for cleaner UI -->
                </div>
                
                <!-- Top Movers Widgets at Top -->
                <div id="wr-top-movers-sidebar" style="margin-bottom: 24px;">
                    <!-- Top movers widgets will be inserted here -->
                </div>
                
                <!-- Main content area -->
                <div>
                    <!-- Rankings Tab Content (Default) -->
                    <div id="wr-rankings-content" class="sub-content active">
                        <div id="wr-players-grid">
                            <!-- WR player cards will be inserted here by tier -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Running Backs Page -->
            <div id="running-backs" class="page">
                <!-- RB Ticker -->
                <div class="ticker-section" id="rb-ticker-section">
                    <div class="ticker-header">
                        <span>Running Backs - Top 50 by Avg Points</span>
                    </div>
                    <div class="ticker-content" id="rb-ticker-content">
                        <div class="ticker-container">
                            <div class="ticker-track" id="rb-ticker-track" style="animation-duration: 720s !important;">
                                <!-- RB ticker items will be inserted here -->
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Sub Navigation - Removed -->
                <div style="margin: 24px 0;">
                    <!-- Sub-navigation removed for cleaner UI -->
                </div>
                
                <!-- Top Movers Widgets at Top -->
                <div id="rb-top-movers-sidebar" style="margin-bottom: 24px;">
                    <!-- Top movers widgets will be inserted here -->
                </div>
                
                <!-- Main content area -->
                <div>
                    <!-- Rankings Tab Content (Default) -->
                    <div id="rb-rankings-content" class="sub-content active">
                        <div id="rb-players-grid">
                            <!-- RB player cards will be inserted here by tier -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Tight Ends Page -->
            <div id="tight-ends" class="page">
                <!-- TE Ticker -->
                <div class="ticker-section" id="te-ticker-section">
                    <div class="ticker-header">
                        <span>Tight Ends - Top 50 by Avg Points</span>
                    </div>
                    <div class="ticker-content" id="te-ticker-content">
                        <div class="ticker-container">
                            <div class="ticker-track" id="te-ticker-track" style="animation-duration: 720s !important;">
                                <!-- TE ticker items will be inserted here -->
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Sub Navigation - Removed -->
                <div style="margin: 24px 0;">
                    <!-- Sub-navigation removed for cleaner UI -->
                </div>
                
                <!-- Top Movers Widgets at Top -->
                <div id="te-top-movers-sidebar" style="margin-bottom: 24px;">
                    <!-- Top movers widgets will be inserted here -->
                </div>
                
                <!-- Main content area -->
                <div>
                    <!-- Rankings Tab Content (Default) -->
                    <div id="te-rankings-content" class="sub-content active">
                        <div id="te-players-grid">
                            <!-- TE player cards will be inserted here by tier -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Teams Page -->
            <div id="teams" class="page">
                <!-- Teams Ticker -->
                <div class="ticker-section" id="teams-ticker-section">
                    <div class="ticker-header">
                        <span>Teams - Ranked by Total Fantasy Points</span>
                    </div>
                    <div class="ticker-content" id="teams-ticker-content">
                        <div class="ticker-container">
                            <div class="ticker-track" id="teams-ticker-track" style="animation-duration: 480s !important;">
                                <!-- Teams ticker items will be inserted here -->
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Team Analysis Section -->
                <div class="advanced-analytics-container" style="margin-bottom: 32px;">
                    <div class="advanced-header">
                        <div class="advanced-title">Team Analysis</div>
                        <div class="advanced-subtitle">Deep dive into team-level target and opportunity distribution</div>
                    </div>
                    
                    <!-- League Comparison Toggle -->
                    <div style="margin-bottom: 16px; display: flex; align-items: center; gap: 12px;">
                        <button 
                            id="league-comparison-toggle" 
                            onclick="toggleLeagueComparison()" 
                            style="padding: 8px 16px; background: var(--positive); border: 1px solid var(--positive); border-radius: 8px; color: white; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; gap: 8px;"
                        >
                            <span id="league-comparison-icon">●</span>
                            <span>Show League Comparison</span>
                        </button>
                        <span style="font-size: 12px; color: var(--text-tertiary);">Compare team's volume to league average</span>
                    </div>
                    
                    <!-- Team Analysis Controls -->
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin-bottom: 16px;">
                        <!-- Team Selector -->
                        <div class="axis-control">
                            <div class="axis-label">Select Team</div>
                            <select class="axis-select" id="team-select" onchange="updateTeamAnalysis()">
                                <!-- Teams will be populated by JavaScript -->
                            </select>
                        </div>
                        
                        <!-- Position Group -->
                        <div class="axis-control">
                            <div class="axis-label">Position Group</div>
                            <select class="axis-select" id="position-group-select" onchange="updateTeamAnalysis()">
                                <option value="WR">Pass-Catchers</option>
                                <option value="RB">Running Backs</option>
                            </select>
                        </div>
                        
                        <!-- Time Frame -->
                        <div class="axis-control">
                            <div class="axis-label">Time Frame</div>
                            <select class="axis-select" id="time-frame-select" onchange="updateTeamAnalysis()">
                                <option value="single">Single Week</option>
                                <option value="last3">Last 3 Weeks</option>
                                <option value="last5">Last 5 Weeks</option>
                                <option value="season">Season Long</option>
                            </select>
                        </div>
                        
                        <!-- Week Selector (shown only for single week) -->
                        <div class="axis-control" id="week-select-container">
                            <div class="axis-label">Select Week</div>
                            <select class="axis-select" id="week-select" onchange="updateTeamAnalysis()">
                                <!-- Weeks will be populated by JavaScript -->
                            </select>
                        </div>
                    </div>
                    
                    <!-- Chart Area -->
                    <div class="scatter-chart-card">
                        <div class="scatter-chart-header">
                            <div class="scatter-chart-title" id="team-chart-title">Team Target Distribution</div>
                            <div class="scatter-chart-description" id="team-chart-description">
                                Select a team and time frame to view distribution
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; min-height: 420px;" id="team-charts-container">
                            <!-- Charts will be rendered here -->
                            <div class="chart-wrapper">
                                <canvas id="team-pie-chart"></canvas>
                            </div>
                            <div class="chart-wrapper" id="team-secondary-chart-wrapper">
                                <canvas id="team-secondary-chart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Team Offensive Balance Scatter -->
                <div class="chart-card" style="margin-bottom: 32px;">
                    <div class="chart-header">
                        <div class="chart-title">Offensive Identity Map</div>
                        <div class="chart-subtitle">Pass-Heavy vs Run-Heavy Offenses</div>
                    </div>
                    <div class="chart-insight">
                        <strong>What to look for:</strong> Top Right = Pass Heavy + Run Heavy, Bottom Right = Pass Heavy, Top Left = Run Heavy, Bottom Left = Avoid. Bigger Circles = More Total Fantasy Output.
                    </div>
                    <div class="chart-wrapper">
                        <canvas id="team-balance-scatter"></canvas>
                    </div>
                </div>
                
                <div class="cards-grid" id="teams-grid" style="display: none;">
                    <!-- Legacy team cards (hidden, keeping for backward compatibility) -->
                </div>
            </div>

            <!-- Insights Page -->
            <div id="top-movers" class="page">
                <!-- Dashboard Ticker -->
                <div class="ticker-section" id="insights-ticker-section">
                    <div class="ticker-header">
                        <span>Trending Opportunity Shifts Over Last 3 Weeks</span>
                    </div>
                    <div class="ticker-content" id="insights-ticker-content">
                        <div class="ticker-container">
                            <div class="ticker-track" id="insights-ticker-track" style="animation-duration: 540s !important;">
                                <!-- Ticker items will be inserted here -->
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Key Insight - Full Width -->
                <div class="dashboard-widget stat-widget-full">
                    <div class="widget-header">
                        <span class="widget-title" style="font-size: 16px;">Key Insight</span>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <button onclick="previousInsight()" class="insight-nav-btn" title="Previous insight">‹</button>
                            <span id="insight-indicator" style="font-size: 11px; color: var(--text-tertiary);">1/4</span>
                            <button onclick="nextInsight()" class="insight-nav-btn" title="Next insight">›</button>
                        </div>
                    </div>
                    <div class="widget-body">
                        <div class="stat-highlight-horizontal" id="stat-of-week" style="transition: opacity 0.3s ease;">
                            <div class="stat-highlight-value">Loading...</div>
                            <div class="stat-highlight-content">
                                <div class="stat-highlight-label">Analyzing data...</div>
                                <div class="stat-highlight-text">
                                    Processing player statistics to find actionable insights.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Leaderboards Section Header -->
                <div class="dashboard-widget" style="margin-bottom: 24px;">
                    <div class="widget-header">
                        <div>
                            <span class="widget-title" style="font-size: 18px; text-transform: uppercase; letter-spacing: 0.5px;">Leaderboards</span>
                            <div style="font-size: 11px; color: var(--text-tertiary); margin-top: 2px;">Last 3 Weeks Performance</div>
                        </div>
                        <button onclick="navigateToPage('all-leaderboards')" style="padding: 8px 16px; background: var(--positive); color: white; border: none; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">
                            See All
                        </button>
                    </div>
                </div>
                
                <!-- Categories Section - Now at top -->
                <div class="categories-section" id="dashboard-categories">
                    <!-- Categories will be dynamically inserted here -->
                </div>
                
                <!-- Dashboard Scatter Plots -->
                <div class="dashboard-header-widgets">
                    <!-- WR Trend Scatter Plot -->
                    <div class="dashboard-widget trend-widget" id="wr-trend-widget" style="grid-column: span 1;">
                        <div class="widget-header">
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <span class="widget-title" style="font-size: 16px;">WR Trends: Volume vs Efficiency</span>
                                <button class="expand-btn" onclick="toggleChartExpand('wr')" id="wr-expand-btn" title="Expand">
                                    ⛶
                                </button>
                            </div>
                            <div class="mover-filter-btns">
                                <button class="filter-btn active" onclick="setDashboardFilter('wr', 'all')" id="wr-filter-all">All</button>
                                <button class="filter-btn" onclick="setDashboardFilter('wr', 'positive')" id="wr-filter-positive">Top 10 ↑</button>
                                <button class="filter-btn" onclick="setDashboardFilter('wr', 'negative')" id="wr-filter-negative">Top 10 ↓</button>
                            </div>
                        </div>
                        <div class="widget-body">
                            <div class="dashboard-chart-wrapper">
                                <canvas id="wr-trend-chart"></canvas>
                            </div>
                            <div class="dashboard-scrubber">
                                <div class="scrubber-label" id="wr-tranche-label">Current</div>
                                <input type="range" class="week-scrubber" id="wr-tranche-scrubber" min="0" max="3" value="3" step="0.005">
                                <button class="playback-btn-small" onclick="toggleDashboardTrend('wr')" id="wr-play-btn">▶</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- RB Trend Scatter Plot -->
                    <div class="dashboard-widget trend-widget" id="rb-trend-widget" style="grid-column: span 1;">
                        <div class="widget-header">
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <span class="widget-title" style="font-size: 16px;">RB Trends: Volume vs Efficiency</span>
                                <button class="expand-btn" onclick="toggleChartExpand('rb')" id="rb-expand-btn" title="Expand">
                                    ⛶
                                </button>
                            </div>
                            <div class="mover-filter-btns">
                                <button class="filter-btn active" onclick="setDashboardFilter('rb', 'all')" id="rb-filter-all">All</button>
                                <button class="filter-btn" onclick="setDashboardFilter('rb', 'positive')" id="rb-filter-positive">Top 10 ↑</button>
                                <button class="filter-btn" onclick="setDashboardFilter('rb', 'negative')" id="rb-filter-negative">Top 10 ↓</button>
                            </div>
                        </div>
                        <div class="widget-body">
                            <div class="dashboard-chart-wrapper">
                                <canvas id="rb-trend-chart"></canvas>
                            </div>
                            <div class="dashboard-scrubber">
                                <div class="scrubber-label" id="rb-tranche-label">Current</div>
                                <input type="range" class="week-scrubber" id="rb-tranche-scrubber" min="0" max="3" value="3" step="0.005">
                                <button class="playback-btn-small" onclick="toggleDashboardTrend('rb')" id="rb-play-btn">▶</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Category Methodology Footnote -->
                <div class="category-footnote">
                    <button class="footnote-toggle" onclick="toggleFootnote()">
                        <span id="footnote-icon">ⓘ</span> Methodology
                    </button>
                    <div class="footnote-content" id="footnote-content" style="display: none;">
                        <strong>📊 Category Leaderboard Methodology</strong><br><br>
                        
                        <strong>Time Window:</strong> All rankings are based on performance over the <strong>last 3 weeks of the season</strong>. Players must have played (with fantasy points scored) in at least <strong>2 of the last 3 weeks</strong> to be eligible for any category.<br><br>
                        
                        <strong>Minimum Threshold:</strong> Players must average <strong>7.0+ fantasy points per game</strong> over their qualifying games to appear on leaderboards.<br><br>
                        
                        <strong>Category Definitions:</strong><br>
                        • <strong>Volume Monsters (RB):</strong> Running backs with the highest opportunities per game (rush attempts + targets) over the last 3 weeks. Identifies true workhorse backs.<br>
                        • <strong>Efficiency Elites:</strong> Players with the best points per touch/target ratio over the last 3 weeks. Shows who's doing the most with their opportunities.<br>
                        • <strong>Red Zone Kings:</strong> Players with the most red zone opportunities per game. For WRs: red zone targets. For RBs: red zone rush attempts + targets. High TD upside.<br>
                        • <strong>High-Volume Alphas (WR):</strong> Wide receivers with the most targets per game over the last 3 weeks. High-volume pass catchers dominating their team's offense.<br><br>
                        
                        <strong>Why Last 3 Weeks?</strong> Recent performance is more predictive than season-long averages. Player roles evolve, injuries affect usage, and offensive schemes shift throughout the season. The last 3 weeks capture current reality and help identify emerging trends and hot streaks.
                    </div>
                </div>
                
            </div>
            
            <!-- Advanced Analytics Page -->
            <div id="advanced-analytics" class="page">
                <div class="advanced-analytics-container">
                    <div class="advanced-header">
                        <div class="advanced-title">Advanced Analytics</div>
                        <div class="advanced-subtitle">Build custom scatterplots to explore correlations between any stats</div>
                    </div>
                    
                    <div class="position-toggle">
                        <button class="position-toggle-btn active" onclick="switchAdvancedPosition('WR')" id="advanced-wr-btn">
                            Wide Receivers
                        </button>
                        <button class="position-toggle-btn" onclick="switchAdvancedPosition('RB')" id="advanced-rb-btn">
                            Running Backs
                        </button>
                        <button class="position-toggle-btn" onclick="switchAdvancedPosition('TE')" id="advanced-te-btn">
                            Tight Ends
                        </button>
                    </div>
                    
                    <!-- Player Search and Week Selector -->
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
                        <!-- Player Search -->
                        <div class="axis-control">
                            <div class="axis-label-static">Highlight Player</div>
                            <div id="selected-players-container" style="display: none; margin-bottom: 8px; display: flex; gap: 8px; flex-wrap: wrap;">
                                <!-- Selected players will appear here -->
                            </div>
                            <div style="position: relative;">
                                <input 
                                    type="text" 
                                    id="player-search-input" 
                                    class="axis-select" 
                                    placeholder="Search to highlight players (Max 4)"
                                    oninput="filterPlayerSearch()"
                                    onfocus="showPlayerSearchDropdown()"
                                    style="padding-right: 30px;"
                                />
                                <button 
                                    id="clear-player-btn" 
                                    onclick="clearPlayerHighlight()"
                                    style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: transparent; border: none; color: var(--text-secondary); cursor: pointer; font-size: 18px; display: none; padding: 0; width: 20px; height: 20px; line-height: 1;"
                                    title="Clear highlighted players"
                                >×</button>
                                <div id="player-search-dropdown" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: var(--bg-elevated); border: 1px solid var(--border-color); border-radius: 8px; margin-top: 4px; max-height: 200px; overflow-y: auto; z-index: 1000; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);">
                                    <!-- Player options will be populated by JavaScript -->
                                </div>
                            </div>
                        </div>
                        
                        <!-- Week Selector -->
                        <div class="axis-control">
                            <div class="axis-label-static">Week Range</div>
                            <select class="axis-select" id="week-range-select" onchange="updateAdvancedScatter()">
                                <option value="all">All Weeks</option>
                                <option value="last3">Last 3 Weeks</option>
                                <option value="last5">Last 5 Weeks</option>
                                <option value="1-4">Weeks 1-4</option>
                                <option value="5-8">Weeks 5-8</option>
                                <!-- Dynamic week options will be added by JavaScript -->
                            </select>
                        </div>
                    </div>
                    
                    <div class="axis-controls">
                        <div class="axis-control">
                            <div class="axis-label" onclick="toggleAxisControl('x-axis')">
                                <span class="axis-label-text">X-Axis Stat</span>
                                <span class="axis-collapse-icon collapsed" id="x-axis-icon">▼</span>
                            </div>
                            <div class="axis-control-content collapsed" id="x-axis-content">
                                <select class="axis-select" id="x-axis-select" onchange="currentQuadrantExplanation = ''; updateAdvancedScatter()">
                                    <!-- Options will be populated by JavaScript -->
                                </select>
                            </div>
                        </div>
                        <div class="axis-control">
                            <div class="axis-label" onclick="toggleAxisControl('y-axis')">
                                <span class="axis-label-text">Y-Axis Stat</span>
                                <span class="axis-collapse-icon collapsed" id="y-axis-icon">▼</span>
                            </div>
                            <div class="axis-control-content collapsed" id="y-axis-content">
                                <select class="axis-select" id="y-axis-select" onchange="currentQuadrantExplanation = ''; updateAdvancedScatter()">
                                    <!-- Options will be populated by JavaScript -->
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Preset Scatterplots - Moved below axis controls -->
                    <div class="preset-section" style="margin-top: 16px;">
                        <div class="preset-label">Quick Presets</div>
                        <div class="preset-buttons" id="preset-buttons-container">
                            <!-- Preset buttons will be populated by JavaScript -->
                        </div>
                    </div>
                    
                    <div class="scatter-chart-card">
                        <div class="scatter-chart-header">
                            <div class="scatter-chart-title" id="scatter-title">Fantasy Points vs Targets</div>
                            <div class="scatter-chart-description" id="scatter-description">
                                Click on any point to view player details
                            </div>
                        </div>
                        <div class="scatter-chart-wrapper">
                            <canvas id="advanced-scatter-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- All Leaderboards Page -->
            <div id="all-leaderboards" class="page">
                <div class="page-header">
                    <h1 class="page-title">All Leaderboards</h1>
                    <p class="page-subtitle">Last 3 Weeks Performance - All Categories</p>
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(450px, 1fr)); gap: 24px; padding: 24px 24px 48px;">
                    <!-- All 11 leaderboards will be rendered here -->
                    <div id="all-leaderboards-grid"></div>
                </div>
            </div>
            
            <!-- Admin Panel Page -->
            <div id="admin-panel" class="page">
                <div class="page-header">
                    <h1 class="page-title">Admin Panel</h1>
                    <p class="page-subtitle">Upload new data and manage the site</p>
                </div>
                
                <div style="max-width: 800px; margin: 0 auto;">
                    <!-- Admin Info Card -->
                    <div style="background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 24px; margin-bottom: 24px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                            <div>
                                <div style="font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px;">Logged in as Admin</div>
                                <div style="font-size: 12px; color: var(--text-tertiary);" id="admin-email-display">aryi3025@gmail.com</div>
                            </div>
                            <button onclick="logoutAdmin()" style="padding: 8px 16px; background: var(--negative); border: none; border-radius: 8px; color: white; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;">
                                Sign Out
                            </button>
                        </div>
                        <div style="padding-top: 16px; border-top: 1px solid var(--border-color); font-size: 12px; color: var(--text-secondary);">
                            Last updated: <span id="admin-last-updated">No data uploaded</span>
                        </div>
                    </div>
                    
                    <!-- Upload Data Card -->
                    <div style="background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 24px;">
                        <h2 style="font-size: 18px; font-weight: 700; color: var(--text-primary); margin-bottom: 16px;">Upload New Data</h2>
                        
                        <div style="display: flex; flex-direction: column; gap: 20px;">
                            <!-- WR Upload -->
                            <div>
                                <label style="display: block; font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">Wide Receiver Data (CSV)</label>
                                <input type="file" id="admin-wr-upload" accept=".csv" onchange="handleAdminWRUpload(event)" style="display: block; width: 100%; padding: 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 13px; cursor: pointer;">
                                <div id="admin-wr-status" style="margin-top: 6px; font-size: 12px; color: var(--text-tertiary);"></div>
                            </div>
                            
                            <!-- RB Upload -->
                            <div>
                                <label style="display: block; font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">Running Back Data (CSV)</label>
                                <input type="file" id="admin-rb-upload" accept=".csv" onchange="handleAdminRBUpload(event)" style="display: block; width: 100%; padding: 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 13px; cursor: pointer;">
                                <div id="admin-rb-status" style="margin-top: 6px; font-size: 12px; color: var(--text-tertiary);"></div>
                            </div>
                            
                            <!-- TE Upload -->
                            <div>
                                <label style="display: block; font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;">Tight End Data (CSV)</label>
                                <input type="file" id="admin-te-upload" accept=".csv" onchange="handleAdminTEUpload(event)" style="display: block; width: 100%; padding: 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 13px; cursor: pointer;">
                                <div id="admin-te-status" style="margin-top: 6px; font-size: 12px; color: var(--text-tertiary);"></div>
                            </div>
                            
                            <!-- Instructions -->
                            <div style="margin-top: 8px; padding: 16px; background: var(--bg-tertiary); border-radius: 8px; font-size: 13px; color: var(--text-secondary); line-height: 1.6;">
                                <strong style="color: var(--text-primary);">Instructions:</strong><br>
                                1. Upload WR, RB, and TE CSV files<br>
                                2. Data will be processed automatically<br>
                                3. All pages will update with new data<br>
                                4. "Last updated" date will be set to today<br>
                                5. Data persists until you upload again
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Footer -->
        <footer class="footer">
            <div class="footer-content">
                <!-- Waitlist Section -->
                <div class="footer-section">
                    <h3>JOIN THE WAITLIST</h3>
                    <p>Get early access to premium features, real-time updates, and exclusive fantasy football insights.</p>
                    <form class="waitlist-form" onsubmit="submitWaitlist(event)">
                        <input 
                            type="email" 
                            class="waitlist-input" 
                            id="waitlist-email"
                            placeholder="Enter your email"
                            required
                        />
                        <button type="submit" class="waitlist-btn">Join Waitlist</button>
                    </form>
                    <div class="success-message" id="waitlist-success">
                        ✓ Thanks! You've been added to the waitlist.
                    </div>
                </div>

                <!-- Quick Links -->
                <div class="footer-section">
                    <h3>QUICK LINKS</h3>
                    <div class="footer-links">
                        <a href="#" class="footer-link" id="admin-login-link" onclick="showLoginModal(); return false;">Admin Login</a>
                        <a href="#" class="footer-link" onclick="navigateToPage('top-movers'); return false;">Dashboard</a>
                        <a href="#" class="footer-link" onclick="navigateToPage('advanced-analytics'); return false;">Analytics</a>
                    </div>
                </div>

                <!-- About -->
                <div class="footer-section">
                    <h3>ABOUT FFSE</h3>
                    <div class="footer-links">
                        <a href="#" class="footer-link" onclick="showPrivacyModal(); return false;">Privacy Policy</a>
                        <a href="#" class="footer-link">Contact</a>
                    </div>
                    <div style="margin-top: 16px; font-size: 11px; color: var(--text-tertiary);">
                        Last updated: <span id="last-updated-date">No data uploaded</span>
                    </div>
                </div>
            </div>

            <div class="footer-bottom">
                © 2025 Fantasy Football Stock Exchange. All rights reserved. | Data updated weekly during NFL season.
            </div>
        </footer>

        <!-- Waitlist Confirmation Modal -->
        <div class="waitlist-modal" id="waitlist-modal">
            <div class="waitlist-modal-content">
                <div class="waitlist-modal-icon">🎉</div>
                <div class="waitlist-modal-title">Welcome to the Waitlist!</div>
                <div class="waitlist-modal-message">
                    Thanks for signing up! We'll keep you updated on new features, premium analytics, and exclusive fantasy football insights.
                </div>
                <button class="waitlist-modal-btn" onclick="closeWaitlistModal()">Got it!</button>
            </div>
        </div>
    </div>

    <!-- Player Modal -->
    <div class="modal-overlay" id="player-modal">
        <div class="modal">
            <div class="modal-header">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; width: 100%;">
                    <div class="modal-player-info">
                        <div class="modal-team-badge" id="modal-team-badge"></div>
                        <div class="modal-player-details">
                            <div class="modal-player-name" id="modal-player-name"></div>
                            <div class="modal-player-meta" id="modal-player-meta"></div>
                        </div>
                    </div>
                    
                    <button class="modal-close" onclick="closeModal()" style="position: absolute; top: 16px; right: 16px;">×</button>
                </div>
                
                <!-- Category Context (shown when opened from a category) -->
                <div id="modal-category-context" style="display: none; margin-top: 16px; padding: 12px 16px; background: var(--bg-elevated); border-radius: 8px; border-left: 3px solid var(--positive);">
                    <div style="font-size: 11px; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; margin-bottom: 4px;">
                        Category Ranking
                    </div>
                    <div style="font-size: 14px; font-weight: 700; color: var(--text-primary); margin-bottom: 8px;">
                        <span id="modal-category-title"></span> - <span id="modal-category-rank"></span>
                    </div>
                    <div style="font-size: 13px; color: var(--text-secondary); line-height: 1.5;">
                        <span id="modal-category-explanation"></span>
                    </div>
                    <div style="display: flex; gap: 16px; margin-top: 8px; font-size: 12px;">
                        <div>
                            <span style="color: var(--text-secondary);"><span id="modal-category-metric-label"></span>:</span>
                            <span style="color: var(--text-primary); font-weight: 600; margin-left: 4px;" id="modal-category-metric-value"></span>
                        </div>
                    </div>
                </div>
                
                <div class="modal-stats-grid" style="margin-top: 20px; grid-template-columns: repeat(4, 1fr); gap: 12px;">
                    <!-- Row 1: Points Stats -->
                    <div class="modal-stat-box">
                        <div class="modal-stat-label">AVG PTS</div>
                        <div class="modal-stat-value" id="modal-avg-pts"></div>
                        <div class="stat-tooltip">Average fantasy points per game across all weeks played</div>
                    </div>
                    <div class="modal-stat-box">
                        <div class="modal-stat-label" id="modal-exp-pts-label">EXP PTS (W9)</div>
                        <div class="modal-stat-value" id="modal-exp-pts"></div>
                        <div class="stat-tooltip">Expected points based on opportunities and efficiency metrics</div>
                    </div>
                    <div class="modal-stat-box">
                        <div class="modal-stat-label" id="modal-actual-pts-label">ACTUAL (W9)</div>
                        <div class="modal-stat-value" id="modal-actual-pts"></div>
                        <div class="stat-tooltip">Actual fantasy points scored in this week's game</div>
                    </div>
                    <div class="modal-stat-box">
                        <div class="modal-stat-label">DIFF %</div>
                        <div class="modal-stat-value" id="modal-diff-pct"></div>
                        <div class="stat-tooltip">Performance vs expectations: (Actual - Expected) / Expected × 100%</div>
                    </div>
                </div>
                <div class="modal-stats-grid" style="margin-top: 12px; grid-template-columns: repeat(4, 1fr); gap: 12px;">
                    <!-- Row 2: Opportunity Stats (position-specific) -->
                    <div class="modal-stat-box" id="modal-stat-opp-this">
                        <div class="modal-stat-label">OPP SHARE THIS WK</div>
                        <div class="modal-stat-value" id="modal-opp-this-week"></div>
                        <div class="stat-tooltip">Player's share of team opportunities in latest week</div>
                    </div>
                    <div class="modal-stat-box" id="modal-stat-opp-last">
                        <div class="modal-stat-label">OPP SHARE LAST WK</div>
                        <div class="modal-stat-value" id="modal-opp-last-week"></div>
                        <div class="stat-tooltip">Player's share of team opportunities in previous week</div>
                    </div>
                    <div class="modal-stat-box" id="modal-stat-vs-avg">
                        <div class="modal-stat-label">OPP VS TOP 24 AVG</div>
                        <div class="modal-stat-value" id="modal-vs-avg"></div>
                        <div class="modal-stat-subvalue" id="modal-vs-avg-detail"></div>
                        <div class="stat-tooltip">Opportunity differential vs Top 24 average for this week</div>
                    </div>
                    <div class="modal-stat-box" id="modal-stat-opp-change">
                        <div class="modal-stat-label">SHARE CHANGE</div>
                        <div class="modal-stat-value" id="modal-share-change"></div>
                        <div class="stat-tooltip">Week-over-week change in opportunity share</div>
                    </div>
                </div>
            </div>
            <div class="modal-body">
                <!-- Horizontal Community Sentiment Section -->
                <div style="background: var(--bg-tertiary); border-radius: 8px; padding: 16px 20px; margin-bottom: 20px; display: flex; align-items: center; gap: 20px;">
                    <div style="flex-shrink: 0;">
                        <div style="font-size: 10px; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px; font-weight: 600;">
                            Community Sentiment
                        </div>
                        <div id="modal-sentiment-compact" style="font-size: 20px; font-weight: bold; line-height: 1;">
                            <!-- Will be filled dynamically -->
                        </div>
                    </div>
                    
                    <div style="flex: 1;">
                        <div class="sentiment-bar" style="height: 24px; border-radius: 8px; background: var(--bg-secondary); box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);">
                            <div class="sentiment-bar-fill sentiment-bar-buy" id="modal-sentiment-buy-compact" style="width: 0%; border-radius: 8px 0 0 8px;"></div>
                            <div class="sentiment-bar-fill sentiment-bar-sell" id="modal-sentiment-sell-compact" style="width: 0%; border-radius: 0 8px 8px 0;"></div>
                        </div>
                    </div>
                    
                    <div class="vote-buttons" style="gap: 6px; display: flex; flex-shrink: 0;">
                        <button class="vote-btn buy-btn" onclick="castVote('buy')" style="padding: 6px 12px; font-size: 11px;">
                            Buy
                        </button>
                        <button class="vote-btn hold-btn" onclick="castVote('hold')" style="padding: 6px 12px; font-size: 11px;">
                            Hold
                        </button>
                        <button class="vote-btn sell-btn" onclick="castVote('sell')" style="padding: 6px 12px; font-size: 11px;">
                            Sell
                        </button>
                    </div>
                </div>
                
                <div class="chart-tabs">
                    <button class="chart-tab active" onclick="switchModalChart('outcomes')">Performance Consistency</button>
                    <button class="chart-tab" onclick="switchModalChart('spider')">Player Profile</button>
                </div>
                <div id="modal-chart-variance" class="chart-content active">
                    <div class="modal-chart-wrapper">
                        <canvas id="modal-variance-chart"></canvas>
                    </div>
                </div>
                <div id="modal-chart-outcomes" class="chart-content">
                    <div class="modal-chart-wrapper">
                        <canvas id="modal-outcomes-chart"></canvas>
                    </div>
                </div>
                <div id="modal-chart-spider" class="chart-content">
                    <div class="modal-chart-wrapper">
                        <canvas id="modal-spider-chart"></canvas>
                    </div>
                    
                    <!-- Metrics Explanation Section -->
                    <div style="margin-top: 16px; border-top: 1px solid var(--border-color); padding-top: 12px;">
                        <button onclick="toggleSpiderExplanation()" 
                                style="display: flex; align-items: center; gap: 6px; background: transparent; border: none; color: var(--text-secondary); cursor: pointer; font-size: 12px; padding: 0; font-weight: 500; transition: color 0.2s;"
                                onmouseover="this.style.color='var(--text-primary)'"
                                onmouseout="this.style.color='var(--text-secondary)'">
                            <span id="spider-explanation-icon" style="font-size: 14px;">ℹ️</span>
                            <span>How rankings are calculated</span>
                        </button>
                        
                        <div id="spider-explanation" style="display: none; margin-top: 12px; background: var(--bg-elevated); border-radius: 8px; padding: 16px; font-size: 13px; line-height: 1.6;">
                            <div style="color: var(--text-primary); font-weight: 600; margin-bottom: 8px;">Player Profile Rankings</div>
                            <div style="color: var(--text-secondary); margin-bottom: 12px;">
                                Each metric is ranked against <strong style="color: var(--text-primary);">all eligible players</strong> (minimum 3 games played) using per-game averages. Your rank determines your score: <strong style="color: var(--positive);">#1 = 100 points</strong>, <strong style="color: var(--text-primary);">#100 = 50 points</strong>, <strong style="color: var(--text-tertiary);">#200 = 0.5 points</strong>.
                            </div>
                            
                            <div id="spider-wr-metrics" style="display: none;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px; font-size: 12px;">WR Metrics:</div>
                                <div style="display: grid; gap: 8px; color: var(--text-secondary); font-size: 12px;">
                                    <div><strong style="color: var(--text-primary);">Volume:</strong> Targets per game (total targets ÷ games played)</div>
                                    <div><strong style="color: var(--text-primary);">Efficiency:</strong> Fantasy points per target (avg points ÷ targets per game)</div>
                                    <div><strong style="color: var(--text-primary);">Red Zone:</strong> Red zone opportunities per game (total RZ opps ÷ games played)</div>
                                    <div><strong style="color: var(--text-primary);">Team Share:</strong> Target share % in most recent week</div>
                                    <div><strong style="color: var(--text-primary);">Catch Rate:</strong> Receptions per target (total receptions ÷ total targets × 100%)</div>
                                </div>
                            </div>
                            
                            <div id="spider-rb-metrics" style="display: none;">
                                <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 8px; font-size: 12px;">RB Metrics:</div>
                                <div style="display: grid; gap: 8px; color: var(--text-secondary); font-size: 12px;">
                                    <div><strong style="color: var(--text-primary);">Volume:</strong> Opportunities per game (total opportunities ÷ games played)</div>
                                    <div><strong style="color: var(--text-primary);">Efficiency:</strong> Fantasy points per opportunity (avg points ÷ opps per game)</div>
                                    <div><strong style="color: var(--text-primary);">Red Zone:</strong> Red zone opportunities per game (total RZ opps ÷ games played)</div>
                                    <div><strong style="color: var(--text-primary);">Team Share:</strong> Opportunity share % in most recent week</div>
                                    <div><strong style="color: var(--text-primary);">Yards After Contact:</strong> Yards after contact per attempt (total YACON ÷ total attempts)</div>
                                </div>
                            </div>
                            
                            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color); font-size: 11px; color: var(--text-tertiary);">
                                <strong style="color: var(--text-secondary);">Note:</strong> Rankings only shown for Top 200 players. All metrics are calculated as per-game averages to ensure fair comparison regardless of games played.
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Comments Section -->
                <div class="comment-section">
                    <div class="comment-header">Quick Takes</div>
                    <div class="comment-input-container">
                        <input type="text" class="comment-input" id="comment-input" placeholder="Share your take (280 chars max)" maxlength="280">
                        <button class="comment-submit" onclick="submitComment()">Post</button>
                    </div>
                    <div class="comment-list" id="comment-list">
                        <!-- Comments will be inserted here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Team Modal -->
    <div class="modal-overlay" id="team-modal">
        <div class="modal">
            <div class="modal-header">
                <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                    <div class="modal-player-info">
                        <div class="modal-team-badge" id="team-modal-badge"></div>
                        <div class="modal-player-details">
                            <div class="modal-player-name" id="team-modal-name"></div>
                            <div class="modal-player-meta" id="team-modal-meta"></div>
                        </div>
                    </div>
                    <button class="modal-close" onclick="closeTeamModal()">×</button>
                </div>
            </div>
            <div class="modal-body">
                <!-- Team Stats Summary -->
                <div class="team-stats-summary" id="team-stats-summary" style="display: none; grid-template-columns: repeat(4, 1fr); gap: 16px; margin-bottom: 24px;">
                    <!-- Stats will be inserted here -->
                </div>
                
                <!-- Key Players Section -->
                <div class="key-players-section" id="key-players-section" style="margin-bottom: 24px;">
                    <h3 style="font-size: 16px; font-weight: 700; margin-bottom: 12px; color: var(--text-primary);">Key Players</h3>
                    <div id="key-players-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
                        <!-- Key players will be inserted here -->
                    </div>
                </div>
                
                <!-- Charts -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div class="chart-card">
                        <div class="chart-header">Latest Game Target Distribution</div>
                        <div class="chart-wrapper" style="height: 300px;">
                            <canvas id="team-modal-share-chart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <div class="chart-header">Target Share Trends</div>
                        <div class="chart-wrapper" style="height: 300px;">
                            <canvas id="team-modal-trends-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Login Modal -->
    <div class="modal-overlay" id="login-modal" style="display: none;">
        <div class="modal" style="max-width: 400px;">
            <div class="modal-header">
                <h2 style="font-size: 20px; font-weight: 700; color: var(--text-primary);">Admin Login</h2>
                <button class="modal-close" onclick="closeLoginModal()">×</button>
            </div>
            <div class="modal-body">
                <form onsubmit="handleLogin(event)" style="display: flex; flex-direction: column; gap: 16px;">
                    <div>
                        <label style="display: block; font-size: 13px; color: var(--text-secondary); margin-bottom: 6px;">Email</label>
                        <input 
                            type="email" 
                            id="login-email"
                            class="waitlist-input" 
                            placeholder="admin@ffse.com"
                            required
                            style="width: 100%;"
                        />
                    </div>
                    <div>
                        <label style="display: block; font-size: 13px; color: var(--text-secondary); margin-bottom: 6px;">Password</label>
                        <input 
                            type="password" 
                            id="login-password"
                            class="waitlist-input" 
                            placeholder="Enter password"
                            required
                            style="width: 100%;"
                        />
                    </div>
                    <button type="submit" class="waitlist-btn" onclick="handleLogin(event); return false;" style="width: 100%; padding: 12px;">
                        Login
                    </button>
                </form>
                <div class="success-message" id="login-error" style="background: var(--negative-bg); border-color: var(--negative); color: var(--negative);">
                    Invalid credentials
                </div>
            </div>
        </div>
    </div>

    <!-- Privacy Policy Modal -->
    <div class="modal-overlay" id="privacy-modal" style="display: none;">
        <div class="modal" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
            <div class="modal-header">
                <h2 style="font-size: 20px; font-weight: 700; color: var(--text-primary);">Privacy Policy</h2>
                <button class="modal-close" onclick="closePrivacyModal()">×</button>
            </div>
            <div class="modal-body" style="color: var(--text-secondary); line-height: 1.6;">
                <p style="margin-bottom: 16px; color: var(--text-tertiary); font-size: 13px;">
                    <strong>Effective Date:</strong> November 2025
                </p>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">1. Information We Collect</h3>
                <p style="margin-bottom: 12px; font-size: 14px;">
                    We collect information you provide directly to us, including:
                </p>
                <ul style="margin-left: 24px; margin-bottom: 16px; font-size: 14px;">
                    <li style="margin-bottom: 8px;">Email addresses submitted through our waitlist</li>
                    <li style="margin-bottom: 8px;">Usage data and analytics about how you interact with our platform</li>
                    <li style="margin-bottom: 8px;">Device and browser information</li>
                </ul>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">2. How We Use Your Information</h3>
                <p style="margin-bottom: 12px; font-size: 14px;">
                    We use the information we collect to:
                </p>
                <ul style="margin-left: 24px; margin-bottom: 16px; font-size: 14px;">
                    <li style="margin-bottom: 8px;">Provide, maintain, and improve our services</li>
                    <li style="margin-bottom: 8px;">Send you updates about FFSE features and releases</li>
                    <li style="margin-bottom: 8px;">Respond to your comments and questions</li>
                    <li style="margin-bottom: 8px;">Analyze usage patterns to enhance user experience</li>
                </ul>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">3. Information Sharing</h3>
                <p style="margin-bottom: 16px; font-size: 14px;">
                    We do not sell, trade, or rent your personal information to third parties. We may share your information only in the following circumstances:
                </p>
                <ul style="margin-left: 24px; margin-bottom: 16px; font-size: 14px;">
                    <li style="margin-bottom: 8px;">With your consent</li>
                    <li style="margin-bottom: 8px;">To comply with legal obligations</li>
                    <li style="margin-bottom: 8px;">With service providers who assist in our operations</li>
                </ul>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">4. Data Security</h3>
                <p style="margin-bottom: 16px; font-size: 14px;">
                    We implement appropriate technical and organizational measures to protect your personal information against unauthorized access, alteration, disclosure, or destruction.
                </p>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">5. Cookies and Tracking</h3>
                <p style="margin-bottom: 16px; font-size: 14px;">
                    We use cookies and similar tracking technologies to collect information about your browsing activities and to remember your preferences. You can control cookies through your browser settings.
                </p>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">6. Your Rights</h3>
                <p style="margin-bottom: 12px; font-size: 14px;">
                    You have the right to:
                </p>
                <ul style="margin-left: 24px; margin-bottom: 16px; font-size: 14px;">
                    <li style="margin-bottom: 8px;">Access the personal information we hold about you</li>
                    <li style="margin-bottom: 8px;">Request correction of inaccurate information</li>
                    <li style="margin-bottom: 8px;">Request deletion of your information</li>
                    <li style="margin-bottom: 8px;">Opt-out of marketing communications</li>
                </ul>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">7. Children's Privacy</h3>
                <p style="margin-bottom: 16px; font-size: 14px;">
                    Our service is not directed to individuals under the age of 13. We do not knowingly collect personal information from children under 13.
                </p>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">8. Changes to This Policy</h3>
                <p style="margin-bottom: 16px; font-size: 14px;">
                    We may update this Privacy Policy from time to time. We will notify you of any changes by posting the new Privacy Policy on this page and updating the "Effective Date."
                </p>

                <h3 style="color: var(--text-primary); font-size: 16px; font-weight: 600; margin: 24px 0 12px 0;">9. Contact Us</h3>
                <p style="margin-bottom: 16px; font-size: 14px;">
                    If you have any questions about this Privacy Policy, please contact us through the FFSE platform.
                </p>

                <div style="margin-top: 32px; padding-top: 24px; border-top: 1px solid var(--border-color);">
                    <p style="font-size: 12px; color: var(--text-tertiary);">
                        By using FFSE, you acknowledge that you have read and understood this Privacy Policy.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Upload Section (Hidden Input) -->
    <input type="file" id="wr-file-input" accept=".csv" onchange="handleWRUpload(event)">
    <input type="file" id="rb-file-input" accept=".csv" onchange="handleRBUpload(event)">

    <script>
        // ============================================
        // TE INTEGRATION PREPARATION
        // ============================================
        // The code is ready for TE data! When TE CSV is uploaded:
        // 1. teData array will be populated (already declared)
        // 2. TE nav tab will auto-show (#te-tab style display)
        // 3. TE page needs to be created (copy WR page structure)
        // 4. TE Advanced Analytics button will auto-show (#advanced-te-btn)
        // 5. Team Analysis "Pass Catchers" will include TEs automatically
        // 6. Add TE leaderboards: "Volume TEs", "Red Zone TEs", "Efficiency TEs"
        // 7. TE color is orange (#FF9F0A) - use getPositionColor('TE')
        // 8. TEs use WR-style metrics (targets, receptions, air yards, etc.)
        
        // ============================================
        // 1. DATA LAYER
        // ============================================
        
        // Position Colors
        const positionColors = {
            'WR': '#0a84ff',  // Blue
            'RB': '#30d158',  // Green
            'TE': '#ff9f0a'   // Orange/Amber
        };
        
        // NFL Team Colors
        const teamColors = {
            // AFC East
            'BUF': '#00338D', 'MIA': '#008E97', 'NE': '#223C67', 'NYJ': '#125740',
            // AFC North
            'BAL': '#241773', 'CIN': '#FB4F14', 'CLE': '#5A381E', 'PIT': '#FFB612', // Fixed PIT to gold
            // AFC South
            'HOU': '#14344C', 'IND': '#002C5F', 'JAC': '#006778', 'JAX': '#006778', 'TEN': '#0C2340',
            // AFC West
            'DEN': '#FB4F14', 'KC': '#E31837', 'LV': '#A5ACAF', 'LAC': '#0080C6',
            // NFC East
            'DAL': '#003594', 'NYG': '#0B2265', 'PHI': '#004C54', 'WAS': '#7A2222',
            // NFC North
            'CHI': '#2E3E66', 'DET': '#0076B6', 'GB': '#203731', 'MIN': '#4F2683',
            // NFC South
            'ATL': '#A71930', 'CAR': '#0085CA', 'NO': '#D3BC8D', 'TB': '#D50A0A',
            // NFC West
            'ARI': '#97233F', 'LAR': '#003594', 'SF': '#AA0000', 'SEA': '#223C67'
        };
        
        // NFL Team Full Color Palettes (Primary, Secondary, Tertiary, Fallback) - Dark UI Optimized
        const teamColorPalettes = {
            // AFC North
            'BAL': ['#241773', '#9E7C0C', '#C8102E', '#8E8AFF'],
            'CIN': ['#FB4F14', '#FF8F33', '#FFD6A5', '#FFB300'],
            'CLE': ['#5A381E', '#FF3C00', '#FF8F66', '#FFB547'],
            'PIT': ['#FFB612', '#00539B', '#C8102E', '#FFD65E'],
            // AFC East
            'BUF': ['#00338D', '#C60C30', '#66A3FF', '#0096FF'],
            'MIA': ['#008E97', '#FC4C02', '#4DD5D0', '#00CFFF'],
            'NE': ['#223C67', '#C60C30', '#B0B7BC', '#748FFF'],
            'NYJ': ['#125740', '#FFFFFF', '#5DBB63', '#29D98C'],
            // AFC South
            'HOU': ['#14344C', '#A6192E', '#D6E3F8', '#007BFF'],
            'IND': ['#002C5F', '#A2AAAD', '#589BFF', '#00A3E0'],
            'JAC': ['#006778', '#D7A22A', '#9F792C', '#00CFCF'],
            'JAX': ['#006778', '#D7A22A', '#9F792C', '#00CFCF'],
            'TEN': ['#0C2340', '#4B92DB', '#C8102E', '#85BFFF'],
            // AFC West
            'DEN': ['#FB4F14', '#223C67', '#FFD6A5', '#FFB300'],
            'KC': ['#E31837', '#FFB81C', '#FF9A66', '#FFD65E'],
            'LV': ['#A5ACAF', '#FFFFFF', '#E6E6E6', '#B8C2CC'],
            'LAC': ['#0080C6', '#FFC20E', '#F4F4F4', '#00CFFF'],
            // NFC North
            'CHI': ['#2E3E66', '#C83803', '#FF8A3D', '#FFB547'],
            'DET': ['#0076B6', '#B0B7BC', '#5CB3FF', '#00A3E0'],
            'GB': ['#203731', '#FFB81C', '#9FCF5A', '#D9B200'],
            'MIN': ['#4F2683', '#FFC62F', '#A285E0', '#8E8AFF'],
            // NFC East
            'DAL': ['#003594', '#869397', '#A8B0B7', '#8CB5FF'],
            'NYG': ['#0B2265', '#A71930', '#7FA9FF', '#007BFF'],
            'PHI': ['#004C54', '#A5ACAF', '#2BAEA6', '#00D6B4'],
            'WAS': ['#7A2222', '#FFB612', '#FFD65E', '#D2691E'],
            // NFC South
            'ATL': ['#A71930', '#A5ACAF', '#E94958', '#FFB5C3'],
            'CAR': ['#0085CA', '#BFC0BF', '#59C9FF', '#00CFFF'],
            'NO': ['#D3BC8D', '#F5E6CC', '#FFF1D4', '#FFD65E'],
            'TB': ['#D50A0A', '#FF7900', '#D3D3D3', '#FFD65E'],
            // NFC West
            'ARI': ['#97233F', '#FFB612', '#E94958', '#FF8C8C'],
            'LAR': ['#003594', '#FFA300', '#FFD65E', '#00CFFF'],
            'SF': ['#AA0000', '#B3995D', '#FFD65E', '#FF8A8A'],
            'SEA': ['#223C67', '#69BE28', '#A5ACAF', '#9EFF78']
        };

        // Global data storage
        let wrData = null;
        let rbData = null;
        let teData = null;
        let aggregatedWRs = {};
        let aggregatedRBs = {};
        let aggregatedTEs = {};
        let currentScoringFormat = localStorage.getItem('ffse_scoring_format') || 'ppr'; // 'ppr', 'half', or 'std'
        let allPlayers = {};
        let teamStats = {}; // Store team statistics globally for Advanced Analytics
        
        // Team Analysis variables
        let teamAnalysisCharts = {
            pie: null,
            secondary: null
        };
        let leagueComparisonEnabled = true; // Start with league comparison ON
        let currentTeamAnalysisTeam = null;
        
        // NFL Divisions structure
        const nflDivisions = {
            'AFC East': ['BUF', 'MIA', 'NYJ', 'NE'],
            'AFC North': ['BAL', 'CIN', 'CLE', 'PIT'],
            'AFC South': ['HOU', 'IND', 'JAX', 'TEN'],
            'AFC West': ['DEN', 'KC', 'LV', 'LAC'],
            'NFC East': ['DAL', 'NYG', 'PHI', 'WAS'],
            'NFC North': ['CHI', 'DET', 'GB', 'MIN'],
            'NFC South': ['ATL', 'CAR', 'NO', 'TB'],
            'NFC West': ['ARI', 'LAR', 'SF', 'SEA']
        };
        
        // Position colors
        const POSITION_COLORS = {
            'WR': '#0a84ff',  // Blue
            'RB': '#30d158',  // Green
            'TE': '#FF9F0A'   // Orange
        };
        
        // Helper function to get position color
        function getPositionColor(position) {
            return POSITION_COLORS[position] || '#8e8e93'; // Default gray
        }
        
        // Sentiment & voting data
        let playerVotes = {}; // { playerName: { buy: count, sell: count, hold: count, lastVote: timestamp } }
        let playerComments = {}; // { playerName: [ { text, timestamp, user } ] }
        
        // Load sentiment data from localStorage
        function loadSentimentData() {
            const stored = localStorage.getItem('ffse_player_votes');
            if (stored) {
                playerVotes = JSON.parse(stored);
                // Clean old votes (older than 30 days)
                const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
                Object.keys(playerVotes).forEach(player => {
                    if (playerVotes[player].lastVote < thirtyDaysAgo) {
                        delete playerVotes[player];
                    }
                });
            }
            
            // Add dummy votes if no votes exist (for demo purposes)
            if (Object.keys(playerVotes).length === 0) {
                const now = Date.now();
                const dummyVotes = {
                    'Amon-Ra St. Brown': { buy: 45, hold: 12, sell: 8, lastVote: now },
                    'CeeDee Lamb': { buy: 38, hold: 15, sell: 10, lastVote: now },
                    'Ja\'Marr Chase': { buy: 52, hold: 8, sell: 5, lastVote: now },
                    'Justin Jefferson': { buy: 48, hold: 10, sell: 7, lastVote: now },
                    'Tyreek Hill': { buy: 35, hold: 18, sell: 12, lastVote: now },
                    'Puka Nacua': { buy: 55, hold: 7, sell: 3, lastVote: now },
                    'A.J. Brown': { buy: 40, hold: 14, sell: 9, lastVote: now },
                    'Christian McCaffrey': { buy: 60, hold: 5, sell: 2, lastVote: now },
                    'Bijan Robinson': { buy: 58, hold: 8, sell: 4, lastVote: now },
                    'Breece Hall': { buy: 42, hold: 15, sell: 8, lastVote: now },
                    'Saquon Barkley': { buy: 50, hold: 10, sell: 6, lastVote: now },
                    'Jahmyr Gibbs': { buy: 48, hold: 12, sell: 7, lastVote: now },
                    'De\'Von Achane': { buy: 45, hold: 13, sell: 9, lastVote: now },
                    'Jonathan Taylor': { buy: 38, hold: 18, sell: 11, lastVote: now },
                    'Derrick Henry': { buy: 35, hold: 20, sell: 10, lastVote: now },
                    'Travis Etienne': { buy: 30, hold: 22, sell: 15, lastVote: now },
                    'Cooper Kupp': { buy: 25, hold: 20, sell: 28, lastVote: now },
                    'Michael Pittman': { buy: 28, hold: 25, sell: 22, lastVote: now },
                    'Stefon Diggs': { buy: 32, hold: 23, sell: 18, lastVote: now },
                    'Drake London': { buy: 40, hold: 15, sell: 10, lastVote: now }
                };
                
                // Merge dummy votes with any existing votes
                playerVotes = { ...dummyVotes, ...playerVotes };
                saveSentimentData();
            }
        }
        
        // Save sentiment data to localStorage
        function saveSentimentData() {
            localStorage.setItem('ffse_player_votes', JSON.stringify(playerVotes));
        }
        
        // Calculate sentiment score with 7-day decay
        function getSentimentScore(playerName) {
            if (!playerVotes[playerName]) return { score: 0, buy: 0, sell: 0, hold: 0, total: 0 };
            
            const votes = playerVotes[playerName];
            const now = Date.now();
            const sevenDays = 7 * 24 * 60 * 60 * 1000;
            
            // Apply time decay (votes older than 7 days have reduced weight)
            const daysSinceVote = (now - votes.lastVote) / (24 * 60 * 60 * 1000);
            const decayFactor = Math.max(0, 1 - (daysSinceVote / 7));
            
            const weightedBuy = votes.buy * decayFactor;
            const weightedSell = votes.sell * decayFactor;
            const weightedHold = votes.hold * decayFactor;
            const total = weightedBuy + weightedSell + weightedHold;
            
            // Score: +1 for buy, 0 for hold, -1 for sell
            const score = total > 0 ? (weightedBuy - weightedSell) / total : 0;
            
            return {
                score: score, // -1 to +1
                buy: votes.buy,
                sell: votes.sell,
                hold: votes.hold,
                total: votes.buy + votes.sell + votes.hold,
                decayFactor: decayFactor
            };
        }
        
        // Generate signal tags based on data
        function getSignalTag(playerData) {
            if (!playerData.oppShare || !playerData.weeklyData) return null;
            
            // Calculate opportunity share change (last 2 weeks vs previous 2 weeks)
            const weeks = playerData.weeklyData.sort((a, b) => b.week - a.week);
            if (weeks.length < 4) return null;
            
            const recent2 = weeks.slice(0, 2);
            const previous2 = weeks.slice(2, 4);
            const recentAvg = recent2.reduce((sum, w) => sum + (parseFloat(w.oppShare) || 0), 0) / 2;
            const previousAvg = previous2.reduce((sum, w) => sum + (parseFloat(w.oppShare) || 0), 0) / 2;
            const change = recentAvg - previousAvg;
            
            if (change >= 5) return { type: 'trending', label: 'Trending Up', class: 'positive' };
            
            // Check consistency (avg ± 3 pts for 4+ weeks)
            const avgPoints = weeks.reduce((sum, w) => sum + (parseFloat(w.fpts) || 0), 0) / weeks.length;
            const variance = weeks.reduce((sum, w) => sum + Math.pow((parseFloat(w.fpts) || 0) - avgPoints, 2), 0) / weeks.length;
            const stdDev = Math.sqrt(variance);
            
            if (stdDev <= 3 && weeks.length >= 4) return { type: 'consistent', label: 'Consistent', class: 'neutral' };
            
            // Check if undershooting projection
            const undershoots = weeks.filter(w => {
                const actual = parseFloat(w.fpts) || 0;
                const expected = parseFloat(w.expected) || actual;
                return actual < expected;
            }).length;
            
            if (undershoots >= 3 && weeks.length >= 4) return { type: 'oversold', label: 'Buy Low', class: 'opportunity' };
            
            return null;
        }
        
        // Chart instances
        let wrScatterChart = null;
        let rbScatterChart = null;
        let modalVarianceChart = null;
        let modalOutcomesChart = null;
        let modalSpiderChart = null;
        let modalShareChart = null;
        let modalTrendsChart = null;
        let teamModalShareChart = null;
        let teamModalTrendsChart = null;
        
        // Matrix chart instances
        let wrEfficiencyMatrix = null;
        let wrShareMatrix = null;
        let wrFloorMatrix = null;
        let wrRedzoneMatrix = null;
        let wrVolumeMonsterMatrix = null;
        let wrCatchRateMatrix = null;
        let rbEfficiencyMatrix = null;
        let rbTalentMatrix = null;
        let rbOpportunityMatrix = null;
        let rbShareMatrix = null;
        let rbFloorMatrix = null;
        let rbRedzoneMatrix = null;
        
        /* New: Player Evaluation Metrics - Data and Chart Instances */
        let evaluationDataWR = {};
        let evaluationDataRB = {};
        
        /* v7: Segment averages (4-week rolling) */
        let segmentDataWR = {};
        let segmentDataRB = {};
        
        let wrEvalVolumeEfficiencyChart = null;
        let wrEvalShareRZChart = null;
        let rbEvalTotalRZChart = null;
        let rbEvalVolumeEfficiencyChart = null;
        
        // Trend animation state
        let evaluationTrendActive = {};
        let evaluationTrendIntervals = {};
        let evaluationTrendCurrentWeek = {};
        
        // Helper function to generate color variations for players on same team
        function getColorPalette(baseColor, count) {
            // Convert hex to RGB
            const r = parseInt(baseColor.slice(1, 3), 16);
            const g = parseInt(baseColor.slice(3, 5), 16);
            const b = parseInt(baseColor.slice(5, 7), 16);
            
            const colors = [];
            for (let i = 0; i < count; i++) {
                // Create variations by adjusting brightness and saturation
                const factor = 1 + (i * 0.3); // 0%, 30%, 60%, 90% lighter
                const lighten = Math.min(1, 0.7 + (i * 0.1)); // Start at 70% brightness
                
                const newR = Math.min(255, Math.floor(r * lighten + (255 - r * lighten) * (i / count)));
                const newG = Math.min(255, Math.floor(g * lighten + (255 - g * lighten) * (i / count)));
                const newB = Math.min(255, Math.floor(b * lighten + (255 - b * lighten) * (i / count)));
                
                colors.push(`rgb(${newR}, ${newG}, ${newB})`);
            }
            
            return colors;
        }

        /* ============================================
           New Feature: Player Headshot Handler
           ============================================ */
        
        // Generate headshot URL for a player
        function getPlayerHeadshotUrl(playerName, team) {
            // Map of player names to their uploaded headshot files
            const headshotMap = {
                'Christian McCaffrey': '/mnt/user-data/uploads/McCaffrey_Christian.JPG',
                'Jonathan Taylor': '/mnt/user-data/uploads/Taylor_Jonathan.JPG',
                'Justin Jefferson': '/mnt/user-data/uploads/Jefferson_Justin.jpg',
                'Ladd McConkey': '/mnt/user-data/uploads/McConkey_Ladd.jpg',
                'Ja\'Marr Chase': '/mnt/user-data/uploads/Chase_Ja_Marr.jpg',
                'Bijan Robinson': '/mnt/user-data/uploads/Robinson_Bijan.JPG'
            };
            
            return headshotMap[playerName] || null;
        }
        
        // Create headshot img element
        function createHeadshotElement(playerName, team) {
            const url = getPlayerHeadshotUrl(playerName, team);
            
            if (url) {
                // REFACTORED: Lazy load images
                return `<img src="" data-src="${url}" alt="${playerName}" class="player-headshot loading" onerror="this.style.display='none'" loading="lazy">`;
            } else {
                // Placeholder: Use team color circle with initials
                const initials = playerName
                    .split(' ')
                    .map(n => n[0])
                    .join('')
                    .toUpperCase()
                    .slice(0, 2);
                const bgColor = teamColors[team] || '#666';
                return `<div class="player-headshot" style="background: ${bgColor}; display: flex; align-items: center; justify-content: center; font-size: 11px; font-weight: 700; color: white;">${initials}</div>`;
            }
        }
        
        // REFACTORED: Lazy load headshot images with Intersection Observer
        function initLazyLoadHeadshots() {
            if ('IntersectionObserver' in window) {
                const imageObserver = new IntersectionObserver((entries, observer) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const img = entry.target;
                            img.src = img.dataset.src;
                            img.classList.remove('loading');
                            observer.unobserve(img);
                        }
                    });
                });
                
                document.querySelectorAll('img.player-headshot[data-src]').forEach(img => {
                    imageObserver.observe(img);
                });
            } else {
                // Fallback for older browsers
                document.querySelectorAll('img.player-headshot[data-src]').forEach(img => {
                    img.src = img.dataset.src;
                    img.classList.remove('loading');
                });
            }
        }
        
        /* ============================================
           REFACTORED: Animation & Chart Utilities
           ============================================ */
        
        // Easing functions for smooth animations
        const Easing = {
            linear: t => t,
            easeInOutSine: t => -(Math.cos(Math.PI * t) - 1) / 2,
            easeOutCubic: t => 1 - Math.pow(1 - t, 3),
            easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2
        };
        
        // Chart update utility - update data instead of destroying
        function updateChartData(chart, newData) {
            if (!chart) return;
            chart.data.datasets[0].data = newData;
            chart.update('none'); // Update without animation for performance
        }
        
        // Smooth interpolation
        function lerp(start, end, t) {
            return start + (end - start) * t;
        }
        
        // Get chart instance by ID
        
        /* ============================================
           New Feature: Trend Animation
           ============================================ */
        
        let trendAnimationActive = {};
        let trendAnimationFrames = {};
        
        function toggleTrendAnimation(chartId) {
            trendAnimationActive[chartId] = !trendAnimationActive[chartId];
            trendAnimationFrames[chartId] = 0;
            
            const btn = document.querySelector(`[data-chart="${chartId}"]`);
            if (btn) {
                btn.classList.toggle('active');
            }
            
            // Note: Animation loop would be triggered here if we had weekly player data
            // For now, this is a placeholder for future implementation
        }
        
        /* ============================================
           Quadrant Highlighting Removed - Using chart annotations instead
           ============================================ */

        // Helper function for linear regression
        function calculateLinearRegression(data) {
            const n = data.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
            
            data.forEach(point => {
                sumX += point.x;
                sumY += point.y;
                sumXY += point.x * point.y;
                sumX2 += point.x * point.x;
            });
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            return { slope, intercept };
        }
        
        /* ============================================
           New: Player Evaluation Metrics Functions
           ============================================ */
        
        /**
         * Calculate evaluation metrics from raw weekly data
         * Creates per-week and aggregated metrics for WRs
         */
        function calculateWREvaluationMetrics(weeklyData) {
            const wrsByWeek = {};
            const wrTeamTotals = {}; // Track team totals by week
            
            // First pass: organize by player and week, calculate team totals
            weeklyData.forEach(row => {
                const week = parseInt(row.Week);
                const player = row.Player?.trim();
                const team = row.Team?.trim();
                
                if (!player || !week || week === 0) return;
                
                // Initialize player data
                if (!wrsByWeek[player]) {
                    wrsByWeek[player] = { team: team, weeks: {} };
                }
                
                // Extract metrics
                const targets = parseFloat(row.TGT) || 0;
                const fpts = parseFloat(row.FPTS) || 0;
                const rzTargets = parseFloat(row['RZ TGT']) || parseFloat(row['RZ_TGT']) || 0;
                
                // Store week data
                wrsByWeek[player].weeks[week] = {
                    targets: targets,
                    fpts: fpts,
                    rzTargets: rzTargets,
                    team: team
                };
                
                // Track team totals for share calculation
                const teamKey = `${team}-${week}`;
                if (!wrTeamTotals[teamKey]) {
                    wrTeamTotals[teamKey] = { targets: 0, rzTargets: 0 };
                }
                wrTeamTotals[teamKey].targets += targets;
                wrTeamTotals[teamKey].rzTargets += rzTargets;
            });
            
            // Second pass: calculate derived metrics
            Object.keys(wrsByWeek).forEach(player => {
                const playerData = wrsByWeek[player];
                const weeks = Object.keys(playerData.weeks).map(Number).sort((a, b) => a - b);
                
                weeks.forEach(week => {
                    const weekData = playerData.weeks[week];
                    const teamKey = `${weekData.team}-${week}`;
                    const teamTotals = wrTeamTotals[teamKey] || { targets: 1, rzTargets: 1 };
                    
                    // Calculate per-game and share metrics
                    weekData.targetsPerGame = weekData.targets; // Already per-game in weekly data
                    weekData.fptsPerTarget = weekData.targets > 0 ? weekData.fpts / weekData.targets : 0;
                    weekData.targetShare = (weekData.targets / teamTotals.targets) * 100;
                    weekData.rzTargetShare = teamTotals.rzTargets > 0 ? (weekData.rzTargets / teamTotals.rzTargets) * 100 : 0;
                });
                
                // Calculate aggregates across all weeks
                const allWeekData = weeks.map(w => playerData.weeks[w]);
                playerData.aggregate = {
                    gamesPlayed: weeks.length,
                    totalTargets: allWeekData.reduce((sum, w) => sum + w.targets, 0),
                    totalFpts: allWeekData.reduce((sum, w) => sum + w.fpts, 0),
                    totalRZTargets: allWeekData.reduce((sum, w) => sum + w.rzTargets, 0),
                    avgTargetsPerGame: allWeekData.reduce((sum, w) => sum + w.targets, 0) / weeks.length,
                    avgFptsPerTarget: allWeekData.reduce((sum, w) => sum + w.fpts, 0) / allWeekData.reduce((sum, w) => sum + w.targets, 0.0001),
                    avgTargetShare: allWeekData.reduce((sum, w) => sum + w.targetShare, 0) / weeks.length,
                    avgRZTargetShare: allWeekData.reduce((sum, w) => sum + w.rzTargetShare, 0) / weeks.length,
                    latestWeek: Math.max(...weeks)
                };
            });
            
            return wrsByWeek;
        }
        
        /**
         * Calculate evaluation metrics from raw weekly data
         * Creates per-week and aggregated metrics for RBs
         */
        function calculateRBEvaluationMetrics(weeklyData) {
            const rbsByWeek = {};
            const rbTeamTotals = {}; // Track team totals by week
            
            // First pass: organize by player and week
            weeklyData.forEach(row => {
                const week = parseInt(row.Week);
                const player = row.Player?.trim();
                const team = row.Team?.trim();
                
                if (!player || !week || week === 0) return;
                
                // Initialize player data
                if (!rbsByWeek[player]) {
                    rbsByWeek[player] = { team: team, weeks: {} };
                }
                
                // Extract metrics
                const rushAtt = parseFloat(row.ATT) || 0;
                const targets = parseFloat(row.TGT) || 0;
                const fpts = parseFloat(row.FPTS) || 0;
                const rzRushAtt = parseFloat(row.RZ_RUSH_ATT) || 0;
                const rzTargets = parseFloat(row['RZ TGT']) || parseFloat(row['RZ_TGT']) || 0;
                const opportunities = rushAtt + targets;
                const rzOpportunities = rzRushAtt + rzTargets;
                
                // Store week data
                rbsByWeek[player].weeks[week] = {
                    opportunities: opportunities,
                    fpts: fpts,
                    rzOpportunities: rzOpportunities,
                    team: team
                };
                
                // Track team totals
                const teamKey = `${team}-${week}`;
                if (!rbTeamTotals[teamKey]) {
                    rbTeamTotals[teamKey] = { opportunities: 0, rzOpportunities: 0 };
                }
                rbTeamTotals[teamKey].opportunities += opportunities;
                rbTeamTotals[teamKey].rzOpportunities += rzOpportunities;
            });
            
            // Second pass: calculate derived metrics
            Object.keys(rbsByWeek).forEach(player => {
                const playerData = rbsByWeek[player];
                const weeks = Object.keys(playerData.weeks).map(Number).sort((a, b) => a - b);
                
                weeks.forEach(week => {
                    const weekData = playerData.weeks[week];
                    // Calculate per-game and efficiency metrics
                    weekData.opportunitiesPerGame = weekData.opportunities;
                    weekData.rzOpportunitiesPerGame = weekData.rzOpportunities;
                    weekData.efficiency = weekData.opportunities > 0 ? weekData.fpts / weekData.opportunities : 0;
                });
                
                // Calculate aggregates
                const allWeekData = weeks.map(w => playerData.weeks[w]);
                playerData.aggregate = {
                    gamesPlayed: weeks.length,
                    totalOpportunities: allWeekData.reduce((sum, w) => sum + w.opportunities, 0),
                    totalFpts: allWeekData.reduce((sum, w) => sum + w.fpts, 0),
                    totalRZOpportunities: allWeekData.reduce((sum, w) => sum + w.rzOpportunities, 0),
                    avgOpportunitiesPerGame: allWeekData.reduce((sum, w) => sum + w.opportunities, 0) / weeks.length,
                    avgRZOpportunitiesPerGame: allWeekData.reduce((sum, w) => sum + w.rzOpportunities, 0) / weeks.length,
                    avgEfficiency: allWeekData.reduce((sum, w) => sum + w.fpts, 0) / allWeekData.reduce((sum, w) => sum + w.opportunities, 0.0001),
                    latestWeek: Math.max(...weeks)
                };
            });
            
            return rbsByWeek;
        }
        
        /**
         * Get the data for a specific week or latest week
         */
        function getEvaluationWeekData(evaluationData, week = null) {
            const result = [];
            
            Object.keys(evaluationData).forEach(player => {
                const playerData = evaluationData[player];
                const targetWeek = week || playerData.aggregate.latestWeek;
                const weekData = playerData.weeks[targetWeek];
                
                if (weekData) {
                    result.push({
                        player: player,
                        team: playerData.team,
                        ...weekData,
                        aggregate: playerData.aggregate
                    });
                }
            });
            
            return result;
        }
        
        /**
         * Get all available weeks from evaluation data
         */
        function getAvailableWeeks(evaluationData) {
            const weeks = new Set();
            Object.values(evaluationData).forEach(playerData => {
                Object.keys(playerData.weeks).forEach(week => weeks.add(parseInt(week)));
            });
            return Array.from(weeks).sort((a, b) => a - b);
        }
        
        /* ========================================================================
         * v7: SEGMENT CALCULATION FUNCTIONS
         * Calculate rolling N-week segment averages from weekly data
         * ======================================================================== */
        
        /**
         * Calculate NON-OVERLAPPING 4-week segment averages
         * Segments: Weeks 1-4, 5-8, 9-12, 13-16, etc.
         * @param {Object} evaluationData - Player-keyed evaluation data (wrsByWeek or rbsByWeek format)
         * @param {number} segmentSize - Number of weeks per segment (default: 4)
         * @returns {Object} Segment data keyed by segment index
         */
        function calculateSegmentAverages(evaluationData, segmentSize = 4) {
            // Get all available weeks from all players
            const allWeeks = new Set();
            Object.values(evaluationData).forEach(playerData => {
                Object.keys(playerData.weeks).forEach(week => {
                    allWeeks.add(parseInt(week));
                });
            });
            
            const weeks = Array.from(allWeeks).sort((a, b) => a - b);
            
            if (weeks.length < segmentSize) {
                console.warn(`Not enough weeks (${weeks.length}) for ${segmentSize}-week segments`);
                return {};
            }
            
            const minWeek = weeks[0];
            const maxWeek = weeks[weeks.length - 1];
            
            // Calculate number of non-overlapping segments
            const numSegments = Math.ceil(maxWeek / segmentSize);
            const segmentData = {};
            
            // Create each non-overlapping segment
            for (let segmentIndex = 0; segmentIndex < numSegments; segmentIndex++) {
                const segmentStartWeek = (segmentIndex * segmentSize) + 1;
                const segmentEndWeek = Math.min(segmentStartWeek + segmentSize - 1, maxWeek);
                const segmentWeeks = [];
                
                // Build array of weeks in this segment
                for (let w = segmentStartWeek; w <= segmentEndWeek; w++) {
                    if (weeks.includes(w)) {
                        segmentWeeks.push(w);
                    }
                }
                
                if (segmentWeeks.length === 0) continue;
                
                // Calculate averages for each player in this segment
                const segmentPlayers = [];
                
                Object.keys(evaluationData).forEach(playerName => {
                    const playerData = evaluationData[playerName];
                    const playerWeeksInSegment = [];
                    
                    // Collect this player's data for weeks in this segment
                    segmentWeeks.forEach(week => {
                        if (playerData.weeks[week]) {
                            playerWeeksInSegment.push({
                                week: week,
                                ...playerData.weeks[week]
                            });
                        }
                    });
                    
                    // Skip if player has no data in this segment
                    if (playerWeeksInSegment.length === 0) return;
                    
                    // Calculate averages
                    const avgPlayer = {
                        player: playerName,
                        team: playerData.team,
                        segmentWeeks: segmentWeeks,
                        weeksInSegment: playerWeeksInSegment.length
                    };
                    
                    // Fields to average - check what fields exist
                    const fieldsToAverage = [
                        'targets', 'targetsPerGame', 'fpts', 'fptsPerTarget', 
                        'targetShare', 'rzTargets', 'rzTargetShare',
                        'opportunities', 'rzOpportunities', 'efficiency'
                    ];
                    
                    fieldsToAverage.forEach(field => {
                        const values = playerWeeksInSegment
                            .map(w => w[field])
                            .filter(v => v !== undefined && v !== null && !isNaN(v));
                        
                        if (values.length > 0) {
                            avgPlayer[field] = values.reduce((sum, v) => sum + v, 0) / values.length;
                        }
                    });
                    
                    // Use player's aggregate data (calculated across all weeks)
                    avgPlayer.aggregate = playerData.aggregate;
                    
                    segmentPlayers.push(avgPlayer);
                });
                
                segmentData[segmentIndex] = segmentPlayers;
            }
            
            return segmentData;
        }
        
        /**
         * Get available segments from segment data
         * @param {Object} segmentData - Segment data object
         * @returns {Array<number>} Sorted array of segment indices
         */
        function getAvailableSegments(segmentData) {
            return Object.keys(segmentData)
                .map(Number)
                .filter(s => !isNaN(s))
                .sort((a, b) => a - b);
        }
        
        /**
         * Get data for a specific segment
         * @param {Object} segmentData - Segment data object  
         * @param {number} segmentIndex - Segment index (can be fractional for interpolation)
         * @returns {Array} Player data for the segment
         */
        function getEvaluationSegmentData(segmentData, segmentIndex = null) {
            const segments = getAvailableSegments(segmentData);
            
            if (segments.length === 0) {
                return [];
            }
            
            // If no segment specified, return latest
            if (segmentIndex === null) {
                return segmentData[segments[segments.length - 1]] || [];
            }
            
            // If integer segment, return directly
            if (Number.isInteger(segmentIndex) && segmentData[segmentIndex]) {
                return segmentData[segmentIndex] || [];
            }
            
            // For fractional segments, return floor value (interpolation handled by animation)
            const floorIndex = Math.floor(segmentIndex);
            return segmentData[floorIndex] || [];
        }
        
        /**
         * Get the week range for a segment index
         * @param {Object} segmentData - Segment data object
         * @param {number} segmentIndex - Segment index
         * @returns {Array<number>} Array of week numbers in the segment
         */
        function getSegmentWeekRange(segmentData, segmentIndex) {
            const segmentPlayers = segmentData[segmentIndex];
            if (!segmentPlayers || segmentPlayers.length === 0) {
                return [];
            }
            
            // Get weeks from first player (all players in segment have same weeks)
            return segmentPlayers[0].segmentWeeks || [];
        }
        
        /**
         * Format segment label for display
         * @param {number} segmentFloat - Segment index (can be fractional)
         * @param {Object} segmentData - Segment data object
         * @returns {string} Formatted label (e.g., "Segments 1-4")
         */
        function formatSegmentLabel(segmentFloat, segmentData) {
            const segmentIndex = Math.floor(segmentFloat);
            const weeks = getSegmentWeekRange(segmentData, segmentIndex);
            
            if (weeks.length === 0) {
                return `Segment ${segmentIndex}`;
            }
            
            const firstWeek = weeks[0];
            const lastWeek = weeks[weeks.length - 1];
            
            if (firstWeek === lastWeek) {
                return `Week ${firstWeek}`;
            }
            
            return `Segments ${firstWeek}-${lastWeek}`;
        }
        
        /* End of v7 Segment Calculation Functions */
        
        // AI Analysis Generator
        function generatePlayerAnalysis(player) {
            const insights = [];
            
            // 1. Opportunity Share Analysis
            const oppShare = player.latestWeekOppShare;
            if (oppShare > 30) {
                insights.push(`<strong>High target</strong> with ${oppShare.toFixed(0)}% opportunity share - commanding a significant portion of team's offense.`);
            } else if (oppShare > 20) {
                insights.push(`<strong>Solid role</strong> with ${oppShare.toFixed(0)}% opportunity share - reliable contributor in the offense.`);
            } else if (oppShare > 10) {
                insights.push(`<strong>Limited role</strong> at ${oppShare.toFixed(0)}% opportunity share - may need more involvement for consistent production.`);
            } else {
                insights.push(`<strong>Minimal role</strong> with only ${oppShare.toFixed(0)}% opportunity share - volatility risk is high.`);
            }
            
            // 2. Performance vs Expected
            const overPerformances = player.weeks.filter(w => w.variance > 0).length;
            const totalWeeks = player.weeks.length;
            const overPerformRate = (overPerformances / totalWeeks) * 100;
            
            if (overPerformRate > 65) {
                insights.push(`<strong>Exceeding expectations</strong> - outperformed projections in ${overPerformances} of ${totalWeeks} games (${overPerformRate.toFixed(0)}%). High efficiency player.`);
            } else if (overPerformRate > 35) {
                insights.push(`<strong>Meeting expectations</strong> - balanced performance around projections (${overPerformRate.toFixed(0)}% over-performance rate).`);
            } else {
                insights.push(`<strong>Underperforming</strong> - only exceeded expectations in ${overPerformances} of ${totalWeeks} games. May be dealing with efficiency issues or tough matchups.`);
            }
            
            // 3. Volume vs Efficiency Analysis
            const avgVariance = player.weeks.reduce((sum, w) => sum + w.variance, 0) / totalWeeks;
            const totalOpps = player.position === 'WR' ? player.totalTargets : player.totalOpportunities;
            
            if (totalOpps > 70 && avgVariance < -1) {
                insights.push(`<strong>High-volume, low-efficiency</strong> - receiving significant opportunities (${totalOpps}) but averaging ${Math.abs(avgVariance).toFixed(1)} points below expected per game.`);
            } else if (totalOpps > 70 && avgVariance > 1) {
                insights.push(`<strong>High-volume, high-efficiency</strong> - elite combination of opportunity (${totalOpps}) and production (+${avgVariance.toFixed(1)} vs expected per game).`);
            } else if (totalOpps < 40 && avgVariance > 1) {
                insights.push(`<strong>Limited volume, high efficiency</strong> - making the most of opportunities with +${avgVariance.toFixed(1)} vs expected, but volume (${totalOpps}) caps upside.`);
            }
            
            // 4. Consistency Analysis
            const variances = player.weeks.map(w => w.variance);
            const stdDev = Math.sqrt(variances.reduce((sum, v) => sum + Math.pow(v, 2), 0) / totalWeeks);
            
            if (stdDev < 3) {
                insights.push(`<strong>High floor, stable producer</strong> - low variance (${stdDev.toFixed(1)}) suggests consistent weekly outcomes.`);
            } else if (stdDev > 6) {
                insights.push(`<strong>Boom-or-bust profile</strong> - high variance (${stdDev.toFixed(1)}) indicates wide range of weekly outcomes.`);
            }
            
            // 5. Trend Analysis
            if (player.oppChange > 5) {
                insights.push(`<strong>📈 Trending up</strong> - opportunity share increased by ${player.oppChange.toFixed(1)}% recently, suggesting growing role.`);
            } else if (player.oppChange < -5) {
                insights.push(`<strong>📉 Trending down</strong> - opportunity share decreased by ${Math.abs(player.oppChange).toFixed(1)}%, role may be shrinking.`);
            }
            
            return insights.join(' ');
        }

        // Load data from localStorage on page load
        function loadStoredData() {
            const storedWR = localStorage.getItem('wrData');
            const storedRB = localStorage.getItem('rbData');
            const storedTE = localStorage.getItem('teData');
            
            if (storedWR) {
                wrData = JSON.parse(storedWR);
            }
            if (storedRB) {
                rbData = JSON.parse(storedRB);
            }
            if (storedTE) {
                teData = JSON.parse(storedTE);
            }
            
            if (wrData || rbData || teData) {
                processAllData();
            }
        }

        // CSV Upload Handlers
        function showUploadSection() {
            const hasData = wrData && rbData && teData;
            if (hasData) {
                if (confirm('You already have data loaded. Do you want to upload new data?')) {
                    document.getElementById('wr-file-input').click();
                }
            } else {
                document.getElementById('wr-file-input').click();
            }
        }

        function handleWRUpload(event) {
            const file = event.target.files[0];
            if (file) {
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        wrData = results.data.filter(row => row.Player && row.Week);
                        localStorage.setItem('wrData', JSON.stringify(wrData));
                        
                        if (rbData) {
                            processAllData();
                        } else {
                            setTimeout(() => {
                                document.getElementById('rb-file-input').click();
                            }, 300);
                        }
                    }
                });
            }
        }

        function handleRBUpload(event) {
            const file = event.target.files[0];
            if (file) {
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        rbData = results.data.filter(row => row.Player && row.Week);
                        localStorage.setItem('rbData', JSON.stringify(rbData));
                        processAllData();
                    }
                });
            }
        }

        // ============================================
        // 2. CALCULATIONS
        // ============================================

        function processAllData() {
            if (wrData) {
                aggregatedWRs = aggregatePlayerData(wrData, 'WR');
                // New: Calculate evaluation metrics for WRs
                evaluationDataWR = calculateWREvaluationMetrics(wrData);
            }
            if (rbData) {
                aggregatedRBs = aggregatePlayerData(rbData, 'RB');
                // New: Calculate evaluation metrics for RBs
                evaluationDataRB = calculateRBEvaluationMetrics(rbData);
            }
            if (teData) {
                aggregatedTEs = aggregatePlayerData(teData, 'TE');
            }
            
            // v7: Calculate 4-week rolling segment averages
            if (Object.keys(evaluationDataWR).length > 0) {
                segmentDataWR = calculateSegmentAverages(evaluationDataWR, 4);
                console.log('✅ WR Segment data calculated:', Object.keys(segmentDataWR).length, 'segments');
            }
            if (Object.keys(evaluationDataRB).length > 0) {
                segmentDataRB = calculateSegmentAverages(evaluationDataRB, 4);
                console.log('✅ RB Segment data calculated:', Object.keys(segmentDataRB).length, 'segments');
            }
            
            // Combine all players
            allPlayers = { ...aggregatedWRs, ...aggregatedRBs, ...aggregatedTEs };
            
            // Add dummy voting data for top 10 WRs and RBs (10k total votes, lean towards buy)
            // Get top 10 WRs by average points
            const sortedWRs = Object.values(aggregatedWRs)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 10);
            
            sortedWRs.forEach((player, idx) => {
                // Generate voting data: 10k total, lean heavily towards buy (60-75%)
                const buyPercent = 0.60 + Math.random() * 0.15; // 60-75%
                const sellPercent = 0.10 + Math.random() * 0.10; // 10-20%
                const holdPercent = 1 - buyPercent - sellPercent; // Remainder
                
                const totalVotes = 10000;
                player.voting = {
                    buy: Math.floor(totalVotes * buyPercent),
                    hold: Math.floor(totalVotes * holdPercent),
                    sell: Math.floor(totalVotes * sellPercent)
                };
            });
            
            // Get top 10 RBs by average points
            const sortedRBs = Object.values(aggregatedRBs)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 10);
            
            sortedRBs.forEach((player, idx) => {
                // Generate voting data: 10k total, lean heavily towards buy (60-75%)
                const buyPercent = 0.60 + Math.random() * 0.15; // 60-75%
                const sellPercent = 0.10 + Math.random() * 0.10; // 10-20%
                const holdPercent = 1 - buyPercent - sellPercent; // Remainder
                
                const totalVotes = 10000;
                player.voting = {
                    buy: Math.floor(totalVotes * buyPercent),
                    hold: Math.floor(totalVotes * holdPercent),
                    sell: Math.floor(totalVotes * sellPercent)
                };
            });
            
            // Calculate ROS ranks
            calculateROSRanks();
            
            // Calculate momentum scores
            calculateAllMomentum();
            
            // Render all pages
            renderAllPages();
            
            // Update last updated date
            setLastUpdatedDate();
        }

        function aggregatePlayerData(weeklyData, position) {
            const players = {};
            
            // Helper function to calculate adjusted fantasy points based on scoring format
            const getAdjustedFantasyPoints = (pprPoints, receptions) => {
                if (currentScoringFormat === 'std') {
                    // Standard: Remove all reception points
                    return pprPoints - receptions;
                } else if (currentScoringFormat === 'half') {
                    // Half-PPR: Remove half of reception points
                    return pprPoints - (0.5 * receptions);
                } else {
                    // PPR: Use points as-is
                    return pprPoints;
                }
            };
            
            weeklyData.forEach(row => {
                if (!row.Player || !row.Week) return;
                
                const id = `${row.Team}-${row.Player}`;
                
                if (!players[id]) {
                    players[id] = {
                        id: id,
                        name: row.Player,
                        team: row.Team,
                        position: position,
                        weeks: [],
                        totalPoints: 0,
                        gamesPlayed: 0,
                        totalTargets: 0,
                        totalOpportunities: 0,
                        rzOpportunities: 0,
                        avgPoints: 0,
                        latestWeek: 0,
                        latestWeekPoints: 0,
                        latestWeekOppShare: 0,
                        oppChange: 0,
                        // WR metrics
                        totalRec: 0,
                        totalAir: 0,
                        totalCatchable: 0,
                        totalYDS: 0,
                        totalYAC: 0,
                        catchRate: 0,
                        catchableCatchRate: 0,
                        racr: 0,
                        tgtPerGame: 0,
                        airYardsPerGame: 0,
                        yacPerRec: 0,
                        // TD stats (all positions)
                        totalRecTDs: 0,
                        totalRushTDs: 0,
                        rzTDs: 0,
                        // RB metrics
                        totalCarries: 0,
                        totalRushYards: 0,
                        totalRecYards: 0,
                        totalYBCON: 0,
                        totalYACON: 0
                    };
                }
                
                const weekNum = parseInt(row.Week);
                const fptsPPR = parseFloat(row.FPTS || row.Fpts) || 0; // Base PPR points from CSV
                const receptions = parseFloat(row.REC) || 0; // Get receptions for adjustment
                
                // Calculate adjusted fantasy points based on current scoring format
                const fpts = getAdjustedFantasyPoints(fptsPPR, receptions);
                
                // Get expected fantasy points and variance based on current scoring format
                let expFpts, variance;
                if (currentScoringFormat === 'std') {
                    expFpts = parseFloat(row.Exp_Ft_Points_STD) || 0;
                    variance = parseFloat(row.FPTS_Variance_STD) || 0;
                } else if (currentScoringFormat === 'half') {
                    expFpts = parseFloat(row.Exp_Ft_Points_HALF) || 0;
                    variance = parseFloat(row.FPTS_Variance_HALF) || 0;
                } else { // PPR (default)
                    expFpts = parseFloat(row.Exp_Ft_Points || row.Exp_Ft_Points_PPR) || 0;
                    variance = parseFloat(row.FPTS_Variance || row.FPTS_Variance_PPR) || 0;
                }
                
                const weekData = {
                    week: weekNum,
                    fpts: fpts, // Adjusted fantasy points
                    fptsPPR: fptsPPR, // Store original PPR points for reference
                    receptions: receptions, // Store receptions for future adjustments
                    expectedFpts: expFpts,
                    variance: variance
                };
                
                if (position === 'WR' || position === 'TE') {
                    const tgt = parseFloat(row.TGT) || 0;
                    const rzTgt = parseFloat(row['RZ TGT']) || parseFloat(row.RZ_TGT) || 0;
                    const teamShare = parseFloat(row['% TM']) || 0;
                    const rec = parseFloat(row.REC) || 0;
                    const air = parseFloat(row.AIR) || 0;
                    const catchable = parseFloat(row.CATCHABLE) || 0;
                    // For TEs, yards might be in YDS column instead of REC_YDS
                    const yds = parseFloat(row.REC_YDS) || parseFloat(row.YDS) || 0;
                    const yac = parseFloat(row.YAC) || 0;
                    const recTD = parseFloat(row.REC_TD) || 0;
                    const rushTD = parseFloat(row.RUSH_TD) || 0;
                    // RZ TDs = RZ_REC_TD + RZ_RUSH_TD
                    const rzRecTD = parseFloat(row.RZ_REC_TD) || 0;
                    const rzRushTD = parseFloat(row.RZ_RUSH_TD) || 0;
                    const rzTD = rzRecTD + rzRushTD;
                    const rushYds = parseFloat(row.RUSH_YDS) || 0;
                    const carries = parseFloat(row.CARRIES) || 0;
                    
                    weekData.targets = tgt;
                    weekData.rzTargets = rzTgt;
                    weekData.teamShare = teamShare;
                    
                    players[id].totalTargets += tgt;
                    players[id].rzOpportunities += rzTgt;
                    players[id].totalRec += rec;
                    players[id].totalAir += air;
                    players[id].totalCatchable += catchable;
                    players[id].totalYDS += yds;
                    players[id].totalYAC += yac;
                    players[id].totalRecTDs += recTD;
                    players[id].totalRushTDs += rushTD;
                    players[id].rzTDs += rzTD;
                    players[id].totalRushYards += rushYds;
                    players[id].totalCarries += carries;
                } else {
                    const rbOpp = parseFloat(row['RB Opp']) || 0;
                    const rzRushAtt = parseFloat(row['RZ_RUSH_ATT']) || 0;
                    const rzTgt = parseFloat(row['RZ TGT']) || parseFloat(row['RZ_TGT']) || 0;
                    const rushAtt = parseFloat(row.ATT) || 0;
                    const tgt = parseFloat(row.TGT) || 0;
                    const rushYds = parseFloat(row.YDS) || 0;
                    const recYds = parseFloat(row.REC_YDS) || 0;
                    const ybcon = parseFloat(row.YBCON) || 0;
                    const yacon = parseFloat(row.YACON) || 0;
                    const rec = parseFloat(row.REC) || 0;
                    const recTD = parseFloat(row.REC_TD) || 0;
                    const rushTD = parseFloat(row.RUSH_TD) || 0;
                    // RZ TDs = RZ_REC_TD + RZ_RUSH_TD
                    const rzRecTD = parseFloat(row.RZ_REC_TD) || 0;
                    const rzRushTD = parseFloat(row.RZ_RUSH_TD) || 0;
                    const rzTD = rzRecTD + rzRushTD;
                    
                    weekData.opportunities = rbOpp;
                    weekData.rzOpportunities = rzRushAtt + rzTgt; // Include both RZ rush attempts and RZ targets
                    weekData.rushAttempts = rushAtt;
                    weekData.targets = tgt;
                    
                    players[id].totalOpportunities += rbOpp;
                    players[id].rzOpportunities += (rzRushAtt + rzTgt); // Include both RZ rush attempts and RZ targets
                    players[id].totalCarries += rushAtt;
                    players[id].totalTargets += tgt;
                    players[id].totalRushYards += rushYds;
                    players[id].totalRecYards += recYds;
                    players[id].totalYBCON += ybcon;
                    players[id].totalYACON += yacon;
                    players[id].totalRec += rec;
                    players[id].totalRecTDs += recTD;
                    players[id].totalRushTDs += rushTD;
                    players[id].rzTDs += rzTD;
                }
                
                players[id].weeks.push(weekData);
                players[id].totalPoints += fpts;
                players[id].gamesPlayed++;
                
                if (weekNum > players[id].latestWeek) {
                    players[id].latestWeek = weekNum;
                    players[id].latestWeekPoints = fpts;
                    if (position === 'WR') {
                        players[id].latestWeekOppShare = parseFloat(row['% TM']) || 0;
                    }
                }
            });
            
            // Calculate averages and opportunity shares for RBs
            Object.values(players).forEach(player => {
                player.avgPoints = player.gamesPlayed > 0 ? player.totalPoints / player.gamesPlayed : 0;
                
                // Calculate percentage over expected
                const totalExpected = player.weeks.reduce((sum, w) => sum + w.expectedFpts, 0);
                player.pctOverExpected = totalExpected > 0 ? ((player.totalPoints - totalExpected) / totalExpected) * 100 : 0;
                
                // Calculate new WR/TE metrics
                if ((position === 'WR' || position === 'TE') && player.gamesPlayed >= 3) {
                    player.catchRate = player.totalTargets > 0 ? (player.totalRec / player.totalTargets) * 100 : 0;
                    player.catchableCatchRate = player.totalCatchable > 0 ? (player.totalRec / player.totalCatchable) * 100 : 0;
                    player.racr = player.totalAir > 0 ? (player.totalYDS / player.totalAir) * 100 : 0;
                    player.tgtPerGame = player.gamesPlayed > 0 ? player.totalTargets / player.gamesPlayed : 0;
                    player.airYardsPerGame = player.gamesPlayed > 0 ? player.totalAir / player.gamesPlayed : 0;
                    player.yacPerRec = player.totalRec > 0 ? player.totalYAC / player.totalRec : 0;
                }
                
                // Sort weeks by week number
                player.weeks.sort((a, b) => a.week - b.week);
                
                if (position === 'RB') {
                    // Calculate RB opportunity share for latest week
                    player.latestWeekOppShare = calculateRBTeamShare(player, weeklyData);
                }
                
                // Calculate opportunity change
                player.oppChange = calculateOppChange(player);
            });
            
            return players;
        }

        function calculateRBTeamShare(player, weeklyData) {
            if (player.weeks.length === 0) return 0;
            
            const latestWeek = player.latestWeek;
            const teamData = weeklyData.filter(row => 
                row.Team === player.team && 
                parseInt(row.Week) === latestWeek &&
                row.Player &&
                parseFloat(row['RB Opp']) > 0
            );
            
            const teamTotal = teamData.reduce((sum, row) => sum + (parseFloat(row['RB Opp']) || 0), 0);
            const playerOpp = teamData.find(row => row.Player === player.name);
            const playerTotal = playerOpp ? parseFloat(playerOpp['RB Opp']) || 0 : 0;
            
            return teamTotal > 0 ? (playerTotal / teamTotal) * 100 : 0;
        }

        function calculateOppChange(player) {
            if (player.weeks.length < 2) return 0;
            
            const lastWeek = player.weeks[player.weeks.length - 1];
            const prevWeek = player.weeks[player.weeks.length - 2];
            
            let lastShare = 0;
            let prevShare = 0;
            
            if (player.position === 'WR') {
                lastShare = lastWeek.teamShare || 0;
                prevShare = prevWeek.teamShare || 0;
            } else {
                // For RB, we'd need to calculate team share, simplified here
                lastShare = player.latestWeekOppShare;
                // Approximate previous week share
                prevShare = lastShare;
            }
            
            return lastShare - prevShare;
        }

        function calculateROSRanks() {
            const allPlayersList = Object.values(allPlayers);
            allPlayersList.sort((a, b) => b.avgPoints - a.avgPoints);
            
            allPlayersList.forEach((player, index) => {
                player.rosRank = index + 1;
            });
        }

        // Calculate momentum scores for all players
        function calculateMomentum(player, position) {
            // Need at least 4 weeks of data
            if (!player.weeks || player.weeks.length < 4) {
                return {
                    score: 0,
                    isValid: false,
                    direction: 'neutral'
                };
            }
            
            const sortedWeeks = [...player.weeks].sort((a, b) => a.week - b.week);
            const totalWeeks = sortedWeeks.length;
            
            // Get last 3 weeks and previous 3 weeks
            const currentWindow = sortedWeeks.slice(-3);
            const previousWindow = sortedWeeks.slice(-6, -3);
            
            // Need both windows to have data
            if (currentWindow.length < 3 || previousWindow.length < 3) {
                return {
                    score: 0,
                    isValid: false,
                    direction: 'neutral'
                };
            }
            
            // Helper function to calculate average
            const avg = (arr, key) => {
                const sum = arr.reduce((s, w) => s + (w[key] || 0), 0);
                return sum / arr.length;
            };
            
            // Helper function to calculate % change
            const pctChange = (current, previous) => {
                if (previous === 0) return current > 0 ? 100 : 0;
                return ((current - previous) / previous) * 100;
            };
            
            let momentum = 0;
            
            if (position === 'WR') {
                // WR Momentum = 0.5 * ΔTargets% + 0.3 * ΔReceptions% + 0.2 * ΔFantasyPoints%
                const currentTargets = avg(currentWindow, 'targets');
                const previousTargets = avg(previousWindow, 'targets');
                const targetsChange = pctChange(currentTargets, previousTargets);
                
                const currentReceptions = avg(currentWindow, 'receptions');
                const previousReceptions = avg(previousWindow, 'receptions');
                const receptionsChange = pctChange(currentReceptions, previousReceptions);
                
                const currentPoints = avg(currentWindow, 'fpts');
                const previousPoints = avg(previousWindow, 'fpts');
                const pointsChange = pctChange(currentPoints, previousPoints);
                
                momentum = (0.5 * targetsChange) + (0.3 * receptionsChange) + (0.2 * pointsChange);
                
            } else if (position === 'RB') {
                // RB Momentum = 0.5 * ΔRushAttempts% + 0.4 * ΔRushYards% + 0.1 * ΔFantasyPoints%
                const currentRushAttempts = avg(currentWindow, 'rushAttempts');
                const previousRushAttempts = avg(previousWindow, 'rushAttempts');
                const rushAttemptsChange = pctChange(currentRushAttempts, previousRushAttempts);
                
                const currentRushYards = currentWindow.reduce((sum, w) => {
                    // Rush yards might be stored differently, need to check
                    return sum + (w.rushYards || 0);
                }, 0) / currentWindow.length;
                
                const previousRushYards = previousWindow.reduce((sum, w) => {
                    return sum + (w.rushYards || 0);
                }, 0) / previousWindow.length;
                
                const rushYardsChange = pctChange(currentRushYards, previousRushYards);
                
                const currentPoints = avg(currentWindow, 'fpts');
                const previousPoints = avg(previousWindow, 'fpts');
                const pointsChange = pctChange(currentPoints, previousPoints);
                
                momentum = (0.5 * rushAttemptsChange) + (0.4 * rushYardsChange) + (0.1 * pointsChange);
            }
            
            // Determine direction
            let direction = 'neutral';
            if (momentum > 5) {
                direction = 'up';
            } else if (momentum < -5) {
                direction = 'down';
            }
            
            return {
                score: momentum,
                isValid: true,
                direction: direction
            };
        }

        // Calculate momentum for all players
        function calculateAllMomentum() {
            console.log('📈 Calculating momentum scores...');
            
            // WRs
            Object.values(aggregatedWRs).forEach(player => {
                const momentum = calculateMomentum(player, 'WR');
                player.momentum = momentum;
            });
            
            // RBs
            Object.values(aggregatedRBs).forEach(player => {
                const momentum = calculateMomentum(player, 'RB');
                player.momentum = momentum;
            });
            
            // TEs (use WR momentum calculation since they're pass catchers)
            Object.values(aggregatedTEs).forEach(player => {
                const momentum = calculateMomentum(player, 'WR');
                player.momentum = momentum;
            });
            
            console.log('✅ Momentum scores calculated');
        }

        // Get top movers (risers and fallers) for a position
        function getTopMovers(position, count = 5) {
            const players = position === 'WR' ? Object.values(aggregatedWRs) : 
                           position === 'RB' ? Object.values(aggregatedRBs) :
                           Object.values(aggregatedTEs);
            
            // Filter for players with valid momentum and enough games
            const validPlayers = players.filter(p => 
                p.momentum && 
                p.momentum.isValid && 
                p.gamesPlayed >= 6 // Need at least 6 weeks for momentum calculation
            );
            
            // Sort by momentum score
            const sorted = [...validPlayers].sort((a, b) => b.momentum.score - a.momentum.score);
            
            // Get top risers (highest positive momentum)
            const risers = sorted.filter(p => p.momentum.score > 0).slice(0, count);
            
            // Get top fallers (most negative momentum)
            const fallers = sorted.filter(p => p.momentum.score < 0).reverse().slice(0, count);
            
            return { risers, fallers };
        }

        // Render top movers widgets for a position
        function renderTopMoversWidgets(position, containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            const { risers, fallers } = getTopMovers(position, 8);
            
            let html = '<div class="top-movers-container">';
            
            // Risers widget
            if (risers.length > 0) {
                html += `
                    <div class="top-movers-widget risers">
                        <div class="top-movers-header">
                            <span class="top-movers-title">Top Movers Up</span>
                        </div>
                        <div class="top-movers-list">
                `;
                
                risers.forEach((player, index) => {
                    const escapedId = player.id.replace(/'/g, "\\'");
                    html += `
                        <div class="top-mover-item" onclick="openPlayerModal('${escapedId}')">
                            <div class="top-mover-rank">${index + 1}</div>
                            <div class="top-mover-arrow">↑</div>
                            <div class="top-mover-info">
                                <div class="top-mover-name">${player.name}</div>
                                <div class="top-mover-team">${player.team}</div>
                            </div>
                            <div class="top-mover-score">+${player.momentum.score.toFixed(1)}%</div>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
            }
            
            // Fallers widget
            if (fallers.length > 0) {
                html += `
                    <div class="top-movers-widget fallers">
                        <div class="top-movers-header">
                            <span class="top-movers-title">Top Movers Down</span>
                        </div>
                        <div class="top-movers-list">
                `;
                
                fallers.forEach((player, index) => {
                    const escapedId = player.id.replace(/'/g, "\\'");
                    html += `
                        <div class="top-mover-item" onclick="openPlayerModal('${escapedId}')">
                            <div class="top-mover-rank">${index + 1}</div>
                            <div class="top-mover-arrow">↓</div>
                            <div class="top-mover-info">
                                <div class="top-mover-name">${player.name}</div>
                                <div class="top-mover-team">${player.team}</div>
                            </div>
                            <div class="top-mover-score">${player.momentum.score.toFixed(1)}%</div>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
            }
            
            html += '</div>';
            container.innerHTML = html;
        }

        // ============================================
        // 3. UI RENDERING
        // ============================================

        // Render mini sparkline chart
        function renderMiniChart(canvasId, player) {
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;
            
            const actuals = player.weeks.map(w => w.fpts);
            const expected = player.weeks.map(w => w.expectedFpts);
            
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: player.weeks.map(w => w.week),
                    datasets: [
                        {
                            data: actuals,
                            borderColor: '#30d158',
                            borderWidth: 2.5, // Thicker trail for better visibility
                            fill: false,
                            pointRadius: 0,
                            tension: 0.3
                        },
                        {
                            data: expected,
                            borderColor: '#8e8e93',
                            borderWidth: 1,
                            borderDash: [2, 2],
                            fill: false,
                            pointRadius: 0,
                            tension: 0.3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    },
                    scales: {
                        x: { display: false },
                        y: { display: false }
                    },
                    interaction: { mode: null }
                }
            });
        }

        function renderAllPages() {
            renderTicker();
            renderTeamsTicker();
            renderInsightsTicker();
            renderWRPlayerCards();
            renderRBPlayerCards();
            renderTEPlayerCards();
            renderTeamsPage();
            renderScatterPlots();
            
            // Render top movers widgets
            renderTopMoversWidgets('WR', 'wr-top-movers-sidebar');
            renderTopMoversWidgets('RB', 'rb-top-movers-sidebar');
            renderTopMoversWidgets('TE', 'te-top-movers-sidebar');
            
            // Setup dashboard trend scrubbers
            setupDashboardTrendScrubbers();
            
            // Initialize Advanced Analytics
            initializeAdvancedAnalytics();
            
            // Note: Trend animations for WR/RB eval charts are lazy loaded when user clicks Advanced Analytics tab
        }

        function renderTicker() {
            // WR Ticker - by avg points
            const wrTickerTrack = document.getElementById('wr-ticker-track');
            const topWRs = Object.values(aggregatedWRs)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 50);
            
            const wrTickerHTML = topWRs.map((player, index) => {
                // Calculate week-over-week team share change
                let shareChange = 0;
                if (player.weeks.length >= 2) {
                    // Get last two weeks where player had targets
                    const weeksWithTargets = player.weeks.filter(w => w.teamShare && w.teamShare > 0);
                    if (weeksWithTargets.length >= 2) {
                        const latestWeek = weeksWithTargets[weeksWithTargets.length - 1];
                        const previousWeek = weeksWithTargets[weeksWithTargets.length - 2];
                        shareChange = latestWeek.teamShare - previousWeek.teamShare;
                    }
                }
                
                const changeClass = shareChange >= 0 ? 'positive' : 'negative';
                const changeSymbol = shareChange >= 0 ? '▲' : '▼';
                const changePct = Math.abs(shareChange).toFixed(1);
                const rank = index + 1;
                
                return `
                    <div class="ticker-item">
                        <span class="player-name">#${rank} ${player.name}</span>
                        <span class="avg-pts">${player.avgPoints.toFixed(1)}</span>
                        <span class="change ${changeClass}">${changeSymbol} ${changePct}% tgt share</span>
                    </div>
                `;
            }).join('');
            
            wrTickerTrack.innerHTML = wrTickerHTML + wrTickerHTML;
            
            // RB Ticker - by avg points
            const rbTickerTrack = document.getElementById('rb-ticker-track');
            const topRBs = Object.values(aggregatedRBs)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 50);
            
            const rbTickerHTML = topRBs.map((player, index) => {
                // Calculate week-over-week RB opp share change
                let shareChange = 0;
                if (player.weeks.length >= 2) {
                    // Get last two weeks with opportunities
                    const weeksWithOpps = player.weeks.filter(w => w.opportunities && w.opportunities > 0);
                    if (weeksWithOpps.length >= 2) {
                        // Calculate share for each week
                        const latestWeek = weeksWithOpps[weeksWithOpps.length - 1];
                        const previousWeek = weeksWithOpps[weeksWithOpps.length - 2];
                        
                        // Get team totals for those weeks
                        const latestTeamRows = rbData.filter(row => 
                            row.Team === player.team && 
                            parseInt(row.Week) === latestWeek.week &&
                            parseFloat(row['RB Opp']) > 0
                        );
                        const prevTeamRows = rbData.filter(row => 
                            row.Team === player.team && 
                            parseInt(row.Week) === previousWeek.week &&
                            parseFloat(row['RB Opp']) > 0
                        );
                        
                        const latestTeamTotal = latestTeamRows.reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);
                        const prevTeamTotal = prevTeamRows.reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);
                        
                        const latestShare = latestTeamTotal > 0 ? (latestWeek.opportunities / latestTeamTotal) * 100 : 0;
                        const prevShare = prevTeamTotal > 0 ? (previousWeek.opportunities / prevTeamTotal) * 100 : 0;
                        
                        shareChange = latestShare - prevShare;
                    }
                }
                
                const changeClass = shareChange >= 0 ? 'positive' : 'negative';
                const changeSymbol = shareChange >= 0 ? '▲' : '▼';
                const changePct = Math.abs(shareChange).toFixed(1);
                const rank = index + 1;
                
                return `
                    <div class="ticker-item">
                        <span class="player-name">#${rank} ${player.name}</span>
                        <span class="avg-pts">${player.avgPoints.toFixed(1)}</span>
                        <span class="change ${changeClass}">${changeSymbol} ${changePct}% touch share</span>
                    </div>
                `;
            }).join('');
            
            rbTickerTrack.innerHTML = rbTickerHTML + rbTickerHTML;
            
            // TE Ticker - by avg points (top 24)
            const teTickerTrack = document.getElementById('te-ticker-track');
            const topTEs = Object.values(aggregatedTEs)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 24);
            
            const teTickerHTML = topTEs.map((player, index) => {
                // Calculate week-over-week target share change (like WRs)
                let shareChange = 0;
                if (player.weeks.length >= 2) {
                    // Get last two weeks where player had targets
                    const weeksWithTargets = player.weeks.filter(w => w.teamShare && w.teamShare > 0);
                    if (weeksWithTargets.length >= 2) {
                        const latestWeek = weeksWithTargets[weeksWithTargets.length - 1];
                        const previousWeek = weeksWithTargets[weeksWithTargets.length - 2];
                        shareChange = latestWeek.teamShare - previousWeek.teamShare;
                    }
                }
                
                const changeClass = shareChange >= 0 ? 'positive' : 'negative';
                const changeSymbol = shareChange >= 0 ? '▲' : '▼';
                const changePct = Math.abs(shareChange).toFixed(1);
                const rank = index + 1;
                
                return `
                    <div class="ticker-item">
                        <span class="player-name">#${rank} ${player.name}</span>
                        <span class="avg-pts">${player.avgPoints.toFixed(1)}</span>
                        <span class="change ${changeClass}">${changeSymbol} ${changePct}% tgt share</span>
                    </div>
                `;
            }).join('');
            
            teTickerTrack.innerHTML = teTickerHTML + teTickerHTML;
        }
        
        function renderTeamsTicker() {
            const teamsTickerTrack = document.getElementById('teams-ticker-track');
            if (!teamsTickerTrack) {
                console.log('Teams ticker: element not found');
                return;
            }
            if (!wrData || !rbData) {
                console.log('Teams ticker: wrData or rbData is null');
                console.log('wrData:', wrData ? 'exists' : 'null');
                console.log('rbData:', rbData ? 'exists' : 'null');
                return;
            }
            
            console.log('Teams ticker: Starting render...');
            console.log('WR Data sample:', wrData.slice(0, 2));
            console.log('RB Data sample:', rbData.slice(0, 2));
            
            // Get the latest week from the data
            const allWeeks = [...new Set(wrData.map(row => parseInt(row.Week)))];
            const latestWeek = Math.max(...allWeeks);
            const previousWeek = latestWeek - 1;
            
            console.log('Teams ticker: Latest week:', latestWeek, 'Previous week:', previousWeek);
            console.log('Teams ticker: All weeks in data:', allWeeks.sort((a,b) => a-b));
            
            // Aggregate team data by week
            const teamWeeklyData = {};
            
            // Process WR data
            wrData.forEach(row => {
                const team = row.Team;
                const week = parseInt(row.Week);
                const points = parseFloat(row.FPTS || row.Fpts) || 0; // Handle both FPTS and Fpts
                
                if (team === 'FA' || !team) return;
                
                if (!teamWeeklyData[team]) {
                    teamWeeklyData[team] = { 
                        team: team,
                        weeks: {}
                    };
                }
                
                if (!teamWeeklyData[team].weeks[week]) {
                    teamWeeklyData[team].weeks[week] = { wrPoints: 0, rbPoints: 0, totalPoints: 0 };
                }
                
                teamWeeklyData[team].weeks[week].wrPoints += points;
                teamWeeklyData[team].weeks[week].totalPoints += points;
            });
            
            console.log('After WR processing, sample team:', Object.keys(teamWeeklyData)[0], teamWeeklyData[Object.keys(teamWeeklyData)[0]]);
            
            // Process RB data
            rbData.forEach(row => {
                const team = row.Team;
                const week = parseInt(row.Week);
                const points = parseFloat(row.FPTS || row.Fpts) || 0; // Handle both FPTS and Fpts
                
                if (team === 'FA' || !team) return;
                
                if (!teamWeeklyData[team]) {
                    teamWeeklyData[team] = { 
                        team: team,
                        weeks: {}
                    };
                }
                
                if (!teamWeeklyData[team].weeks[week]) {
                    teamWeeklyData[team].weeks[week] = { wrPoints: 0, rbPoints: 0, totalPoints: 0 };
                }
                
                teamWeeklyData[team].weeks[week].rbPoints += points;
                teamWeeklyData[team].weeks[week].totalPoints += points;
            });
            
            console.log('After RB processing, sample team:', Object.keys(teamWeeklyData)[0], teamWeeklyData[Object.keys(teamWeeklyData)[0]]);
            
            // Calculate totals and changes for latest week
            const teamsData = Object.values(teamWeeklyData).map(teamData => {
                const latestWeekData = teamData.weeks[latestWeek] || { wrPoints: 0, rbPoints: 0, totalPoints: 0 };
                const previousWeekData = teamData.weeks[previousWeek] || { wrPoints: 0, rbPoints: 0, totalPoints: 0 };
                
                // Calculate percentage change
                let percentChange = 0;
                if (previousWeekData.totalPoints > 0) {
                    percentChange = ((latestWeekData.totalPoints - previousWeekData.totalPoints) / previousWeekData.totalPoints) * 100;
                } else if (latestWeekData.totalPoints > 0) {
                    percentChange = 100; // If no previous week data but has current, show +100%
                }
                
                return {
                    team: teamData.team,
                    wrPoints: latestWeekData.wrPoints,
                    rbPoints: latestWeekData.rbPoints,
                    totalPoints: latestWeekData.totalPoints,
                    percentChange: percentChange,
                    previousTotal: previousWeekData.totalPoints
                };
            });
            
            console.log('Teams ticker - Final data count:', teamsData.length);
            console.log('Teams ticker - Top 3 teams:', teamsData.sort((a, b) => b.totalPoints - a.totalPoints).slice(0, 3));
            
            // Sort by total points for latest week
            const topTeams = teamsData
                .sort((a, b) => b.totalPoints - a.totalPoints)
                .slice(0, 32); // All teams
            
            const teamsTickerHTML = topTeams.map((team, index) => {
                const rank = index + 1;
                const teamColor = teamColors[team.team] || '#0a84ff';
                const changeClass = team.percentChange >= 0 ? 'positive' : 'negative';
                const changeSymbol = team.percentChange >= 0 ? '▲' : '▼';
                
                return `
                    <div class="ticker-item">
                        <span style="font-weight: 700; color: ${teamColor};">#${rank}</span>
                        <span class="player-name">${team.team}</span>
                        <span class="avg-pts">${team.totalPoints.toFixed(1)} pts</span>
                        <span style="color: var(--text-secondary); font-size: 11px;">
                            WR: ${team.wrPoints.toFixed(0)} | RB: ${team.rbPoints.toFixed(0)}
                        </span>
                        <span class="change ${changeClass}">${changeSymbol} ${Math.abs(team.percentChange).toFixed(1)}%</span>
                    </div>
                `;
            }).join('');
            
            teamsTickerTrack.innerHTML = teamsTickerHTML + teamsTickerHTML;
        }
        
        function renderInsightsTicker() {
            const insightsTickerTrack = document.getElementById('insights-ticker-track');
            if (!insightsTickerTrack) return;
            
            // Find the global maximum week across ALL players (current week of season)
            let globalMaxWeek = 0;
            Object.values(aggregatedWRs).forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });
            Object.values(aggregatedRBs).forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });
            
            if (globalMaxWeek === 0) return;
            
            // The last 3 weeks and prior 3 weeks
            const last3ActualWeeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
            const prior3ActualWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];
            
            // Get all players with opportunity share changes AND record scores in last 2/3 games
            const allMovers = [];
            
            // Add WRs
            Object.values(aggregatedWRs).forEach(player => {
                if (!player.weeks || player.weeks.length === 0) return;
                
                // Filter to only games within the last 3 actual weeks where player had fantasy points
                const last3WeeksGames = player.weeks.filter(w => 
                    last3ActualWeeks.includes(w.week) && w.fpts > 0
                );
                
                // Player must have played at least 2 of the last 3 weeks
                if (last3WeeksGames.length < 2) return;
                
                // Check for record scores: Count how many of last 3 games are in player's top 2 scores
                const allGameScores = player.weeks.map(w => w.fpts).sort((a, b) => b - a);
                const top2Scores = allGameScores.slice(0, 2);
                const recordGamesInLast3 = last3WeeksGames.filter(w => 
                    top2Scores.includes(w.fpts)
                ).length;
                
                // Only include if player had record scores in at least 2 of last 3 games
                if (recordGamesInLast3 < 2) return;
                
                // Calculate average target share for last 3 weeks
                const last3Shares = player.weeks
                    .filter(w => last3ActualWeeks.includes(w.week) && w.teamShare && w.teamShare > 0)
                    .map(w => w.teamShare);
                
                // Calculate average target share for prior 3 weeks
                const prior3Shares = player.weeks
                    .filter(w => prior3ActualWeeks.includes(w.week) && w.teamShare && w.teamShare > 0)
                    .map(w => w.teamShare);
                
                // Need at least some data from both periods
                if (last3Shares.length === 0) return;
                
                const avgLast3 = last3Shares.reduce((sum, s) => sum + s, 0) / last3Shares.length;
                const avgPrior3 = prior3Shares.length > 0 
                    ? prior3Shares.reduce((sum, s) => sum + s, 0) / prior3Shares.length 
                    : 0;
                
                const shareChange = avgLast3 - avgPrior3;
                
                allMovers.push({
                    name: player.name,
                    team: player.team,
                    position: 'WR',
                    shareChange: shareChange,
                    avgPoints: player.avgPoints
                });
            });
            
            // Add RBs
            Object.values(aggregatedRBs).forEach(player => {
                if (!player.weeks || player.weeks.length === 0) return;
                
                // Filter to only games within the last 3 actual weeks where player had fantasy points
                const last3WeeksGames = player.weeks.filter(w => 
                    last3ActualWeeks.includes(w.week) && w.fpts > 0
                );
                
                // Player must have played at least 2 of the last 3 weeks
                if (last3WeeksGames.length < 2) return;
                
                // Check for record scores: Count how many of last 3 games are in player's top 2 scores
                const allGameScores = player.weeks.map(w => w.fpts).sort((a, b) => b - a);
                const top2Scores = allGameScores.slice(0, 2);
                const recordGamesInLast3 = last3WeeksGames.filter(w => 
                    top2Scores.includes(w.fpts)
                ).length;
                
                // Only include if player had record scores in at least 2 of last 3 games
                if (recordGamesInLast3 < 2) return;
                
                // Calculate average opportunity share for last 3 weeks
                const last3Shares = [];
                last3ActualWeeks.forEach(weekNum => {
                    const weekData = player.weeks.find(w => w.week === weekNum);
                    if (weekData && weekData.opportunities > 0) {
                        // Get team total for this week
                        const teamRows = rbData.filter(row => 
                            row.Team === player.team && 
                            parseInt(row.Week) === weekNum &&
                            parseFloat(row['RB Opp']) > 0
                        );
                        const teamTotal = teamRows.reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);
                        if (teamTotal > 0) {
                            const share = (weekData.opportunities / teamTotal) * 100;
                            last3Shares.push(share);
                        }
                    }
                });
                
                // Calculate average opportunity share for prior 3 weeks
                const prior3Shares = [];
                prior3ActualWeeks.forEach(weekNum => {
                    const weekData = player.weeks.find(w => w.week === weekNum);
                    if (weekData && weekData.opportunities > 0) {
                        // Get team total for this week
                        const teamRows = rbData.filter(row => 
                            row.Team === player.team && 
                            parseInt(row.Week) === weekNum &&
                            parseFloat(row['RB Opp']) > 0
                        );
                        const teamTotal = teamRows.reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);
                        if (teamTotal > 0) {
                            const share = (weekData.opportunities / teamTotal) * 100;
                            prior3Shares.push(share);
                        }
                    }
                });
                
                // Need at least some data from last 3 weeks
                if (last3Shares.length === 0) return;
                
                const avgLast3 = last3Shares.reduce((sum, s) => sum + s, 0) / last3Shares.length;
                const avgPrior3 = prior3Shares.length > 0 
                    ? prior3Shares.reduce((sum, s) => sum + s, 0) / prior3Shares.length 
                    : 0;
                
                const shareChange = avgLast3 - avgPrior3;
                
                allMovers.push({
                    name: player.name,
                    team: player.team,
                    position: 'RB',
                    shareChange: shareChange,
                    avgPoints: player.avgPoints
                });
            });
            
            // Sort by absolute value of share change and take top 40
            const topMovers = allMovers
                .sort((a, b) => Math.abs(b.shareChange) - Math.abs(a.shareChange))
                .slice(0, 40);
            
            const insightsTickerHTML = topMovers.map((player, index) => {
                const changeClass = player.shareChange >= 0 ? 'positive' : 'negative';
                const changeSymbol = player.shareChange >= 0 ? '▲' : '▼';
                const changePct = Math.abs(player.shareChange).toFixed(1);
                const rank = index + 1;
                
                return `
                    <div class="ticker-item">
                        <span class="player-name">#${rank} ${player.name}</span>
                        <span style="color: var(--text-secondary); font-size: 11px;">${player.position} · ${player.team}</span>
                        <span class="change ${changeClass}">${changeSymbol} ${changePct}%</span>
                        <span class="avg-pts">${player.avgPoints.toFixed(1)} pts</span>
                    </div>
                `;
            }).join('');
            
            insightsTickerTrack.innerHTML = insightsTickerHTML + insightsTickerHTML;
        }
        
        function toggleTicker(position) {
            // WR ticker should always stay expanded
            if (position === 'wr') return;
            
            const content = document.getElementById(`${position}-ticker-content`);
            const toggle = document.getElementById(`${position}-ticker-toggle`);
            const section = document.getElementById(`${position}-ticker-section`);
            
            content.classList.toggle('collapsed');
            toggle.classList.toggle('collapsed');
            section.classList.toggle('collapsed');
            
            // Adjust RB ticker position when WR ticker collapses (no longer needed since WR stays expanded)
        }

        // ============================================
        // TAGGING ENGINE
        // ============================================
        
        function calculatePlayerTags(position) {
            const players = position === 'WR' ? Object.values(aggregatedWRs) : 
                           position === 'RB' ? Object.values(aggregatedRBs) :
                           Object.values(aggregatedTEs);
            const rawData = position === 'WR' ? wrData : 
                           position === 'RB' ? rbData :
                           teData;
            
            // Find global max week
            let globalMaxWeek = 0;
            players.forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });
            
            if (globalMaxWeek < 4) return {}; // Need at least 4 weeks of data
            
            // Define time windows: last 2 weeks vs weeks 3-4 back
            const last2Weeks = [globalMaxWeek, globalMaxWeek - 1];
            const prior2Weeks = [globalMaxWeek - 2, globalMaxWeek - 3];
            
            const tagCandidates = {
                buy_low: [],
                sell_high: [],
                rz_trend_up: []
            };
            
            players.forEach(player => {
                if (!player.weeks || player.weeks.length < 3) return;
                
                // Filter: Only tag players averaging 5+ PPG
                if (player.avgPoints < 5) return;
                
                // Get games from last 2 weeks and prior 2 weeks
                const last2Games = player.weeks.filter(w => last2Weeks.includes(w.week) && w.fpts > 0);
                const prior2Games = player.weeks.filter(w => prior2Weeks.includes(w.week) && w.fpts > 0);
                
                // Need at least 1 game in each period
                if (last2Games.length === 0 || prior2Games.length === 0) return;
                
                // Calculate metrics for both periods
                let last2Efficiency = 0, prior2Efficiency = 0;
                let last2Volume = 0, prior2Volume = 0;
                let last2RzShare = 0, prior2RzShare = 0;
                
                if (position === 'WR' || position === 'TE') {
                    // WR/TE: volume = targets, efficiency = points per target
                    const last2Targets = last2Games.reduce((sum, w) => sum + (w.targets || 0), 0);
                    const last2Points = last2Games.reduce((sum, w) => sum + w.fpts, 0);
                    last2Volume = last2Targets / last2Games.length;
                    last2Efficiency = last2Targets > 0 ? last2Points / last2Targets : 0;
                    
                    const prior2Targets = prior2Games.reduce((sum, w) => sum + (w.targets || 0), 0);
                    const prior2Points = prior2Games.reduce((sum, w) => sum + w.fpts, 0);
                    prior2Volume = prior2Targets / prior2Games.length;
                    prior2Efficiency = prior2Targets > 0 ? prior2Points / prior2Targets : 0;
                    
                    // RZ share calculation for WRs/TEs
                    let last2RzTargets = 0, prior2RzTargets = 0;
                    last2Weeks.forEach(weekNum => {
                        const weekRow = rawData.find(row => 
                            row.Team === player.team && 
                            row.Player === player.name && 
                            parseInt(row.Week) === weekNum
                        );
                        if (weekRow) {
                            last2RzTargets += parseFloat(weekRow.RZTGT) || parseFloat(weekRow['RZ TGT']) || 0;
                        }
                    });
                    prior2Weeks.forEach(weekNum => {
                        const weekRow = rawData.find(row => 
                            row.Team === player.team && 
                            row.Player === player.name && 
                            parseInt(row.Week) === weekNum
                        );
                        if (weekRow) {
                            prior2RzTargets += parseFloat(weekRow.RZTGT) || parseFloat(weekRow['RZ TGT']) || 0;
                        }
                    });
                    
                    last2RzShare = last2RzTargets / last2Games.length;
                    prior2RzShare = prior2RzTargets / prior2Games.length;
                    
                } else {
                    // RB: volume = opportunities, efficiency = points per opportunity
                    const last2Opps = last2Games.reduce((sum, w) => sum + (w.opportunities || 0), 0);
                    const last2Points = last2Games.reduce((sum, w) => sum + w.fpts, 0);
                    last2Volume = last2Opps / last2Games.length;
                    last2Efficiency = last2Opps > 0 ? last2Points / last2Opps : 0;
                    
                    const prior2Opps = prior2Games.reduce((sum, w) => sum + (w.opportunities || 0), 0);
                    const prior2Points = prior2Games.reduce((sum, w) => sum + w.fpts, 0);
                    prior2Volume = prior2Opps / prior2Games.length;
                    prior2Efficiency = prior2Opps > 0 ? prior2Points / prior2Opps : 0;
                    
                    // RZ share calculation for RBs
                    let last2RzOpps = 0, prior2RzOpps = 0;
                    last2Weeks.forEach(weekNum => {
                        const weekRow = rawData.find(row => 
                            row.Team === player.team && 
                            row.Player === player.name && 
                            parseInt(row.Week) === weekNum
                        );
                        if (weekRow) {
                            const rzAtt = parseFloat(weekRow.RZATT) || parseFloat(weekRow['RZ ATT']) || 0;
                            const rzTgt = parseFloat(weekRow.RZTGT) || parseFloat(weekRow['RZ TGT']) || 0;
                            last2RzOpps += rzAtt + rzTgt;
                        }
                    });
                    prior2Weeks.forEach(weekNum => {
                        const weekRow = rawData.find(row => 
                            row.Team === player.team && 
                            row.Player === player.name && 
                            parseInt(row.Week) === weekNum
                        );
                        if (weekRow) {
                            const rzAtt = parseFloat(weekRow.RZATT) || parseFloat(weekRow['RZ ATT']) || 0;
                            const rzTgt = parseFloat(weekRow.RZTGT) || parseFloat(weekRow['RZ TGT']) || 0;
                            prior2RzOpps += rzAtt + rzTgt;
                        }
                    });
                    
                    last2RzShare = last2RzOpps / last2Games.length;
                    prior2RzShare = prior2RzOpps / prior2Games.length;
                }
                
                // Calculate percentage changes
                const efficiencyChange = prior2Efficiency > 0 ? ((last2Efficiency - prior2Efficiency) / prior2Efficiency) * 100 : 0;
                const volumeChange = prior2Volume > 0 ? ((last2Volume - prior2Volume) / prior2Volume) * 100 : 0;
                const rzChange = prior2RzShare > 0 ? ((last2RzShare - prior2RzShare) / prior2RzShare) * 100 : 0;
                
                // Tag logic with 5% threshold
                // BUY LOW: efficiency up 5%+, volume down 5%+
                // But exclude top-tier players (elite performers shouldn't be "buy low")
                const topTierThreshold = position === 'WR' ? 20 : 22; // Elite WR1 / Elite RB1 threshold
                if (efficiencyChange >= 5 && volumeChange <= -5 && player.avgPoints < topTierThreshold) {
                    tagCandidates.buy_low.push({
                        player: player,
                        score: efficiencyChange + Math.abs(volumeChange) // Combined magnitude
                    });
                }
                
                // SELL HIGH: efficiency down 5%+, volume up 5%+
                if (efficiencyChange <= -5 && volumeChange >= 5) {
                    tagCandidates.sell_high.push({
                        player: player,
                        score: Math.abs(efficiencyChange) + volumeChange // Combined magnitude
                    });
                }
                
                // RZ TREND UP: red zone share up 5%+
                if (rzChange >= 5) {
                    tagCandidates.rz_trend_up.push({
                        player: player,
                        score: rzChange
                    });
                }
            });
            
            // Get top 4 for each tag type
            const tags = {};
            
            tagCandidates.buy_low.sort((a, b) => b.score - a.score).slice(0, 4).forEach(item => {
                tags[item.player.id] = tags[item.player.id] || [];
                tags[item.player.id].push('buy_low');
            });
            
            tagCandidates.sell_high.sort((a, b) => b.score - a.score).slice(0, 4).forEach(item => {
                tags[item.player.id] = tags[item.player.id] || [];
                tags[item.player.id].push('sell_high');
            });
            
            tagCandidates.rz_trend_up.sort((a, b) => b.score - a.score).slice(0, 4).forEach(item => {
                tags[item.player.id] = tags[item.player.id] || [];
                tags[item.player.id].push('rz_trend_up');
            });
            
            return tags;
        }

        function renderWRPlayerCards() {
            const grid = document.getElementById('wr-players-grid');
            let wrs = Object.values(aggregatedWRs).sort((a, b) => b.avgPoints - a.avgPoints);
            
            // Calculate tags for WRs
            const playerTags = calculatePlayerTags('WR');
            
            // FILTER: Remove Malik Nabers and Tyreek Hill
            wrs = wrs.filter(p => !['Malik Nabers', 'Tyreek Hill'].includes(p.name));
            
            // DEMOTE: Players with no stats since Week 4
            wrs = wrs.map(player => {
                if (player.latestWeek && player.latestWeek < 5) {
                    // Apply penalty to move them down tiers (reduce avg points by 50%)
                    return {
                        ...player,
                        avgPoints: player.avgPoints * 0.5,
                        inactive: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);
            
            // DEMOTE: Players with only 1-2 games should max out at WR3/Flex tier
            wrs = wrs.map(player => {
                if (player.gamesPlayed <= 2) {
                    // Cap their avg points at 7.9 (just below Low WR2/Flex threshold of 8)
                    return {
                        ...player,
                        avgPoints: Math.min(player.avgPoints, 7.9),
                        lowSampleSize: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);
            
            // Calculate top 24 averages
            const top24 = wrs.slice(0, 24);
            const top24AvgPoints = top24.reduce((sum, p) => sum + p.avgPoints, 0) / top24.length;
            const top24AvgTargets = top24.reduce((sum, p) => sum + (p.totalTargets / p.gamesPlayed), 0) / top24.length;
            
            // Track ranking for top 50 determination
            let overallRank = 0;
            
            // Define tiers - top two are rank-based (max 4 players each), then point-based
            const tiers = [
                { name: 'Elite WR1', class: 'elite', type: 'rank', maxPlayers: 4, color: '#30d158', showCharts: true },
                { name: 'High-End WR1', class: 'elite', type: 'rank', maxPlayers: 4, color: '#30d158', showCharts: true },
                { name: 'Solid WR1', class: 'elite', type: 'points', min: 17, max: 999, color: '#30d158', showCharts: true }, // Remaining WR1s (17+ ppg)
                { name: 'High Upside WR2', class: 'wr2', type: 'points', min: 14.5, max: 17, color: '#0a84ff', showCharts: true },
                { name: 'Solid WR2', class: 'wr2', type: 'points', min: 12, max: 14.5, color: '#0a84ff', showCharts: true },
                { name: 'Mid WR2', class: 'wr2', type: 'points', min: 10, max: 12, color: '#0a84ff', showCharts: true },
                { name: 'Low WR2/Flex', class: 'flex', type: 'points', min: 8, max: 10, color: '#FFD60A', showCharts: false },
                { name: 'WR3/Flex', class: 'flex', type: 'points', min: 5, max: 8, color: '#FFD60A', showCharts: false },
                { name: 'Depth/Streaming', class: 'depth', type: 'points', min: 0, max: 5, color: '#8e8e93', showCharts: false }
            ];
            
            let html = '';
            let chartIndex = 0;
            let rankIndex = 0; // Track position for rank-based tiers
            
            tiers.forEach(tier => {
                let tierPlayers = [];
                
                if (tier.type === 'rank') {
                    // Rank-based tier: take next N players in order
                    tierPlayers = wrs.slice(rankIndex, rankIndex + tier.maxPlayers);
                    rankIndex += tierPlayers.length;
                } else {
                    // Point-based tier: filter by point threshold from remaining players
                    const remainingPlayers = wrs.slice(rankIndex);
                    tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                    // Update rankIndex to skip these players for next tier
                    rankIndex += tierPlayers.length;
                }
                
                if (tierPlayers.length === 0) return;
                
                html += `
                    <div class="tier-section">
                        <div class="tier-header">
                            <div class="tier-badge ${tier.class}">${tier.name}</div>
                            <div class="tier-count">Avg: ${(tierPlayers.reduce((sum, p) => sum + p.avgPoints, 0) / tierPlayers.length).toFixed(1)} pts/game</div>
                        </div>
                        <div class="cards-grid">
                `;
                
                tierPlayers.forEach(player => {
                    overallRank++;
                    const chartId = `wr-player-chart-${chartIndex++}`;
                    const escapedId = player.id.replace(/'/g, "\\'");
                    const sentiment = getSentimentScore(player.name);
                    const buyPct = sentiment.total > 0 ? (sentiment.buy / sentiment.total * 100) : 0;
                    
                    // Use original avg points for display (not demoted value)
                    const displayAvgPoints = player.inactive ? player.avgPoints * 2 : player.avgPoints;
                    
                    // Calculate comparisons to top 24
                    const targetsPerGame = player.totalTargets / player.gamesPlayed;
                    const pointsDiff = displayAvgPoints - top24AvgPoints;
                    const targetsDiff = targetsPerGame - top24AvgTargets;
                    
                    const pointsClass = pointsDiff >= 0 ? 'comparison-up' : 'comparison-down';
                    const pointsIcon = pointsDiff >= 0 ? '▲' : '▼';
                    const targetsClass = targetsDiff >= 0 ? 'comparison-up' : 'comparison-down';
                    const targetsIcon = targetsDiff >= 0 ? '▲' : '▼';
                    
                    // Include chart based on tier setting
                    const includeChart = tier.showCharts;
                    
                    // Get tags for this player
                    const tags = playerTags[player.id] || [];
                    
                    // Build tags HTML including momentum badge
                    let tagElements = tags.map(tag => {
                        if (tag === 'buy_low') return '<span class="player-tag buy-low" data-tooltip="Efficiency ↑ but Volume ↓ - Undervalued opportunity">Buy Low</span>';
                        if (tag === 'sell_high') return '<span class="player-tag sell-high" data-tooltip="Volume ↑ but Efficiency ↓ - Regression risk">Sell High</span>';
                        if (tag === 'rz_trend_up') return '<span class="player-tag rz-up" data-tooltip="Red Zone opportunities trending up - TD upside">RZ↑</span>';
                        return '';
                    }).filter(t => t);
                    
                    // Add momentum badge to tags if valid
                    if (player.momentum && player.momentum.isValid && player.momentum.direction !== 'neutral') {
                        tagElements.push(`<span class="momentum-badge ${player.momentum.direction}" data-tooltip="Momentum: ${player.momentum.score > 0 ? '+' : ''}${player.momentum.score.toFixed(1)}% (last 3 vs prev 3 weeks)">${player.momentum.direction === 'up' ? '↑' : '↓'}</span>`);
                    }
                    
                    const tagsHTML = tagElements.length > 0 ? `
                        <div class="player-tags">
                            ${tagElements.join('')}
                        </div>
                    ` : '';
                    
                    html += `
                        <div class="player-card" onclick="openPlayerModal('${escapedId}')" ${player.inactive ? 'style="opacity: 0.6; border-left: 3px solid #ff453a;"' : ''}>
                            <div class="player-card-header">
                                <div class="player-card-badge" style="background: ${teamColors[player.team] || '#666'}">${player.team}</div>
                                <div style="flex: 1;">
                                    <div class="player-card-name">
                                        ${player.name}${player.inactive ? ' <span style="color: #ff453a; font-size: 11px;">⚠ INACTIVE</span>' : ''}
                                    </div>
                                    <div class="player-card-team">WR · ${player.team}</div>
                                    ${tagsHTML}
                                </div>
                            </div>
                            <div class="player-card-stats">
                                <div class="player-stat">
                                    <span class="player-stat-label">Avg Points</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="player-stat-value">${displayAvgPoints.toFixed(1)}</span>
                                        <span class="player-comparison ${pointsClass}">
                                            <span class="comparison-icon">${pointsIcon}</span>
                                            ${Math.abs(pointsDiff).toFixed(1)}
                                        </span>
                                        <div class="comparison-tooltip">
                                            <div class="tooltip-label">vs Top 24 WR Avg</div>
                                            <div class="tooltip-data">${displayAvgPoints.toFixed(1)} vs ${top24AvgPoints.toFixed(1)}</div>
                                            <div class="tooltip-data">${pointsDiff >= 0 ? '+' : ''}${pointsDiff.toFixed(1)} pts</div>
                                        </div>
                                    </div>
                                    <div class="stat-tooltip">Average fantasy points per game over ${player.gamesPlayed} games</div>
                                </div>
                                <div class="player-stat">
                                    <span class="player-stat-label">Targets/Game</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="player-stat-value">${targetsPerGame.toFixed(1)}</span>
                                        <span class="player-comparison ${targetsClass}">
                                            <span class="comparison-icon">${targetsIcon}</span>
                                            ${Math.abs(targetsDiff).toFixed(1)}
                                        </span>
                                        <div class="comparison-tooltip">
                                            <div class="tooltip-label">vs Top 24 WR Avg</div>
                                            <div class="tooltip-data">${targetsPerGame.toFixed(1)} vs ${top24AvgTargets.toFixed(1)}</div>
                                            <div class="tooltip-data">${targetsDiff >= 0 ? '+' : ''}${targetsDiff.toFixed(1)} tgt/g</div>
                                        </div>
                                    </div>
                                    <div class="stat-tooltip">Average targets per game (${player.totalTargets} total targets)</div>
                                </div>
                                ${player.voting ? `
                                    <div class="player-stat" style="grid-column: 1 / -1;">
                                        <span class="player-stat-label">Community Sentiment</span>
                                        <div style="margin-top: 4px;">
                                            ${(() => {
                                                const totalVotes = player.voting.buy + player.voting.hold + player.voting.sell;
                                                const buyPct = Math.round((player.voting.buy / totalVotes) * 100);
                                                const holdPct = Math.round((player.voting.hold / totalVotes) * 100);
                                                const sellPct = Math.round((player.voting.sell / totalVotes) * 100);
                                                
                                                // Determine majority
                                                const max = Math.max(buyPct, holdPct, sellPct);
                                                let label, color, bgColor, icon;
                                                if (buyPct === max) {
                                                    label = 'BUY';
                                                    color = 'var(--positive)';
                                                    bgColor = 'rgba(48, 209, 88, 0.15)';
                                                    icon = '▲';
                                                } else if (sellPct === max) {
                                                    label = 'SELL';
                                                    color = 'var(--negative)';
                                                    bgColor = 'rgba(255, 69, 58, 0.15)';
                                                    icon = '▼';
                                                } else {
                                                    label = 'HOLD';
                                                    color = 'var(--text-secondary)';
                                                    bgColor = 'rgba(142, 142, 147, 0.15)';
                                                    icon = '—';
                                                }
                                                
                                                return '<span style="padding: 3px 6px; background: ' + bgColor + '; color: ' + color + '; border-radius: 5px; font-size: 10px; font-weight: 600; display: inline-block;">' + icon + ' ' + max + '% ' + label + '</span>';
                                            })()}
                                        </div>
                                        <div class="stat-tooltip">Community voting: ${player.voting.buy + player.voting.hold + player.voting.sell} total votes</div>
                                    </div>
                                ` : ''}
                            </div>
                            ${includeChart ? `<div class="player-card-chart">
                                <canvas id="${chartId}"></canvas>
                            </div>` : ''}
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            grid.innerHTML = html;
            
            // Render mini charts only for tiers with showCharts: true
            chartIndex = 0;
            rankIndex = 0; // Reset rank index for chart rendering
            
            tiers.forEach(tier => {
                if (!tier.showCharts) {
                    // Skip chart rendering for this tier, but still count the players
                    let tierPlayers = [];
                    if (tier.type === 'rank') {
                        tierPlayers = wrs.slice(rankIndex, rankIndex + tier.maxPlayers);
                        rankIndex += tierPlayers.length;
                    } else {
                        const remainingPlayers = wrs.slice(rankIndex);
                        tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                        rankIndex += tierPlayers.length;
                    }
                    chartIndex += tierPlayers.length;
                    return;
                }
                
                let tierPlayers = [];
                if (tier.type === 'rank') {
                    tierPlayers = wrs.slice(rankIndex, rankIndex + tier.maxPlayers);
                    rankIndex += tierPlayers.length;
                } else {
                    const remainingPlayers = wrs.slice(rankIndex);
                    tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                    rankIndex += tierPlayers.length;
                }
                
                tierPlayers.forEach(player => {
                    renderPlayerCardChart(`wr-player-chart-${chartIndex}`, player, 'WR');
                    chartIndex++;
                });
            });
        }

        function renderRBPlayerCards() {
            const grid = document.getElementById('rb-players-grid');
            let rbs = Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints);
            
            // Calculate tags for RBs
            const playerTags = calculatePlayerTags('RB');
            
            // FILTER: Mark Cam Skattebo as inactive
            rbs = rbs.map(player => {
                if (player.name === 'Cam Skattebo') {
                    return {
                        ...player,
                        latestWeek: 0, // Force inactive status
                        inactive: true
                    };
                }
                return player;
            });
            
            // DEMOTE: Players with no stats since Week 4
            rbs = rbs.map(player => {
                if (player.latestWeek && player.latestWeek < 5) {
                    // Apply penalty to move them down tiers (reduce avg points by 50%)
                    return {
                        ...player,
                        avgPoints: player.avgPoints * 0.5,
                        inactive: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);
            
            // DEMOTE: Players with only 1 game should max out at Deep Flex tier
            rbs = rbs.map(player => {
                if (player.gamesPlayed === 1) {
                    // Cap their avg points at 7.9 (just below RB3/Flex threshold of 8)
                    return {
                        ...player,
                        avgPoints: Math.min(player.avgPoints, 7.9),
                        lowSampleSize: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);
            
            // Calculate top 24 averages
            const top24 = rbs.slice(0, 24);
            const top24AvgPoints = top24.reduce((sum, p) => sum + p.avgPoints, 0) / top24.length;
            const top24AvgOpps = top24.reduce((sum, p) => sum + (p.totalOpportunities / p.gamesPlayed), 0) / top24.length;
            
            // Track ranking for top 50 determination
            let overallRank = 0;
            
            // Define tiers based on avg points thresholds (performance-based)
            const tiers = [
                { name: 'Elite RB1', class: 'elite', min: 22, max: 999, color: '#30d158', showCharts: true },
                { name: 'High-End RB1', class: 'elite', min: 20, max: 22, color: '#30d158', showCharts: true },
                { name: 'Solid RB1', class: 'elite', min: 18, max: 20, color: '#30d158', showCharts: true },
                { name: 'Low RB1/High RB2', class: 'wr2', min: 15, max: 18, color: '#0a84ff', showCharts: true },
                { name: 'Mid RB2', class: 'wr2', min: 13, max: 15, color: '#0a84ff', showCharts: true },
                { name: 'Low RB2/Flex', class: 'flex', min: 10, max: 13, color: '#FFD60A', showCharts: true },
                { name: 'RB3/Flex', class: 'flex', min: 8, max: 10, color: '#FFD60A', showCharts: true },
                { name: 'Deep Flex', class: 'depth', min: 5, max: 8, color: '#8e8e93', showCharts: false },
                { name: 'Depth/Streaming', class: 'depth', min: 0, max: 5, color: '#8e8e93', showCharts: false }
            ];
            
            let html = '';
            let chartIndex = 0;
            
            tiers.forEach(tier => {
                const tierPlayers = rbs.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                if (tierPlayers.length === 0) return;
                
                html += `
                    <div class="tier-section">
                        <div class="tier-header">
                            <div class="tier-badge ${tier.class}">${tier.name}</div>
                            <div class="tier-count">Avg: ${(tierPlayers.reduce((sum, p) => sum + p.avgPoints, 0) / tierPlayers.length).toFixed(1)} pts/game</div>
                        </div>
                        <div class="cards-grid">
                `;
                
                tierPlayers.forEach(player => {
                    overallRank++;
                    const chartId = `rb-player-chart-${chartIndex++}`;
                    const escapedId = player.id.replace(/'/g, "\\'");
                    const sentiment = getSentimentScore(player.name);
                    const buyPct = sentiment.total > 0 ? (sentiment.buy / sentiment.total * 100) : 0;
                    
                    // Use original avg points for display (not demoted value)
                    const displayAvgPoints = player.inactive ? player.avgPoints * 2 : player.avgPoints;
                    
                    // Calculate comparisons to top 24
                    const oppsPerGame = player.totalOpportunities / player.gamesPlayed;
                    const pointsDiff = displayAvgPoints - top24AvgPoints;
                    const oppsDiff = oppsPerGame - top24AvgOpps;
                    
                    const pointsClass = pointsDiff >= 0 ? 'comparison-up' : 'comparison-down';
                    const pointsIcon = pointsDiff >= 0 ? '▲' : '▼';
                    const oppsClass = oppsDiff >= 0 ? 'comparison-up' : 'comparison-down';
                    const oppsIcon = oppsDiff >= 0 ? '▲' : '▼';
                    
                    // Include chart based on tier setting
                    const includeChart = tier.showCharts;
                    
                    // Get tags for this player (RB specific)
                    const tags = playerTags[player.id] || [];
                    
                    // Build tags HTML including momentum badge
                    let tagElements = tags.map(tag => {
                        if (tag === 'buy_low') return '<span class="player-tag buy-low" data-tooltip="Efficiency ↑ but Volume ↓ - Undervalued opportunity">Buy Low</span>';
                        if (tag === 'sell_high') return '<span class="player-tag sell-high" data-tooltip="Volume ↑ but Efficiency ↓ - Regression risk">Sell High</span>';
                        if (tag === 'rz_trend_up') return '<span class="player-tag rz-up" data-tooltip="Red Zone opportunities trending up - TD upside">RZ↑</span>';
                        return '';
                    }).filter(t => t);
                    
                    // Add momentum badge to tags if valid
                    if (player.momentum && player.momentum.isValid && player.momentum.direction !== 'neutral') {
                        tagElements.push(`<span class="momentum-badge ${player.momentum.direction}" data-tooltip="Momentum: ${player.momentum.score > 0 ? '+' : ''}${player.momentum.score.toFixed(1)}% (last 3 vs prev 3 weeks)">${player.momentum.direction === 'up' ? '↑' : '↓'}</span>`);
                    }
                    
                    const tagsHTML = tagElements.length > 0 ? `
                        <div class="player-tags">
                            ${tagElements.join('')}
                        </div>
                    ` : '';
                    
                    html += `
                        <div class="player-card" onclick="openPlayerModal('${escapedId}')" ${player.inactive ? 'style="opacity: 0.6; border-left: 3px solid #ff453a;"' : ''}>
                            <div class="player-card-header">
                                <div class="player-card-badge" style="background: ${teamColors[player.team] || '#666'}">${player.team}</div>
                                <div style="flex: 1;">
                                    <div class="player-card-name">
                                        ${player.name}${player.inactive ? ' <span style="color: #ff453a; font-size: 11px;">⚠ INACTIVE</span>' : ''}
                                    </div>
                                    <div class="player-card-team">RB · ${player.team}</div>
                                    ${tagsHTML}
                                </div>
                            </div>
                            <div class="player-card-stats">
                                <div class="player-stat">
                                    <span class="player-stat-label">Avg Points</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="player-stat-value">${displayAvgPoints.toFixed(1)}</span>
                                        <span class="player-comparison ${pointsClass}">
                                            <span class="comparison-icon">${pointsIcon}</span>
                                            ${Math.abs(pointsDiff).toFixed(1)}
                                        </span>
                                        <div class="comparison-tooltip">
                                            <div class="tooltip-label">vs Top 24 RB Avg</div>
                                            <div class="tooltip-data">${displayAvgPoints.toFixed(1)} vs ${top24AvgPoints.toFixed(1)}</div>
                                            <div class="tooltip-data">${pointsDiff >= 0 ? '+' : ''}${pointsDiff.toFixed(1)} pts</div>
                                        </div>
                                    </div>
                                    <div class="stat-tooltip">Average fantasy points per game over ${player.gamesPlayed} games</div>
                                </div>
                                <div class="player-stat">
                                    <span class="player-stat-label">Opps/Game</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="player-stat-value">${oppsPerGame.toFixed(1)}</span>
                                        <span class="player-comparison ${oppsClass}">
                                            <span class="comparison-icon">${oppsIcon}</span>
                                            ${Math.abs(oppsDiff).toFixed(1)}
                                        </span>
                                        <div class="comparison-tooltip">
                                            <div class="tooltip-label">vs Top 24 RB Avg</div>
                                            <div class="tooltip-data">${oppsPerGame.toFixed(1)} vs ${top24AvgOpps.toFixed(1)}</div>
                                            <div class="tooltip-data">${oppsDiff >= 0 ? '+' : ''}${oppsDiff.toFixed(1)} opp/g</div>
                                        </div>
                                    </div>
                                    <div class="stat-tooltip">Average opportunities per game (${player.totalOpportunities} total opportunities)</div>
                                </div>
                                ${player.voting ? `
                                    <div class="player-stat" style="grid-column: 1 / -1;">
                                        <span class="player-stat-label">Community Sentiment</span>
                                        <div style="margin-top: 4px;">
                                            ${(() => {
                                                const totalVotes = player.voting.buy + player.voting.hold + player.voting.sell;
                                                const buyPct = Math.round((player.voting.buy / totalVotes) * 100);
                                                const holdPct = Math.round((player.voting.hold / totalVotes) * 100);
                                                const sellPct = Math.round((player.voting.sell / totalVotes) * 100);
                                                
                                                // Determine majority
                                                const max = Math.max(buyPct, holdPct, sellPct);
                                                let label, color, bgColor, icon;
                                                if (buyPct === max) {
                                                    label = 'BUY';
                                                    color = 'var(--positive)';
                                                    bgColor = 'rgba(48, 209, 88, 0.15)';
                                                    icon = '▲';
                                                } else if (sellPct === max) {
                                                    label = 'SELL';
                                                    color = 'var(--negative)';
                                                    bgColor = 'rgba(255, 69, 58, 0.15)';
                                                    icon = '▼';
                                                } else {
                                                    label = 'HOLD';
                                                    color = 'var(--text-secondary)';
                                                    bgColor = 'rgba(142, 142, 147, 0.15)';
                                                    icon = '—';
                                                }
                                                
                                                return '<span style="padding: 3px 6px; background: ' + bgColor + '; color: ' + color + '; border-radius: 5px; font-size: 10px; font-weight: 600; display: inline-block;">' + icon + ' ' + max + '% ' + label + '</span>';
                                            })()}
                                        </div>
                                        <div class="stat-tooltip">Community voting: ${player.voting.buy + player.voting.hold + player.voting.sell} total votes</div>
                                    </div>
                                ` : ''}
                            </div>
                            ${includeChart ? `<div class="player-card-chart">
                                <canvas id="${chartId}"></canvas>
                            </div>` : ''}
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            grid.innerHTML = html;
            
            // Render mini charts only for tiers with showCharts: true
            chartIndex = 0;
            rankIndex = 0; // Reset rank index for chart rendering
            tiers.forEach(tier => {
                if (!tier.showCharts) {
                    // Skip chart rendering for this tier, but still count the players
                    let tierPlayers = [];
                    if (tier.type === 'rank') {
                        tierPlayers = wrs.slice(rankIndex, rankIndex + tier.maxPlayers);
                        rankIndex += tierPlayers.length;
                    } else {
                        const remainingPlayers = wrs.slice(rankIndex);
                        tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                        rankIndex += tierPlayers.length;
                    }
                    chartIndex += tierPlayers.length;
                    return;
                }
                
                let tierPlayers = [];
                if (tier.type === 'rank') {
                    tierPlayers = wrs.slice(rankIndex, rankIndex + tier.maxPlayers);
                    rankIndex += tierPlayers.length;
                } else {
                    const remainingPlayers = wrs.slice(rankIndex);
                    tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                    rankIndex += tierPlayers.length;
                }
                
                tierPlayers.forEach(player => {
                    renderPlayerCardChart(`wr-player-chart-${chartIndex}`, player, 'WR');
                    chartIndex++;
                });
            });
        }

        function renderRBPlayerCards() {
            const grid = document.getElementById('rb-players-grid');
            let rbs = Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints);
            
            // Calculate tags for RBs
            const playerTags = calculatePlayerTags('RB');
            
            // FILTER: Mark Cam Skattebo as inactive
            rbs = rbs.map(player => {
                if (player.name === 'Cam Skattebo') {
                    return {
                        ...player,
                        latestWeek: 0, // Force inactive status
                        inactive: true
                    };
                }
                return player;
            });
            
            // DEMOTE: Players with no stats since Week 4
            rbs = rbs.map(player => {
                if (player.latestWeek && player.latestWeek < 5) {
                    // Apply penalty to move them down tiers (reduce avg points by 50%)
                    return {
                        ...player,
                        avgPoints: player.avgPoints * 0.5,
                        inactive: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);
            
            
            // DEMOTE: Players with only 1 game should max out at Deep Flex tier
            rbs = rbs.map(player => {
                if (player.gamesPlayed === 1) {
                    // Cap their avg points at 7.9 (just below RB3/Flex threshold of 8)
                    return {
                        ...player,
                        avgPoints: Math.min(player.avgPoints, 7.9),
                        lowSampleSize: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);
            // Calculate top 24 averages
            const top24 = rbs.slice(0, 24);
            const top24AvgPoints = top24.reduce((sum, p) => sum + p.avgPoints, 0) / top24.length;
            const top24AvgOpps = top24.reduce((sum, p) => sum + (p.totalOpportunities / p.gamesPlayed), 0) / top24.length;
            
            // Track ranking for top 50 determination
            let overallRank = 0;
            
            // Define tiers based on avg points thresholds (performance-based)
            const tiers = [
                { name: 'Elite RB1', class: 'elite', min: 22, max: 999, color: '#30d158', showCharts: true },
                { name: 'High-End RB1', class: 'elite', min: 20, max: 22, color: '#30d158', showCharts: true },
                { name: 'Solid RB1', class: 'elite', min: 18, max: 20, color: '#30d158', showCharts: true },
                { name: 'Low RB1/High RB2', class: 'wr2', min: 15, max: 18, color: '#0a84ff', showCharts: true },
                { name: 'Mid RB2', class: 'wr2', min: 13, max: 15, color: '#0a84ff', showCharts: true },
                { name: 'Low RB2/Flex', class: 'flex', min: 10, max: 13, color: '#FFD60A', showCharts: true },
                { name: 'RB3/Flex', class: 'flex', min: 8, max: 10, color: '#FFD60A', showCharts: true },
                { name: 'Deep Flex', class: 'depth', min: 5, max: 8, color: '#8e8e93', showCharts: false },
                { name: 'Depth/Streaming', class: 'depth', min: 0, max: 5, color: '#8e8e93', showCharts: false }
            ];
            
            let html = '';
            let chartIndex = 0;
            
            tiers.forEach(tier => {
                const tierPlayers = rbs.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                if (tierPlayers.length === 0) return;
                
                html += `
                    <div class="tier-section">
                        <div class="tier-header">
                            <div class="tier-badge ${tier.class}">${tier.name}</div>
                            <div class="tier-count">Avg: ${(tierPlayers.reduce((sum, p) => sum + p.avgPoints, 0) / tierPlayers.length).toFixed(1)} pts/game</div>
                        </div>
                        <div class="cards-grid">
                `;
                
                tierPlayers.forEach(player => {
                    overallRank++;
                    const chartId = `rb-player-chart-${chartIndex++}`;
                    const escapedId = player.id.replace(/'/g, "\\'");
                    const sentiment = getSentimentScore(player.name);
                    const buyPct = sentiment.total > 0 ? (sentiment.buy / sentiment.total * 100) : 0;
                    
                    // Use original avg points for display (not demoted value)
                    const displayAvgPoints = player.inactive ? player.avgPoints * 2 : player.avgPoints;
                    
                    // Calculate comparisons to top 24
                    const oppsPerGame = player.totalOpportunities / player.gamesPlayed;
                    const pointsDiff = displayAvgPoints - top24AvgPoints;
                    const oppsDiff = oppsPerGame - top24AvgOpps;
                    
                    const pointsClass = pointsDiff >= 0 ? 'comparison-up' : 'comparison-down';
                    const pointsIcon = pointsDiff >= 0 ? '▲' : '▼';
                    const oppsClass = oppsDiff >= 0 ? 'comparison-up' : 'comparison-down';
                    const oppsIcon = oppsDiff >= 0 ? '▲' : '▼';
                    
                    // Include chart based on tier setting
                    const includeChart = tier.showCharts;
                    
                    // Get tags for this player (RB specific)
                    const tags = playerTags[player.id] || [];
                    
                    // Build tags HTML including momentum badge
                    let tagElements = tags.map(tag => {
                        if (tag === 'buy_low') return '<span class="player-tag buy-low" data-tooltip="Efficiency ↑ but Volume ↓ - Undervalued opportunity">Buy Low</span>';
                        if (tag === 'sell_high') return '<span class="player-tag sell-high" data-tooltip="Volume ↑ but Efficiency ↓ - Regression risk">Sell High</span>';
                        if (tag === 'rz_trend_up') return '<span class="player-tag rz-up" data-tooltip="Red Zone opportunities trending up - TD upside">RZ↑</span>';
                        return '';
                    }).filter(t => t);
                    
                    // Add momentum badge to tags if valid
                    if (player.momentum && player.momentum.isValid && player.momentum.direction !== 'neutral') {
                        tagElements.push(`<span class="momentum-badge ${player.momentum.direction}" data-tooltip="Momentum: ${player.momentum.score > 0 ? '+' : ''}${player.momentum.score.toFixed(1)}% (last 3 vs prev 3 weeks)">${player.momentum.direction === 'up' ? '↑' : '↓'}</span>`);
                    }
                    
                    const tagsHTML = tagElements.length > 0 ? `
                        <div class="player-tags">
                            ${tagElements.join('')}
                        </div>
                    ` : '';
                    
                    html += `
                        <div class="player-card" onclick="openPlayerModal('${escapedId}')" ${player.inactive ? 'style="opacity: 0.6; border-left: 3px solid #ff453a;"' : ''}>
                            <div class="player-card-header">
                                <div class="player-card-badge" style="background: ${teamColors[player.team] || '#666'}">${player.team}</div>
                                <div style="flex: 1;">
                                    <div class="player-card-name">
                                        ${player.name}${player.inactive ? ' <span style="color: #ff453a; font-size: 11px;">⚠ INACTIVE</span>' : ''}
                                    </div>
                                    <div class="player-card-team">RB · ${player.team}</div>
                                    ${tagsHTML}
                                </div>
                            </div>
                            <div class="player-card-stats">
                                <div class="player-stat">
                                    <span class="player-stat-label">Avg Points</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="player-stat-value">${displayAvgPoints.toFixed(1)}</span>
                                        <span class="player-comparison ${pointsClass}">
                                            <span class="comparison-icon">${pointsIcon}</span>
                                            ${Math.abs(pointsDiff).toFixed(1)}
                                        </span>
                                        <div class="comparison-tooltip">
                                            <div class="tooltip-label">vs Top 24 RB Avg</div>
                                            <div class="tooltip-data">${displayAvgPoints.toFixed(1)} vs ${top24AvgPoints.toFixed(1)}</div>
                                            <div class="tooltip-data">${pointsDiff >= 0 ? '+' : ''}${pointsDiff.toFixed(1)} pts</div>
                                        </div>
                                    </div>
                                    <div class="stat-tooltip">Average fantasy points per game over ${player.gamesPlayed} games</div>
                                </div>
                                <div class="player-stat">
                                    <span class="player-stat-label">Opps/Game</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="player-stat-value">${oppsPerGame.toFixed(1)}</span>
                                        <span class="player-comparison ${oppsClass}">
                                            <span class="comparison-icon">${oppsIcon}</span>
                                            ${Math.abs(oppsDiff).toFixed(1)}
                                        </span>
                                        <div class="comparison-tooltip">
                                            <div class="tooltip-label">vs Top 24 RB Avg</div>
                                            <div class="tooltip-data">${oppsPerGame.toFixed(1)} vs ${top24AvgOpps.toFixed(1)}</div>
                                            <div class="tooltip-data">${oppsDiff >= 0 ? '+' : ''}${oppsDiff.toFixed(1)} opp/g</div>
                                        </div>
                                    </div>
                                    <div class="stat-tooltip">Average opportunities per game (${player.totalOpportunities} total opportunities)</div>
                                </div>
                                ${player.voting ? (() => {
                                    const totalVotes = player.voting.buy + player.voting.hold + player.voting.sell;
                                    const buyPct = Math.round((player.voting.buy / totalVotes) * 100);
                                    const holdPct = Math.round((player.voting.hold / totalVotes) * 100);
                                    const sellPct = Math.round((player.voting.sell / totalVotes) * 100);
                                    
                                    // Determine majority
                                    let majorityLabel, majorityColor, majorityBg;
                                    if (buyPct >= holdPct && buyPct >= sellPct) {
                                        majorityLabel = `▲ BUY ${buyPct}%`;
                                        majorityColor = 'var(--positive)';
                                        majorityBg = 'rgba(48, 209, 88, 0.15)';
                                    } else if (sellPct >= holdPct && sellPct >= buyPct) {
                                        majorityLabel = `▼ SELL ${sellPct}%`;
                                        majorityColor = 'var(--negative)';
                                        majorityBg = 'rgba(255, 69, 58, 0.15)';
                                    } else {
                                        majorityLabel = `— HOLD ${holdPct}%`;
                                        majorityColor = 'var(--text-secondary)';
                                        majorityBg = 'rgba(142, 142, 147, 0.15)';
                                    }
                                    
                                    return `
                                        <div class="player-stat" style="grid-column: 1 / -1;">
                                            <span class="player-stat-label">Community Sentiment</span>
                                            <div style="display: flex; gap: 8px; margin-top: 4px;">
                                                <span style="
                                                    padding: 3px 6px;
                                                    background: ${majorityBg};
                                                    color: ${majorityColor};
                                                    border-radius: 5px;
                                                    font-size: 10px;
                                                    font-weight: 600;
                                                    flex: 1;
                                                    text-align: center;
                                                ">${majorityLabel}</span>
                                            </div>
                                            <div class="stat-tooltip">${totalVotes.toLocaleString()} total votes - Click to see breakdown</div>
                                        </div>
                                    `;
                                })() : ''}
                            </div>
                            ${includeChart ? `<div class="player-card-chart">
                                <canvas id="${chartId}"></canvas>
                            </div>` : ''}
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            grid.innerHTML = html;
            
            // Render mini charts ONLY for top 50 players
            chartIndex = 0;
            overallRank = 0;
            tiers.forEach(tier => {
                const tierPlayers = rbs.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                tierPlayers.forEach(player => {
                    overallRank++;
                    if (overallRank <= 50) {
                        renderPlayerCardChart(`rb-player-chart-${chartIndex}`, player, 'RB');
                    }
                    chartIndex++;
                });
            });
        }

        function renderTEPlayerCards() {
            const grid = document.getElementById('te-players-grid');
            let tes = Object.values(aggregatedTEs).sort((a, b) => b.avgPoints - a.avgPoints);
            
            // Calculate tags for TEs
            const playerTags = calculatePlayerTags('TE');
            
            // DEMOTE: Players with no stats since Week 4
            tes = tes.map(player => {
                if (player.latestWeek && player.latestWeek < 5) {
                    // Apply penalty to move them down tiers (reduce avg points by 50%)
                    return {
                        ...player,
                        avgPoints: player.avgPoints * 0.5,
                        inactive: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);
            
            // Find global max week (current week)
            let globalMaxWeek = 0;
            tes.forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });
            
            // DEMOTE: Players who haven't played in 2+ weeks - drop them 1 tier (~3.5 ppg)
            tes = tes.map(player => {
                if (player.latestWeek && globalMaxWeek - player.latestWeek >= 2) {
                    return {
                        ...player,
                        avgPoints: Math.max(0, player.avgPoints - 3.5),
                        recentlyInactive: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);
            
            // SPECIFIC: Move Darren Waller to TE2 tier max (6 ppg) until he plays again
            tes = tes.map(player => {
                if (player.name === 'Darren Waller') {
                    return {
                        ...player,
                        avgPoints: Math.min(player.avgPoints, 5.9), // Just below TE2 threshold
                        wallerException: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);
            
            // SPECIFIC: Tucker Kraft injured - mark inactive and keep below Bowers/McBride
            tes = tes.map(player => {
                if (player.name === 'Tucker Kraft') {
                    return {
                        ...player,
                        inactive: true,
                        kraftInjury: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);
            
            // ELITE TIER 0: Bowers and McBride are in their own tier
            // Everyone else must be within 1.5 ppg of them to join
            const eliteTwoAvg = tes.slice(0, 2).reduce((sum, p) => sum + p.avgPoints, 0) / 2;
            tes = tes.map((player, idx) => {
                // Skip the top 2 (Bowers and McBride)
                if (idx < 2) return player;
                
                // Everyone else must be within 1.5 ppg of the elite duo's average
                if (player.avgPoints < eliteTwoAvg - 1.5) {
                    return {
                        ...player,
                        avgPoints: Math.min(player.avgPoints, eliteTwoAvg - 1.6), // Push them down to next tier
                        notElite: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);
            
            // DEMOTE: Players with only 1 game should max out at tier 4 or 5 depending on points
            tes = tes.map(player => {
                if (player.gamesPlayed === 1) {
                    // If they scored 10+ points, cap at tier 4 (8 ppg)
                    // If they scored less, cap at tier 5 (6 ppg)
                    const maxPpg = player.avgPoints >= 10 ? 7.9 : 5.9;
                    return {
                        ...player,
                        avgPoints: Math.min(player.avgPoints, maxPpg),
                        lowSampleSize: true
                    };
                }
                return player;
            }).sort((a, b) => b.avgPoints - a.avgPoints);
            
            // Calculate top 12 averages (not 24 like WR/RB)
            const top12 = tes.slice(0, 12);
            const top12AvgPoints = top12.reduce((sum, p) => sum + p.avgPoints, 0) / top12.length;
            const top12AvgTargets = top12.reduce((sum, p) => sum + (p.totalTargets / p.gamesPlayed), 0) / top12.length;
            
            // Track ranking for tier assignment
            let overallRank = 0;
            
            // Define 7 tiers - Elite Tier 0 for top 2, then rank-based for next 3, then point-based
            const tiers = [
                { name: 'Elite TE (Tier 0)', class: 'elite', type: 'rank', maxPlayers: 2, color: '#30d158', showCharts: true },
                { name: 'Elite TE1', class: 'elite', type: 'rank', maxPlayers: 3, color: '#30d158', showCharts: true },
                { name: 'High-End TE1', class: 'elite', type: 'rank', maxPlayers: 5, color: '#30d158', showCharts: true },
                { name: 'Solid TE1', class: 'elite', type: 'rank', maxPlayers: 8, color: '#30d158', showCharts: true },
                { name: 'TE2', class: 'wr2', type: 'points', min: 6, max: 999, color: '#0a84ff', showCharts: true },
                { name: 'Flex/Streamer', class: 'flex', type: 'points', min: 4, max: 6, color: '#FFD60A', showCharts: true },
                { name: 'Depth', class: 'depth', type: 'points', min: 0, max: 4, color: '#8e8e93', showCharts: false }
            ];
            
            let html = '';
            let chartIndex = 0;
            let rankIndex = 0; // Track position for rank-based tiers
            
            tiers.forEach(tier => {
                let tierPlayers = [];
                
                if (tier.type === 'rank') {
                    // Rank-based tier: take next N players in order
                    tierPlayers = tes.slice(rankIndex, rankIndex + tier.maxPlayers);
                    rankIndex += tierPlayers.length;
                } else {
                    // Point-based tier: filter by point threshold from remaining players
                    const remainingPlayers = tes.slice(rankIndex);
                    tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                    // Update rankIndex to skip these players for next tier
                    rankIndex += tierPlayers.length;
                }
                
                if (tierPlayers.length === 0) return;
                
                html += `
                    <div class="tier-section">
                        <div class="tier-header">
                            <div class="tier-badge ${tier.class}">${tier.name}</div>
                            <div class="tier-count">Avg: ${(tierPlayers.reduce((sum, p) => sum + p.avgPoints, 0) / tierPlayers.length).toFixed(1)} pts/game</div>
                        </div>
                        <div class="cards-grid">
                `;
                
                tierPlayers.forEach(player => {
                    overallRank++;
                    const chartId = `te-player-chart-${chartIndex++}`;
                    const escapedId = player.id.replace(/'/g, "\\'");
                    const sentiment = getSentimentScore(player.name);
                    const buyPct = sentiment.total > 0 ? (sentiment.buy / sentiment.total * 100) : 0;
                    
                    // Use original avg points for display (not demoted value)
                    const displayAvgPoints = player.inactive ? player.avgPoints * 2 : player.avgPoints;
                    
                    // Calculate comparisons to top 12
                    const targetsPerGame = player.totalTargets / player.gamesPlayed;
                    const pointsDiff = displayAvgPoints - top12AvgPoints;
                    const targetsDiff = targetsPerGame - top12AvgTargets;
                    
                    const pointsClass = pointsDiff >= 0 ? 'comparison-up' : 'comparison-down';
                    const pointsIcon = pointsDiff >= 0 ? '▲' : '▼';
                    const targetsClass = targetsDiff >= 0 ? 'comparison-up' : 'comparison-down';
                    const targetsIcon = targetsDiff >= 0 ? '▲' : '▼';
                    
                    // Include chart based on tier setting
                    const includeChart = tier.showCharts;
                    
                    // Get tags for this player
                    const tags = playerTags[player.id] || [];
                    
                    // Build tags HTML including momentum badge
                    let tagElements = tags.map(tag => {
                        if (tag === 'buy_low') return '<span class="player-tag buy-low" data-tooltip="Efficiency ↑ but Volume ↓ - Undervalued opportunity">Buy Low</span>';
                        if (tag === 'sell_high') return '<span class="player-tag sell-high" data-tooltip="Volume ↑ but Efficiency ↓ - Regression risk">Sell High</span>';
                        if (tag === 'rz_trend_up') return '<span class="player-tag rz-up" data-tooltip="Red Zone opportunities trending up - TD upside">RZ↑</span>';
                        return '';
                    }).filter(t => t);
                    
                    // Add momentum badge to tags if valid
                    if (player.momentum && player.momentum.isValid && player.momentum.direction !== 'neutral') {
                        tagElements.push(`<span class="momentum-badge ${player.momentum.direction}" data-tooltip="Momentum: ${player.momentum.score > 0 ? '+' : ''}${player.momentum.score.toFixed(1)}% (last 3 vs prev 3 weeks)">${player.momentum.direction === 'up' ? '↑' : '↓'}</span>`);
                    }
                    
                    const tagsHTML = tagElements.length > 0 ? `
                        <div class="player-tags">
                            ${tagElements.join('')}
                        </div>
                    ` : '';
                    
                    html += `
                        <div class="player-card" onclick="openPlayerModal('${escapedId}')" ${player.inactive ? 'style="opacity: 0.6; border-left: 3px solid #ff453a;"' : ''}>
                            <div class="player-card-header">
                                <div class="player-card-badge" style="background: ${teamColors[player.team] || '#666'}">${player.team}</div>
                                <div style="flex: 1;">
                                    <div class="player-card-name">
                                        ${player.name}${player.inactive ? ' <span style="color: #ff453a; font-size: 11px;">⚠ INACTIVE</span>' : ''}
                                    </div>
                                    <div class="player-card-team">TE · ${player.team}</div>
                                    ${tagsHTML}
                                </div>
                            </div>
                            <div class="player-card-stats">
                                <div class="player-stat">
                                    <span class="player-stat-label">Avg Points</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="player-stat-value">${displayAvgPoints.toFixed(1)}</span>
                                        <span class="player-comparison ${pointsClass}">
                                            <span class="comparison-icon">${pointsIcon}</span>
                                            ${Math.abs(pointsDiff).toFixed(1)}
                                        </span>
                                        <div class="comparison-tooltip">
                                            <div class="tooltip-label">vs Top 12 TE Avg</div>
                                            <div class="tooltip-data">${displayAvgPoints.toFixed(1)} vs ${top12AvgPoints.toFixed(1)}</div>
                                            <div class="tooltip-data">${pointsDiff >= 0 ? '+' : ''}${pointsDiff.toFixed(1)} pts</div>
                                        </div>
                                    </div>
                                    <div class="stat-tooltip">Average fantasy points per game over ${player.gamesPlayed} games</div>
                                </div>
                                <div class="player-stat">
                                    <span class="player-stat-label">Targets/Game</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="player-stat-value">${targetsPerGame.toFixed(1)}</span>
                                        <span class="player-comparison ${targetsClass}">
                                            <span class="comparison-icon">${targetsIcon}</span>
                                            ${Math.abs(targetsDiff).toFixed(1)}
                                        </span>
                                        <div class="comparison-tooltip">
                                            <div class="tooltip-label">vs Top 12 TE Avg</div>
                                            <div class="tooltip-data">${targetsPerGame.toFixed(1)} vs ${top12AvgTargets.toFixed(1)}</div>
                                            <div class="tooltip-data">${targetsDiff >= 0 ? '+' : ''}${targetsDiff.toFixed(1)} tgt/g</div>
                                        </div>
                                    </div>
                                    <div class="stat-tooltip">Average targets per game (${player.totalTargets} total targets)</div>
                                </div>
                                ${player.voting ? `
                                <div class="community-sentiment-compact">
                                    <div class="sentiment-bar-bg">
                                        <div class="sentiment-bar-fill sentiment-${player.voting.dominant}" style="width: ${player.voting.dominantPct}%"></div>
                                    </div>
                                    <div class="sentiment-details">
                                        <span class="sentiment-label">${player.voting.dominantPct}% ${player.voting.dominant.toUpperCase()}</span>
                                        <span class="sentiment-count">${player.voting.total.toLocaleString()} votes</span>
                                    </div>
                                </div>
                                ` : ''}
                            </div>
                            ${includeChart ? `<div class="player-card-chart">
                                <canvas id="${chartId}"></canvas>
                            </div>` : ''}
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            grid.innerHTML = html;
            
            // Render mini charts only for tiers with showCharts: true
            chartIndex = 0;
            rankIndex = 0; // Reset rank index for chart rendering
            
            tiers.forEach(tier => {
                if (!tier.showCharts) {
                    rankIndex += tier.type === 'rank' ? tier.maxPlayers : 
                                tes.slice(rankIndex).filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max).length;
                    return;
                }
                
                let tierPlayers = [];
                if (tier.type === 'rank') {
                    tierPlayers = tes.slice(rankIndex, rankIndex + tier.maxPlayers);
                    rankIndex += tierPlayers.length;
                } else {
                    const remainingPlayers = tes.slice(rankIndex);
                    tierPlayers = remainingPlayers.filter(p => p.avgPoints >= tier.min && p.avgPoints < tier.max);
                    rankIndex += tierPlayers.length;
                }
                
                // Render charts for this tier
                tierPlayers.forEach(player => {
                    renderPlayerCardChart(`te-player-chart-${chartIndex}`, player, 'TE');
                    chartIndex++;
                });
            });
        }
        function renderTeamsPage() {
            const teamsGrid = document.getElementById('teams-grid');
            
            // Reset and recalculate global teamStats
            teamStats = {};
            
            // NFL Division mapping
            const divisions = {
                'AFC East': ['BUF', 'MIA', 'NE', 'NYJ'],
                'AFC North': ['BAL', 'CIN', 'CLE', 'PIT'],
                'AFC South': ['HOU', 'IND', 'JAC', 'TEN'],
                'AFC West': ['DEN', 'KC', 'LAC', 'LV'],
                'NFC East': ['DAL', 'NYG', 'PHI', 'WAS'],
                'NFC North': ['CHI', 'DET', 'GB', 'MIN'],
                'NFC South': ['ATL', 'CAR', 'NO', 'TB'],
                'NFC West': ['ARI', 'LAR', 'SF', 'SEA']
            };
            
            // Aggregate by team
            Object.values(allPlayers).forEach(player => {
                if (!teamStats[player.team]) {
                    teamStats[player.team] = {
                        team: player.team,
                        wrCount: 0,
                        rbCount: 0,
                        totalPoints: 0,
                        players: [],
                        totalTargets: 0,
                        totalRushAtts: 0,
                        totalGames: 0,
                        weeklyTargets: {}, // Track targets by week
                        weeklyRushAtts: {} // Track rush attempts by week
                    };
                }
                
                if (player.position === 'WR') {
                    teamStats[player.team].wrCount++;
                } else {
                    teamStats[player.team].rbCount++;
                }
                
                teamStats[player.team].totalPoints += player.totalPoints;
                teamStats[player.team].players.push(player);
                
                // Aggregate targets and rush attempts by week
                player.weeks.forEach(week => {
                    const weekNum = week.week;
                    
                    // Track targets (both WR and RB)
                    if (week.targets) {
                        if (!teamStats[player.team].weeklyTargets[weekNum]) {
                            teamStats[player.team].weeklyTargets[weekNum] = 0;
                        }
                        teamStats[player.team].weeklyTargets[weekNum] += week.targets;
                        teamStats[player.team].totalTargets += week.targets;
                    }
                    
                    // Track rush attempts (RB only)
                    if (player.position === 'RB' && week.rushAttempts) {
                        if (!teamStats[player.team].weeklyRushAtts[weekNum]) {
                            teamStats[player.team].weeklyRushAtts[weekNum] = 0;
                        }
                        teamStats[player.team].weeklyRushAtts[weekNum] += week.rushAttempts;
                        teamStats[player.team].totalRushAtts += week.rushAttempts;
                    }
                });
                
                teamStats[player.team].totalGames = Math.max(
                    teamStats[player.team].totalGames,
                    player.weeks.length
                );
            });
            
            // Calculate averages and week-over-week changes for each team
            Object.values(teamStats).forEach(team => {
                // Find global max week
                let globalMaxWeek = 0;
                team.players.forEach(p => {
                    if (p.weeks && p.weeks.length > 0) {
                        const maxWeek = Math.max(...p.weeks.map(w => w.week));
                        if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                    }
                });
                
                // Calculate number of games (unique weeks with data)
                const uniqueWeeks = new Set();
                team.players.forEach(p => {
                    p.weeks.forEach(w => uniqueWeeks.add(w.week));
                });
                const numGames = uniqueWeeks.size;
                
                // Average targets per game
                team.avgTargetsPerGame = numGames > 0 ? team.totalTargets / numGames : 0;
                
                // Average rush attempts per game
                team.avgRushAttsPerGame = numGames > 0 ? team.totalRushAtts / numGames : 0;
                
                // Calculate week-over-week changes
                const lastWeek = globalMaxWeek;
                let prevWeek = globalMaxWeek - 1;
                
                // If team didn't play last week, look for the most recent week they did play
                let lastWeekTargets = team.weeklyTargets[lastWeek] || 0;
                let lastWeekRushAtts = team.weeklyRushAtts[lastWeek] || 0;
                
                // If no data for last week, find most recent week with data
                if (lastWeekTargets === 0 && lastWeekRushAtts === 0) {
                    for (let w = lastWeek - 1; w >= 1; w--) {
                        if (team.weeklyTargets[w] || team.weeklyRushAtts[w]) {
                            lastWeekTargets = team.weeklyTargets[w] || 0;
                            lastWeekRushAtts = team.weeklyRushAtts[w] || 0;
                            prevWeek = w - 1; // Compare to week before that
                            break;
                        }
                    }
                }
                
                const prevWeekTargets = team.weeklyTargets[prevWeek] || 0;
                const prevWeekRushAtts = team.weeklyRushAtts[prevWeek] || 0;
                
                team.targetsChange = prevWeekTargets > 0 ? lastWeekTargets - prevWeekTargets : 0;
                team.rushAttsChange = prevWeekRushAtts > 0 ? lastWeekRushAtts - prevWeekRushAtts : 0;
                
                // Calculate average points per game for Advanced Analytics
                team.avgPoints = numGames > 0 ? team.totalPoints / numGames : 0;
            });
            
            // Build HTML organized by division
            let html = '';
            let teamIndex = 0;
            
            Object.entries(divisions).forEach(([divisionName, teamCodes]) => {
                // Get teams in this division and sort by total points
                const divisionTeams = teamCodes
                    .map(code => teamStats[code])
                    .filter(team => team) // Filter out teams with no data
                    .sort((a, b) => b.totalPoints - a.totalPoints);
                
                if (divisionTeams.length === 0) return;
                
                // Division header
                html += `
                    <div style="grid-column: 1 / -1; margin-top: ${html ? '32px' : '0'};">
                        <h2 style="font-size: 18px; font-weight: 700; color: var(--text-primary); margin-bottom: 16px; padding-bottom: 8px; border-bottom: 2px solid var(--border-color);">
                            ${divisionName}
                        </h2>
                    </div>
                `;
                
                // Team cards for this division
                divisionTeams.forEach(team => {
                    const chartId = `team-chart-${teamIndex++}`;
                    html += `
                        <div class="team-card" onclick="openTeamModal('${team.team}')">
                            <div class="team-card-header">
                                <div class="team-card-badge" style="background: ${teamColors[team.team] || '#666'}">${team.team}</div>
                                <div class="team-card-name" style="font-weight: 700;">${team.team}</div>
                            </div>
                            <div class="team-card-stats">
                                <div class="team-stat">
                                    <span class="team-stat-label">Total Points</span>
                                    <span class="team-stat-value">${team.totalPoints.toFixed(1)}</span>
                                    <span class="stat-tooltip">Combined fantasy points from all WRs and RBs this season</span>
                                </div>
                                <div class="team-stat">
                                    <span class="team-stat-label">Avg Targets/Game</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="team-stat-value">${team.avgTargetsPerGame.toFixed(1)}</span>
                                        ${team.targetsChange !== 0 ? `
                                            <span class="player-comparison ${team.targetsChange > 0 ? 'comparison-up' : 'comparison-down'}">
                                                <span class="comparison-icon">${team.targetsChange > 0 ? '▲' : '▼'}</span>
                                                ${Math.abs(team.targetsChange).toFixed(1)}
                                            </span>
                                        ` : ''}
                                    </div>
                                    <span class="stat-tooltip">Average WR/RB targets per game (change vs last week)</span>
                                </div>
                                <div class="team-stat">
                                    <span class="team-stat-label">Avg Rush Atts/Game</span>
                                    <div class="player-stat-with-comparison">
                                        <span class="team-stat-value">${team.avgRushAttsPerGame.toFixed(1)}</span>
                                        ${team.rushAttsChange !== 0 ? `
                                            <span class="player-comparison ${team.rushAttsChange > 0 ? 'comparison-up' : 'comparison-down'}">
                                                <span class="comparison-icon">${team.rushAttsChange > 0 ? '▲' : '▼'}</span>
                                                ${Math.abs(team.rushAttsChange).toFixed(1)}
                                            </span>
                                        ` : ''}
                                    </div>
                                    <span class="stat-tooltip">Average RB rush attempts per game (change vs last week)</span>
                                </div>
                            </div>
                            <div class="team-card-chart">
                                <canvas id="${chartId}"></canvas>
                            </div>
                        </div>
                    `;
                });
            });
            
            teamsGrid.innerHTML = html;
            
            // Now render charts for each team
            teamIndex = 0;
            Object.entries(divisions).forEach(([divisionName, teamCodes]) => {
                const divisionTeams = teamCodes
                    .map(code => teamStats[code])
                    .filter(team => team)
                    .sort((a, b) => b.totalPoints - a.totalPoints);
                
                divisionTeams.forEach(team => {
                    renderTeamCardChart(`team-chart-${teamIndex++}`, team);
                });
            });
        }
        
        function renderTeamCardChart(canvasId, team) {
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;
            
            // Get top 5 players by avg points
            const topPlayers = team.players
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 5);
            
            const labels = topPlayers.map(p => `${p.name} (${p.position})`);
            const data = topPlayers.map(p => p.avgPoints);
            
            // Generate color palette
            const teamColor = teamColors[team.team] || '#0a84ff';
            const colorPalette = getColorPalette(teamColor, topPlayers.length);
            
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colorPalette,
                        borderColor: '#0a0a0a',
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => `${context.parsed.x.toFixed(1)} PPG`
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: false,
                            grid: { display: false }
                        },
                        y: {
                            ticks: { 
                                color: '#8e8e93',
                                font: { size: 10 }
                            },
                            grid: { display: false }
                        }
                    }
                }
            });
        }
        
        function renderPlayerCardChart(canvasId, player, position) {
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;
            
            // Get weekly points data
            const weeks = player.weeks
                .sort((a, b) => a.week - b.week)
                .slice(-8); // Last 8 weeks
            
            const labels = weeks.map(w => `W${w.week}`);
            const actualData = weeks.map(w => w.fpts || 0);
            const expectedData = weeks.map(w => w.expectedFpts || 0);
            
            // Color based on team
            const teamColor = teamColors[player.team] || '#0a84ff';
            
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Actual Points',
                            data: actualData,
                            borderColor: teamColor,
                            backgroundColor: teamColor + '33',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.3,
                            pointRadius: 3,
                            pointHoverRadius: 5,
                            pointBackgroundColor: teamColor,
                            pointBorderColor: '#fff',
                            pointBorderWidth: 1
                        },
                        {
                            label: 'Expected Points',
                            data: expectedData,
                            borderColor: '#8e8e93',
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false,
                            tension: 0.3,
                            pointRadius: 0,
                            pointHoverRadius: 4,
                            pointBackgroundColor: '#8e8e93',
                            pointBorderColor: '#fff',
                            pointBorderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: (context) => {
                                    const label = context.dataset.label || '';
                                    return `${label}: ${context.parsed.y.toFixed(1)} pts`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#8e8e93',
                                font: { size: 9 }
                            },
                            grid: { display: false }
                        },
                        y: {
                            beginAtZero: true,
                            ticks: { 
                                color: '#8e8e93',
                                font: { size: 9 }
                            },
                            grid: { 
                                color: '#1c1c1e'
                            }
                        }
                    }
                }
            });
        }
        
        function openTeamModal(teamCode) {
            const modal = document.getElementById('team-modal');
            modal.style.display = 'flex';
            
            // Get all players from this team
            const teamPlayers = Object.values(allPlayers).filter(p => p.team === teamCode);
            if (teamPlayers.length === 0) return;
            
            // Determine if WR or RB dominant team (or show both)
            const wrs = teamPlayers.filter(p => p.position === 'WR');
            const rbs = teamPlayers.filter(p => p.position === 'RB');
            
            // Set header info
            document.getElementById('team-modal-badge').style.background = teamColors[teamCode] || '#666';
            document.getElementById('team-modal-badge').textContent = teamCode;
            document.getElementById('team-modal-name').textContent = `${teamCode} Team Analysis`;
            document.getElementById('team-modal-meta').textContent = `${wrs.length} WRs · ${rbs.length} RBs`;
            
            // Calculate team stats
            const allTeamPlayers = [...wrs, ...rbs];
            const totalPoints = allTeamPlayers.reduce((sum, p) => sum + (p.avgPoints * p.gamesPlayed), 0);
            const totalGames = allTeamPlayers.reduce((sum, p) => sum + p.gamesPlayed, 0);
            const avgPointsPerGame = totalGames > 0 ? totalPoints / totalGames : 0;
            
            const topPlayer = allTeamPlayers.sort((a, b) => b.avgPoints - a.avgPoints)[0];
            const topTargets = wrs.length > 0 ? Math.max(...wrs.map(w => w.totalTargets / w.gamesPlayed)) : 0;
            const topOpps = rbs.length > 0 ? Math.max(...rbs.map(r => r.totalOpportunities / r.gamesPlayed)) : 0;
            
            // Render team stats summary
            const statsHTML = `
                <div class="team-stat-card">
                    <div class="team-stat-value">${avgPointsPerGame.toFixed(1)}</div>
                    <div class="team-stat-label">Fantasy PPG</div>
                </div>
                <div class="team-stat-card">
                    <div class="team-stat-value">${topPlayer ? topPlayer.avgPoints.toFixed(1) : '0'}</div>
                    <div class="team-stat-label">Top Player PPG</div>
                </div>
                <div class="team-stat-card">
                    <div class="team-stat-value">${topTargets.toFixed(1)}</div>
                    <div class="team-stat-label">Top WR Targets</div>
                </div>
                <div class="team-stat-card">
                    <div class="team-stat-value">${topOpps.toFixed(1)}</div>
                    <div class="team-stat-label">Top RB Opps</div>
                </div>
            `;
            document.getElementById('team-stats-summary').innerHTML = statsHTML;
            
            // Render key players (top 4 by avg points)
            const keyPlayers = allTeamPlayers
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 4);
            
            const keyPlayersHTML = keyPlayers.map(player => {
                const posColor = getPositionColor(player.position);
                const statLabel = player.position === 'WR' || player.position === 'TE'
                    ? `${(player.totalTargets / player.gamesPlayed).toFixed(1)} tgts/g`
                    : `${(player.totalOpportunities / player.gamesPlayed).toFixed(1)} opps/g`;
                
                return `
                    <div class="key-player-card" onclick="openPlayerModal('${player.id.replace(/'/g, "\\'")}')">
                        <div class="key-player-position" style="background: ${posColor};">
                            ${player.position}
                        </div>
                        <div class="key-player-info">
                            <div class="key-player-name">${player.name}</div>
                            <div class="key-player-stat">${player.avgPoints.toFixed(1)} PPG · ${statLabel}</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            document.getElementById('key-players-grid').innerHTML = keyPlayersHTML;
            
            // Render charts - showing WR data by default, or RB if no WRs
            const position = wrs.length > 0 ? 'WR' : 'RB';
            renderTeamModalShareChart(teamCode, position);
            renderTeamModalTrendsChart(teamCode, position);
        }
        
        function closeTeamModal() {
            document.getElementById('team-modal').style.display = 'none';
            if (teamModalShareChart) teamModalShareChart.destroy();
            if (teamModalTrendsChart) teamModalTrendsChart.destroy();
        }
        
        function renderTeamModalShareChart(teamCode, position) {
            const ctx = document.getElementById('team-modal-share-chart');
            
            if (teamModalShareChart) {
                teamModalShareChart.destroy();
            }
            
            // Find the most recent week where this team actually played (has data)
            const teamWeeksWR = wrData
                .filter(row => row.Team === teamCode && parseFloat(row.TGT) > 0)
                .map(row => parseInt(row.Week))
                .filter(w => !isNaN(w));
            const teamWeeksRB = rbData
                .filter(row => row.Team === teamCode && parseFloat(row.TGT) > 0)
                .map(row => parseInt(row.Week))
                .filter(w => !isNaN(w));
            
            const allTeamWeeks = [...new Set([...teamWeeksWR, ...teamWeeksRB])].sort((a, b) => b - a);
            const latestWeek = allTeamWeeks[0]; // Most recent week with data
            
            // Get WR data
            const wrTeamData = wrData.filter(row => 
                row.Team === teamCode && 
                parseInt(row.Week) === latestWeek &&
                row.Player &&
                parseFloat(row.TGT) > 0
            );
            
            // Get RB data  
            const rbTeamData = rbData.filter(row => 
                row.Team === teamCode && 
                parseInt(row.Week) === latestWeek &&
                row.Player &&
                parseFloat(row.TGT) > 0
            );
            
            // Combine all players
            const allPlayerShares = [];
            
            // Add WRs
            wrTeamData.forEach(row => {
                allPlayerShares.push({
                    name: row.Player,
                    targets: parseFloat(row.TGT) || 0,
                    position: 'WR'
                });
            });
            
            // Add RBs
            rbTeamData.forEach(row => {
                allPlayerShares.push({
                    name: row.Player,
                    targets: parseFloat(row.TGT) || 0,
                    position: 'RB'
                });
            });
            
            // Calculate total team targets (WR + RB)
            const totalTargets = allPlayerShares.reduce((sum, p) => sum + p.targets, 0);
            
            // Calculate share percentage for each player
            allPlayerShares.forEach(p => {
                p.share = totalTargets > 0 ? (p.targets / totalTargets) * 100 : 0;
            });
            
            // Sort by share
            allPlayerShares.sort((a, b) => b.share - a.share);
            
            const labels = allPlayerShares.map(p => `${p.name} (${p.position})`);
            const data = allPlayerShares.map(p => p.share);
            
            // Generate color palette from team color
            const teamColor = teamColors[teamCode] || '#0a84ff';
            const colorPalette = getColorPalette(teamColor, allPlayerShares.length);
            
            teamModalShareChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colorPalette,
                        borderColor: '#0a0a0a',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        animateRotate: true,
                        animateScale: true,
                        duration: 800,
                        easing: 'easeInOutQuart'
                    },
                    plugins: {
                        legend: { 
                            display: true,
                            labels: { color: '#8e8e93' },
                            position: 'bottom'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.label}: ${context.parsed.toFixed(1)}%`;
                                }
                            }
                        },
                        title: {
                            display: true,
                            text: `Week ${latestWeek} Target Distribution`,
                            color: '#8e8e93',
                            font: { size: 11 }
                        }
                    }
                }
            });
        }
        
        function renderTeamModalTrendsChart(teamCode, position) {
            const ctx = document.getElementById('team-modal-trends-chart');
            
            if (teamModalTrendsChart) {
                teamModalTrendsChart.destroy();
            }
            
            // Get all weeks for this team from both WR and RB data
            const teamWeeks = [...new Set([
                ...wrData.filter(row => row.Team === teamCode).map(row => parseInt(row.Week)),
                ...rbData.filter(row => row.Team === teamCode).map(row => parseInt(row.Week))
            ].filter(w => !isNaN(w)))].sort((a, b) => a - b);
            
            // Calculate weekly shares - combining WRs and RBs
            const weeklyShares = {};
            
            teamWeeks.forEach(weekNum => {
                // Get both WR and RB data for this week
                const wrWeekData = wrData.filter(row => 
                    row.Team === teamCode && 
                    parseInt(row.Week) === weekNum &&
                    row.Player &&
                    parseFloat(row.TGT) > 0
                );
                
                const rbWeekData = rbData.filter(row => 
                    row.Team === teamCode && 
                    parseInt(row.Week) === weekNum &&
                    row.Player &&
                    parseFloat(row.TGT) > 0
                );
                
                // Combine all players
                const allPlayerShares = [];
                
                // Calculate total team targets for this week
                const totalTargets = 
                    wrWeekData.reduce((sum, r) => sum + (parseFloat(r.TGT) || 0), 0) +
                    rbWeekData.reduce((sum, r) => sum + (parseFloat(r.TGT) || 0), 0);
                
                // Add WRs
                wrWeekData.forEach(row => {
                    const targets = parseFloat(row.TGT) || 0;
                    const share = totalTargets > 0 ? (targets / totalTargets) * 100 : 0;
                    allPlayerShares.push({
                        name: `${row.Player} (WR)`,
                        share: share
                    });
                });
                
                // Add RBs
                rbWeekData.forEach(row => {
                    const targets = parseFloat(row.TGT) || 0;
                    const share = totalTargets > 0 ? (targets / totalTargets) * 100 : 0;
                    allPlayerShares.push({
                        name: `${row.Player} (RB)`,
                        share: share
                    });
                });
                
                allPlayerShares.sort((a, b) => b.share - a.share);
                weeklyShares[weekNum] = allPlayerShares;
            });
            
            // Get top 4 players by total share across all weeks
            const allPlayers = new Map();
            Object.values(weeklyShares).forEach(weekData => {
                weekData.forEach(p => {
                    if (!allPlayers.has(p.name)) {
                        allPlayers.set(p.name, 0);
                    }
                    allPlayers.set(p.name, allPlayers.get(p.name) + p.share);
                });
            });
            
            const sortedPlayers = Array.from(allPlayers.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 4)
                .map(entry => entry[0]);
            
            // Build datasets for stacked bar chart
            const labels = teamWeeks.map(w => `W${w}`);
            const datasets = [];
            
            // Generate color palette
            const teamColor = teamColors[teamCode] || '#0a84ff';
            const colorPalette = getColorPalette(teamColor, 4);
            
            sortedPlayers.forEach((playerName, idx) => {
                const weeklyData = teamWeeks.map(weekNum => {
                    const weekData = weeklyShares[weekNum];
                    const playerWeekData = weekData.find(p => p.name === playerName);
                    return playerWeekData ? playerWeekData.share : 0;
                });
                
                datasets.push({
                    label: playerName,
                    data: weeklyData,
                    backgroundColor: colorPalette[idx],
                    borderColor: '#0a0a0a',
                    borderWidth: 1
                });
            });
            
            // Everyone else
            const othersData = teamWeeks.map(weekNum => {
                const weekData = weeklyShares[weekNum];
                const top4Total = weekData
                    .filter(p => sortedPlayers.includes(p.name))
                    .reduce((sum, p) => sum + p.share, 0);
                return Math.max(0, 100 - top4Total);
            });
            
            datasets.push({
                label: 'Everyone Else',
                data: othersData,
                backgroundColor: '#1c1c1e',
                borderColor: '#0a0a0a',
                borderWidth: 1
            });
            
            teamModalTrendsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 1000,
                        easing: 'easeInOutQuart'
                    },
                    plugins: {
                        legend: { 
                            display: true,
                            labels: { color: '#8e8e93' },
                            position: 'bottom'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'Opportunity Share %',
                                color: '#8e8e93'
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }


        // ============================================
        // 4. CHARTS
        // ============================================

        function renderScatterPlots() {
            // Only render team scatter - WR/RB charts are lazy loaded
            renderTeamBalanceScatter();
            initializeTeamAnalysis();
        }
        
        // Matrix switching functions
        function switchMatrix(matrixType) {
            // Update button states
            document.querySelectorAll('.matrix-tab').forEach(btn => {
                btn.classList.remove('active');
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.color = 'var(--text-secondary)';
            });
            event.target.classList.add('active');
            event.target.style.background = 'var(--positive)';
            event.target.style.color = 'white';
            
            // Show correct section
            document.querySelectorAll('.matrix-section').forEach(section => {
                section.style.display = 'none';
            });
            document.getElementById(matrixType).style.display = 'block';
        }
        
        function switchWRMatrix(chartType) {
            // Update button states
            document.querySelectorAll('.wr-matrix-tab').forEach(btn => {
                btn.classList.remove('active');
                btn.style.color = 'var(--text-secondary)';
                btn.style.borderBottomColor = 'transparent';
            });
            event.target.classList.add('active');
            event.target.style.color = 'var(--text-primary)';
            event.target.style.borderBottomColor = 'var(--positive)';
            
            // Show correct chart with animation
            document.querySelectorAll('.wr-matrix-content').forEach(content => {
                content.style.display = 'none';
            });
            const targetChart = document.getElementById(`wr-matrix-${chartType}`);
            targetChart.style.display = 'block';
            targetChart.style.animation = 'fadeIn 0.3s ease';
        }
        
        function switchRBMatrix(chartType) {
            // Update button states
            document.querySelectorAll('.rb-matrix-tab').forEach(btn => {
                btn.classList.remove('active');
                btn.style.color = 'var(--text-secondary)';
                btn.style.borderBottomColor = 'transparent';
            });
            event.target.classList.add('active');
            event.target.style.color = 'var(--text-primary)';
            event.target.style.borderBottomColor = 'var(--positive)';
            
            // Show correct chart with animation
            document.querySelectorAll('.rb-matrix-content').forEach(content => {
                content.style.display = 'none';
            });
            const targetChart = document.getElementById(`rb-matrix-${chartType}`);
            targetChart.style.display = 'block';
            targetChart.style.animation = 'fadeIn 0.3s ease';
        }
        
        function switchMatrixChart(chartType) {
            // Update button states in current section
            const activeSection = document.querySelector('.matrix-section:not([style*="display: none"])');
            activeSection.querySelectorAll('.matrix-chart-tab').forEach(btn => {
                btn.classList.remove('active');
                btn.style.color = 'var(--text-secondary)';
                btn.style.borderBottomColor = 'transparent';
            });
            event.target.classList.add('active');
            event.target.style.color = 'var(--text-primary)';
            event.target.style.borderBottomColor = 'var(--positive)';
            
            // Show correct chart
            activeSection.querySelectorAll('.matrix-chart-content').forEach(content => {
                content.style.display = 'none';
            });
            activeSection.querySelector(`#matrix-${chartType}`).style.display = 'block';
        }
        
        function renderMatrices() {
            // WR Matrices
            renderEfficiencyMatrix('wr');
            renderShareMatrix('wr');
            renderFloorMatrix('wr');
            renderVolumeMonsterMatrix();
            renderCatchRateMatrix();
            renderRedzoneMatrix('wr');
            
            // RB Matrices
            renderEfficiencyMatrix('rb');
            renderTalentSituationMatrix();
            renderOpportunityEfficiencyMatrix();
            renderShareMatrix('rb');
            renderFloorMatrix('rb');
            renderRedzoneMatrix('rb');
        }
        
        // Matrix 1: Efficiency vs Volume
        function renderEfficiencyMatrix(position) {
            const canvasId = position === 'wr' ? 'wr-efficiency-matrix' : 'rb-efficiency-matrix';
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;
            
            const players = position === 'wr' ? 
                Object.values(aggregatedWRs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50) :
                Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);
            
            const data = players.map(player => {
                const volume = position === 'wr' ? player.totalTargets : player.totalOpportunities;
                const efficiency = player.avgPoints / (volume / player.gamesPlayed); // Points per opportunity per game
                
                return {
                    x: volume,
                    y: efficiency,
                    label: player.name,
                    player: player
                };
            });
            
            // Calculate medians for quadrant lines
            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];
            
            const chartVar = position === 'wr' ? 'wrEfficiencyMatrix' : 'rbEfficiencyMatrix';
            if (window[chartVar]) {
                window[chartVar].destroy();
            }
            
            window[chartVar] = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: position.toUpperCase() + 's',
                            data: data,
                            backgroundColor: data.map(d => {
                                const color = teamColors[d.player.team] || '#666';
                                const r = parseInt(color.slice(1, 3), 16);
                                const g = parseInt(color.slice(3, 5), 16);
                                const b = parseInt(color.slice(5, 7), 16);
                                return `rgba(${r}, ${g}, ${b}, 0.6)`;
                            }),
                            borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                            borderWidth: 2,
                            pointRadius: 8,
                            pointHoverRadius: 10,
                            pointStyle: 'circle',
                            pointBorderWidth: 2,
                            shadowOffsetX: 0,
                            shadowOffsetY: 0,
                            shadowBlur: 12,
                            shadowColor: data.map(d => teamColors[d.player.team] || '#666')
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const player = data[elements[0].index].player;
                            openPlayerModal(player.id);
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const player = context.raw.player;
                                    return [
                                        player.name,
                                        `Volume: ${context.parsed.x.toFixed(0)}`,
                                        `Efficiency: ${context.parsed.y.toFixed(2)} pts/opp`,
                                        `AVG: ${player.avgPoints.toFixed(1)}`
                                    ];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                vLine: {
                                    type: 'line',
                                    xMin: medianX,
                                    xMax: medianX,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                hLine: {
                                    type: 'line',
                                    yMin: medianY,
                                    yMax: medianY,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                topRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: [position === 'wr' ? 'Safe Floor' : 'Volume RBs'],
                                    color: '#FFD60A',
                                    font: { size: 9, weight: 'bold' }
                                },
                                topLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: ['Efficient'],
                                    color: '#0a84ff',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: [''],
                                    color: '#FFD60A',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: [''],
                                    color: '#ff453a',
                                    font: { size: 9, weight: 'bold' }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: position === 'wr' ? 'Total Targets →' : 'Total Opportunities →',
                                color: '#8e8e93',
                                font: { weight: 'bold' }
                            },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianX) < 1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Efficiency (Points per Opportunity) →',
                                color: '#8e8e93',
                                font: { weight: 'bold' }
                            },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianY) < 0.1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }
        
        // Matrix 2: Share vs Team Strength
        function renderShareMatrix(position) {
            const canvasId = position === 'wr' ? 'wr-share-matrix' : 'rb-share-matrix';
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;
            
            const players = position === 'wr' ? 
                Object.values(aggregatedWRs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50) :
                Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);
            
            // Calculate team total points
            const teamTotals = {};
            Object.values(allPlayers).forEach(p => {
                if (!teamTotals[p.team]) teamTotals[p.team] = 0;
                teamTotals[p.team] += p.totalPoints;
            });
            
            const data = players.map(player => ({
                x: player.latestWeekOppShare,
                y: teamTotals[player.team] || 0,
                label: player.name,
                player: player
            }));
            
            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];
            
            const chartVar = position === 'wr' ? 'wrShareMatrix' : 'rbShareMatrix';
            if (window[chartVar]) window[chartVar].destroy();
            
            window[chartVar] = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(d => {
                            const color = teamColors[d.player.team] || '#666';
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, 0.6)`;
                        }),
                        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            openPlayerModal(data[elements[0].index].player.id);
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    return [p.name, `Share: ${context.parsed.x.toFixed(1)}%`, `Team Total: ${context.parsed.y.toFixed(0)}`, `AVG: ${p.avgPoints.toFixed(1)}`];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                vLine: {
                                    type: 'line',
                                    xMin: medianX,
                                    xMax: medianX,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                hLine: {
                                    type: 'line',
                                    yMin: medianY,
                                    yMax: medianY,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                topRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: [position === 'rb' ? 'Elite RB1' : ''],
                                    color: '#30d158',
                                    font: { size: 9, weight: 'bold' }
                                },
                                topLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: [position === 'wr' ? 'Big piece of small pie' : 'Good offense low share'],
                                    color: position === 'wr' ? '#FFD60A' : '#0a84ff',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: [position === 'wr' ? 'Small piece of big pie' : 'Bellcow, bad offense'],
                                    color: position === 'wr' ? '#0a84ff' : '#FFD60A',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: [position === 'wr' ? 'Limited role on bad offense' : 'Avoid'],
                                    color: '#ff453a',
                                    font: { size: 9, weight: 'bold' }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Opportunity Share % →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianX) < 1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: { display: true, text: 'Team Total Points →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianY) < 1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }
        
        // Matrix 3: Floor vs Ceiling
        function renderFloorMatrix(position) {
            const canvasId = position === 'wr' ? 'wr-floor-matrix' : 'rb-floor-matrix';
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;
            
            const players = position === 'wr' ? 
                Object.values(aggregatedWRs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50) :
                Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);
            
            const data = players.map(player => {
                const variances = player.weeks.map(w => w.variance);
                const stdDev = Math.sqrt(variances.reduce((sum, v) => sum + Math.pow(v, 2), 0) / variances.length);
                const consistency = 10 / (stdDev + 1); // Higher is more consistent
                
                return {
                    x: player.avgPoints,
                    y: consistency,
                    label: player.name,
                    player: player,
                    stdDev: stdDev
                };
            });
            
            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];
            
            const chartVar = position === 'wr' ? 'wrFloorMatrix' : 'rbFloorMatrix';
            if (window[chartVar]) window[chartVar].destroy();
            
            window[chartVar] = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(d => {
                            const color = teamColors[d.player.team] || '#666';
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, 0.6)`;
                        }),
                        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            openPlayerModal(data[elements[0].index].player.id);
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const d = data[context.dataIndex];
                                    return [d.player.name, `Ceiling: ${context.parsed.x.toFixed(1)}`, `Floor Score: ${context.parsed.y.toFixed(1)}`, `Std Dev: ${d.stdDev.toFixed(2)}`];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                vLine: {
                                    type: 'line',
                                    xMin: medianX,
                                    xMax: medianX,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                hLine: {
                                    type: 'line',
                                    yMin: medianY,
                                    yMax: medianY,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Average Points (Ceiling) →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianX) < 1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: { display: true, text: 'Consistency Score (Floor) →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianY) < 0.1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }
        
        // Matrix 4: Red Zone Usage vs Efficiency
        function renderRedzoneMatrix(position) {
            const canvasId = position === 'wr' ? 'wr-redzone-matrix' : 'rb-redzone-matrix';
            const ctx = document.getElementById(canvasId);
            if (!ctx) return;
            
            const players = position === 'wr' ? 
                Object.values(aggregatedWRs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50) :
                Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);
            
            const data = players.map(player => {
                let xValue, yValue;
                
                if (position === 'wr') {
                    // NEW: Total Targets (x) vs RZ Targets (y)
                    xValue = player.totalTargets;
                    yValue = player.rzOpportunities;
                } else {
                    // RB: Keep existing (RZ opps per game vs PPG)
                    xValue = player.rzOpportunities / player.gamesPlayed; // RZ opps per game
                    yValue = player.avgPoints / player.gamesPlayed; // Points per game
                }
                
                return {
                    x: xValue,
                    y: yValue,
                    label: player.name,
                    player: player
                };
            });
            
            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];
            
            const chartVar = position === 'wr' ? 'wrRedzoneMatrix' : 'rbRedzoneMatrix';
            if (window[chartVar]) window[chartVar].destroy();
            
            window[chartVar] = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(d => {
                            const color = teamColors[d.player.team] || '#666';
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, 0.6)`;
                        }),
                        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            openPlayerModal(data[elements[0].index].player.id);
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    if (position === 'wr') {
                                        return [p.name, `Total Targets: ${context.parsed.x}`, `RZ Targets: ${context.parsed.y}`, `AVG: ${p.avgPoints.toFixed(1)}`];
                                    } else {
                                        return [p.name, `RZ/Game: ${context.parsed.x.toFixed(1)}`, `PPG: ${context.parsed.y.toFixed(1)}`, `Total RZ: ${p.rzOpportunities}`];
                                    }
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                vLine: {
                                    type: 'line',
                                    xMin: medianX,
                                    xMax: medianX,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                hLine: {
                                    type: 'line',
                                    yMin: medianY,
                                    yMax: medianY,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                topRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: ['Elite RZ usage'],
                                    color: '#30d158',
                                    font: { size: 13, weight: 'bold' }
                                },
                                topLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.2,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: position === 'wr' ? ['High scoring low RZ'] : ['Efficient but no RZ'],
                                    color: '#0a84ff',
                                    font: { size: 13, weight: 'bold' }
                                },
                                bottomRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.min(...yValues) + (Math.max(...yValues) - Math.min(...yValues)) * 0.15,
                                    content: position === 'rb' ? ['Buy low candidates'] : [''],
                                    color: '#FFD60A',
                                    font: { size: 13, weight: 'bold' }
                                },
                                bottomLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.2,
                                    yValue: Math.min(...yValues) + (Math.max(...yValues) - Math.min(...yValues)) * 0.15,
                                    content: ['Low production'],
                                    color: '#ff453a',
                                    font: { size: 13, weight: 'bold' }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { 
                                display: true, 
                                text: position === 'wr' ? 'Total Targets →' : 'Red Zone Opportunities per Game →', 
                                color: '#8e8e93', 
                                font: { weight: 'bold' } 
                            },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianX) < 0.1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: { 
                                display: true, 
                                text: position === 'wr' ? 'Red Zone Targets →' : 'Total Fantasy Points per Game →', 
                                color: '#8e8e93', 
                                font: { weight: 'bold' } 
                            },
                            grid: { color: '#2c2c2e', lineWidth: function(context) {
                                return Math.abs(context.tick.value - medianY) < 1 ? 2 : 1;
                            }},
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }
        
        // WR-Specific Matrix: Volume Monster (Target Share vs Targets per Game)
        function renderVolumeMonsterMatrix() {
            const ctx = document.getElementById('wr-volume-monster-matrix');
            if (!ctx) return;
            
            const wrs = Object.values(aggregatedWRs)
                .filter(p => p.gamesPlayed >= 3)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 50);
            
            const data = wrs.map(player => ({
                x: player.latestWeekOppShare,
                y: player.tgtPerGame,
                label: player.name,
                player: player
            }));
            
            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];
            
            if (wrVolumeMonsterMatrix) wrVolumeMonsterMatrix.destroy();
            
            wrVolumeMonsterMatrix = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(d => {
                            const color = teamColors[d.player.team] || '#666';
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, 0.6)`;
                        }),
                        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
                    onClick: (event, elements) => {
                        if (elements.length > 0) openPlayerModal(data[elements[0].index].player.id);
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    return [p.name, `Target Share: ${context.parsed.x.toFixed(1)}%`, `TGT/G: ${context.parsed.y.toFixed(1)}`, `AVG: ${p.avgPoints.toFixed(1)}`];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                vLine: {
                                    type: 'line',
                                    xMin: medianX,
                                    xMax: medianX,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                hLine: {
                                    type: 'line',
                                    yMin: medianY,
                                    yMax: medianY,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                topRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: ['Volume Monster'],
                                    color: '#30d158',
                                    font: { size: 9, weight: 'bold' }
                                },
                                topLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: ['High Volume, Low Share'],
                                    color: '#0a84ff',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: ['Concentrated Targets'],
                                    color: '#FFD60A',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: ['Limited Role'],
                                    color: '#ff453a',
                                    font: { size: 9, weight: 'bold' }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Target Share % (Latest Week) →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: { display: true, text: 'Targets per Game →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }
        
        // WR-Specific Matrix: Catch Rate (Air Yards per Game vs Catch Rate)
        function renderCatchRateMatrix() {
            const ctx = document.getElementById('wr-catch-rate-matrix');
            if (!ctx) return;
            
            const wrs = Object.values(aggregatedWRs)
                .filter(p => p.gamesPlayed >= 3)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 50);
            
            const data = wrs.map(player => ({
                x: player.airYardsPerGame,
                y: player.catchRate,
                label: player.name,
                player: player
            }));
            
            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];
            
            if (wrCatchRateMatrix) wrCatchRateMatrix.destroy();
            
            wrCatchRateMatrix = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(d => {
                            const color = teamColors[d.player.team] || '#666';
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, 0.6)`;
                        }),
                        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
                    onClick: (event, elements) => {
                        if (elements.length > 0) openPlayerModal(data[elements[0].index].player.id);
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    return [p.name, `Air Yds/G: ${context.parsed.x.toFixed(1)}`, `Catch Rate: ${context.parsed.y.toFixed(1)}%`, `AVG: ${p.avgPoints.toFixed(1)}`];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                vLine: {
                                    type: 'line',
                                    xMin: medianX,
                                    xMax: medianX,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                hLine: {
                                    type: 'line',
                                    yMin: medianY,
                                    yMax: medianY,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                topRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: ['Deep Threats'],
                                    color: '#30d158',
                                    font: { size: 9, weight: 'bold' }
                                },
                                topLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.max(...yValues) * 0.9,
                                    content: ['Reliable Hands'],
                                    color: '#0a84ff',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomRight: {
                                    type: 'label',
                                    xValue: Math.max(...xValues) * 0.9,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: ['Contested Catches'],
                                    color: '#FFD60A',
                                    font: { size: 9, weight: 'bold' }
                                },
                                bottomLeft: {
                                    type: 'label',
                                    xValue: Math.min(...xValues) * 1.1,
                                    yValue: Math.min(...yValues) * 1.1,
                                    content: ['Drop Issues'],
                                    color: '#ff453a',
                                    font: { size: 9, weight: 'bold' }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Air Yards per Game →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: { display: true, text: 'Catch Rate % →', color: '#8e8e93', font: { weight: 'bold' } },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }
        
        // RB-Specific Matrix: Talent vs Situation (YBCON vs YACON)
        function renderTalentSituationMatrix() {
            const ctx = document.getElementById('rb-talent-matrix');
            if (!ctx) return;
            
            const rbs = Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);
            
            const data = rbs.map(player => {
                const playerRows = rbData.filter(row => row.Team === player.team && row.Player === player.name);
                let totalYBCON = 0, totalYACON = 0, totalATT = 0;
                playerRows.forEach(row => {
                    totalYBCON += parseFloat(row.YBCON) || 0;
                    totalYACON += parseFloat(row.YACON) || 0;
                    totalATT += parseFloat(row.ATT) || 0;
                });
                return {
                    x: totalATT > 0 ? totalYBCON / totalATT : 0,
                    y: totalATT > 0 ? totalYACON / totalATT : 0,
                    label: player.name,
                    player: player
                };
            });
            
            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];
            
            if (rbTalentMatrix) rbTalentMatrix.destroy();
            
            rbTalentMatrix = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(d => {
                            const color = teamColors[d.player.team] || '#666';
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, 0.6)`;
                        }),
                        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) openPlayerModal(data[elements[0].index].player.id);
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    return [p.name, `YBCON/ATT: ${context.parsed.x.toFixed(2)}`, `YACON/ATT: ${context.parsed.y.toFixed(2)}`, `AVG: ${p.avgPoints.toFixed(1)}`];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Yards Before Contact per Attempt (O-Line Quality) →', color: '#8e8e93' },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: { display: true, text: 'Yards After Contact per Attempt (RB Talent) →', color: '#8e8e93' },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                },
                plugins: [{
                    id: 'quadrantLabels',
                    afterDraw: (chart) => {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const xAxis = chart.scales.x;
                        const yAxis = chart.scales.y;
                        const xMid = xAxis.getPixelForValue(medianX);
                        const yMid = yAxis.getPixelForValue(medianY);
                        
                        // Draw dotted median lines (2px thick)
                        ctx.strokeStyle = '#8e8e93';
                        ctx.setLineDash([5, 5]);
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(xMid, chartArea.top);
                        ctx.lineTo(xMid, chartArea.bottom);
                        ctx.moveTo(chartArea.left, yMid);
                        ctx.lineTo(chartArea.right, yMid);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Add corner labels (9px font, colored)
                        ctx.font = 'bold 9px -apple-system, BlinkMacSystemFont, sans-serif';
                        
                        // Top-right: Elite Situation + Talent (GREEN)
                        ctx.fillStyle = '#30d158';
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'top';
                        ctx.fillText('Elite', chartArea.right - 5, chartArea.top + 5);
                        
                        // Top-left: Elite Talent (BLUE)
                        ctx.fillStyle = '#0a84ff';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        ctx.fillText('Elite Talent', chartArea.left + 5, chartArea.top + 5);
                        
                        // Bottom-right: Elite Situation (YELLOW)
                        ctx.fillStyle = '#FFD60A';
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'bottom';
                        ctx.fillText('Elite Situation', chartArea.right - 5, chartArea.bottom - 5);
                        
                        // Bottom-left: Avoid (RED)
                        ctx.fillStyle = '#ff453a';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'bottom';
                        ctx.fillText('Avoid', chartArea.left + 5, chartArea.bottom - 5);
                    }
                }]
            });
        }
        
        // RB-Specific Matrix: Opportunity vs Efficiency (Touch Share vs YAC)
        function renderOpportunityEfficiencyMatrix() {
            const ctx = document.getElementById('rb-opportunity-matrix');
            if (!ctx) return;
            
            const rbs = Object.values(aggregatedRBs).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 50);
            
            const data = rbs.map(player => {
                const playerRows = rbData.filter(row => row.Team === player.team && row.Player === player.name);
                let totalYACON = 0, totalATT = 0;
                playerRows.forEach(row => {
                    totalYACON += parseFloat(row.YACON) || 0;
                    totalATT += parseFloat(row.ATT) || 0;
                });
                return {
                    x: player.latestWeekOppShare,
                    y: totalATT > 0 ? totalYACON / totalATT : 0,
                    label: player.name,
                    player: player
                };
            });
            
            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            const medianX = xValues[Math.floor(xValues.length / 2)];
            const medianY = yValues[Math.floor(yValues.length / 2)];
            
            if (rbOpportunityMatrix) rbOpportunityMatrix.destroy();
            
            rbOpportunityMatrix = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        data: data,
                        backgroundColor: data.map(d => {
                            const color = teamColors[d.player.team] || '#666';
                            const r = parseInt(color.slice(1, 3), 16);
                            const g = parseInt(color.slice(3, 5), 16);
                            const b = parseInt(color.slice(5, 7), 16);
                            return `rgba(${r}, ${g}, ${b}, 0.6)`;
                        }),
                        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                        borderWidth: 2,
                        pointRadius: 8,
                        pointHoverRadius: 10
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) openPlayerModal(data[elements[0].index].player.id);
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    return [p.name, `Touch Share: ${context.parsed.x.toFixed(1)}%`, `YAC/ATT: ${context.parsed.y.toFixed(2)}`, `AVG: ${p.avgPoints.toFixed(1)}`];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Touch Share % →', color: '#8e8e93' },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: { display: true, text: 'Yards After Contact per Attempt →', color: '#8e8e93' },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                },
                plugins: [{
                    id: 'quadrantLabels',
                    afterDraw: (chart) => {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const xAxis = chart.scales.x;
                        const yAxis = chart.scales.y;
                        const xMid = xAxis.getPixelForValue(medianX);
                        const yMid = yAxis.getPixelForValue(medianY);
                        
                        // Draw dotted median lines (2px thick)
                        ctx.strokeStyle = '#8e8e93';
                        ctx.setLineDash([5, 5]);
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(xMid, chartArea.top);
                        ctx.lineTo(xMid, chartArea.bottom);
                        ctx.moveTo(chartArea.left, yMid);
                        ctx.lineTo(chartArea.right, yMid);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Add corner labels (9px font, colored)
                        ctx.font = 'bold 9px -apple-system, BlinkMacSystemFont, sans-serif';
                        
                        // Top-right: Elite (GREEN)
                        ctx.fillStyle = '#30d158';
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'top';
                        ctx.fillText('Elite', chartArea.right - 5, chartArea.top + 5);
                        
                        // Top-left: Inefficient Volume (BLUE)
                        ctx.fillStyle = '#0a84ff';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'top';
                        ctx.fillText('Inefficient', chartArea.left + 5, chartArea.top + 5);
                        
                        // Bottom-right: Boom-Bust (YELLOW)
                        ctx.fillStyle = '#FFD60A';
                        ctx.textAlign = 'right';
                        ctx.textBaseline = 'bottom';
                        ctx.fillText('Boom-Bust', chartArea.right - 5, chartArea.bottom - 5);
                        
                        // Bottom-left: Fade (RED)
                        ctx.fillStyle = '#ff453a';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'bottom';
                        ctx.fillText('Fade', chartArea.left + 5, chartArea.bottom - 5);
                    }
                }]
            });
        }

        function renderWRScatter() {
            const ctx = document.getElementById('wr-scatter-chart');
            if (!ctx) return;
            
            // Get top 36 WRs by avg points
            const wrs = Object.values(aggregatedWRs)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 50);
            
            const data = wrs.map(player => ({
                x: player.totalTargets,
                y: player.rzOpportunities,
                label: player.name,
                player: player
            }));
            
            // Calculate linear regression for diagonal trendline
            const regression = calculateLinearRegression(data);
            const minX = Math.min(...data.map(d => d.x));
            const maxX = Math.max(...data.map(d => d.x));
            const trendlineData = [
                { x: minX, y: regression.slope * minX + regression.intercept },
                { x: maxX, y: regression.slope * maxX + regression.intercept }
            ];
            
            if (wrScatterChart) {
                wrScatterChart.destroy();
            }
            
            wrScatterChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Wide Receivers',
                            data: data,
                            backgroundColor: data.map(d => {
                                const color = teamColors[d.player.team] || '#666';
                                // Convert hex to rgba with 0.3 opacity
                                const r = parseInt(color.slice(1, 3), 16);
                                const g = parseInt(color.slice(3, 5), 16);
                                const b = parseInt(color.slice(5, 7), 16);
                                return `rgba(${r}, ${g}, ${b}, 0.6)`;
                            }),
                            borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                            borderWidth: 2,
                            pointRadius: 8,
                            pointHoverRadius: 10
                        },
                        {
                            label: 'Trendline',
                            type: 'line',
                            data: trendlineData,
                            borderColor: '#FFD60A',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0 && elements[0].datasetIndex === 0) {
                            const index = elements[0].index;
                            const player = data[index].player;
                            openPlayerModal(player.id);
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.datasetIndex === 1) return 'Trendline';
                                    const player = context.raw.player;
                                    return [
                                        player.name,
                                        `Targets: ${player.totalTargets}`,
                                        `RZ Targets: ${player.rzOpportunities}`,
                                        `AVG: ${player.avgPoints.toFixed(1)}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Total Season Targets',
                                color: '#8e8e93'
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Red Zone Targets',
                                color: '#8e8e93'
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
            
            // Add labels for top 8 players
            const chartArea = wrScatterChart.chartArea;
            const ctx2d = wrScatterChart.ctx;
            
            wrs.slice(0, 8).forEach((player, idx) => {
                const meta = wrScatterChart.getDatasetMeta(0);
                const point = meta.data[idx];
                if (point && chartArea) {
                    ctx2d.save();
                    ctx2d.fillStyle = '#fff';
                    ctx2d.font = '11px -apple-system, sans-serif';
                    ctx2d.textAlign = 'center';
                    ctx2d.fillText(player.name.split(' ').pop(), point.x, point.y - 12);
                    ctx2d.restore();
                }
            });
        }

        function renderRBScatter() {
            const ctx = document.getElementById('rb-scatter-chart');
            if (!ctx) return;
            
            // Get top 36 RBs by avg points
            const rbs = Object.values(aggregatedRBs)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 50);
            
            const data = rbs.map(player => ({
                x: player.totalOpportunities,
                y: player.rzOpportunities,
                label: player.name,
                player: player
            }));
            
            // Calculate linear regression for diagonal trendline
            const regression = calculateLinearRegression(data);
            const minX = Math.min(...data.map(d => d.x));
            const maxX = Math.max(...data.map(d => d.x));
            const trendlineData = [
                { x: minX, y: regression.slope * minX + regression.intercept },
                { x: maxX, y: regression.slope * maxX + regression.intercept }
            ];
            
            if (rbScatterChart) {
                rbScatterChart.destroy();
            }
            
            rbScatterChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Running Backs',
                            data: data,
                            backgroundColor: data.map(d => {
                                const color = teamColors[d.player.team] || '#666';
                                // Convert hex to rgba with 0.3 opacity
                                const r = parseInt(color.slice(1, 3), 16);
                                const g = parseInt(color.slice(3, 5), 16);
                                const b = parseInt(color.slice(5, 7), 16);
                                return `rgba(${r}, ${g}, ${b}, 0.6)`;
                            }),
                            borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                            borderWidth: 2,
                            pointRadius: 8,
                            pointHoverRadius: 10
                        },
                        {
                            label: 'Trendline',
                            type: 'line',
                            data: trendlineData,
                            borderColor: '#FFD60A',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0 && elements[0].datasetIndex === 0) {
                            const index = elements[0].index;
                            const player = data[index].player;
                            openPlayerModal(player.id);
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.datasetIndex === 1) return 'Trendline';
                                    const player = context.raw.player;
                                    return [
                                        player.name,
                                        `Opportunities: ${player.totalOpportunities}`,
                                        `RZ Opportunities: ${player.rzOpportunities}`,
                                        `AVG: ${player.avgPoints.toFixed(1)}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Total Season Opportunities',
                                color: '#8e8e93'
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Red Zone Opportunities',
                                color: '#8e8e93'
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
            
            // Add labels for top 8 players
            const chartArea = rbScatterChart.chartArea;
            const ctx2d = rbScatterChart.ctx;
            
            rbs.slice(0, 8).forEach((player, idx) => {
                const meta = rbScatterChart.getDatasetMeta(0);
                const point = meta.data[idx];
                if (point && chartArea) {
                    ctx2d.save();
                    ctx2d.fillStyle = '#fff';
                    ctx2d.font = '11px -apple-system, sans-serif';
                    ctx2d.textAlign = 'center';
                    ctx2d.fillText(player.name.split(' ').pop(), point.x, point.y - 12);
                    ctx2d.restore();
                }
            });
        }
        
        function renderTeamBalanceScatter() {
            const ctx = document.getElementById('team-balance-scatter');
            if (!ctx) {
                console.log('Team balance scatter: canvas not found');
                return;
            }
            if (!wrData || !rbData) {
                console.log('Team balance scatter: wrData or rbData is null');
                return;
            }
            
            // Destroy existing chart if it exists
            const existingChart = Chart.getChart(ctx);
            if (existingChart) {
                existingChart.destroy();
            }
            
            // Aggregate team data (all weeks combined for season totals)
            const teamData = {};
            
            // Calculate total targets and points per team from WR data (exclude FA)
            wrData.forEach(row => {
                const team = row.Team;
                if (team === 'FA' || !team) return;
                if (!teamData[team]) {
                    teamData[team] = { team: team, targets: 0, rushOpps: 0, totalPoints: 0 };
                }
                teamData[team].targets += parseFloat(row.TGT) || 0;
                teamData[team].totalPoints += parseFloat(row.FPTS || row.Fpts) || 0; // Handle both cases
            });
            
            // Calculate total rush opportunities and points per team from RB data (exclude FA)
            rbData.forEach(row => {
                const team = row.Team;
                if (team === 'FA' || !team) return;
                if (!teamData[team]) {
                    teamData[team] = { team: team, targets: 0, rushOpps: 0, totalPoints: 0 };
                }
                teamData[team].rushOpps += parseFloat(row['RB Opp']) || 0;
                teamData[team].totalPoints += parseFloat(row.FPTS || row.Fpts) || 0; // Handle both cases
            });
            
            const teams = Object.values(teamData);
            console.log('Team balance scatter - teams count:', teams.length);
            console.log('Team balance scatter - sample data:', teams.slice(0, 3));
            
            // Find min and max points for scaling
            const allPoints = teams.map(t => t.totalPoints);
            const minPoints = Math.min(...allPoints);
            const maxPoints = Math.max(...allPoints);
            
            console.log('Points range for bubble sizing:', minPoints, 'to', maxPoints);
            
            // Create scatter data with point-based radius
            const scatterData = teams.map(team => {
                // Scale radius from 8 to 20 based on total points
                const normalizedPoints = (team.totalPoints - minPoints) / (maxPoints - minPoints);
                const radius = 8 + (normalizedPoints * 12); // Range: 8-20
                
                return {
                    x: team.targets,
                    y: team.rushOpps,
                    r: radius, // For bubble chart
                    team: team.team,
                    totalPoints: team.totalPoints
                };
            });
            
            console.log('Scatter data sample with radius:', scatterData.slice(0, 3));
            
            // Calculate medians
            const sortedTargets = teams.map(t => t.targets).sort((a, b) => a - b);
            const sortedOpps = teams.map(t => t.rushOpps).sort((a, b) => a - b);
            const medianTargets = sortedTargets[Math.floor(sortedTargets.length / 2)];
            const medianOpps = sortedOpps[Math.floor(sortedOpps.length / 2)];
            
            new Chart(ctx, {
                type: 'bubble',
                data: {
                    datasets: [{
                        data: scatterData,
                        backgroundColor: scatterData.map(d => {
                            const color = teamColors[d.team] || '#0a84ff';
                            return color + '99'; // 60% opacity
                        }),
                        borderColor: scatterData.map(d => teamColors[d.team] || '#0a84ff'),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const data = context.raw;
                                    return [
                                        data.team,
                                        `Targets: ${data.x.toFixed(0)}`,
                                        `Rush Opps: ${data.y.toFixed(0)}`,
                                        `Total Points: ${data.totalPoints.toFixed(1)}`
                                    ];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                vLine: {
                                    type: 'line',
                                    xMin: medianTargets,
                                    xMax: medianTargets,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                },
                                hLine: {
                                    type: 'line',
                                    yMin: medianOpps,
                                    yMax: medianOpps,
                                    borderColor: '#8e8e93',
                                    borderWidth: 2,
                                    borderDash: [5, 5]
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Total Pass Targets',
                                color: '#8e8e93',
                                font: { size: 12, weight: 'bold' }
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Total Rush Opportunities',
                                color: '#8e8e93',
                                font: { size: 12, weight: 'bold' }
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const dataIndex = elements[0].index;
                            const teamCode = scatterData[dataIndex].team;
                            openTeamModal(teamCode);
                        }
                    }
                }
            });
        }

        // ============================================
        // TEAM ANALYSIS FUNCTIONS
        // ============================================
        
        // Helper function to generate color variations from team palette
        function generateTeamColorVariations(team, count) {
            const primaryColor = teamColors[team];
            
            if (!primaryColor) {
                // Fallback for unknown teams - use gray shades
                return Array.from({length: count}, (_, i) => {
                    const lightness = 40 + (i * (70 / count));
                    return `hsl(0, 0%, ${lightness}%)`;
                });
            }
            
            // Special case: single player uses team primary color
            if (count === 1) {
                return [primaryColor];
            }
            
            // Convert hex to HSL
            const hexToHSL = (hex) => {
                hex = hex.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16) / 255;
                const g = parseInt(hex.substr(2, 2), 16) / 255;
                const b = parseInt(hex.substr(4, 2), 16) / 255;
                
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;
                
                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    
                    switch (max) {
                        case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                        case g: h = ((b - r) / d + 2) / 6; break;
                        case b: h = ((r - g) / d + 4) / 6; break;
                    }
                }
                
                return [h * 360, s * 100, l * 100];
            };
            
            const [baseHue, baseSat, baseLightness] = hexToHSL(primaryColor);
            
            // Generate count colors from primary to off-white
            // Start with primary color, progressively lighten and desaturate
            const colors = [];
            
            for (let i = 0; i < count; i++) {
                const progress = i / (count - 1); // 0 to 1
                
                // Keep hue constant
                const h = baseHue;
                
                // Gradually decrease saturation from base to ~20% (near gray)
                const s = baseSat * (1 - progress * 0.7); // Keep some saturation
                
                // Gradually increase lightness from base to ~85% (off-white)
                const targetLightness = 85;
                const l = baseLightness + (targetLightness - baseLightness) * progress;
                
                colors.push(`hsl(${h}, ${s}%, ${l}%)`);
            }
            
            return colors;
        }
        
        // Initialize Team Analysis
        function initializeTeamAnalysis() {
            if (!wrData || !rbData) return;
            
            // Populate team selector
            const teams = [...new Set([...wrData, ...rbData].map(row => row.Team).filter(t => t && t !== 'FA'))].sort();
            const teamSelect = document.getElementById('team-select');
            teamSelect.innerHTML = '';
            teams.forEach(team => {
                const option = document.createElement('option');
                option.value = team;
                option.textContent = team;
                teamSelect.appendChild(option);
            });
            
            // Set first team as default
            if (teams.length > 0) {
                currentTeamAnalysisTeam = teams[0];
                teamSelect.value = teams[0];
            }
            
            // Populate week selector
            const weeks = [...new Set([...wrData, ...rbData].map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);
            const weekSelect = document.getElementById('week-select');
            weekSelect.innerHTML = '';
            weeks.forEach(week => {
                const option = document.createElement('option');
                option.value = week;
                option.textContent = `Week ${week}`;
                weekSelect.appendChild(option);
            });
            
            // Set most recent week as default
            if (weeks.length > 0) {
                weekSelect.value = weeks[weeks.length - 1];
            }
            
            // Render initial charts
            updateTeamAnalysis();
        }
        
        // Toggle League Comparison
        function toggleLeagueComparison() {
            leagueComparisonEnabled = !leagueComparisonEnabled;
            
            const toggleBtn = document.getElementById('league-comparison-toggle');
            const icon = document.getElementById('league-comparison-icon');
            
            if (leagueComparisonEnabled) {
                toggleBtn.style.background = 'var(--positive)';
                toggleBtn.style.borderColor = 'var(--positive)';
                toggleBtn.style.color = 'white';
                icon.textContent = '●';
            } else {
                toggleBtn.style.background = 'var(--bg-tertiary)';
                toggleBtn.style.borderColor = 'var(--border-color)';
                toggleBtn.style.color = 'var(--text-secondary)';
                icon.textContent = '○';
            }
            
            updateTeamAnalysis();
        }
        
        // Update Team Analysis based on selections
        function updateTeamAnalysis() {
            const team = document.getElementById('team-select').value;
            const position = document.getElementById('position-group-select').value;
            const timeFrame = document.getElementById('time-frame-select').value;
            const week = parseInt(document.getElementById('week-select').value);
            
            currentTeamAnalysisTeam = team;
            
            // Show/hide week selector based on time frame
            const weekContainer = document.getElementById('week-select-container');
            weekContainer.style.display = timeFrame === 'single' ? 'block' : 'none';
            
            // Disable/enable league comparison toggle for season long
            const leagueToggleBtn = document.getElementById('league-comparison-toggle');
            if (timeFrame === 'season') {
                leagueToggleBtn.disabled = true;
                leagueToggleBtn.style.opacity = '0.4';
                leagueToggleBtn.style.cursor = 'not-allowed';
            } else {
                leagueToggleBtn.disabled = false;
                leagueToggleBtn.style.opacity = '1';
                leagueToggleBtn.style.cursor = 'pointer';
            }
            
            // Update title
            const titleEl = document.getElementById('team-chart-title');
            const descEl = document.getElementById('team-chart-description');
            
            const positionLabel = (position === 'WR' || position === 'TE') ? 'Target' : 'Opportunity';
            let timeLabel = '';
            
            if (timeFrame === 'single') {
                timeLabel = `Week ${week}`;
            } else if (timeFrame === 'last3') {
                timeLabel = 'Last 3 Weeks';
            } else if (timeFrame === 'last5') {
                timeLabel = 'Last 5 Weeks';
            } else {
                timeLabel = 'Season Long';
            }
            
            titleEl.textContent = `${team} ${position} ${positionLabel} Distribution - ${timeLabel}`;
            
            // Add description based on position
            if (position === 'WR' || position === 'TE') {
                descEl.textContent = `Showing top 4 pass catchers (WR/RB/TE) by target share - all positions compete for targets`;
            } else {
                descEl.textContent = `Showing RB opportunity distribution (rush attempts + targets)`;
            }
            
            // Render appropriate charts
            if (timeFrame === 'season') {
                renderSeasonLongChart(team, position);
            } else {
                renderPieAndBarCharts(team, position, timeFrame, week);
            }
        }
        
        // Render Pie and Bar Charts (for single week, last3, last5)
        function renderPieAndBarCharts(team, position, timeFrame, week) {
            // Reset grid layout to 50/50 for dual charts
            const container = document.getElementById('team-charts-container');
            container.style.gridTemplateColumns = '1fr 1fr';
            document.getElementById('team-secondary-chart-wrapper').style.display = 'block';
            
            // For WR and TE charts, include ALL pass catchers (WR/RB/TE) for accurate target share
            // For RB charts, use only RB data for opportunities
            let combinedData;
            if (position === 'WR' || position === 'TE') {
                // Include all positions that receive targets
                combinedData = [...wrData, ...rbData];
                if (teData) {
                    combinedData = [...combinedData, ...teData];
                }
            } else {
                combinedData = rbData;
            }
            
            // Filter data based on time frame
            let filteredData;
            if (timeFrame === 'single') {
                filteredData = combinedData.filter(row => row.Team === team && parseInt(row.Week) === week);
            } else {
                const weeks = [...new Set(combinedData.map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);
                const latestWeek = Math.max(...weeks);
                const weeksToInclude = timeFrame === 'last3' ? 3 : 5;
                const startWeek = latestWeek - weeksToInclude + 1;
                filteredData = combinedData.filter(row => row.Team === team && parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek);
            }
            
            // Calculate player shares
            const playerStats = {};
            filteredData.forEach(row => {
                const player = row.Player;
                if (!playerStats[player]) {
                    playerStats[player] = { targets: 0, opportunities: 0, position: row.Pos };
                }
                
                if (position === 'WR' || position === 'TE') {
                    // For WR/TE view, count targets for all pass catchers
                    playerStats[player].targets += parseFloat(row.TGT) || 0;
                } else {
                    playerStats[player].opportunities += parseFloat(row['RB Opp']) || 0;
                }
            });
            
            // Convert to array and sort
            const playerArray = Object.entries(playerStats).map(([name, stats]) => ({
                name,
                value: (position === 'WR' || position === 'TE') ? stats.targets : stats.opportunities,
                position: stats.position
            })).sort((a, b) => b.value - a.value);
            
            const totalValue = playerArray.reduce((sum, p) => sum + p.value, 0);
            
            // For WR/TE views (showing all pass catchers), take top 4 players
            // For RB views, take top 5 players
            const topCount = (position === 'WR' || position === 'TE') ? 4 : 5;
            const topPlayers = playerArray.slice(0, topCount);
            const otherValue = playerArray.slice(topCount).reduce((sum, p) => sum + p.value, 0);
            
            // Build chart data
            let chartData = [...topPlayers];
            if (otherValue > 0) {
                chartData.push({ name: 'Other', value: otherValue, position: 'Other' });
            }
            
            // Render pie chart
            renderTeamPieChart(chartData, totalValue, position);
            
            // Render bar chart or league comparison
            if (leagueComparisonEnabled) {
                renderLeagueComparison(team, position, timeFrame, week, totalValue);
            } else {
                renderTeamBarChart(chartData, position);
            }
        }
        
        // Render Pie Chart
        function renderTeamPieChart(chartData, totalValue, position) {
            const canvas = document.getElementById('team-pie-chart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Destroy existing chart
            if (teamAnalysisCharts.pie) {
                teamAnalysisCharts.pie.destroy();
            }
            
            const labels = chartData.map(d => d.name);
            const values = chartData.map(d => d.value);
            const percentages = chartData.map(d => ((d.value / totalValue) * 100).toFixed(1));
            
            // Generate color variations based on team color palette
            const playerCount = chartData.filter(d => d.name !== 'Other').length;
            const teamColorVariations = generateTeamColorVariations(currentTeamAnalysisTeam, playerCount);
            
            // Create colors with opacity for fills
            // Use higher opacity (85%) for single player so team color is clearly visible
            const opacity = playerCount === 1 ? 0.85 : 0.45;
            
            const fillColors = chartData.map((d, i) => {
                if (d.name === 'Other') return 'rgba(99, 99, 102, 0.45)';
                const baseColor = teamColorVariations[i];
                // Convert to rgba with appropriate opacity
                if (baseColor.startsWith('#')) {
                    const r = parseInt(baseColor.slice(1, 3), 16);
                    const g = parseInt(baseColor.slice(3, 5), 16);
                    const b = parseInt(baseColor.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                } else if (baseColor.startsWith('hsl')) {
                    return baseColor.replace('hsl', 'hsla').replace(')', `, ${opacity})`);
                }
                return baseColor;
            });
            
            // Solid colors for borders (same color, 100% opacity)
            const borderColors = chartData.map((d, i) => {
                if (d.name === 'Other') return '#636366';
                return teamColorVariations[i];
            });
            
            const metric = position === 'WR' ? 'Targets' : 'Opportunities';
            
            teamAnalysisCharts.pie = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: values,
                        backgroundColor: fillColors,
                        borderColor: borderColors,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Total ${metric}: ${totalValue.toFixed(0)}`,
                            color: '#8e8e93',
                            font: { size: 13, weight: '600' },
                            padding: { top: 0, bottom: 10 }
                        },
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: '#ffffff',
                                padding: 15,
                                font: { size: 12 },
                                generateLabels: (chart) => {
                                    const data = chart.data;
                                    return data.labels.map((label, i) => ({
                                        text: `${label} (${percentages[i]}%)`,
                                        fillStyle: data.datasets[0].backgroundColor[i],
                                        fontColor: '#ffffff',
                                        hidden: false,
                                        index: i
                                    }));
                                }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const label = context.label || '';
                                    const value = context.parsed;
                                    const percentage = ((value / totalValue) * 100).toFixed(1);
                                    return `${label}: ${value.toFixed(1)} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Render Bar Chart (when league comparison is off)
        function renderTeamBarChart(chartData, position) {
            const canvas = document.getElementById('team-secondary-chart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Destroy existing chart
            if (teamAnalysisCharts.secondary) {
                teamAnalysisCharts.secondary.destroy();
            }
            
            const labels = chartData.map(d => d.name);
            const values = chartData.map(d => d.value);
            
            // Generate color variations based on team color palette
            const playerCount = chartData.filter(d => d.name !== 'Other').length;
            const teamColorVariations = generateTeamColorVariations(currentTeamAnalysisTeam, playerCount);
            
            // Create colors with medium opacity for fills
            const fillColors = chartData.map((d, i) => {
                if (d.name === 'Other') return 'rgba(99, 99, 102, 0.45)';
                const baseColor = teamColorVariations[i];
                // Convert to rgba with 45% opacity
                if (baseColor.startsWith('#')) {
                    const r = parseInt(baseColor.slice(1, 3), 16);
                    const g = parseInt(baseColor.slice(3, 5), 16);
                    const b = parseInt(baseColor.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, 0.45)`;
                } else if (baseColor.startsWith('hsl')) {
                    return baseColor.replace('hsl', 'hsla').replace(')', ', 0.45)');
                }
                return baseColor;
            });
            
            // Solid colors for borders (same color, 100% opacity)
            const borderColors = chartData.map((d, i) => {
                if (d.name === 'Other') return '#636366';
                return teamColorVariations[i];
            });
            
            const totalValue = chartData.reduce((sum, d) => sum + d.value, 0);
            const metric = position === 'WR' ? 'Targets' : 'Opportunities';
            
            teamAnalysisCharts.secondary = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: metric,
                        data: values,
                        backgroundColor: fillColors,
                        borderColor: borderColors,
                        borderWidth: 2
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Total ${metric}: ${totalValue.toFixed(0)}`,
                            color: '#8e8e93',
                            font: { size: 13, weight: '600' },
                            padding: { top: 0, bottom: 10 }
                        },
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    return `${context.parsed.x.toFixed(1)} ${position === 'WR' ? 'targets' : 'opportunities'}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            grid: { display: false },
                            ticks: { color: '#fff' }
                        }
                    }
                }
            });
        }
        
        // Render League Comparison
        function renderLeagueComparison(team, position, timeFrame, week, teamTotal) {
            // For WR view, include RBs who receive targets; for RB view, use only RB data
            let data;
            if (position === 'WR') {
                data = [...wrData, ...rbData]; // Include RBs in WR league comparison
            } else {
                data = rbData;
            }
            
            // Calculate totals for all teams
            const teamTotals = {};
            
            if (timeFrame === 'single') {
                data.filter(row => parseInt(row.Week) === week).forEach(row => {
                    const t = row.Team;
                    if (t && t !== 'FA') {
                        if (!teamTotals[t]) teamTotals[t] = 0;
                        // For WR view, count targets for all positions
                        teamTotals[t] += position === 'WR' ? (parseFloat(row.TGT) || 0) : (parseFloat(row['RB Opp']) || 0);
                    }
                });
            } else {
                const weeks = [...new Set(data.map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);
                const latestWeek = Math.max(...weeks);
                const weeksToInclude = timeFrame === 'last3' ? 3 : 5;
                const startWeek = latestWeek - weeksToInclude + 1;
                
                data.filter(row => parseInt(row.Week) >= startWeek && parseInt(row.Week) <= latestWeek).forEach(row => {
                    const t = row.Team;
                    if (t && t !== 'FA') {
                        if (!teamTotals[t]) teamTotals[t] = 0;
                        // For WR view, count targets for all positions
                        teamTotals[t] += position === 'WR' ? (parseFloat(row.TGT) || 0) : (parseFloat(row['RB Opp']) || 0);
                    }
                });
            }
            
            // Convert to array and sort
            const leagueData = Object.entries(teamTotals)
                .map(([t, total]) => ({ team: t, total }))
                .sort((a, b) => b.total - a.total);
            
            const canvas = document.getElementById('team-secondary-chart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Destroy existing chart
            if (teamAnalysisCharts.secondary) {
                teamAnalysisCharts.secondary.destroy();
            }
            
            const labels = leagueData.map(d => d.team);
            const values = leagueData.map(d => d.total);
            
            // Get selected team color
            const selectedTeamColor = teamColors[team] || '#666';
            let selectedBgColor, selectedBorderColor;
            if (selectedTeamColor.startsWith('#')) {
                const r = parseInt(selectedTeamColor.slice(1, 3), 16);
                const g = parseInt(selectedTeamColor.slice(3, 5), 16);
                const b = parseInt(selectedTeamColor.slice(5, 7), 16);
                selectedBgColor = `rgba(${r}, ${g}, ${b}, 0.6)`;
                selectedBorderColor = selectedTeamColor;
            }
            
            // Create colors arrays - different color for selected vs others
            const backgroundColors = leagueData.map(d => {
                if (d.team === team) {
                    return selectedBgColor;
                }
                const color = teamColors[d.team] || '#666';
                if (color.startsWith('#')) {
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, 0.45)`;
                }
                return color;
            });
            
            const borderColors = leagueData.map(d => {
                if (d.team === team) return selectedBorderColor;
                return teamColors[d.team] || '#666';
            });
            
            const borderWidths = leagueData.map(d => d.team === team ? 3 : 2);
            
            const metric = position === 'WR' ? 'Targets' : 'Opportunities';
            
            teamAnalysisCharts.secondary = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: `Total ${metric}`,
                            data: values,
                            backgroundColor: backgroundColors,
                            borderColor: borderColors,
                            borderWidth: borderWidths,
                            barThickness: 'flex',
                            maxBarThickness: 30
                        }
                    ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    aspectRatio: 0.8,
                    plugins: {
                        title: {
                            display: true,
                            text: `${team} Total ${metric}: ${teamTotal.toFixed(0)}`,
                            color: '#8e8e93',
                            font: { size: 13, weight: '600' },
                            padding: { top: 0, bottom: 10 }
                        },
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const value = context.parsed.x;
                                    if (value === null || value === 0) return null;
                                    return `${value.toFixed(1)} ${position === 'WR' ? 'targets' : 'opportunities'}`;
                                },
                                title: (context) => {
                                    return context[0].label;
                                }
                            },
                            filter: (tooltipItem) => {
                                return tooltipItem.parsed.x !== null && tooltipItem.parsed.x !== 0;
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y: {
                            grid: { display: false },
                            ticks: { 
                                autoSkip: false, // Show all team labels
                                maxRotation: 0,
                                minRotation: 0,
                                color: (context) => {
                                    // Much brighter white for selected team, dimmer for others
                                    return context.tick.label === team ? '#ffffff' : '#8e8e93';
                                },
                                font: (context) => {
                                    const isSelected = context.tick.label === team;
                                    
                                    if (isSelected) {
                                        // Selected team is bigger and bolder
                                        return { size: 13, weight: 'bold' };
                                    } else {
                                        // Normal size for others
                                        return { size: 10, weight: 'normal' };
                                    }
                                },
                                // Two-column staggered layout
                                align: (context) => {
                                    // Even indices right-aligned, odd indices left-aligned
                                    return context.index % 2 === 0 ? 'end' : 'start';
                                },
                                crossAlign: 'near',
                                padding: (context) => {
                                    // Add extra padding for odd indices to create column effect
                                    return context.index % 2 === 0 ? 4 : 12;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Render Season Long Chart
        function renderSeasonLongChart(team, position) {
            // For WR and TE charts, include ALL pass catchers (WR/RB/TE) for accurate target share
            // For RB charts, use only RB data for opportunities
            let data;
            if (position === 'WR' || position === 'TE') {
                data = [...wrData, ...rbData];
                if (teData) {
                    data = [...data, ...teData];
                }
            } else {
                data = rbData;
            }
            
            const filteredData = data.filter(row => row.Team === team);
            
            // Get all weeks
            const weeks = [...new Set(filteredData.map(row => parseInt(row.Week)).filter(w => !isNaN(w)))].sort((a, b) => a - b);
            
            // Calculate total for the time period
            let seasonTotal = 0;
            
            // Calculate weekly totals for labels
            const weeklyTotals = {};
            
            // Calculate weekly shares
            const weeklyShares = {};
            weeks.forEach(week => {
                const weekData = filteredData.filter(row => parseInt(row.Week) === week);
                const totalValue = weekData.reduce((sum, row) => {
                    const val = (position === 'WR' || position === 'TE') ? (parseFloat(row.TGT) || 0) : (parseFloat(row['RB Opp']) || 0);
                    return sum + val;
                }, 0);
                
                weeklyTotals[week] = totalValue;
                seasonTotal += totalValue;
                
                weekData.forEach(row => {
                    const player = row.Player;
                    const value = (position === 'WR' || position === 'TE') ? (parseFloat(row.TGT) || 0) : (parseFloat(row['RB Opp']) || 0);
                    const share = totalValue > 0 ? (value / totalValue) * 100 : 0;
                    
                    if (!weeklyShares[player]) {
                        weeklyShares[player] = [];
                    }
                    weeklyShares[player].push({ week, share, value });
                });
            });
            
            // Get top players by average share
            const playerAverages = Object.entries(weeklyShares).map(([player, shares]) => {
                const avgShare = shares.reduce((sum, s) => sum + s.share, 0) / shares.length;
                return { player, avgShare, shares };
            }).sort((a, b) => b.avgShare - a.avgShare);
            
            // Take top 4 players (regardless of position for WR/TE views)
            const topPlayers = playerAverages.slice(0, 4);
            
            // Hide secondary chart wrapper, show full width for season long
            const container = document.getElementById('team-charts-container');
            container.style.gridTemplateColumns = '1fr';
            document.getElementById('team-secondary-chart-wrapper').style.display = 'none';
            
            const canvas = document.getElementById('team-pie-chart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Destroy existing chart
            if (teamAnalysisCharts.pie) {
                teamAnalysisCharts.pie.destroy();
            }
            
            const metric = (position === 'WR' || position === 'TE') ? 'Targets' : 'Opportunities';
            
            if (position === 'WR' || position === 'TE') {
                // Stacked bar chart for WR/TE (showing top 4 pass catchers)
                const teamPalette = teamColorPalettes[team] || ['#666', '#888', '#aaa', '#ccc'];
                const teamColorVariations = generateTeamColorVariations(team, topPlayers.length);
                
                const datasets = topPlayers.map((p, i) => {
                    const baseColor = teamColorVariations[i];
                    // Convert to rgba with 45% opacity for fills
                    let fillColor = baseColor;
                    if (baseColor.startsWith('#')) {
                        const r = parseInt(baseColor.slice(1, 3), 16);
                        const g = parseInt(baseColor.slice(3, 5), 16);
                        const b = parseInt(baseColor.slice(5, 7), 16);
                        fillColor = `rgba(${r}, ${g}, ${b}, 0.45)`;
                    } else if (baseColor.startsWith('hsl')) {
                        fillColor = baseColor.replace('hsl', 'hsla').replace(')', ', 0.45)');
                    }
                    
                    return {
                        label: p.player,
                        data: weeks.map(week => {
                            const weekShare = p.shares.find(s => s.week === week);
                            return weekShare ? weekShare.share : 0;
                        }),
                        backgroundColor: fillColor,
                        borderColor: baseColor,
                        borderWidth: 2
                    };
                });
                
                // Add "Other" category
                const otherData = weeks.map(week => {
                    const weekTotal = 100;
                    const topTotal = topPlayers.reduce((sum, p) => {
                        const weekShare = p.shares.find(s => s.week === week);
                        return sum + (weekShare ? weekShare.share : 0);
                    }, 0);
                    return Math.max(0, weekTotal - topTotal);
                });
                
                datasets.push({
                    label: 'Other',
                    data: otherData,
                    backgroundColor: 'rgba(99, 99, 102, 0.45)',
                    borderColor: '#636366',
                    borderWidth: 2
                });
                
                teamAnalysisCharts.pie = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: weeks.map(w => `Week ${w} (${Math.round(weeklyTotals[w])})`),
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        aspectRatio: 2.5,
                        plugins: {
                            title: {
                                display: true,
                                text: `Total ${metric} (Season): ${seasonTotal.toFixed(0)}`,
                                color: '#8e8e93',
                                font: { size: 13, weight: '600' },
                                padding: { top: 5, bottom: 15 }
                            },
                            legend: {
                                position: 'bottom',
                                labels: { color: '#fff', padding: 10, font: { size: 11 } }
                            },
                            tooltip: {
                                mode: 'point',
                                intersect: true,
                                callbacks: {
                                    label: (context) => {
                                        return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                stacked: true,
                                grid: { color: '#2c2c2e' },
                                ticks: { color: '#8e8e93', font: { size: 10 } }
                            },
                            y: {
                                stacked: true,
                                max: 100,
                                grid: { color: '#2c2c2e' },
                                ticks: { color: '#8e8e93' },
                                title: {
                                    display: true,
                                    text: 'Target Share %',
                                    color: '#8e8e93'
                                }
                            }
                        }
                    }
                });
            } else {
                // Line chart for RBs
                const teamColorVariations = generateTeamColorVariations(team, topPlayers.length);
                
                const datasets = topPlayers.map((p, i) => {
                    const baseColor = teamColorVariations[i];
                    // Convert to rgba with 45% opacity for fills
                    let fillColor = baseColor + '45';
                    if (baseColor.startsWith('#')) {
                        const r = parseInt(baseColor.slice(1, 3), 16);
                        const g = parseInt(baseColor.slice(3, 5), 16);
                        const b = parseInt(baseColor.slice(5, 7), 16);
                        fillColor = `rgba(${r}, ${g}, ${b}, 0.45)`;
                    } else if (baseColor.startsWith('hsl')) {
                        fillColor = baseColor.replace('hsl', 'hsla').replace(')', ', 0.45)');
                    }
                    
                    return {
                        label: p.player,
                        data: weeks.map(week => {
                            const weekShare = p.shares.find(s => s.week === week);
                            return weekShare ? weekShare.share : null;
                        }),
                        borderColor: baseColor,
                        backgroundColor: fillColor,
                        borderWidth: 3,
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        pointBackgroundColor: fillColor,
                        pointBorderColor: baseColor,
                        pointBorderWidth: 2,
                        tension: 0.3
                    };
                });
                
                teamAnalysisCharts.pie = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: weeks.map(w => `Week ${w} (${Math.round(weeklyTotals[w])})`),
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        aspectRatio: 2.5,
                        plugins: {
                            title: {
                                display: true,
                                text: `Total ${metric} (Season): ${seasonTotal.toFixed(0)}`,
                                color: '#8e8e93',
                                font: { size: 13, weight: '600' },
                                padding: { top: 5, bottom: 15 }
                            },
                            legend: {
                                position: 'bottom',
                                labels: { color: '#fff', padding: 10, font: { size: 11 } }
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    label: (context) => {
                                        return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                grid: { color: '#2c2c2e' },
                                ticks: { color: '#8e8e93' }
                            },
                            y: {
                                grid: { color: '#2c2c2e' },
                                ticks: { color: '#8e8e93' },
                                title: {
                                    display: true,
                                    text: 'Opportunity Share %',
                                    color: '#8e8e93'
                                }
                            }
                        }
                    }
                });
            }
        }
        
        // Render Collapsible Divisions
        function renderCollapsibleDivisions() {
            if (!wrData || !rbData) return;
            
            const divisionsContainer = document.getElementById('divisions-grid');
            divisionsContainer.innerHTML = '';
            
            // Calculate team stats for display
            const teamStatsMap = {};
            const allData = [...wrData, ...rbData];
            allData.forEach(row => {
                const team = row.Team;
                if (team && team !== 'FA') {
                    if (!teamStatsMap[team]) {
                        teamStatsMap[team] = { totalPoints: 0, games: 0 };
                    }
                    teamStatsMap[team].totalPoints += parseFloat(row.FPTS || row.Fpts) || 0;
                }
            });
            
            // Count games per team
            const uniqueTeamWeeks = {};
            allData.forEach(row => {
                const team = row.Team;
                const week = row.Week;
                if (team && team !== 'FA' && week) {
                    const key = `${team}-${week}`;
                    uniqueTeamWeeks[key] = true;
                }
            });
            
            Object.keys(uniqueTeamWeeks).forEach(key => {
                const team = key.split('-')[0];
                if (teamStatsMap[team]) {
                    teamStatsMap[team].games++;
                }
            });
            
            // Render each division
            Object.entries(nflDivisions).forEach(([divisionName, teams]) => {
                const divSection = document.createElement('div');
                divSection.className = 'division-section';
                
                const header = document.createElement('div');
                header.className = 'division-header';
                header.onclick = () => toggleDivision(divisionName);
                
                const title = document.createElement('div');
                title.className = 'division-title';
                title.textContent = divisionName;
                
                const arrow = document.createElement('div');
                arrow.className = 'division-arrow';
                arrow.id = `arrow-${divisionName.replace(/\s+/g, '-')}`;
                arrow.textContent = '▼';
                
                header.appendChild(title);
                header.appendChild(arrow);
                
                const content = document.createElement('div');
                content.className = 'division-content';
                content.id = `content-${divisionName.replace(/\s+/g, '-')}`;
                
                const teamsGrid = document.createElement('div');
                teamsGrid.className = 'division-teams-grid';
                
                // Add team cards
                teams.forEach(team => {
                    const stats = teamStatsMap[team] || { totalPoints: 0, games: 1 };
                    const ppg = stats.games > 0 ? (stats.totalPoints / stats.games).toFixed(1) : '0.0';
                    
                    const teamCard = document.createElement('div');
                    teamCard.className = 'division-team-card';
                    teamCard.onclick = () => selectTeamFromDivision(team);
                    
                    const logo = document.createElement('div');
                    logo.className = 'division-team-logo';
                    logo.style.background = teamColors[team] || '#666';
                    logo.textContent = team;
                    
                    const info = document.createElement('div');
                    info.className = 'division-team-info';
                    
                    const name = document.createElement('div');
                    name.className = 'division-team-name';
                    name.textContent = team;
                    
                    const statsDiv = document.createElement('div');
                    statsDiv.className = 'division-team-stats';
                    statsDiv.textContent = `${ppg} PPG · ${stats.games} games`;
                    
                    info.appendChild(name);
                    info.appendChild(statsDiv);
                    
                    teamCard.appendChild(logo);
                    teamCard.appendChild(info);
                    
                    teamsGrid.appendChild(teamCard);
                });
                
                content.appendChild(teamsGrid);
                
                divSection.appendChild(header);
                divSection.appendChild(content);
                
                divisionsContainer.appendChild(divSection);
            });
        }
        
        // Toggle Division Collapse/Expand
        function toggleDivision(divisionName) {
            const contentId = `content-${divisionName.replace(/\s+/g, '-')}`;
            const arrowId = `arrow-${divisionName.replace(/\s+/g, '-')}`;
            
            const content = document.getElementById(contentId);
            const arrow = document.getElementById(arrowId);
            
            if (content && arrow) {
                content.classList.toggle('expanded');
                arrow.classList.toggle('expanded');
            }
        }
        
        // Select Team from Division
        function selectTeamFromDivision(team) {
            const teamSelect = document.getElementById('team-select');
            teamSelect.value = team;
            currentTeamAnalysisTeam = team;
            updateTeamAnalysis();
            
            // Scroll to Team Analysis section
            document.querySelector('.advanced-analytics-container').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        // ============================================
        // 5. INTERACTIONS
        // ============================================

        // Sub-Tab Navigation (Rankings vs Advanced Analytics)
        let wrAnalyticsRendered = false;
        let rbAnalyticsRendered = false;
        
        function switchWRSubTab(tab) {
            // Update button styles
            const tabs = document.querySelectorAll('#wide-receivers .sub-nav-tab');
            tabs.forEach(t => {
                t.style.color = 'var(--text-secondary)';
                t.style.borderBottomColor = 'transparent';
                t.classList.remove('active');
            });
            
            event.target.classList.add('active');
            event.target.style.color = 'var(--text-primary)';
            event.target.style.borderBottomColor = 'var(--positive)';
            
            // Show/hide content
            if (tab === 'rankings') {
                document.getElementById('wr-rankings-content').style.display = 'block';
                document.getElementById('wr-analytics-content').style.display = 'none';
            } else if (tab === 'analytics') {
                document.getElementById('wr-rankings-content').style.display = 'none';
                document.getElementById('wr-analytics-content').style.display = 'block';
                
                // Lazy load charts on first view
                if (!wrAnalyticsRendered) {
                    renderWRScatter();
                    renderMatrices(); // This will render WR matrices
                    
                    // Initialize trend animations for WR eval charts
                    if (Object.keys(evaluationDataWR).length > 0) {
                        initSmoothTrendAnimation('wr-eval-volume-efficiency');
                        initSmoothTrendAnimation('wr-eval-share-rz');
                        initSmoothTrendAnimation('wr-eval-production-volume');
                    }
                    
                    wrAnalyticsRendered = true;
                }
            }
        }
        
        function switchRBSubTab(tab) {
            // Update button styles
            const tabs = document.querySelectorAll('#running-backs .sub-nav-tab');
            tabs.forEach(t => {
                t.style.color = 'var(--text-secondary)';
                t.style.borderBottomColor = 'transparent';
                t.classList.remove('active');
            });
            
            event.target.classList.add('active');
            event.target.style.color = 'var(--text-primary)';
            event.target.style.borderBottomColor = 'var(--positive)';
            
            // Show/hide content
            if (tab === 'rankings') {
                document.getElementById('rb-rankings-content').style.display = 'block';
                document.getElementById('rb-analytics-content').style.display = 'none';
            } else if (tab === 'analytics') {
                document.getElementById('rb-rankings-content').style.display = 'none';
                document.getElementById('rb-analytics-content').style.display = 'block';
                
                // Lazy load charts on first view
                if (!rbAnalyticsRendered) {
                    renderRBScatter();
                    renderMatrices(); // This will render RB matrices
                    
                    // Initialize trend animations for RB eval charts
                    if (Object.keys(evaluationDataRB).length > 0) {
                        initSmoothTrendAnimation('rb-eval-total-rz');
                        initSmoothTrendAnimation('rb-eval-volume-efficiency');
                        initSmoothTrendAnimation('rb-eval-production-volume');
                    }
                    
                    rbAnalyticsRendered = true;
                }
            }
        }

        // Navigation
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const pageName = this.getAttribute('data-page');
                
                // Update active tab
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                
                // Show page
                document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
                document.getElementById(pageName).classList.add('active');
                
                // Render dashboard categories if on dashboard page
                if (pageName === 'top-movers') {
                    setTimeout(() => {
                        renderDashboardCategories();
                        setTimeout(renderMiniScatterPlots, 100);
                    }, 100);
                }
                
                // Scroll to top of page
                window.scrollTo({ top: 0, behavior: 'smooth' });
            });
        });

        // Modal Functions
        let currentModalPlayer = null;
        
        // Open modal with category context
        function openPlayerModalWithCategory(playerId, categoryTitle, explanation, rank, metricLabel, metricValue) {
            // First open the modal normally
            openPlayerModal(playerId);
            
            // Then add category context
            const contextDiv = document.getElementById('modal-category-context');
            if (contextDiv && categoryTitle) {
                contextDiv.style.display = 'block';
                document.getElementById('modal-category-title').textContent = categoryTitle;
                document.getElementById('modal-category-rank').textContent = `#${rank}`;
                document.getElementById('modal-category-explanation').textContent = explanation;
                document.getElementById('modal-category-metric-label').textContent = metricLabel;
                document.getElementById('modal-category-metric-value').textContent = metricValue;
            }
        }
        
        function openPlayerModal(playerId) {
            const player = allPlayers[playerId];
            if (!player) return;
            
            // Hide category context by default
            const contextDiv = document.getElementById('modal-category-context');
            if (contextDiv) {
                contextDiv.style.display = 'none';
            }
            
            currentModalPlayer = player;
            
            // Set player info with momentum badge
            const modalNameEl = document.getElementById('modal-player-name');
            modalNameEl.textContent = player.name;
            
            // Add momentum badge if valid
            if (player.momentum && player.momentum.isValid && player.momentum.direction !== 'neutral') {
                const momentumBadge = document.createElement('span');
                momentumBadge.className = `momentum-badge ${player.momentum.direction}`;
                momentumBadge.setAttribute('data-tooltip', `Momentum: ${player.momentum.score > 0 ? '+' : ''}${player.momentum.score.toFixed(1)}% (last 3 vs prev 3 weeks)`);
                momentumBadge.textContent = player.momentum.direction === 'up' ? '↑' : '↓';
                modalNameEl.appendChild(momentumBadge);
            }
            
            document.getElementById('modal-player-meta').textContent = `${player.position} · ${player.team} · Rank #${player.rosRank}`;
            document.getElementById('modal-team-badge').textContent = player.team;
            document.getElementById('modal-team-badge').style.background = teamColors[player.team] || '#666';
            
            // Get latest week data
            const latestWeek = player.weeks[player.weeks.length - 1];
            const latestWeekNum = latestWeek.week;
            const actualPts = latestWeek.fpts;
            const expectedPts = latestWeek.expectedFpts;
            const diffPct = expectedPts > 0 ? ((actualPts - expectedPts) / expectedPts) * 100 : 0;
            
            // Get previous week data for comparison
            const prevWeek = player.weeks.length > 1 ? player.weeks[player.weeks.length - 2] : null;
            
            // Row 1: Points Stats
            document.getElementById('modal-avg-pts').textContent = player.avgPoints.toFixed(1);
            document.getElementById('modal-exp-pts-label').textContent = `EXP PTS (W${latestWeekNum})`;
            document.getElementById('modal-exp-pts').textContent = expectedPts.toFixed(1);
            document.getElementById('modal-actual-pts-label').textContent = `ACTUAL (W${latestWeekNum})`;
            document.getElementById('modal-actual-pts').textContent = actualPts.toFixed(1);
            
            const diffEl = document.getElementById('modal-diff-pct');
            const diffColor = diffPct >= 0 ? '#30d158' : '#ff453a';
            const diffSymbol = diffPct >= 0 ? '▲' : '▼';
            diffEl.textContent = `${diffSymbol} ${Math.abs(diffPct).toFixed(1)}%`;
            diffEl.style.color = diffColor;
            
            // Row 2: Opportunity Stats (position-specific)
            if (player.position === 'WR') {
                // Show WR-specific stats
                document.getElementById('modal-stat-opp-this').style.display = 'block';
                document.getElementById('modal-stat-opp-last').style.display = 'block';
                document.getElementById('modal-stat-vs-avg').style.display = 'block';
                document.getElementById('modal-stat-opp-change').style.display = 'block';
                
                // Update tooltips for WRs
                document.querySelector('#modal-stat-opp-this .stat-tooltip').textContent = 'Percentage of team\'s targets this player received in latest week';
                document.querySelector('#modal-stat-opp-last .stat-tooltip').textContent = 'Percentage of team\'s targets this player received in previous week';
                document.querySelector('#modal-stat-vs-avg .stat-tooltip').textContent = 'Target differential vs Top 24 WR average for this week';
                document.querySelector('#modal-stat-opp-change .stat-tooltip').textContent = 'Week-over-week change in target share percentage';
                
                const thisWeekShare = latestWeek.teamShare || 0;
                const lastWeekShare = prevWeek ? (prevWeek.teamShare || 0) : 0;
                const shareChange = thisWeekShare - lastWeekShare;
                const thisWeekTargets = latestWeek.targets || 0;
                
                // Calculate top 24 WR average targets for this week
                const allWRs = Object.values(aggregatedWRs);
                const top24WRs = allWRs
                    .filter(wr => wr.gamesPlayed >= 3)
                    .sort((a, b) => b.avgPoints - a.avgPoints)
                    .slice(0, 24);
                
                // Get targets for latest week for top 24
                const top24LatestWeekTargets = top24WRs
                    .map(wr => {
                        const wrLatestWeek = wr.weeks.find(w => w.week === latestWeekNum);
                        return wrLatestWeek ? (wrLatestWeek.targets || 0) : 0;
                    })
                    .filter(t => t > 0);
                
                const avgTop24Targets = top24LatestWeekTargets.length > 0 
                    ? top24LatestWeekTargets.reduce((sum, t) => sum + t, 0) / top24LatestWeekTargets.length 
                    : 0;
                
                const vsAvg = thisWeekTargets - avgTop24Targets;
                
                document.getElementById('modal-opp-this-week').textContent = thisWeekShare.toFixed(1) + '%';
                document.getElementById('modal-opp-last-week').textContent = lastWeekShare.toFixed(1) + '%';
                
                const vsAvgEl = document.getElementById('modal-vs-avg');
                const vsAvgColor = vsAvg >= 0 ? '#30d158' : '#ff453a';
                const vsAvgSymbol = vsAvg >= 0 ? '+' : '';
                vsAvgEl.textContent = `${vsAvgSymbol}${vsAvg.toFixed(1)}`;
                vsAvgEl.style.color = vsAvgColor;
                
                // Show actual numbers below
                const vsAvgDetailEl = document.getElementById('modal-vs-avg-detail');
                vsAvgDetailEl.textContent = `${thisWeekTargets.toFixed(1)} / ${avgTop24Targets.toFixed(1)} avg`;
                
                const shareChangeEl = document.getElementById('modal-share-change');
                const shareChangeColor = shareChange >= 0 ? '#30d158' : '#ff453a';
                const shareChangeSymbol = shareChange >= 0 ? '▲' : '▼';
                shareChangeEl.textContent = `${shareChangeSymbol} ${Math.abs(shareChange).toFixed(1)}%`;
                shareChangeEl.style.color = shareChangeColor;
            } else {
                // For RBs, update labels and show RB-specific stats
                document.getElementById('modal-stat-opp-this').style.display = 'block';
                document.getElementById('modal-stat-opp-last').style.display = 'block';
                document.getElementById('modal-stat-vs-avg').style.display = 'block';
                document.getElementById('modal-stat-opp-change').style.display = 'block';
                
                // Update labels for RBs
                document.querySelector('#modal-stat-opp-this .modal-stat-label').textContent = 'OPP SHARE THIS WK';
                document.querySelector('#modal-stat-opp-last .modal-stat-label').textContent = 'OPP SHARE LAST WK';
                document.querySelector('#modal-stat-vs-avg .modal-stat-label').textContent = 'OPP vs TOP 24 AVG';
                
                // Update tooltips for RBs
                document.querySelector('#modal-stat-opp-this .stat-tooltip').textContent = 'Number of opportunities (carries + targets) this player received in latest week';
                document.querySelector('#modal-stat-opp-last .stat-tooltip').textContent = 'Number of opportunities (carries + targets) this player received in previous week';
                document.querySelector('#modal-stat-vs-avg .stat-tooltip').textContent = 'Opportunity differential vs Top 24 RB average for this week';
                document.querySelector('#modal-stat-opp-change .stat-tooltip').textContent = 'Week-over-week change in total opportunities';
                
                const thisWeekOpp = latestWeek.opportunities || 0;
                const lastWeekOpp = prevWeek ? (prevWeek.opportunities || 0) : 0;
                const oppChange = thisWeekOpp - lastWeekOpp;
                
                // Calculate top 24 RB average opportunities for this week
                const allRBs = Object.values(aggregatedRBs);
                const top24RBs = allRBs
                    .filter(rb => rb.gamesPlayed >= 3)
                    .sort((a, b) => b.avgPoints - a.avgPoints)
                    .slice(0, 24);
                
                // Get opportunities for latest week for top 24
                const top24LatestWeekOpps = top24RBs
                    .map(rb => {
                        const rbLatestWeek = rb.weeks.find(w => w.week === latestWeekNum);
                        return rbLatestWeek ? (rbLatestWeek.opportunities || 0) : 0;
                    })
                    .filter(o => o > 0);
                
                const avgTop24Opps = top24LatestWeekOpps.length > 0 
                    ? top24LatestWeekOpps.reduce((sum, o) => sum + o, 0) / top24LatestWeekOpps.length 
                    : 0;
                
                const vsAvg = thisWeekOpp - avgTop24Opps;
                
                document.getElementById('modal-opp-this-week').textContent = thisWeekOpp.toFixed(1);
                document.getElementById('modal-opp-last-week').textContent = lastWeekOpp.toFixed(1);
                
                const vsAvgEl = document.getElementById('modal-vs-avg');
                const vsAvgColor = vsAvg >= 0 ? '#30d158' : '#ff453a';
                const vsAvgSymbol = vsAvg >= 0 ? '+' : '';
                vsAvgEl.textContent = `${vsAvgSymbol}${vsAvg.toFixed(1)}`;
                vsAvgEl.style.color = vsAvgColor;
                
                // Show actual numbers below
                const vsAvgDetailEl = document.getElementById('modal-vs-avg-detail');
                vsAvgDetailEl.textContent = `${thisWeekOpp.toFixed(1)} / ${avgTop24Opps.toFixed(1)} avg`;
                
                const oppChangeEl = document.getElementById('modal-share-change');
                const oppChangeColor = oppChange >= 0 ? '#30d158' : '#ff453a';
                const oppChangeSymbol = oppChange >= 0 ? '▲' : '▼';
                oppChangeEl.textContent = `${oppChangeSymbol} ${Math.abs(oppChange).toFixed(1)}`;
                oppChangeEl.style.color = oppChangeColor;
            }
            
            // Update sentiment display
            updateModalSentiment(player.name);
            
            // Load comments
            loadComments(player.name);
            
            // Show modal first (important for chart rendering)
            document.getElementById('player-modal').classList.add('active');
            
            // Render charts - outcomes chart needs to wait for modal to be visible
            renderModalVarianceChart(player);
            renderModalSpiderChart(player);
            
            // Delay outcomes chart rendering to ensure modal is fully visible
            setTimeout(() => {
                renderModalOutcomesChart(player);
            }, 50);
            
            // Reset to Performance Consistency tab
            document.querySelectorAll('.chart-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.chart-content').forEach(content => content.classList.remove('active'));
            document.querySelector('.chart-tab[onclick*="outcomes"]').classList.add('active');
            document.getElementById('modal-chart-outcomes').classList.add('active');
            
            // Setup spider explanation section
            const explanation = document.getElementById('spider-explanation');
            const icon = document.getElementById('spider-explanation-icon');
            if (explanation) {
                explanation.style.display = 'none'; // Collapsed by default
                icon.textContent = 'ℹ️';
                
                // Show correct metrics section based on position
                const wrMetrics = document.getElementById('spider-wr-metrics');
                const rbMetrics = document.getElementById('spider-rb-metrics');
                if (player.position === 'WR') {
                    wrMetrics.style.display = 'block';
                    rbMetrics.style.display = 'none';
                } else {
                    wrMetrics.style.display = 'none';
                    rbMetrics.style.display = 'block';
                }
            }
            
            // Scroll modal to top
            setTimeout(() => {
                const modalBody = document.querySelector('#player-modal .modal');
                if (modalBody) {
                    modalBody.scrollTop = 0;
                }
            }, 100);
        }
        
        function updateModalSentiment(playerName) {
            const sentiment = getSentimentScore(playerName);
            const total = sentiment.total;
            const buyPct = total > 0 ? (sentiment.buy / total * 100) : 0;
            const sellPct = total > 0 ? (sentiment.sell / total * 100) : 0;
            const holdPct = total > 0 ? (sentiment.hold / total * 100) : 0;
            
            // Update compact horizontal bar widths
            document.getElementById('modal-sentiment-buy-compact').style.width = buyPct + '%';
            document.getElementById('modal-sentiment-sell-compact').style.width = sellPct + '%';
            
            // Determine dominant sentiment
            const max = Math.max(buyPct, holdPct, sellPct);
            let label, color, icon;
            
            if (buyPct === max) {
                label = 'BUY';
                color = 'var(--positive)';
                icon = '▲';
            } else if (sellPct === max) {
                label = 'SELL';
                color = 'var(--negative)';
                icon = '▼';
            } else {
                label = 'HOLD';
                color = 'var(--text-secondary)';
                icon = '—';
            }
            
            // Update compact horizontal display
            const compactEl = document.getElementById('modal-sentiment-compact');
            if (total > 0) {
                compactEl.innerHTML = `<span style="color: ${color};">${icon} ${Math.round(max)}% ${label}</span>`;
            } else {
                compactEl.innerHTML = `<span style="color: var(--text-secondary);">— No votes</span>`;
            }
            
            // Highlight user's vote if exists
            document.querySelectorAll('.vote-btn').forEach(btn => btn.classList.remove('active'));
            const userVote = localStorage.getItem(`ffse_user_vote_${playerName}`);
            if (userVote) {
                document.querySelector(`.vote-btn.${userVote}-btn`)?.classList.add('active');
            }
        }
        
        function castVote(voteType) {
            if (!currentModalPlayer) return;
            
            const playerName = currentModalPlayer.name;
            
            // Remove previous vote if exists
            const previousVote = localStorage.getItem(`ffse_user_vote_${playerName}`);
            if (previousVote) {
                if (!playerVotes[playerName]) {
                    playerVotes[playerName] = { buy: 0, sell: 0, hold: 0, lastVote: Date.now() };
                }
                playerVotes[playerName][previousVote] = Math.max(0, playerVotes[playerName][previousVote] - 1);
            }
            
            // Add new vote
            if (!playerVotes[playerName]) {
                playerVotes[playerName] = { buy: 0, sell: 0, hold: 0, lastVote: Date.now() };
            }
            playerVotes[playerName][voteType]++;
            playerVotes[playerName].lastVote = Date.now();
            
            // Store user's vote
            localStorage.setItem(`ffse_user_vote_${playerName}`, voteType);
            
            // Save to localStorage
            saveSentimentData();
            
            // Update display
            updateModalSentiment(playerName);
            
            // Refresh player cards to show updated sentiment
            if (currentModalPlayer.position === 'WR') {
                renderWRPlayerCards();
            } else {
                renderRBPlayerCards();
            }
        }
        
        function loadComments(playerName) {
            if (!playerComments[playerName]) {
                playerComments[playerName] = [];
            }
            
            const commentList = document.getElementById('comment-list');
            const comments = playerComments[playerName].sort((a, b) => b.timestamp - a.timestamp);
            
            if (comments.length === 0) {
                commentList.innerHTML = '<div style="color: var(--text-secondary); font-size: 13px; text-align: center; padding: 20px;">No comments yet. Be the first!</div>';
                return;
            }
            
            commentList.innerHTML = comments.slice(0, 10).map(comment => {
                const timeAgo = getTimeAgo(comment.timestamp);
                return `
                    <div class="comment-item">
                        <div>${comment.text}</div>
                        <div class="comment-meta">${timeAgo}</div>
                    </div>
                `;
            }).join('');
            
            // Add Enter key listener
            const input = document.getElementById('comment-input');
            input.onkeypress = function(e) {
                if (e.key === 'Enter') {
                    submitComment();
                }
            };
        }
        
        function submitComment() {
            if (!currentModalPlayer) return;
            
            const input = document.getElementById('comment-input');
            const text = input.value.trim();
            
            if (!text) return;
            
            const playerName = currentModalPlayer.name;
            
            if (!playerComments[playerName]) {
                playerComments[playerName] = [];
            }
            
            playerComments[playerName].push({
                text: text,
                timestamp: Date.now(),
                user: 'Anonymous' // Could be enhanced with user system
            });
            
            // Save to localStorage
            localStorage.setItem('ffse_player_comments', JSON.stringify(playerComments));
            
            // Clear input
            input.value = '';
            
            // Reload comments
            loadComments(playerName);
        }
        
        function getTimeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);
            
            if (seconds < 60) return 'Just now';
            if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
            if (seconds < 86400) return Math.floor(seconds / 3600) + 'h ago';
            return Math.floor(seconds / 86400) + 'd ago';
        }

        function closeModal() {
            document.getElementById('player-modal').classList.remove('active');
            
            // Destroy charts
            if (modalVarianceChart) modalVarianceChart.destroy();
            if (modalOutcomesChart) modalOutcomesChart.destroy();
            if (modalSpiderChart) modalSpiderChart.destroy();
            if (modalShareChart) modalShareChart.destroy();
            if (modalTrendsChart) modalTrendsChart.destroy();
        }

        function switchModalChart(chartName) {
            // Update tabs
            document.querySelectorAll('.chart-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update content
            document.querySelectorAll('.chart-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`modal-chart-${chartName}`).classList.add('active');
            
            // Charts are now fully loaded on modal open (no re-rendering needed)
        }
        
        function toggleSpiderExplanation() {
            const explanation = document.getElementById('spider-explanation');
            const icon = document.getElementById('spider-explanation-icon');
            
            if (explanation.style.display === 'none') {
                explanation.style.display = 'block';
                icon.textContent = '▼';
            } else {
                explanation.style.display = 'none';
                icon.textContent = 'ℹ️';
            }
        }

        function renderModalVarianceChart(player) {
            const ctx = document.getElementById('modal-variance-chart');
            
            if (modalVarianceChart) {
                modalVarianceChart.destroy();
            }
            
            const weeks = player.weeks.map(w => `W${w.week}`);
            const actuals = player.weeks.map(w => w.fpts);
            const expected = player.weeks.map(w => w.expectedFpts);
            const variance = player.weeks.map(w => w.variance);
            
            modalVarianceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: weeks,
                    datasets: [
                        {
                            type: 'line',
                            label: 'Actual',
                            data: actuals,
                            borderColor: '#fff',
                            borderWidth: 2,
                            fill: false,
                            pointRadius: 4,
                            pointBackgroundColor: '#fff',
                            yAxisID: 'y'
                        },
                        {
                            type: 'line',
                            label: 'Expected',
                            data: expected,
                            borderColor: '#8e8e93',
                            borderDash: [5, 5],
                            borderWidth: 2,
                            fill: false,
                            pointRadius: 4,
                            pointBackgroundColor: '#8e8e93',
                            yAxisID: 'y'
                        },
                        {
                            type: 'bar',
                            label: 'Variance',
                            data: variance,
                            backgroundColor: variance.map(v => 
                                v >= 0 ? 'rgba(48, 209, 88, 0.6)' : 'rgba(255, 69, 58, 0.6)'
                            ),
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { 
                            display: true,
                            labels: { color: '#8e8e93' }
                        }
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Fantasy Points',
                                color: '#8e8e93'
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Variance',
                                color: '#8e8e93'
                            },
                            grid: { display: false },
                            ticks: { color: '#8e8e93' }
                        },
                        x: {
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }

        function renderModalOutcomesChart(player) {
            const ctx = document.getElementById('modal-outcomes-chart');
            
            if (modalOutcomesChart) {
                modalOutcomesChart.destroy();
            }
            
            // Get team color
            const teamColor = teamColors[player.team] || '#0a84ff';
            const teamColorRgba = hexToRgba(teamColor, 0.1);
            
            // Calculate average variance (how much they beat or miss expectations)
            const variances = player.weeks.map(w => w.variance);
            const avgVariance = variances.reduce((sum, v) => sum + v, 0) / variances.length;
            const weeksOverExpected = variances.filter(v => v > 0).length;
            const consistency = (weeksOverExpected / variances.length * 100).toFixed(0);
            
            const weeks = player.weeks.map(w => `W${w.week}`);
            const actuals = player.weeks.map(w => w.fpts);
            const expected = player.weeks.map(w => w.expectedFpts);
            
            modalOutcomesChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: weeks,
                    datasets: [
                        {
                            label: 'Actual',
                            data: actuals,
                            borderColor: teamColor,
                            backgroundColor: teamColorRgba,
                            borderWidth: 3,
                            fill: true,
                            tension: 0.3,
                            pointRadius: 5,
                            pointBackgroundColor: teamColor,
                            pointBorderColor: '#fff',
                            pointBorderWidth: 2
                        },
                        {
                            label: 'Expected',
                            data: expected,
                            borderColor: '#8e8e93',
                            borderDash: [5, 5],
                            borderWidth: 2,
                            fill: false,
                            tension: 0.3,
                            pointRadius: 4,
                            pointBackgroundColor: '#8e8e93'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: { 
                            display: true,
                            labels: { 
                                color: '#8e8e93', 
                                font: { size: 12 },
                                usePointStyle: true,
                                pointStyle: 'line'
                            }
                        },
                        title: {
                            display: true,
                            text: [
                                `Avg ${avgVariance >= 0 ? '+' : ''}${avgVariance.toFixed(1)} vs Expected`,
                                `Beats Expectations: ${consistency}% of weeks (${weeksOverExpected}/${variances.length})`
                            ],
                            color: avgVariance >= 0 ? '#30d158' : '#ff453a',
                            padding: { bottom: 15 },
                            font: { size: 13, weight: '600' }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(1) + ' pts';
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Fantasy Points',
                                color: '#8e8e93'
                            },
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        },
                        x: {
                            grid: { color: '#2c2c2e' },
                            ticks: { color: '#8e8e93' }
                        }
                    }
                }
            });
        }
        
        // Helper function to convert hex to rgba
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        function renderModalSpiderChart(player) {
            const ctx = document.getElementById('modal-spider-chart');
            
            if (modalSpiderChart) {
                modalSpiderChart.destroy();
                modalSpiderChart = null;
            }
            
            // Get team color
            const teamColor = teamColors[player.team] || '#0a84ff';
            const teamColorRgba = hexToRgba(teamColor, 0.2);
            
            // Get all players for ranking
            const allPlayers = player.position === 'WR' ? 
                Object.values(aggregatedWRs).filter(p => p.gamesPlayed >= 3) :
                Object.values(aggregatedRBs).filter(p => p.gamesPlayed >= 3);
            
            // Calculate rankings for each metric (lower rank = better)
            let metrics = {};
            let rankings = {};
            
            if (player.position === 'WR') {
                // WR: Volume (targets/game), Efficiency (pts/target), Red Zone, Consistency
                const targetsPerGameData = allPlayers.map(p => ({
                    player: p,
                    value: p.totalTargets / p.gamesPlayed
                })).sort((a, b) => b.value - a.value);
                
                const efficiencyData = allPlayers.map(p => ({
                    player: p,
                    value: p.avgPoints / (p.totalTargets / p.gamesPlayed) // pts per target
                })).sort((a, b) => b.value - a.value);
                
                const redZoneData = allPlayers.map(p => ({
                    player: p,
                    value: p.rzOpportunities / p.gamesPlayed
                })).sort((a, b) => b.value - a.value);
                
                const teamShareData = allPlayers.map(p => ({
                    player: p,
                    value: p.latestWeekOppShare || 0
                })).sort((a, b) => b.value - a.value);
                
                // Catch Rate: Receptions / Targets (%)
                const catchRateData = allPlayers.map(p => {
                    // Calculate from raw data
                    const playerRows = wrData.filter(row => row.Team === p.team && row.Player === p.name);
                    let totalReceptions = 0;
                    let totalTargets = 0;
                    playerRows.forEach(row => {
                        totalReceptions += parseFloat(row.REC) || 0;
                        totalTargets += parseFloat(row.TGT) || 0;
                    });
                    const catchRate = totalTargets > 0 ? (totalReceptions / totalTargets) * 100 : 0;
                    return { player: p, value: catchRate };
                }).sort((a, b) => b.value - a.value);
                
                // Find player's rank in each category
                rankings = {
                    'Volume': targetsPerGameData.findIndex(p => p.player.id === player.id) + 1,
                    'Efficiency': efficiencyData.findIndex(p => p.player.id === player.id) + 1,
                    'Red Zone': redZoneData.findIndex(p => p.player.id === player.id) + 1,
                    'Team Share': teamShareData.findIndex(p => p.player.id === player.id) + 1,
                    'Catch Rate': catchRateData.findIndex(p => p.player.id === player.id) + 1
                };
                
            } else {
                // RB: Volume (opps/game), Efficiency (pts/opp), Red Zone, Consistency
                const oppsPerGameData = allPlayers.map(p => ({
                    player: p,
                    value: p.totalOpportunities / p.gamesPlayed
                })).sort((a, b) => b.value - a.value);
                
                const efficiencyData = allPlayers.map(p => ({
                    player: p,
                    value: p.avgPoints / (p.totalOpportunities / p.gamesPlayed) // pts per opp
                })).sort((a, b) => b.value - a.value);
                
                const redZoneData = allPlayers.map(p => ({
                    player: p,
                    value: p.rzOpportunities / p.gamesPlayed
                })).sort((a, b) => b.value - a.value);
                
                const teamShareData = allPlayers.map(p => ({
                    player: p,
                    value: p.latestWeekOppShare || 0
                })).sort((a, b) => b.value - a.value);
                
                // Yards After Contact: YACON per attempt
                const yacData = allPlayers.map(p => {
                    // Calculate from raw data
                    const playerRows = rbData.filter(row => row.Team === p.team && row.Player === p.name);
                    let totalYACON = 0;
                    let totalATT = 0;
                    playerRows.forEach(row => {
                        totalYACON += parseFloat(row.YACON) || 0;
                        totalATT += parseFloat(row.ATT) || 0;
                    });
                    const yacPerAtt = totalATT > 0 ? totalYACON / totalATT : 0;
                    return { player: p, value: yacPerAtt };
                }).sort((a, b) => b.value - a.value);
                
                // Find player's rank in each category
                rankings = {
                    'Volume': oppsPerGameData.findIndex(p => p.player.id === player.id) + 1,
                    'Efficiency': efficiencyData.findIndex(p => p.player.id === player.id) + 1,
                    'Red Zone': redZoneData.findIndex(p => p.player.id === player.id) + 1,
                    'Team Share': teamShareData.findIndex(p => p.player.id === player.id) + 1,
                    'Yards After Contact': yacData.findIndex(p => p.player.id === player.id) + 1
                };
            }
            
            // Check if player is in top 200 for all metrics
            const isTop200 = Object.values(rankings).every(rank => rank <= 200);
            
            if (!isTop200) {
                // Don't render chart for players outside top 200
                // Clear the canvas properly
                if (ctx) {
                    const context = ctx.getContext('2d');
                    if (context) {
                        context.clearRect(0, 0, ctx.width, ctx.height);
                        context.fillStyle = '#8e8e93';
                        context.font = '14px -apple-system, BlinkMacSystemFont, SF Pro Display';
                        context.textAlign = 'center';
                        context.fillText('Player Profile Not Available', ctx.width / 2, ctx.height / 2 - 10);
                        context.fillText('Rankings shown for Top 200 players only', ctx.width / 2, ctx.height / 2 + 10);
                    }
                }
                return;
            }
            
            // Convert rankings to scores (rank 1 = 100, rank 200 = 0.5)
            const labels = Object.keys(rankings);
            const data = labels.map(label => {
                const rank = rankings[label];
                // Linear scale: rank 1 gets 100, rank 200 gets 0.5
                // Formula: 100 - ((rank - 1) / 199 * 99.5)
                return Math.max(0.5, 100 - ((rank - 1) / 199 * 99.5));
            });
            
            modalSpiderChart = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: player.name,
                        data: data,
                        backgroundColor: teamColorRgba,
                        borderColor: teamColor,
                        borderWidth: 3,
                        pointBackgroundColor: teamColor,
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: teamColor,
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        pointBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: {
                        legend: { display: false },
                        title: {
                            display: true,
                            text: 'Rankings vs Top 200 (Higher = Better Rank)',
                            color: '#8e8e93',
                            font: { size: 12 }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const rank = rankings[context.label];
                                    const score = context.parsed.r.toFixed(0);
                                    return `${context.label}: #${rank} (Score: ${score}/100)`;
                                }
                            }
                        }
                    },
                    scales: {
                        r: {
                            beginAtZero: true,
                            min: 0,
                            max: 100,
                            ticks: {
                                stepSize: 20,
                                color: '#8e8e93',
                                backdropColor: 'transparent',
                                font: { size: 10 }
                            },
                            grid: {
                                color: '#1c1c1e'
                            },
                            pointLabels: {
                                color: '#fff',
                                font: {
                                    size: 12,
                                    weight: 'bold'
                                }
                            },
                            angleLines: {
                                color: '#1c1c1e'
                            }
                        }
                    }
                }
            });
        }

        function renderModalShareChart(player) {
            const ctx = document.getElementById('modal-share-chart');
            
            if (modalShareChart) {
                modalShareChart.destroy();
                modalShareChart = null;
            }
            
            // Get team data from latest week
            const latestWeek = player.latestWeek;
            let teamData = [];
            
            if (player.position === 'WR') {
                teamData = wrData.filter(row => 
                    row.Team === player.team && 
                    parseInt(row.Week) === latestWeek &&
                    row.Player &&
                    parseFloat(row.TGT) > 0
                );
            } else {
                teamData = rbData.filter(row => 
                    row.Team === player.team && 
                    parseInt(row.Week) === latestWeek &&
                    row.Player &&
                    parseFloat(row['RB Opp']) > 0
                );
            }
            
            // Calculate shares for each player
            const playerShares = teamData.map(row => {
                let share = 0;
                if (player.position === 'WR') {
                    share = parseFloat(row['% TM']) || 0;
                } else {
                    // Calculate RB share
                    const playerOpp = parseFloat(row['RB Opp']) || 0;
                    const teamTotal = teamData.reduce((sum, r) => sum + (parseFloat(r['RB Opp']) || 0), 0);
                    share = teamTotal > 0 ? (playerOpp / teamTotal) * 100 : 0;
                }
                
                return {
                    name: row.Player,
                    share: share,
                    isTarget: row.Player === player.name
                };
            });
            
            // Sort by share
            playerShares.sort((a, b) => b.share - a.share);
            
            // Get top 3 (including our player) + everyone else
            const top3 = playerShares.slice(0, 3);
            const others = playerShares.slice(3);
            const othersTotal = others.reduce((sum, p) => sum + p.share, 0);
            
            const labels = top3.map(p => p.name);
            const data = top3.map(p => p.share);
            
            // Generate color palette from team color
            const teamColor = teamColors[player.team] || '#0a84ff';
            const colorPalette = getColorPalette(teamColor, 3);
            const colors = colorPalette.slice(0, top3.length);
            
            if (othersTotal > 0) {
                labels.push('Everyone Else');
                data.push(othersTotal);
                colors.push('#1c1c1e');
            }
            
            modalShareChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colors,
                        borderColor: '#0a0a0a',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,  // Disabled animation
                    plugins: {
                        legend: { 
                            display: true,
                            labels: { color: '#8e8e93' },
                            position: 'bottom'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.label}: ${context.parsed.toFixed(1)}%`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function renderModalTrendsChart(player) {
            const ctx = document.getElementById('modal-trends-chart');
            
            if (modalTrendsChart) {
                modalTrendsChart.destroy();
            }
            
            if (player.position === 'RB') {
                // For RBs: Show line chart with all team RBs' opportunity shares
                
                // Get all RBs from this team
                const teamRBs = Object.values(aggregatedRBs).filter(rb => rb.team === player.team);
                
                // Get all weeks that have been played
                const allWeeks = [...new Set(player.weeks.map(w => w.week))].sort((a, b) => a - b);
                
                // Calculate total opportunities per week
                const weekTotals = {};
                allWeeks.forEach(weekNum => {
                    const weekData = rbData.filter(row => 
                        row.Team === player.team && 
                        parseInt(row.Week) === weekNum &&
                        parseFloat(row['RB Opp']) > 0
                    );
                    weekTotals[weekNum] = weekData.reduce((sum, row) => sum + (parseFloat(row['RB Opp']) || 0), 0);
                });
                
                // Calculate total opportunity share for each RB across all weeks to rank them
                const rbTotalShares = teamRBs.map(rb => {
                    const totalShare = allWeeks.reduce((sum, weekNum) => {
                        const weekData = rbData.filter(row => 
                            row.Team === rb.team && 
                            parseInt(row.Week) === weekNum &&
                            parseFloat(row['RB Opp']) > 0
                        );
                        const rbWeek = weekData.find(row => row.Player === rb.name);
                        const totalOpp = weekData.reduce((sum, row) => sum + (parseFloat(row['RB Opp']) || 0), 0);
                        const weekShare = rbWeek && totalOpp > 0 ? (parseFloat(rbWeek['RB Opp']) / totalOpp * 100) : 0;
                        return sum + weekShare;
                    }, 0);
                    return { rb, totalShare };
                });
                
                // Sort by total share and get top 3
                rbTotalShares.sort((a, b) => b.totalShare - a.totalShare);
                const top3RBs = rbTotalShares.slice(0, 3).map(item => item.rb);
                
                // Generate color palette from team color for top 3
                const teamColor = teamColors[player.team] || '#0a84ff';
                const colorPalette = getColorPalette(teamColor, 3);
                
                // Create datasets for top 3 RBs
                const datasets = top3RBs.map((rb, index) => {
                    const rbColor = colorPalette[index];
                    
                    // Calculate opportunity share for each week
                    const shareData = allWeeks.map(weekNum => {
                        const weekData = rbData.filter(row => 
                            row.Team === rb.team && 
                            parseInt(row.Week) === weekNum &&
                            parseFloat(row['RB Opp']) > 0
                        );
                        const rbWeek = weekData.find(row => row.Player === rb.name);
                        const totalOpp = weekData.reduce((sum, row) => sum + (parseFloat(row['RB Opp']) || 0), 0);
                        return rbWeek && totalOpp > 0 ? (parseFloat(rbWeek['RB Opp']) / totalOpp * 100) : null;
                    });
                    
                    return {
                        label: rb.name,
                        data: shareData,
                        borderColor: rbColor,  // Use full color for all top 3
                        backgroundColor: 'transparent',
                        borderWidth: rb.id === player.id ? 4 : 2,  // Only thickness varies
                        tension: 0.3,
                        pointRadius: rb.id === player.id ? 6 : 3,  // Point size varies
                        pointBackgroundColor: rbColor,
                        pointBorderColor: '#0a0a0a',
                        pointBorderWidth: 2,
                        spanGaps: true
                    };
                });
                
                // Add "Everyone Else" line if there are more than 3 RBs
                if (teamRBs.length > 3) {
                    const everyoneElseData = allWeeks.map(weekNum => {
                        // Calculate share for everyone else
                        const weekData = rbData.filter(row => 
                            row.Team === player.team && 
                            parseInt(row.Week) === weekNum &&
                            parseFloat(row['RB Opp']) > 0
                        );
                        const totalOpp = weekData.reduce((sum, row) => sum + (parseFloat(row['RB Opp']) || 0), 0);
                        
                        // Calculate top 3 share
                        const top3Share = top3RBs.reduce((sum, rb) => {
                            const rbWeek = weekData.find(row => row.Player === rb.name);
                            const rbOpp = rbWeek ? parseFloat(rbWeek['RB Opp']) || 0 : 0;
                            return sum + (totalOpp > 0 ? (rbOpp / totalOpp * 100) : 0);
                        }, 0);
                        
                        return totalOpp > 0 ? Math.max(0, 100 - top3Share) : null;
                    });
                    
                    datasets.push({
                        label: 'Everyone Else',
                        data: everyoneElseData,
                        borderColor: '#1c1c1e',
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 2,
                        pointBackgroundColor: '#1c1c1e',
                        pointBorderColor: '#0a0a0a',
                        pointBorderWidth: 2,
                        spanGaps: true,
                        borderDash: [5, 5]
                    });
                }
                
                modalTrendsChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: allWeeks.map(w => `Week ${w}`),
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { 
                                display: true,
                                position: 'bottom',
                                labels: {
                                    color: '#8e8e93',
                                    font: { size: 12 },
                                    boxWidth: 15,
                                    padding: 10
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    title: (context) => {
                                        const weekNum = allWeeks[context[0].dataIndex];
                                        const totalOpps = weekTotals[weekNum];
                                        return `Week ${weekNum} (${totalOpps.toFixed(0)} Total RB Opps)`;
                                    },
                                    label: (context) => `${context.dataset.label}: ${context.parsed.y ? context.parsed.y.toFixed(1) : '0'}% share`
                                }
                            }
                        },
                        scales: {
                            x: {
                                grid: { color: '#2c2c2e' },
                                ticks: { color: '#8e8e93' }
                            },
                            y: {
                                beginAtZero: true,
                                max: 100,
                                title: {
                                    display: true,
                                    text: 'Opportunity Share %',
                                    color: '#8e8e93'
                                },
                                grid: { color: '#2c2c2e' },
                                ticks: { 
                                    color: '#8e8e93',
                                    callback: (value) => value + '%'
                                }
                            }
                        }
                    }
                });
            } else {
                // For WRs: Keep stacked bar chart
                
                // Get all weeks that player played
                const weeks = player.weeks.map(w => w.week);
                
                // For each week, get team data and calculate shares
                const weeklyShares = {};
                const weekTotals = {};
                
                weeks.forEach(weekNum => {
                    const teamData = wrData.filter(row => 
                        row.Team === player.team && 
                        parseInt(row.Week) === weekNum &&
                        row.Player &&
                        parseFloat(row.TGT) > 0
                    );
                    
                    // Calculate total targets for this week
                    weekTotals[weekNum] = teamData.reduce((sum, row) => sum + (parseFloat(row.TGT) || 0), 0);
                    
                    // Calculate shares for this week
                    const playerShares = teamData.map(row => {
                        const share = parseFloat(row['% TM']) || 0;
                        return {
                            name: row.Player,
                            share: share
                        };
                    });
                    
                    // Sort by share
                    playerShares.sort((a, b) => b.share - a.share);
                    
                    weeklyShares[weekNum] = playerShares;
                });
                
                // Identify consistent top 3 players across all weeks
                const allPlayers = new Map();
                Object.values(weeklyShares).forEach(weekData => {
                    weekData.forEach(p => {
                        if (!allPlayers.has(p.name)) {
                            allPlayers.set(p.name, 0);
                        }
                        allPlayers.set(p.name, allPlayers.get(p.name) + p.share);
                    });
                });
                
                // Get top 3 by total share across all weeks
                const sortedPlayers = Array.from(allPlayers.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3)
                    .map(entry => entry[0]);
                
                // Build datasets for stacked bar chart
                const labels = weeks.map(w => `W${w}`);
                const datasets = [];
                
                // Generate color palette from team color
                const teamColor = teamColors[player.team] || '#0a84ff';
                const colorPalette = getColorPalette(teamColor, 3);
                
                // Use color palette for each player
                sortedPlayers.forEach((playerName, idx) => {
                    const color = colorPalette[idx];
                    
                    const weeklyData = weeks.map(weekNum => {
                        const weekData = weeklyShares[weekNum];
                        const playerWeekData = weekData.find(p => p.name === playerName);
                        return playerWeekData ? playerWeekData.share : 0;
                    });
                    
                    datasets.push({
                        label: playerName,
                        data: weeklyData,
                        backgroundColor: color,
                        borderColor: '#0a0a0a',
                        borderWidth: 1
                    });
                });
                
                // Everyone else
                const othersData = weeks.map(weekNum => {
                    const weekData = weeklyShares[weekNum];
                    const top3Total = weekData
                        .filter(p => sortedPlayers.includes(p.name))
                        .reduce((sum, p) => sum + p.share, 0);
                    return Math.max(0, 100 - top3Total);
                });
                
                datasets.push({
                    label: 'Everyone Else',
                    data: othersData,
                    backgroundColor: '#1c1c1e',
                    borderColor: '#0a0a0a',
                    borderWidth: 1
                });
                
                modalTrendsChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { 
                                display: true,
                                labels: { color: '#8e8e93' },
                                position: 'bottom'
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(context) {
                                        const weekNum = weeks[context[0].dataIndex];
                                        const totalTargets = weekTotals[weekNum];
                                        return `W${weekNum} (${totalTargets.toFixed(0)} Total Targets)`;
                                    },
                                    label: function(context) {
                                        return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                stacked: true,
                                grid: { color: '#2c2c2e' },
                                ticks: { color: '#8e8e93' }
                            },
                            y: {
                                stacked: true,
                                beginAtZero: true,
                                max: 100,
                                title: {
                                    display: true,
                                    text: 'Opportunity Share %',
                                    color: '#8e8e93'
                                },
                                grid: { color: '#2c2c2e' },
                                ticks: { color: '#8e8e93' }
                            }
                        }
                    }
                });
            }
        }


        /* ============================================
           New: Evaluation Chart Rendering + Trend Animation
           ============================================ */
        /**
 * Render WR Evaluation Chart 1: Volume vs Efficiency
 * X = Targets per Game, Y = Fantasy Points per Target
 */
function renderWREvalVolumeEfficiency(week = null) {
    const ctx = document.getElementById('wr-eval-volume-efficiency');
    if (!ctx) return;
    
    const weekData = getEvaluationWeekData(evaluationDataWR, week);
    
    // Filter by total fantasy points
    const topPlayers = weekData
        .filter(p => p.aggregate.gamesPlayed >= 3)
        .sort((a, b) => b.aggregate.totalFpts - a.aggregate.totalFpts)
        .slice(0, 50);
    
    const data = topPlayers.map(player => ({
        x: player.targetsPerGame || player.targets || 0,
        y: player.fptsPerTarget || 0,
        label: player.player,
        player: player
    }));
    
    // Calculate medians for quadrant lines
    const xValues = data.map(d => d.x).filter(x => x > 0).sort((a, b) => a - b);
    const yValues = data.map(d => d.y).filter(y => y > 0).sort((a, b) => a - b);
    const medianX = xValues[Math.floor(xValues.length / 2)] || 5;
    const medianY = yValues[Math.floor(yValues.length / 2)] || 1.5;
    
    if (wrEvalVolumeEfficiencyChart) wrEvalVolumeEfficiencyChart.destroy();
    
    wrEvalVolumeEfficiencyChart = new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: [{
                data: data,
                backgroundColor: data.map(d => {
                    const color = teamColors[d.player.team] || '#666';
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, 0.7)`;
                }),
                borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                borderWidth: 2,
                pointRadius: 8,
                pointHoverRadius: 12
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: (context) => {
                            const p = context.raw.player;
                            return [
                                p.player,
                                `Tgts/G: ${context.parsed.x.toFixed(1)}`,
                                `Pts/Tgt: ${context.parsed.y.toFixed(2)}`,
                                `Total: ${p.aggregate.totalFpts.toFixed(1)} pts`
                            ];
                        }
                    }
                },
                annotation: {
                    annotations: {
                        vLine: {
                            type: 'line',
                            xMin: medianX,
                            xMax: medianX,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        hLine: {
                            type: 'line',
                            yMin: medianY,
                            yMax: medianY,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        topRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['Reliable Studs', '(Hold)'],
                            color: '#30d158',
                            font: { size: 13, weight: 'bold' }
                        },
                        topLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.5,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['Efficient Sleepers', '(Buy Low)'],
                            color: '#0a84ff',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.min(...yValues) * 2.0,
                            content: ['Volume, Poor Efficiency', '(Sell Window)'],
                            color: '#FFD60A',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.5,
                            yValue: Math.min(...yValues) * 2.0,
                            content: ['Bench Fodder'],
                            color: '#ff453a',
                            font: { size: 13, weight: 'bold' }
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: 'Targets per Game →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' }
                },
                y: {
                    title: { display: true, text: 'Fantasy Points per Target →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' }
                }
            }
        }
    });
}

/**
 * Render WR Evaluation Chart 2: Target Share vs RZ Share
 * X = Target Share %, Y = Red Zone Target Share %
 */
function renderWREvalShareRZ(week = null) {
    const ctx = document.getElementById('wr-eval-share-rz');
    if (!ctx) return;
    
    const weekData = getEvaluationWeekData(evaluationDataWR, week);
    
    // Filter by total fantasy points
    const topPlayers = weekData
        .filter(p => p.aggregate.gamesPlayed >= 3)
        .sort((a, b) => b.aggregate.totalFpts - a.aggregate.totalFpts)
        .slice(0, 50);
    
    const data = topPlayers.map(player => ({
        x: player.targetShare || 0,
        y: player.rzTargetShare || 0,
        label: player.player,
        player: player
    }));
    
    // Calculate medians
    const xValues = data.map(d => d.x).filter(x => x > 0).sort((a, b) => a - b);
    const yValues = data.map(d => d.y).filter(y => y > 0).sort((a, b) => a - b);
    const medianX = xValues[Math.floor(xValues.length / 2)] || 20;
    const medianY = yValues[Math.floor(yValues.length / 2)] || 20;
    
    if (wrEvalShareRZChart) wrEvalShareRZChart.destroy();
    
    wrEvalShareRZChart = new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: [{
                data: data,
                backgroundColor: data.map(d => {
                    const color = teamColors[d.player.team] || '#666';
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, 0.7)`;
                }),
                borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                borderWidth: 2,
                pointRadius: 8,
                pointHoverRadius: 12
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: (context) => {
                            const p = context.raw.player;
                            return [
                                p.player,
                                `Tgt Share: ${context.parsed.x.toFixed(1)}%`,
                                `RZ Share: ${context.parsed.y.toFixed(1)}%`,
                                `Total: ${p.aggregate.totalFpts.toFixed(1)} pts`
                            ];
                        }
                    }
                },
                annotation: {
                    annotations: {
                        vLine: {
                            type: 'line',
                            xMin: medianX,
                            xMax: medianX,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        hLine: {
                            type: 'line',
                            yMin: medianY,
                            yMax: medianY,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        topRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['Alpha WR1s'],
                            color: '#30d158',
                            font: { size: 13, weight: 'bold' }
                        },
                        topLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.3,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['TD-Dependent', 'Boom/Busts'],
                            color: '#FFD60A',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.min(...yValues) * 2.0,
                            content: ['Chain Movers'],
                            color: '#0a84ff',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.3,
                            yValue: Math.min(...yValues) * 2.0,
                            content: ['Background Noise'],
                            color: '#ff453a',
                            font: { size: 13, weight: 'bold' }
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: 'Target Share (% of Team) →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93', callback: (value) => value + '%' }
                },
                y: {
                    title: { display: true, text: 'Red Zone Target Share (% of Team) →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93', callback: (value) => value + '%' }
                }
            }
        }
    });
}

/**
 * Render RB Evaluation Chart 1: Total vs Red Zone Opportunities
 * X = Opportunities per Game, Y = RZ Opportunities per Game
 */
function renderRBEvalTotalRZ(week = null) {
    const ctx = document.getElementById('rb-eval-total-rz');
    if (!ctx) return;
    
    const weekData = getEvaluationWeekData(evaluationDataRB, week);
    
    // Filter by total fantasy points
    const topPlayers = weekData
        .filter(p => p.aggregate.gamesPlayed >= 3)
        .sort((a, b) => b.aggregate.totalFpts - a.aggregate.totalFpts)
        .slice(0, 50);
    
    const data = topPlayers.map(player => ({
        x: player.opportunitiesPerGame || 0,
        y: player.rzOpportunitiesPerGame || 0,
        label: player.player,
        player: player
    }));
    
    // Calculate medians
    const xValues = data.map(d => d.x).filter(x => x > 0).sort((a, b) => a - b);
    const yValues = data.map(d => d.y).filter(y => y > 0).sort((a, b) => a - b);
    const medianX = xValues[Math.floor(xValues.length / 2)] || 12;
    const medianY = yValues[Math.floor(yValues.length / 2)] || 2;
    
    if (rbEvalTotalRZChart) rbEvalTotalRZChart.destroy();
    
    rbEvalTotalRZChart = new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: [{
                data: data,
                backgroundColor: data.map(d => {
                    const color = teamColors[d.player.team] || '#666';
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, 0.7)`;
                }),
                borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                borderWidth: 2,
                pointRadius: 8,
                pointHoverRadius: 12
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: (context) => {
                            const p = context.raw.player;
                            return [
                                p.player,
                                `Opps/G: ${context.parsed.x.toFixed(1)}`,
                                `RZ Opps/G: ${context.parsed.y.toFixed(1)}`,
                                `Total: ${p.aggregate.totalFpts.toFixed(1)} pts`
                            ];
                        }
                    }
                },
                annotation: {
                    annotations: {
                        vLine: {
                            type: 'line',
                            xMin: medianX,
                            xMax: medianX,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        hLine: {
                            type: 'line',
                            yMin: medianY,
                            yMax: medianY,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        topRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['True Workhorses', '(Buy/Hold)'],
                            color: '#30d158',
                            font: { size: 13, weight: 'bold' }
                        },
                        topLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.2,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['TD Vultures', '(Sell High)'],
                            color: '#FFD60A',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.min(...yValues) * 1.5,
                            content: ['Between-the-20s Backs', '(Neutral)'],
                            color: '#0a84ff',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.2,
                            yValue: Math.min(...yValues) * 1.5,
                            content: ['Irrelevant Depth'],
                            color: '#ff453a',
                            font: { size: 13, weight: 'bold' }
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: 'Opportunities per Game (Rush + Targets) →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' }
                },
                y: {
                    title: { display: true, text: 'Red Zone Opportunities per Game →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' }
                }
            }
        }
    });
}

/**
 * Render RB Evaluation Chart 2: Volume vs Efficiency
 * X = Opportunities per Game, Y = Efficiency (Pts per Opp)
 */
function renderRBEvalVolumeEfficiency(week = null) {
    const ctx = document.getElementById('rb-eval-volume-efficiency');
    if (!ctx) return;
    
    const weekData = getEvaluationWeekData(evaluationDataRB, week);
    
    // Filter by total fantasy points
    const topPlayers = weekData
        .filter(p => p.aggregate.gamesPlayed >= 3)
        .sort((a, b) => b.aggregate.totalFpts - a.aggregate.totalFpts)
        .slice(0, 50);
    
    const data = topPlayers.map(player => ({
        x: player.opportunitiesPerGame || 0,
        y: player.efficiency || 0,
        label: player.player,
        player: player
    }));
    
    // Calculate medians
    const xValues = data.map(d => d.x).filter(x => x > 0).sort((a, b) => a - b);
    const yValues = data.map(d => d.y).filter(y => y > 0).sort((a, b) => a - b);
    const medianX = xValues[Math.floor(xValues.length / 2)] || 12;
    const medianY = yValues[Math.floor(yValues.length / 2)] || 1;
    
    if (rbEvalVolumeEfficiencyChart) rbEvalVolumeEfficiencyChart.destroy();
    
    rbEvalVolumeEfficiencyChart = new Chart(ctx, {
        type: 'scatter',
        data: {
            datasets: [{
                data: data,
                backgroundColor: data.map(d => {
                    const color = teamColors[d.player.team] || '#666';
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return `rgba(${r}, ${g}, ${b}, 0.7)`;
                }),
                borderColor: data.map(d => teamColors[d.player.team] || '#666'),
                borderWidth: 2,
                pointRadius: 8,
                pointHoverRadius: 12
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
                layout: { padding: { left: 50, right: 50, top: 50, bottom: 50 } },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: (context) => {
                            const p = context.raw.player;
                            return [
                                p.player,
                                `Opps/G: ${context.parsed.x.toFixed(1)}`,
                                `Efficiency: ${context.parsed.y.toFixed(2)} pts/opp`,
                                `Total: ${p.aggregate.totalFpts.toFixed(1)} pts`
                            ];
                        }
                    }
                },
                annotation: {
                    annotations: {
                        vLine: {
                            type: 'line',
                            xMin: medianX,
                            xMax: medianX,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        hLine: {
                            type: 'line',
                            yMin: medianY,
                            yMax: medianY,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        topRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['Elite Dual Threats'],
                            color: '#30d158',
                            font: { size: 13, weight: 'bold' }
                        },
                        topLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.2,
                            yValue: Math.max(...yValues) * 0.70,
                            content: ['Breakout Candidates'],
                            color: '#0a84ff',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomRight: {
                            type: 'label',
                            xValue: Math.max(...xValues) * 0.70,
                            yValue: Math.min(...yValues) * 2.0,
                            content: ['Inefficient', 'Workhorses'],
                            color: '#FFD60A',
                            font: { size: 13, weight: 'bold' }
                        },
                        bottomLeft: {
                            type: 'label',
                            xValue: Math.min(...xValues) * 1.2,
                            yValue: Math.min(...yValues) * 2.0,
                            content: ['Bench Fodder'],
                            color: '#ff453a',
                            font: { size: 13, weight: 'bold' }
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: 'Opportunities per Game (Rush + Targets) →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' }
                },
                y: {
                    title: { display: true, text: 'Efficiency (Fantasy Points per Opportunity) →', color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' }
                }
            }
        }
    });
}
/* ============================================
   Player Evaluation Matrix | Smooth Trend Animation + Week Scrubber
   Features: Linear interpolation, fading trails, interactive scrubber
   ============================================ */

// Smooth animation state
let smoothTrendState = {};
let smoothTrendAnimationFrames = {};
let smoothTrendPlayerTrails = {};
let smoothTrendMoversFilter = {};  // Track movers filter state for each chart

/**
 * Initialize smooth trend animation for a chart
 */
/**
 * Initialize smooth trend animation for a chart (v7: SEGMENT VERSION)
 */
function initSmoothTrendAnimation(chartId) {
    const isWR = chartId.includes('wr-eval');
    const segmentData = isWR ? segmentDataWR : segmentDataRB;  // v7: use segmentData
    const segments = getAvailableSegments(segmentData);         // v7: use segments
    
    if (segments.length === 0) return;
    
    // Initialize state
    smoothTrendState[chartId] = {
        isPlaying: false,
        currentSegmentFloat: segments[segments.length - 1],    // v7: segment instead of week
        segments: segments,                                    // v7: segments instead of weeks
        fps: 30,
        speedMultiplier: 0.01,  // Segments per frame (500% slower - was 0.05)
        maxTrailLength: 20      // Longer trail (was 5)
    };
    
    // Initialize trail data
    smoothTrendPlayerTrails[chartId] = {};
    
    // Setup scrubber
    const scrubber = document.getElementById(`${chartId}-scrubber`);
    if (scrubber) {
        scrubber.min = segments[0];
        scrubber.max = segments[segments.length - 1];
        scrubber.value = segments[segments.length - 1];
        
        // Scrubber input handler
        scrubber.addEventListener('input', (e) => {
            const segmentFloat = parseFloat(e.target.value);   // v7: segment naming
            smoothTrendState[chartId].currentSegmentFloat = segmentFloat;
            smoothTrendState[chartId].isPlaying = false;
            updatePlayButton(chartId, false);
            renderSmoothTrendFrame(chartId, segmentFloat);     // v7: pass segment
            updateSegmentLabel(chartId, segmentFloat);         // v7: update segment label
        });
    }
    
    // Render initial frame (latest segment)
    renderSmoothTrendFrame(chartId, smoothTrendState[chartId].currentSegmentFloat);
    updateSegmentLabel(chartId, smoothTrendState[chartId].currentSegmentFloat);
}

/**
 * Toggle playback for smooth trend animation
 */
function toggleSmoothTrendPlayback(chartId) {
    if (!smoothTrendState[chartId]) {
        initSmoothTrendAnimation(chartId);
    }
    
    const state = smoothTrendState[chartId];
    state.isPlaying = !state.isPlaying;
    
    updatePlayButton(chartId, state.isPlaying);
    
    if (state.isPlaying) {
        startSmoothAnimation(chartId);
    } else {
        stopSmoothAnimation(chartId);
    }
}

/**
 * Toggle movers filter for a chart
 * @param {string} chartId - Chart identifier
 * @param {string} mode - 'all' or 'movers'
 */
/**
 * Toggle movers filter for a chart
 * @param {string} chartId - Chart identifier
 * @param {string} mode - 'all', 'positive', or 'negative'
 */
function toggleMoversFilter(chartId, mode) {
    // Update filter state
    smoothTrendMoversFilter[chartId] = mode;
    
    // Update button styles
    const allBtn = document.getElementById(`${chartId}-filter-all`);
    const positiveBtn = document.getElementById(`${chartId}-filter-positive`);
    const negativeBtn = document.getElementById(`${chartId}-filter-negative`);
    
    // Reset all buttons to inactive style
    [allBtn, positiveBtn, negativeBtn].forEach(btn => {
        if (btn) {
            btn.style.background = 'var(--bg-elevated)';
            btn.style.color = 'var(--text-primary)';
            btn.style.border = '1px solid var(--border-color)';
        }
    });
    
    // Set active button to active style
    let activeBtn;
    if (mode === 'all') activeBtn = allBtn;
    else if (mode === 'positive') activeBtn = positiveBtn;
    else if (mode === 'negative') activeBtn = negativeBtn;
    
    if (activeBtn) {
        activeBtn.style.background = 'var(--positive)';
        activeBtn.style.color = '#000';
        activeBtn.style.border = 'none';
    }
    
    // Re-render current frame
    if (smoothTrendState[chartId]) {
        renderSmoothTrendFrame(chartId, smoothTrendState[chartId].currentSegmentFloat);
    }
}

/**
 * Calculate top movers between first and last segment
 * @param {Array} allPlayers - All players with data
 * @param {Object} segmentData - Segment data
 * @param {Array} segments - Available segment indices
 * @param {string} chartId - Chart ID to determine axes
 * @returns {Object} Object with topPositive and topNegative movers
 */
function calculateTopMovers(allPlayers, segmentData, segments, chartId) {
    if (segments.length < 2) return { topPositive: [], topNegative: [] };
    
    const firstSegment = segments[0];
    const lastSegment = segments[segments.length - 1];
    
    const firstData = getEvaluationSegmentData(segmentData, firstSegment);
    const lastData = getEvaluationSegmentData(segmentData, lastSegment);
    
    // Calculate movement for each player
    const movements = [];
    
    allPlayers.forEach(player => {
        const playerFirst = firstData.find(p => p.player === player.player);
        const playerLast = lastData.find(p => p.player === player.player);
        
        if (!playerFirst || !playerLast) return;
        
        // Calculate movement based on chart type
        let xFirst, yFirst, xLast, yLast;
        
        if (chartId === 'wr-eval-volume-efficiency') {
            xFirst = playerFirst.targets || 0;
            yFirst = playerFirst.fptsPerTarget || 0;
            xLast = playerLast.targets || 0;
            yLast = playerLast.fptsPerTarget || 0;
        } else if (chartId === 'wr-eval-share-rz') {
            xFirst = playerFirst.targetShare || 0;
            yFirst = playerFirst.rzTargetShare || 0;
            xLast = playerLast.targetShare || 0;
            yLast = playerLast.rzTargetShare || 0;
        } else if (chartId === 'rb-eval-total-rz') {
            xFirst = playerFirst.opportunities || 0;
            yFirst = playerFirst.rzOpportunities || 0;
            xLast = playerLast.opportunities || 0;
            yLast = playerLast.rzOpportunities || 0;
        } else if (chartId === 'rb-eval-volume-efficiency') {
            xFirst = playerFirst.opportunities || 0;
            yFirst = playerFirst.efficiency || 0;
            xLast = playerLast.opportunities || 0;
            yLast = playerLast.efficiency || 0;
        } else if (chartId === 'wr-eval-production-volume') {
            xFirst = (playerFirst.targets || 0) / (playerFirst.weeksInSegment || 1);
            yFirst = (playerFirst.fpts || 0) / (playerFirst.weeksInSegment || 1);
            xLast = (playerLast.targets || 0) / (playerLast.weeksInSegment || 1);
            yLast = (playerLast.fpts || 0) / (playerLast.weeksInSegment || 1);
        } else if (chartId === 'rb-eval-production-volume') {
            xFirst = (playerFirst.opportunities || 0) / (playerFirst.weeksInSegment || 1);
            yFirst = (playerFirst.fpts || 0) / (playerFirst.weeksInSegment || 1);
            xLast = (playerLast.opportunities || 0) / (playerLast.weeksInSegment || 1);
            yLast = (playerLast.fpts || 0) / (playerLast.weeksInSegment || 1);
        }
        
        // Calculate Euclidean distance moved (with Y weighted 2x)
        const xChange = xLast - xFirst;
        const yChange = yLast - yFirst;
        const distance = Math.sqrt(xChange * xChange + (yChange * yChange * 4)); // Y weighted more
        
        // Determine if positive or negative mover (upward/rightward = positive)
        const direction = (xChange + yChange * 2) >= 0 ? 1 : -1;
        const signedDistance = distance * direction;
        
        movements.push({
            player: player.player,
            distance: signedDistance,
            absDistance: Math.abs(signedDistance)
        });
    });
    
    // Sort and get top 5 positive and top 5 negative
    movements.sort((a, b) => b.distance - a.distance);
    
    const topPositive = movements.slice(0, 5).map(m => m.player);
    const topNegative = movements.slice(-5).reverse().map(m => m.player);
    
    return { topPositive, topNegative };
}

/**
 * Start smooth animation loop (v7: SEGMENT VERSION)
 */
function startSmoothAnimation(chartId) {
    const state = smoothTrendState[chartId];
    
    // If at end, restart from beginning and clear trails
    if (state.currentSegmentFloat >= state.segments[state.segments.length - 1]) {
        state.currentSegmentFloat = state.segments[0];
        smoothTrendPlayerTrails[chartId] = {};  // Clear trails on restart
    }
    
    // Animation loop using requestAnimationFrame
    function animationLoop() {
        if (!state.isPlaying) return;
        
        // Increment segment position
        state.currentSegmentFloat += state.speedMultiplier;
        
        // Stop at end (don't loop automatically)
        if (state.currentSegmentFloat >= state.segments[state.segments.length - 1]) {
            state.currentSegmentFloat = state.segments[state.segments.length - 1];
            state.isPlaying = false;
            updatePlayButton(chartId, false);
            
            // Render final frame with full trails
            renderSmoothTrendFrame(chartId, state.currentSegmentFloat, true);  // Pass showFullTrail flag
            updateSegmentLabel(chartId, state.currentSegmentFloat);
            updateScrubberPosition(chartId, state.currentSegmentFloat);
            return;  // Stop animation
        }
        
        // Render frame
        renderSmoothTrendFrame(chartId, state.currentSegmentFloat);
        
        // Update UI
        updateSegmentLabel(chartId, state.currentSegmentFloat);
        updateScrubberPosition(chartId, state.currentSegmentFloat);
        
        // Continue loop
        smoothTrendAnimationFrames[chartId] = requestAnimationFrame(animationLoop);
    }
    
    smoothTrendAnimationFrames[chartId] = requestAnimationFrame(animationLoop);
}

/**
 * Stop smooth animation
 */
function stopSmoothAnimation(chartId) {
    const state = smoothTrendState[chartId];
    state.isPlaying = false;
    
    if (smoothTrendAnimationFrames[chartId]) {
        cancelAnimationFrame(smoothTrendAnimationFrames[chartId]);
        delete smoothTrendAnimationFrames[chartId];
    }
}

/**
/**
 * Render a single frame with interpolation (v7: SEGMENT VERSION)
 * segmentFloat can be a decimal (e.g., 3.5 for halfway between segment 3 and 4)
 * @param {string} chartId - Chart identifier
 * @param {number} segmentFloat - Current segment position (can be fractional)
 * @param {boolean} showFullTrail - If true, show full trail from start to finish
 */
function renderSmoothTrendFrame(chartId, segmentFloat, showFullTrail = false) {
    const isWR = chartId.includes('wr-eval');
    const segmentData = isWR ? segmentDataWR : segmentDataRB;  // v7: use segmentData
    const state = smoothTrendState[chartId];
    
    // Determine which segments to interpolate between
    const segmentBefore = Math.floor(segmentFloat);
    const segmentAfter = Math.ceil(segmentFloat);
    const interpolationFactor = segmentFloat - segmentBefore;
    
    // Get data for both segments
    const dataBefore = getEvaluationSegmentData(segmentData, segmentBefore);  // v7: use segment function
    const dataAfter = segmentBefore !== segmentAfter ? 
                     getEvaluationSegmentData(segmentData, segmentAfter) : 
                     dataBefore;
    
    // Collect all unique players from both segments
    const playerSet = new Set();
    dataBefore.forEach(p => playerSet.add(p.player));
    dataAfter.forEach(p => playerSet.add(p.player));
    
    const allPlayers = Array.from(playerSet).map(playerName => {
        const pBefore = dataBefore.find(p => p.player === playerName);
        const pAfter = dataAfter.find(p => p.player === playerName);
        return pBefore || pAfter;
    });
    
    // Filter by total fantasy points OR top 5 positive/negative movers if filter is active
    let topPlayers;
    
    if (smoothTrendMoversFilter[chartId] === 'positive' || smoothTrendMoversFilter[chartId] === 'negative') {
        // Calculate top movers
        const segments = getAvailableSegments(segmentData);
        const movers = calculateTopMovers(allPlayers, segmentData, segments, chartId);
        
        // Get the appropriate set of movers
        let moverNames;
        if (smoothTrendMoversFilter[chartId] === 'positive') {
            moverNames = movers.topPositive;  // Top 5 positive movers
        } else {
            moverNames = movers.topNegative;  // Top 5 negative movers
        }
        
        // Filter to only selected movers
        topPlayers = allPlayers.filter(p => 
            p && p.aggregate && p.aggregate.gamesPlayed >= 3 && moverNames.includes(p.player)
        );
    } else {
        // Default: filter by fantasy points
        topPlayers = allPlayers
            .filter(p => p && p.aggregate && p.aggregate.gamesPlayed >= 3)
            .sort((a, b) => b.aggregate.totalFpts - a.aggregate.totalFpts)
            .slice(0, 50);
    }
    
    // Build interpolated data points with trails
    const interpolatedData = topPlayers.map(player => {
        const pBefore = dataBefore.find(p => p.player === player.player);
        const pAfter = dataAfter.find(p => p.player === player.player);
        
        // Get coordinates for interpolation
        let xBefore, yBefore, xAfter, yAfter;
        
        // Determine axes based on chart type
        if (chartId === 'wr-eval-volume-efficiency') {
            xBefore = pBefore ? (pBefore.targets || 0) : 0;
            yBefore = pBefore ? (pBefore.fptsPerTarget || 0) : 0;
            xAfter = pAfter ? (pAfter.targets || 0) : xBefore;
            yAfter = pAfter ? (pAfter.fptsPerTarget || 0) : yBefore;
        } else if (chartId === 'wr-eval-share-rz') {
            xBefore = pBefore ? (pBefore.targetShare || 0) : 0;
            yBefore = pBefore ? (pBefore.rzTargetShare || 0) : 0;
            xAfter = pAfter ? (pAfter.targetShare || 0) : xBefore;
            yAfter = pAfter ? (pAfter.rzTargetShare || 0) : yBefore;
        } else if (chartId === 'rb-eval-total-rz') {
            xBefore = pBefore ? (pBefore.opportunities || 0) : 0;
            yBefore = pBefore ? (pBefore.rzOpportunities || 0) : 0;
            xAfter = pAfter ? (pAfter.opportunities || 0) : xBefore;
            yAfter = pAfter ? (pAfter.rzOpportunities || 0) : yBefore;
        } else if (chartId === 'rb-eval-volume-efficiency') {
            xBefore = pBefore ? (pBefore.opportunities || 0) : 0;
            yBefore = pBefore ? (pBefore.efficiency || 0) : 0;
            xAfter = pAfter ? (pAfter.opportunities || 0) : xBefore;
            yAfter = pAfter ? (pAfter.efficiency || 0) : yBefore;
        } else if (chartId === 'wr-eval-production-volume') {
            xBefore = pBefore ? ((pBefore.targets || 0) / (pBefore.weeksInSegment || 1)) : 0;
            yBefore = pBefore ? ((pBefore.fpts || 0) / (pBefore.weeksInSegment || 1)) : 0;
            xAfter = pAfter ? ((pAfter.targets || 0) / (pAfter.weeksInSegment || 1)) : xBefore;
            yAfter = pAfter ? ((pAfter.fpts || 0) / (pAfter.weeksInSegment || 1)) : yBefore;
        } else if (chartId === 'rb-eval-production-volume') {
            xBefore = pBefore ? ((pBefore.opportunities || 0) / (pBefore.weeksInSegment || 1)) : 0;
            yBefore = pBefore ? ((pBefore.fpts || 0) / (pBefore.weeksInSegment || 1)) : 0;
            xAfter = pAfter ? ((pAfter.opportunities || 0) / (pAfter.weeksInSegment || 1)) : xBefore;
            yAfter = pAfter ? ((pAfter.fpts || 0) / (pAfter.weeksInSegment || 1)) : yBefore;
        }
        
        // Linear interpolation (lerp)
        const x = xBefore + (xAfter - xBefore) * interpolationFactor;
        const y = yBefore + (yAfter - yBefore) * interpolationFactor;
        
        // Store trail data
        if (!smoothTrendPlayerTrails[chartId][player.player]) {
            smoothTrendPlayerTrails[chartId][player.player] = [];
        }
        const trail = smoothTrendPlayerTrails[chartId][player.player];
        trail.push({ x, y, segment: segmentFloat });  // v7: segment instead of week
        
        // Keep only last N positions (unless showing full trail at end)
        if (!showFullTrail && trail.length > state.maxTrailLength) {
            trail.shift();
        }
        
        return {
            x: x,
            y: y,
            label: player.player,
            player: player,
            trail: [...trail] // Copy trail for rendering
        };
    });
    
    // Render the chart with trails
    renderSmoothTrendChart(chartId, interpolatedData);
}

/**
 * Render chart with smooth data and trails
 */
function renderSmoothTrendChart(chartId, data) {
    const ctx = document.getElementById(chartId);
    if (!ctx) return;
    
    // v7: Calculate fixed axis ranges from ALL segments (not just current frame)
    const isWR = chartId.includes('wr-eval');
    const segmentData = isWR ? segmentDataWR : segmentDataRB;  // v7: use segmentData
    const segments = getAvailableSegments(segmentData);         // v7: use segments
    
    let allXValues = [];
    let allYValues = [];
    
    segments.forEach(segment => {                               // v7: iterate segments
        const segmentPlayers = getEvaluationSegmentData(segmentData, segment);  // v7: get segment data
        segmentPlayers.forEach(player => {
            if (chartId === 'wr-eval-volume-efficiency') {
                allXValues.push(player.targets || 0);
                allYValues.push(player.fptsPerTarget || 0);
            } else if (chartId === 'wr-eval-share-rz') {
                allXValues.push(player.targetShare || 0);
                allYValues.push(player.rzTargetShare || 0);
            } else if (chartId === 'rb-eval-total-rz') {
                allXValues.push(player.opportunities || 0);
                allYValues.push(player.rzOpportunities || 0);
            } else if (chartId === 'rb-eval-volume-efficiency') {
                allXValues.push(player.opportunities || 0);
                allYValues.push(player.efficiency || 0);
            } else if (chartId === 'wr-eval-production-volume') {
                allXValues.push((player.targets || 0) / (player.weeksInSegment || 1));
                allYValues.push((player.fpts || 0) / (player.weeksInSegment || 1));
            } else if (chartId === 'rb-eval-production-volume') {
                allXValues.push((player.opportunities || 0) / (player.weeksInSegment || 1));
                allYValues.push((player.fpts || 0) / (player.weeksInSegment || 1));
            }
        });
    });
    
    const xMin = Math.min(...allXValues.filter(v => v > 0));
    const xMax = Math.max(...allXValues);
    const yMin = Math.min(...allYValues.filter(v => v > 0));
    const yMax = Math.max(...allYValues);
    
    // Calculate medians for quadrant lines
    const xValues = allXValues.filter(v => v > 0).sort((a, b) => a - b);
    const yValues = allYValues.filter(v => v > 0).sort((a, b) => a - b);
    const medianX = xValues[Math.floor(xValues.length / 2)] || 5;
    const medianY = yValues[Math.floor(yValues.length / 2)] || 1.5;
    
    // Get existing chart
    let chart = window[`${chartId}Chart`];
    
    if (!chart) {
        // Create new chart with fixed axes
        chart = createSmoothTrendChart(ctx, chartId, medianX, medianY, xMin, xMax, yMin, yMax);
        window[`${chartId}Chart`] = chart;
    }
    
    // Update chart data (points + trails)
    const datasets = [];
    
    // Add trail datasets (one per player with trail)
    data.forEach(point => {
        if (point.trail && point.trail.length > 1) {
            const trailData = point.trail.map((t, idx) => ({
                x: t.x,
                y: t.y
            }));
            
            const teamColor = teamColors[point.player.team] || '#666';
            const r = parseInt(teamColor.slice(1, 3), 16);
            const g = parseInt(teamColor.slice(3, 5), 16);
            const b = parseInt(teamColor.slice(5, 7), 16);
            
            datasets.push({
                type: 'line',
                data: trailData,
                borderColor: `rgba(${r}, ${g}, ${b}, 0.6)`,  // More opaque (was 0.4)
                backgroundColor: 'transparent',
                borderWidth: 4,  // Thicker trail (was 2)
                pointRadius: 0,
                showLine: true,
                tension: 0.4
            });
        }
    });
    
    // Add main data points (current positions)
    datasets.push({
        type: 'scatter',
        data: data.map(d => ({ x: d.x, y: d.y, label: d.label, player: d.player })),
        backgroundColor: data.map(d => {
            const color = teamColors[d.player.team] || '#666';
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, 0.85)`;
        }),
        borderColor: data.map(d => teamColors[d.player.team] || '#666'),
        borderWidth: 2,
        pointRadius: 8,
        pointHoverRadius: 12
    });
    
    chart.data.datasets = datasets;
    chart.update('none'); // No animation for smooth movement
}

/**
 * Create a new chart with fixed configuration
 */
function createSmoothTrendChart(ctx, chartId, medianX, medianY, xMin, xMax, yMin, yMax) {
    // Determine labels based on chart type
    let xLabel, yLabel, quadrantLabels;
    
    if (chartId === 'wr-eval-volume-efficiency') {
        xLabel = 'Targets per Game →';
        yLabel = 'Fantasy Points per Target →';
        quadrantLabels = {
            topRight: ['Reliable Studs', '(Hold)'],
            topLeft: ['Efficient Sleepers', '(Buy Low)'],
            bottomRight: ['Volume, Poor Efficiency', '(Sell Window)'],
            bottomLeft: ['Bench Fodder']
        };
    } else if (chartId === 'wr-eval-share-rz') {
        xLabel = 'Target Share (% of Team) →';
        yLabel = 'Red Zone Target Share (% of Team) →';
        quadrantLabels = {
            topRight: ['Alpha WR1s'],
            topLeft: ['TD-Dependent', 'Boom/Busts'],
            bottomRight: ['Chain Movers'],
            bottomLeft: ['Background Noise']
        };
    } else if (chartId === 'rb-eval-total-rz') {
        xLabel = 'Opportunities per Game (Rush + Targets) →';
        yLabel = 'Red Zone Opportunities per Game →';
        quadrantLabels = {
            topRight: ['True Workhorses', '(Buy/Hold)'],
            topLeft: ['TD Vultures', '(Sell High)'],
            bottomRight: ['Between-the-20s Backs', '(Neutral)'],
            bottomLeft: ['Irrelevant Depth']
        };
    } else if (chartId === 'rb-eval-volume-efficiency') {
        xLabel = 'Opportunities per Game (Rush + Targets) →';
        yLabel = 'Efficiency (Fantasy Points per Opportunity) →';
        quadrantLabels = {
            topRight: ['Elite Dual Threats'],
            topLeft: ['Breakout Candidates'],
            bottomRight: ['Inefficient', 'Workhorses'],
            bottomLeft: ['Bench Fodder']
        };
    } else if (chartId === 'wr-eval-production-volume') {
        xLabel = 'Targets per Game →';
        yLabel = 'Fantasy Points per Game (FPPG) →';
        quadrantLabels = {
            topRight: ['Elite WR1s'],
            topLeft: ['Efficient Sleepers'],
            bottomRight: ['Volume Drags'],
            bottomLeft: ['Irrelevant']
        };
    } else if (chartId === 'rb-eval-production-volume') {
        xLabel = 'Opportunities per Game →';
        yLabel = 'Fantasy Points per Game (FPPG) →';
        quadrantLabels = {
            topRight: ['Elite Bellcows'],
            topLeft: ['Efficient Backups'],
            bottomRight: ['Plodding Workhorses'],
            bottomLeft: ['Irrelevant']
        };
    }
    
    return new Chart(ctx, {
        type: 'scatter',
        data: { datasets: [] },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false, // Disable default animations
            layout: {
                padding: {
                    left: 50,
                    right: 50,
                    top: 50,
                    bottom: 50
                }
            },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: (context) => {
                            const p = context.raw.player;
                            if (!p) return '';
                            return [
                                p.player,
                                `X: ${context.parsed.x.toFixed(1)}`,
                                `Y: ${context.parsed.y.toFixed(2)}`,
                                `Total: ${p.aggregate.totalFpts.toFixed(1)} pts`
                            ];
                        }
                    }
                },
                annotation: {
                    annotations: {
                        vLine: {
                            type: 'line',
                            xMin: medianX,
                            xMax: medianX,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        hLine: {
                            type: 'line',
                            yMin: medianY,
                            yMax: medianY,
                            borderColor: '#8e8e93',
                            borderWidth: 2,
                            borderDash: [5, 5]
                        },
                        topRight: {
                            type: 'label',
                            xValue: xMax * 0.70,  // Much closer to center (was 0.82)
                            yValue: yMax * 0.70,  // Much closer to center (was 0.82)
                            content: quadrantLabels.topRight,
                            color: '#30d158',
                            font: { size: 13, weight: 'bold' }  // Larger (was 10)
                        },
                        topLeft: {
                            type: 'label',
                            xValue: xMin * 1.5,   // Much closer to center (was 1.3)
                            yValue: yMax * 0.70,  // Much closer to center (was 0.82)
                            content: quadrantLabels.topLeft,
                            color: '#0a84ff',
                            font: { size: 13, weight: 'bold' }  // Larger (was 10)
                        },
                        bottomRight: {
                            type: 'label',
                            xValue: xMax * 0.70,  // Much closer to center (was 0.82)
                            yValue: yMin * 2.0,   // Much closer to center (was 1.5)
                            content: quadrantLabels.bottomRight,
                            color: '#FFD60A',
                            font: { size: 13, weight: 'bold' }  // Larger (was 10)
                        },
                        bottomLeft: {
                            type: 'label',
                            xValue: xMin * 1.5,   // Much closer to center (was 1.3)
                            yValue: yMin * 2.0,   // Much closer to center (was 1.5)
                            content: quadrantLabels.bottomLeft,
                            color: '#ff453a',
                            font: { size: 13, weight: 'bold' }  // Larger (was 10)
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: { display: true, text: xLabel, color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' },
                    min: xMin * 0.9,
                    max: xMax * 1.1
                },
                y: {
                    title: { display: true, text: yLabel, color: '#8e8e93', font: { weight: 'bold' } },
                    grid: { color: '#2c2c2e' },
                    ticks: { color: '#8e8e93' },
                    min: yMin * 0.9,
                    max: chartId === 'wr-eval-share-rz' ? 110 : yMax * 1.1  // Special case for WR RZ Share
                }
            }
        }
    });
}

/**
 * Update UI helpers
 */
function updatePlayButton(chartId, isPlaying) {
    const btn = document.getElementById(`${chartId}-play-btn`);
    if (btn) {
        if (isPlaying) {
            btn.classList.add('playing');
            btn.querySelector('.play-icon').textContent = '⏸';
        } else {
            btn.classList.remove('playing');
            btn.querySelector('.play-icon').textContent = '▶';
        }
    }
}

/**
 * Update segment label display (v7: NEW FUNCTION)
 */
function updateSegmentLabel(chartId, segmentFloat) {
    const label = document.getElementById(`${chartId}-week-label`);
    if (label && smoothTrendState[chartId]) {
        const isWR = chartId.includes('wr-eval');
        const segmentData = isWR ? segmentDataWR : segmentDataRB;
        
        // Format the segment label
        const segmentIndex = Math.floor(segmentFloat);
        const weeks = getSegmentWeekRange(segmentData, segmentIndex);
        
        if (weeks.length > 0) {
            const firstWeek = weeks[0];
            const lastWeek = weeks[weeks.length - 1];
            label.textContent = `Segments ${firstWeek}-${lastWeek}`;
        } else {
            label.textContent = `Segment ${segmentIndex}`;
        }
    }
}

/**
 * Legacy week label function (kept for compatibility)
 */
function updateWeekLabel(chartId, weekFloat) {
    // Redirect to segment label
    updateSegmentLabel(chartId, weekFloat);
}

function updateScrubberPosition(chartId, segmentFloat) {
    const scrubber = document.getElementById(`${chartId}-scrubber`);
    if (scrubber) {
        scrubber.value = segmentFloat;
    }
}


        


                // Sort table function (now re-renders card tiers)
        function sortTable(position, column) {
            // Re-render player cards (tiers are always sorted by avg points)
            if (position === 'wr') {
                renderWRPlayerCards();
            } else {
                renderRBPlayerCards();
            }
        }

        // Close modal on click outside
        document.getElementById('player-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeModal();
            }
        });
        
        document.getElementById('team-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeTeamModal();
            }
        });

        // Close modal on ESC key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeModal();
                closeTeamModal();
            }
        });

        // ============================================
        // 6. INITIALIZATION
        // ============================================

        window.addEventListener('DOMContentLoaded', function() {
            // Load sentiment data
            loadSentimentData();
            
            // Load comments
            const storedComments = localStorage.getItem('ffse_player_comments');
            if (storedComments) {
                playerComments = JSON.parse(storedComments);
            }
            
            loadStoredData();
            
            // Show upload prompt if no data
            if (!wrData || !rbData) {
                const mainContent = document.querySelector('.main-content');
                mainContent.innerHTML = `
                    <div class="upload-section">
                        <div class="upload-title">Welcome to Fantasy Stock Exchange</div>
                        <div class="upload-subtitle">Upload your WR and RB CSV files to get started</div>
                        <div class="upload-buttons">
                            <label class="upload-file-btn" for="wr-file-input">
                                📊 Upload WR Data
                            </label>
                            <label class="upload-file-btn" for="rb-file-input">
                                📊 Upload RB Data
                            </label>
                        </div>
                        ${wrData ? '<div class="data-status">✓ WR Data Loaded</div>' : ''}
                        ${rbData ? '<div class="data-status">✓ RB Data Loaded</div>' : ''}
                    </div>
                ` + mainContent.innerHTML;
            } else {
                // Data is loaded - render dashboard if it's the active page
                setTimeout(() => {
                    const dashboardPage = document.getElementById('top-movers');
                    if (dashboardPage && dashboardPage.classList.contains('active')) {
                        renderDashboardCategories();
                        setTimeout(renderMiniScatterPlots, 100);
                    }
                }, 200);
            }
        });
        
        // ============================================
        // PAGE VISIBILITY API - Pause Animations
        // ============================================
        document.addEventListener('visibilitychange', function() {
            // Only run if animationStates is defined (for WR/RB analytics pages)
            if (typeof animationStates === 'undefined') return;
            
            if (document.hidden) {
                // Page is hidden - pause all animations
                Object.keys(animationStates).forEach(chartId => {
                    if (animationStates[chartId].isPlaying) {
                        // Store that it was playing
                        animationStates[chartId].wasPlayingBeforeHidden = true;
                        // Pause the animation
                        pauseSmoothTrendAnimation(chartId);
                    }
                });
            } else {
                // Page is visible again - resume animations that were playing
                Object.keys(animationStates).forEach(chartId => {
                    if (animationStates[chartId].wasPlayingBeforeHidden) {
                        // Resume the animation
                        playSmoothTrendAnimation(chartId);
                        animationStates[chartId].wasPlayingBeforeHidden = false;
                    }
                });
            }
        });
        
        // ============================================
        // DASHBOARD CATEGORIES SYSTEM
        // ============================================
        
        // Helper: Calculate averages for last 3 games
        function getLast3GamesAvg(player) {
            if (!player.weeks || player.weeks.length === 0) return null;
            
            // Find the global maximum week across ALL WRs, RBs, and TEs (the current week of the season)
            let globalMaxWeek = 0;
            
            // Check all WRs
            Object.values(aggregatedWRs).forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });
            
            // Check all RBs
            Object.values(aggregatedRBs).forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });
            
            // Check all TEs
            Object.values(aggregatedTEs).forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });
            
            if (globalMaxWeek === 0) return null;
            
            // The last 3 weeks are based on the GLOBAL max week (current week of season)
            const last3ActualWeeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
            const prior3ActualWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];
            
            // Filter to only games within the last 3 actual weeks where player had fantasy points
            let last3WeeksGames = player.weeks.filter(w => 
                last3ActualWeeks.includes(w.week) && w.fpts > 0
            );
            
            // NEW LOGIC: If player only has 1 game in last 3 weeks (e.g., injured/bye most recent week)
            // but has 2+ games in weeks 2-3 of the window, use those 2 weeks
            let usedAlternateWeeks = false;
            if (last3WeeksGames.length === 1) {
                // Check if they have data from weeks globalMaxWeek-1 and globalMaxWeek-2
                const weeks2and3 = player.weeks.filter(w => 
                    [globalMaxWeek - 1, globalMaxWeek - 2].includes(w.week) && w.fpts > 0
                );
                
                if (weeks2and3.length >= 2) {
                    // Use these 2 weeks for "last 3"
                    last3WeeksGames = weeks2and3;
                    usedAlternateWeeks = true;
                }
            }
            
            // If still less than 2 games, try getting most recent games regardless of week
            if (last3WeeksGames.length < 2) {
                // Get all games with points, sorted by week descending
                const allGamesWithPoints = player.weeks
                    .filter(w => w.fpts > 0)
                    .sort((a, b) => b.week - a.week);
                
                if (allGamesWithPoints.length >= 2) {
                    last3WeeksGames = allGamesWithPoints.slice(0, Math.min(3, allGamesWithPoints.length));
                    usedAlternateWeeks = true;
                }
            }
            
            // Filter for prior 3 weeks
            let prior3WeeksGames = player.weeks.filter(w =>
                prior3ActualWeeks.includes(w.week) && w.fpts > 0
            );
            
            // If we used alternate weeks for last 3, adjust prior weeks accordingly
            if (usedAlternateWeeks && last3WeeksGames.length > 0) {
                const oldestRecentWeek = Math.min(...last3WeeksGames.map(w => w.week));
                // Get 3 games before the oldest recent week
                prior3WeeksGames = player.weeks
                    .filter(w => w.week < oldestRecentWeek && w.fpts > 0)
                    .sort((a, b) => b.week - a.week)
                    .slice(0, 3);
            }
            
            // Count how many of the last 3 weeks the player actually played with points
            const gamesPlayed = last3WeeksGames.length;
            
            // Player must have played at least 2 games
            if (gamesPlayed < 2) return null;
            
            const totalPoints = last3WeeksGames.reduce((sum, w) => sum + w.fpts, 0);
            const avgPoints = totalPoints / gamesPlayed;
            
            let avgVolume = 0;
            if (player.position === 'WR' || player.position === 'TE') {
                avgVolume = last3WeeksGames.reduce((sum, w) => sum + (w.targets || 0), 0) / gamesPlayed;
            } else {
                avgVolume = last3WeeksGames.reduce((sum, w) => sum + (w.opportunities || 0), 0) / gamesPlayed;
            }
            
            const efficiency = avgVolume > 0 ? avgPoints / avgVolume : 0;
            
            // Calculate prior 3 weeks metrics for comparison
            let priorAvgVolume = 0;
            let priorEfficiency = 0;
            let priorRzOppsPerGame = 0;
            
            if (prior3WeeksGames.length >= 2) {
                if (player.position === 'WR' || player.position === 'TE') {
                    priorAvgVolume = prior3WeeksGames.reduce((sum, w) => sum + (w.targets || 0), 0) / prior3WeeksGames.length;
                } else {
                    priorAvgVolume = prior3WeeksGames.reduce((sum, w) => sum + (w.opportunities || 0), 0) / prior3WeeksGames.length;
                }
                priorEfficiency = priorAvgVolume > 0 ? prior3WeeksGames.reduce((sum, w) => sum + w.fpts, 0) / prior3WeeksGames.length / priorAvgVolume : 0;
                
                // Calculate prior RZ opps
                const rawData = player.position === 'WR' ? wrData : (player.position === 'TE' ? teData : rbData);
                if (rawData) {
                    let priorTotalRzOpps = 0;
                    prior3WeeksGames.forEach(weekData => {
                        const weekNum = weekData.week;
                        const weekRow = rawData.find(row => 
                            row.Team === player.team && 
                            row.Player === player.name && 
                            parseInt(row.Week) === weekNum
                        );
                        if (weekRow) {
                            if (player.position === 'WR' || player.position === 'TE') {
                                priorTotalRzOpps += parseFloat(weekRow.RZTGT) || 
                                                  parseFloat(weekRow['RZ TGT']) || 
                                                  parseFloat(weekRow.RZ_TGT) || 
                                                  parseFloat(weekRow['Red Zone Targets']) || 
                                                  0;
                            } else {
                                const rzAtt = parseFloat(weekRow.RZ_RUSH_ATT) || 
                                             parseFloat(weekRow['RZ_RUSH_ATT']) || 
                                             parseFloat(weekRow.RZATT) || 
                                             parseFloat(weekRow['RZ ATT']) || 
                                             parseFloat(weekRow.RZ_ATT) || 
                                             0;
                                const rzTgt = parseFloat(weekRow['RZ TGT']) || 
                                             parseFloat(weekRow.RZ_TGT) || 
                                             parseFloat(weekRow.RZTGT) || 
                                             0;
                                priorTotalRzOpps += rzAtt + rzTgt;
                            }
                        }
                    });
                    priorRzOppsPerGame = priorTotalRzOpps / prior3WeeksGames.length;
                }
            }
            
            // Calculate RZ opportunities from last 3 weeks
            let totalRzOpps = 0;
            const rawData = player.position === 'WR' ? wrData : (player.position === 'TE' ? teData : rbData);
            if (rawData) {
                last3WeeksGames.forEach(weekData => {
                    const weekNum = weekData.week;
                    const weekRow = rawData.find(row => 
                        row.Team === player.team && 
                        row.Player === player.name && 
                        parseInt(row.Week) === weekNum
                    );
                    if (weekRow) {
                        if (player.position === 'WR' || player.position === 'TE') {
                            // Try multiple column name variations for WR/TE red zone targets
                            totalRzOpps += parseFloat(weekRow.RZTGT) || 
                                          parseFloat(weekRow['RZ TGT']) || 
                                          parseFloat(weekRow.RZ_TGT) || 
                                          parseFloat(weekRow['Red Zone Targets']) || 
                                          0;
                        } else {
                            // For RBs: Red zone attempts + red zone targets
                            const rzAtt = parseFloat(weekRow.RZ_RUSH_ATT) || 
                                         parseFloat(weekRow['RZ_RUSH_ATT']) || 
                                         parseFloat(weekRow.RZATT) || 
                                         parseFloat(weekRow['RZ ATT']) || 
                                         parseFloat(weekRow.RZ_ATT) || 
                                         0;
                            const rzTgt = parseFloat(weekRow['RZ TGT']) || 
                                         parseFloat(weekRow.RZ_TGT) || 
                                         parseFloat(weekRow.RZTGT) || 
                                         0;
                            totalRzOpps += rzAtt + rzTgt;
                        }
                    }
                });
            }
            
            return {
                avgPoints,
                avgVolume,
                efficiency,
                gamesPlayed,
                rzOppsPerGame: totalRzOpps / gamesPlayed,
                globalMaxWeek,  // Include for debugging if needed
                // Prior 3 weeks for comparison
                priorAvgVolume,
                priorEfficiency,
                priorRzOppsPerGame
            };
        }
        
        function calculateDashboardCategories() {
            // Combine WR, RB, and TE players with minimum 3 games played
            const allEligiblePlayers = [
                ...Object.values(aggregatedWRs).filter(p => p.gamesPlayed >= 3),
                ...Object.values(aggregatedRBs).filter(p => p.gamesPlayed >= 3),
                ...Object.values(aggregatedTEs).filter(p => p.gamesPlayed >= 3)
            ];
            
            if (allEligiblePlayers.length === 0) return null;
            
            // Helper function: Check if player should be excluded due to inactivity
            // Returns true if player should be EXCLUDED (hasn't played in 3+ weeks without 2 games back)
            function shouldExcludePlayerForInactivity(player) {
                if (!player.weeks || player.weeks.length === 0) return true;
                
                // Find global max week (current week)
                let globalMaxWeek = 0;
                [...Object.values(aggregatedWRs), ...Object.values(aggregatedRBs), ...Object.values(aggregatedTEs)].forEach(p => {
                    if (p.weeks && p.weeks.length > 0) {
                        const maxWeek = Math.max(...p.weeks.map(w => w.week));
                        if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                    }
                });
                
                // Get player's games with points
                const gamesWithPoints = player.weeks.filter(w => w.fpts > 0).sort((a, b) => b.week - a.week);
                if (gamesWithPoints.length === 0) return true;
                
                const mostRecentGame = gamesWithPoints[0];
                const weeksAgo = globalMaxWeek - mostRecentGame.week;
                
                // If player's last game was 3+ weeks ago
                if (weeksAgo >= 3) {
                    // Check if they have 2+ games since coming back
                    // "Coming back" means any games after a 3+ week absence
                    // Count games in the last 3 weeks
                    const recentGames = player.weeks.filter(w => 
                        w.week >= (globalMaxWeek - 2) && w.fpts > 0
                    );
                    
                    // If they don't have at least 2 recent games, exclude them
                    if (recentGames.length < 2) {
                        return true; // EXCLUDE
                    }
                }
                
                return false; // INCLUDE
            }
            
            // Add last 3 games data to each player and filter by 7+ PPG and activity
            const playersWithLast3 = allEligiblePlayers
                .filter(p => !shouldExcludePlayerForInactivity(p)) // NEW: Filter out inactive players
                .map(p => {
                    const last3 = getLast3GamesAvg(p);
                    return { ...p, last3 };
                })
                .filter(p => {
                    // getLast3GamesAvg returns null if player hasn't played 2 of last 3 weeks
                    if (!p.last3) return false;
                    // MIN 7 PPG filter
                    return p.last3.avgPoints >= 7.0;
                });
            
            const categories = {
                volumeMonsters: calculateVolumeMonsters(playersWithLast3),
                efficiencyElites: calculateEfficiencyElites(playersWithLast3),
                redZoneKingsWR: calculateRedZoneKingsWR(playersWithLast3),
                redZoneBacks: calculateRedZoneBacks(playersWithLast3),
                rbEfficiency: calculateRBEfficiency(playersWithLast3),
                consistentFloor: calculateConsistentFloor(playersWithLast3),
                airYardsLeaders: calculateAirYardsLeaders(playersWithLast3),
                passCatchingBacks: calculatePassCatchingBacks(playersWithLast3),
                targetLeadersTE: calculateTargetLeadersTE(playersWithLast3),
                redZoneDominanceTE: calculateRedZoneDominanceTE(playersWithLast3),
                totalTouchdownLeadersWR: calculateTotalTouchdownLeadersWR(playersWithLast3)
            };
            
            return categories;
        }
        
        // Category 1: Volume Monsters (Last 3 Games) - RBs Only
        function calculateVolumeMonsters(players) {
            // Filter to only RBs
            const rbPlayers = players.filter(p => p.position === 'RB');
            
            const volumeData = rbPlayers.map(p => {
                const volume = p.last3.avgVolume; // Use last 3 games average
                const priorVolume = p.last3.priorAvgVolume || 0;
                const change = priorVolume > 0 ? volume - priorVolume : 0;
                return { player: p, value: volume, change: change };
            }).sort((a, b) => b.value - a.value);
            
            // Get 75th percentile threshold
            const threshold = volumeData[Math.floor(volumeData.length * 0.25)]?.value || 0;
            
            return volumeData
                .filter(d => d.value >= threshold)
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'Opps/Game (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'High touch volume (last 3 games) - workhouse usage',
                    scatterKey: 'volume-efficiency'
                }));
        }
        
        // Category 2: Efficiency Elites (Last 3 Games)
        function calculateEfficiencyElites(players) {
            const efficiencyData = players
                .filter(p => p.avgPoints >= 7) // Only players with 7+ PPG
                .map(p => {
                    const efficiency = p.last3.efficiency; // Use last 3 games efficiency
                    const priorEfficiency = p.last3.priorEfficiency || 0;
                    const change = priorEfficiency > 0 ? efficiency - priorEfficiency : 0;
                    return { player: p, value: efficiency, change: change };
                }).sort((a, b) => b.value - a.value);
            
            // Top 20%
            return efficiencyData
                .slice(0, Math.ceil(efficiencyData.length * 0.2))
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(2),
                    metricLabel: d.player.position === 'WR' ? 'Pts/Tgt (L3)' : 'Pts/Opp (L3)',
                    change: d.change.toFixed(2),
                    explanation: 'Elite production per touch (last 3 games) - league winner upside if volume increases',
                    scatterKey: 'volume-efficiency'
                }));
        }
        
        // Category 3: Red Zone Kings WR (Last 3 Games) - WRs Only
        function calculateRedZoneKingsWR(players) {
            // Filter to only WRs
            const wrPlayers = players.filter(p => p.position === 'WR');
            
            const redZoneData = wrPlayers.map(p => {
                const rzPerGame = p.last3.rzOppsPerGame; // Use last 3 games RZ opps
                const priorRzPerGame = p.last3.priorRzOppsPerGame || 0;
                const change = priorRzPerGame > 0 ? rzPerGame - priorRzPerGame : 0;
                return { player: p, value: rzPerGame, change: change };
            })
            .filter(d => d.value > 0) // Only players with RZ opportunities
            .sort((a, b) => b.value - a.value);
            
            // Take top 8 WRs
            return redZoneData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'RZ Tgt/G (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'WRs with highest red zone target rate (last 3 games) - weekly TD upside',
                    scatterKey: 'redzone'
                }));
        }
        
        // Category 4: Red Zone Backs (Last 3 Games) - RBs Only
        function calculateRedZoneBacks(players) {
            // Filter to only RBs
            const rbPlayers = players.filter(p => p.position === 'RB');
            
            const redZoneData = rbPlayers.map(p => {
                const rzPerGame = p.last3.rzOppsPerGame; // Use last 3 games RZ opps (rush + targets)
                const priorRzPerGame = p.last3.priorRzOppsPerGame || 0;
                const change = priorRzPerGame > 0 ? rzPerGame - priorRzPerGame : 0;
                return { player: p, value: rzPerGame, change: change };
            })
            .filter(d => d.value > 0) // Only players with RZ opportunities
            .sort((a, b) => b.value - a.value);
            
            // Take top 8 RBs
            return redZoneData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'RZ Opps/G (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'RBs with highest red zone usage (last 3 games) - carries + targets in scoring position',
                    scatterKey: 'redzone'
                }));
        }
        
        // Category 5: RB Efficiency (Last 3 Games) - Rushing Yards Per Attempt
        function calculateRBEfficiency(players) {
            // Filter to only RBs
            const rbPlayers = players.filter(p => p.position === 'RB');
            
            const efficiencyData = rbPlayers.map(p => {
                // Calculate yards per attempt from last 3 games
                let totalYards = 0;
                let totalAttempts = 0;
                let priorTotalYards = 0;
                let priorTotalAttempts = 0;
                
                if (p.weeks && p.weeks.length > 0) {
                    // Get the global max week
                    let globalMaxWeek = 0;
                    Object.values(aggregatedRBs).forEach(rb => {
                        if (rb.weeks && rb.weeks.length > 0) {
                            const maxWeek = Math.max(...rb.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });
                    
                    const last3Weeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
                    const prior3Weeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];
                    
                    // Sum yards and attempts from last 3 weeks
                    p.weeks.forEach(w => {
                        if (last3Weeks.includes(w.week)) {
                            // Get raw data for this week
                            const weekRow = rbData.find(row => 
                                row.Player === p.name && 
                                row.Team === p.team && 
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow) {
                                totalYards += parseFloat(weekRow.YDS) || 0;
                                totalAttempts += parseFloat(weekRow.ATT) || 0;
                            }
                        }
                        // Calculate prior 3 weeks for comparison
                        if (prior3Weeks.includes(w.week)) {
                            const weekRow = rbData.find(row => 
                                row.Player === p.name && 
                                row.Team === p.team && 
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow) {
                                priorTotalYards += parseFloat(weekRow.YDS) || 0;
                                priorTotalAttempts += parseFloat(weekRow.ATT) || 0;
                            }
                        }
                    });
                }
                
                const yardsPerAttempt = totalAttempts > 0 ? totalYards / totalAttempts : 0;
                const priorYardsPerAttempt = priorTotalAttempts > 0 ? priorTotalYards / priorTotalAttempts : 0;
                const change = priorYardsPerAttempt > 0 ? yardsPerAttempt - priorYardsPerAttempt : 0;
                
                return { 
                    player: p, 
                    value: yardsPerAttempt, 
                    totalAttempts: totalAttempts,
                    change: change
                };
            })
            .filter(d => d.totalAttempts >= 20) // Minimum 20 attempts over last 3 games
            .sort((a, b) => b.value - a.value);
            
            // Take top 8 RBs
            return efficiencyData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(2),
                    metricLabel: 'Yds/Att (L3)',
                    change: d.change,
                    explanation: 'RBs with highest yards per carry (last 3 games) - explosive rushing efficiency',
                    scatterKey: 'volume-efficiency'
                }));
        }
        
        // Category 4: Buy Low Gems (Last 3 Games Performance)
        function calculateBuyLowGems(players) {
            const buyLowData = players.map(p => {
                // High opportunity share on good offense, but underperforming recently
                const oppShare = p.latestWeekOppShare || 0;
                const teamPts = p.latestWeekTeamPoints || 0;
                const situationScore = oppShare * (teamPts / 30); // Normalize team points
                const actualPPG = p.last3.avgPoints; // Use last 3 games average
                const expectedPPG = situationScore * 2; // Rough expected
                const underperformance = expectedPPG - actualPPG;
                
                return { 
                    player: p, 
                    value: underperformance,
                    situationScore: situationScore,
                    actualPPG: actualPPG
                };
            })
            .filter(d => d.underperformance > 0 && d.situationScore > 15)
            .sort((a, b) => b.value - a.value);
            
            return buyLowData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.actualPPG.toFixed(1),
                    metricLabel: 'PPG (L3)',
                    score: d.situationScore.toFixed(0),
                    explanation: 'Good situation + volume, recent production should improve',
                    scatterKey: 'opportunity-share'
                }));
        }
        
        // Category 5: Sell High Alerts (Last 3 Games Variance)
        function calculateSellHighAlerts(players) {
            const sellHighData = players.map(p => {
                // Calculate variance from last 3 games
                const last3Weeks = [...p.weeks].sort((a, b) => b.week - a.week).slice(0, 3);
                const variances = last3Weeks.map(w => {
                    const weekAvg = w.fpts;
                    return Math.pow(weekAvg - p.last3.avgPoints, 2);
                });
                const variance = variances.reduce((sum, v) => sum + v, 0) / variances.length;
                const stdDev = Math.sqrt(variance);
                const consistency = 10 / (stdDev + 1);
                
                const ppg = p.last3.avgPoints; // Use last 3 games average
                
                return { 
                    player: p, 
                    value: ppg,
                    consistency: consistency,
                    stdDev: stdDev
                };
            })
            .filter(d => d.value > 12) // High recent PPG
            .sort((a, b) => a.consistency - b.consistency); // Low consistency (high variance)
            
            return sellHighData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'PPG (L3)',
                    score: d.consistency.toFixed(1),
                    explanation: 'Boom/bust scoring recently - sell while value is high',
                    scatterKey: 'floor-ceiling'
                }));
        }
        
        // Category 6: Bellcows / Target Hogs (Recent Performance)
        function calculateBellcowsTargetHogs(players) {
            const bellcowData = players.map(p => {
                // Calculate average opportunity share over last 3 weeks
                const last3Weeks = [...p.weeks].sort((a, b) => b.week - a.week).slice(0, 3);
                let totalShare = 0;
                let weekCount = 0;
                
                last3Weeks.forEach(weekData => {
                    const rawData = p.position === 'WR' ? wrData : rbData;
                    if (rawData) {
                        const weekRow = rawData.find(row => 
                            row.Team === p.team && 
                            row.Player === p.name && 
                            parseInt(row.Week) === weekData.week
                        );
                        if (weekRow && weekRow['Opp Share']) {
                            totalShare += parseFloat(weekRow['Opp Share']) || 0;
                            weekCount++;
                        }
                    }
                });
                
                const avgShare = weekCount > 0 ? totalShare / weekCount : 0;
                const threshold = p.position === 'WR' ? 28 : 70; // WR: 28% target share, RB: 70% opp share
                
                return { player: p, value: avgShare, threshold: threshold };
            })
            .filter(d => d.value >= d.threshold)
            .sort((a, b) => b.value - a.value);
            
            return bellcowData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1) + '%',
                    metricLabel: d.player.position === 'WR' ? 'Tgt Share (L3)' : 'Opp Share (L3)',
                    score: d.player.last3.avgPoints.toFixed(1),
                    explanation: d.player.position === 'WR' ? 
                        'Target hog over last 3 games - will get volume in any game script' :
                        'Bellcow back over last 3 games - elite workload share',
                    scatterKey: 'opportunity-share'
                }));
        }
        
        // Category 7: High-Volume Alphas (Last 3 Games) - WRs Only, Based on Targets
        function calculateConsistentFloor(players) {
            // Filter to only WRs
            const wrPlayers = players.filter(p => p.position === 'WR');
            
            const consistentData = wrPlayers.map(p => {
                // Use targets per game as the consistency metric for WRs
                const targetsPerGame = p.last3.avgVolume; // For WRs, avgVolume is targets
                const ppg = p.last3.avgPoints;
                const priorTargetsPerGame = p.last3.priorAvgVolume || 0;
                const change = priorTargetsPerGame > 0 ? targetsPerGame - priorTargetsPerGame : 0;
                
                return { 
                    player: p, 
                    value: targetsPerGame,
                    ppg: ppg,
                    change: change
                };
            })
            .filter(d => d.ppg > 8 && d.value >= 6) // Decent production and minimum target volume
            .sort((a, b) => b.value - a.value); // Sort by targets per game
            
            return consistentData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'Tgt/Game (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'Consistent target volume recently - reliable PPR floor',
                    scatterKey: 'volume-efficiency'
                }));
        }
        
        // Category 8: Air Yards Leaders (Last 3 Games) - WRs Only
        function calculateAirYardsLeaders(players) {
            // Filter to only WRs
            const wrPlayers = players.filter(p => p.position === 'WR');
            
            const airYardsData = wrPlayers.map(p => {
                // Calculate air yards per game from last 3 games
                let totalAirYards = 0;
                let gameCount = 0;
                
                if (p.weeks && p.weeks.length > 0) {
                    // Get the global max week
                    let globalMaxWeek = 0;
                    Object.values(aggregatedWRs).forEach(wr => {
                        if (wr.weeks && wr.weeks.length > 0) {
                            const maxWeek = Math.max(...wr.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });
                    
                    const last3Weeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
                    
                    // Sum air yards from last 3 weeks
                    p.weeks.forEach(w => {
                        if (last3Weeks.includes(w.week)) {
                            // Get raw data for this week
                            const weekRow = wrData.find(row => 
                                row.Team === p.team && 
                                row.Player === p.name && 
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow && weekRow['Air Yards']) {
                                totalAirYards += parseFloat(weekRow['Air Yards']) || 0;
                                gameCount++;
                            }
                        }
                    });
                }
                
                const airYardsPerGame = gameCount > 0 ? totalAirYards / gameCount : 0;
                
                // Calculate prior weeks for change
                let priorAirYards = 0;
                let priorGameCount = 0;
                
                if (p.weeks && p.weeks.length > 0) {
                    let globalMaxWeek = 0;
                    Object.values(aggregatedWRs).forEach(wr => {
                        if (wr.weeks && wr.weeks.length > 0) {
                            const maxWeek = Math.max(...wr.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });
                    
                    const priorWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];
                    
                    p.weeks.forEach(w => {
                        if (priorWeeks.includes(w.week)) {
                            const weekRow = wrData.find(row => 
                                row.Team === p.team && 
                                row.Player === p.name && 
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow && weekRow['Air Yards']) {
                                priorAirYards += parseFloat(weekRow['Air Yards']) || 0;
                                priorGameCount++;
                            }
                        }
                    });
                }
                
                const priorAirYardsPerGame = priorGameCount > 0 ? priorAirYards / priorGameCount : 0;
                const change = priorAirYardsPerGame > 0 ? airYardsPerGame - priorAirYardsPerGame : 0;
                
                return { player: p, value: airYardsPerGame, change: change };
            })
            .filter(d => d.value > 0)
            .sort((a, b) => b.value - a.value);
            
            return airYardsData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'Air Yds/G (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'Deep threat potential - high air yards signal downfield usage',
                    scatterKey: 'volume-efficiency'
                }));
        }
        
        // Category 9: Pass-Catching Backs (Last 3 Games) - RBs Only
        function calculatePassCatchingBacks(players) {
            // Filter to only RBs
            const rbPlayers = players.filter(p => p.position === 'RB');
            
            const receivingData = rbPlayers.map(p => {
                // Calculate targets per game from last 3 games
                let totalTargets = 0;
                let gameCount = 0;
                
                if (p.weeks && p.weeks.length > 0) {
                    // Get the global max week
                    let globalMaxWeek = 0;
                    Object.values(aggregatedRBs).forEach(rb => {
                        if (rb.weeks && rb.weeks.length > 0) {
                            const maxWeek = Math.max(...rb.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });
                    
                    const last3Weeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
                    
                    // Sum targets from last 3 weeks
                    p.weeks.forEach(w => {
                        if (last3Weeks.includes(w.week)) {
                            // Get raw data for this week
                            const weekRow = rbData.find(row => 
                                row.Team === p.team && 
                                row.Player === p.name && 
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow && weekRow.TGT) {
                                totalTargets += parseFloat(weekRow.TGT) || 0;
                                gameCount++;
                            }
                        }
                    });
                }
                
                const targetsPerGame = gameCount > 0 ? totalTargets / gameCount : 0;
                
                // Calculate prior weeks for change
                let priorTargets = 0;
                let priorGameCount = 0;
                
                if (p.weeks && p.weeks.length > 0) {
                    let globalMaxWeek = 0;
                    Object.values(aggregatedRBs).forEach(rb => {
                        if (rb.weeks && rb.weeks.length > 0) {
                            const maxWeek = Math.max(...rb.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });
                    
                    const priorWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];
                    
                    p.weeks.forEach(w => {
                        if (priorWeeks.includes(w.week)) {
                            const weekRow = rbData.find(row => 
                                row.Team === p.team && 
                                row.Player === p.name && 
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow && weekRow.TGT) {
                                priorTargets += parseFloat(weekRow.TGT) || 0;
                                priorGameCount++;
                            }
                        }
                    });
                }
                
                const priorTargetsPerGame = priorGameCount > 0 ? priorTargets / priorGameCount : 0;
                const change = priorTargetsPerGame > 0 ? targetsPerGame - priorTargetsPerGame : 0;
                
                return { player: p, value: targetsPerGame, change: change };
            })
            .filter(d => d.value >= 2.0) // Minimum 2 targets per game
            .sort((a, b) => b.value - a.value);
            
            return receivingData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'Tgt/Game (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'Pass-catching backs - PPR gold with receiving volume',
                    scatterKey: 'volume-efficiency'
                }));
        }
        
        // NEW Category 9: TE Target Leaders (Last 3 Games) - TEs Only
        function calculateTargetLeadersTE(players) {
            // Filter to only TEs
            const tePlayers = players.filter(p => p.position === 'TE');
            
            const targetData = tePlayers.map(p => {
                const targetsPerGame = p.last3.avgVolume; // For TEs, avgVolume is targets per game
                const priorTargetsPerGame = p.last3.priorAvgVolume || 0;
                const change = priorTargetsPerGame > 0 ? targetsPerGame - priorTargetsPerGame : 0;
                return { player: p, value: targetsPerGame, change: change };
            })
            .filter(d => d.value > 0) // Only TEs with targets
            .sort((a, b) => b.value - a.value);
            
            // Take top 8 TEs
            return targetData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'Tgt/Game (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'TEs with highest target volume (last 3 games) - consistent fantasy floor',
                    scatterKey: 'volume-efficiency'
                }));
        }
        
        // NEW Category 10: TE Red Zone Dominance (Last 3 Games) - TEs Only
        function calculateRedZoneDominanceTE(players) {
            // Filter to only TEs
            const tePlayers = players.filter(p => p.position === 'TE');
            
            const redZoneData = tePlayers.map(p => {
                // Calculate combined RZ targets and TDs per game from last 3 games
                let rzTargets = 0;
                let rzTDs = 0;
                let gameCount = 0;
                
                if (p.weeks && p.weeks.length > 0) {
                    // Get the global max week
                    let globalMaxWeek = 0;
                    Object.values(aggregatedTEs).forEach(te => {
                        if (te.weeks && te.weeks.length > 0) {
                            const maxWeek = Math.max(...te.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });
                    
                    const last3Weeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
                    
                    // Sum RZ data from last 3 weeks
                    p.weeks.forEach(w => {
                        if (last3Weeks.includes(w.week)) {
                            const weekRow = teData.find(row => 
                                row.Player === p.name && 
                                row.Team === p.team && 
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow) {
                                rzTargets += parseFloat(weekRow.RZ_TGT) || 0;
                                rzTDs += parseFloat(weekRow.RZ_TD) || 0;
                                gameCount++;
                            }
                        }
                    });
                }
                
                // Weight: RZ targets + (RZ TDs * 3) - TDs are more valuable
                const rzScore = gameCount > 0 ? (rzTargets + (rzTDs * 3)) / gameCount : 0;
                
                // Calculate prior weeks for change
                let priorRzTargets = 0;
                let priorRzTDs = 0;
                let priorGameCount = 0;
                
                if (p.weeks && p.weeks.length > 0) {
                    let globalMaxWeek = 0;
                    Object.values(aggregatedTEs).forEach(te => {
                        if (te.weeks && te.weeks.length > 0) {
                            const maxWeek = Math.max(...te.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });
                    
                    const priorWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];
                    
                    p.weeks.forEach(w => {
                        if (priorWeeks.includes(w.week)) {
                            const weekRow = teData.find(row => 
                                row.Player === p.name && 
                                row.Team === p.team && 
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow) {
                                priorRzTargets += parseFloat(weekRow.RZ_TGT) || 0;
                                priorRzTDs += parseFloat(weekRow.RZ_TD) || 0;
                                priorGameCount++;
                            }
                        }
                    });
                }
                
                const priorRzScore = priorGameCount > 0 ? (priorRzTargets + (priorRzTDs * 3)) / priorGameCount : 0;
                const change = priorRzScore > 0 ? rzScore - priorRzScore : 0;
                
                return { player: p, value: rzScore, change: change, rzTargets: rzTargets, rzTDs: rzTDs, gameCount: gameCount };
            })
            .filter(d => d.value > 0) // Only TEs with RZ involvement
            .sort((a, b) => b.value - a.value);
            
            return redZoneData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'RZ Score (L3)',
                    change: d.change.toFixed(1),
                    explanation: 'TEs with most RZ targets + TDs (last 3 games) - weekly TD upside',
                    scatterKey: 'redzone'
                }));
        }
        
        // NEW Category 11: WR Total Touchdown Leaders (Last 3 Games) - WRs Only
        function calculateTotalTouchdownLeadersWR(players) {
            // Filter to only WRs
            const wrPlayers = players.filter(p => p.position === 'WR');
            
            const tdData = wrPlayers.map(p => {
                // Calculate total TDs per game from last 3 games (receiving + rushing)
                let recTDs = 0;
                let rushTDs = 0;
                let gameCount = 0;
                
                if (p.weeks && p.weeks.length > 0) {
                    // Get the global max week
                    let globalMaxWeek = 0;
                    Object.values(aggregatedWRs).forEach(wr => {
                        if (wr.weeks && wr.weeks.length > 0) {
                            const maxWeek = Math.max(...wr.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });
                    
                    const last3Weeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
                    
                    // Sum TDs from last 3 weeks
                    p.weeks.forEach(w => {
                        if (last3Weeks.includes(w.week)) {
                            const weekRow = wrData.find(row => 
                                row.Player === p.name && 
                                row.Team === p.team && 
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow) {
                                recTDs += parseFloat(weekRow.REC_TD) || 0;
                                rushTDs += parseFloat(weekRow.RUSH_TD) || 0;
                                gameCount++;
                            }
                        }
                    });
                }
                
                const totalTDs = recTDs + rushTDs;
                const tdsPerGame = gameCount > 0 ? totalTDs / gameCount : 0;
                
                // Calculate prior weeks for change
                let priorRecTDs = 0;
                let priorRushTDs = 0;
                let priorGameCount = 0;
                
                if (p.weeks && p.weeks.length > 0) {
                    let globalMaxWeek = 0;
                    Object.values(aggregatedWRs).forEach(wr => {
                        if (wr.weeks && wr.weeks.length > 0) {
                            const maxWeek = Math.max(...wr.weeks.map(w => w.week));
                            if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                        }
                    });
                    
                    const priorWeeks = [globalMaxWeek - 3, globalMaxWeek - 4, globalMaxWeek - 5];
                    
                    p.weeks.forEach(w => {
                        if (priorWeeks.includes(w.week)) {
                            const weekRow = wrData.find(row => 
                                row.Player === p.name && 
                                row.Team === p.team && 
                                parseInt(row.Week) === w.week
                            );
                            if (weekRow) {
                                priorRecTDs += parseFloat(weekRow.REC_TD) || 0;
                                priorRushTDs += parseFloat(weekRow.RUSH_TD) || 0;
                                priorGameCount++;
                            }
                        }
                    });
                }
                
                const priorTotalTDs = priorRecTDs + priorRushTDs;
                const priorTdsPerGame = priorGameCount > 0 ? priorTotalTDs / priorGameCount : 0;
                const change = priorTdsPerGame > 0 ? tdsPerGame - priorTdsPerGame : 0;
                
                return { player: p, value: tdsPerGame, change: change, recTDs: recTDs, rushTDs: rushTDs, totalTDs: totalTDs };
            })
            .filter(d => d.totalTDs > 0) // Only WRs who scored TDs
            .sort((a, b) => b.value - a.value);
            
            return tdData
                .slice(0, 8)
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(2),
                    metricLabel: 'TDs/Game (L3)',
                    change: d.change.toFixed(2),
                    explanation: 'WRs scoring the most TDs (receiving + rushing) in last 3 games',
                    scatterKey: 'redzone'
                }));
        }
        
        // Category 8: Boom/Bust DFS (Last 3 Games Volatility)
        function calculateBoomBustDFS(players) {
            const boomBustData = players.map(p => {
                // High ceiling, low floor based on last 3 games
                const last3Weeks = [...p.weeks].sort((a, b) => b.week - a.week).slice(0, 3);
                const variances = last3Weeks.map(w => {
                    const weekAvg = w.fpts;
                    return Math.pow(weekAvg - p.last3.avgPoints, 2);
                });
                const variance = variances.reduce((sum, v) => sum + v, 0) / variances.length;
                const stdDev = Math.sqrt(variance);
                const consistency = 10 / (stdDev + 1);
                
                const ppg = p.last3.avgPoints; // Use last 3 games average
                const ceiling = ppg; // Simplified ceiling
                
                return { 
                    player: p, 
                    value: ceiling,
                    consistency: consistency,
                    stdDev: stdDev
                };
            })
            .filter(d => d.value > 10) // Decent recent ceiling
            .sort((a, b) => a.consistency - b.consistency) // Low consistency (high variance)
            .slice(0, 8);
            
            return boomBustData
                .map((d, idx) => ({
                    player: d.player,
                    rank: idx + 1,
                    metric: d.value.toFixed(1),
                    metricLabel: 'PPG (L3)',
                    score: d.stdDev.toFixed(1),
                    explanation: 'High recent variance - tournament play, avoid cash games',
                    scatterKey: 'floor-ceiling'
                }));
        }
        
        // Key Insights state management
        let keyInsightsState = {
            currentIndex: 0,
            insights: [],
            autoRotateInterval: null
        };
        
        // Render Key Insights widget with dynamic data
        function renderStatOfTheWeek() {
            const statContainer = document.getElementById('stat-of-week');
            if (!statContainer) return;
            
            const allWRs = Object.values(aggregatedWRs).filter(p => p.gamesPlayed >= 3);
            const allRBs = Object.values(aggregatedRBs).filter(p => p.gamesPlayed >= 3);
            
            if (allWRs.length === 0 && allRBs.length === 0) return;
            
            // Create 4 insights - one for each leaderboard category
            const stats = [];
            
            // Insight 1: High-Volume Alphas (WR) - Tied to leaderboard
            const highTargetWRs = allWRs
                .map(p => ({
                    player: p,
                    targetsPerGame: p.totalTargets / p.gamesPlayed
                }))
                .filter(d => d.targetsPerGame >= 8)
                .sort((a, b) => b.targetsPerGame - a.targetsPerGame);
            
            if (highTargetWRs.length > 0) {
                const avgHighTarget = highTargetWRs.reduce((sum, p) => sum + p.player.avgPoints, 0) / highTargetWRs.length;
                const avgAllWRs = allWRs.reduce((sum, p) => sum + p.avgPoints, 0) / allWRs.length;
                const difference = avgHighTarget - avgAllWRs;
                
                stats.push({
                    value: '8+',
                    label: `High-Volume Alphas (${highTargetWRs.length} WRs)`,
                    text: `WRs commanding <strong>8+ targets/game</strong> are averaging <strong>+${difference.toFixed(1)} PPG</strong> over the field. Target these alpha receivers dominating their team's passing offense.`,
                    category: 'High-Volume Alphas'
                });
            }
            
            // Insight 2: Volume Monsters (RB) - Tied to leaderboard
            const volumeRBs = allRBs
                .map(p => ({
                    player: p,
                    oppsPerGame: p.totalOpportunities / p.gamesPlayed
                }))
                .filter(d => d.oppsPerGame >= 18)
                .sort((a, b) => b.oppsPerGame - a.oppsPerGame);
            
            if (volumeRBs.length > 0) {
                const avgVolRBPts = volumeRBs.reduce((sum, p) => sum + p.player.avgPoints, 0) / volumeRBs.length;
                const avgAllRBs = allRBs.reduce((sum, p) => sum + p.avgPoints, 0) / allRBs.length;
                const rbDiff = avgVolRBPts - avgAllRBs;
                
                stats.push({
                    value: '18+',
                    label: `Volume Monsters (${volumeRBs.length} RBs)`,
                    text: `RBs seeing <strong>18+ opportunities/game</strong> average <strong>+${rbDiff.toFixed(1)} PPG</strong> vs the field. Bell-cow backs deliver consistent RB1 production—prioritize workload.`,
                    category: 'Volume Monsters'
                });
            }
            
            // Insight 3: Efficiency Elites - Players with 2.76+ PPT
            const allPlayers = [...allWRs, ...allRBs];
            const efficiencyThreshold = 2.76;
            const efficiencyPlayers = allPlayers
                .map(p => {
                    const touches = p.position === 'WR' 
                        ? p.totalTargets 
                        : (p.totalRushAttempts || 0) + (p.totalTargets || 0);
                    const ppt = touches > 0 ? p.totalPoints / touches : 0;
                    return { player: p, ppt: ppt, touches: touches };
                })
                .filter(d => d.ppt >= efficiencyThreshold && d.touches >= 30)
                .sort((a, b) => b.ppt - a.ppt);
            
            if (efficiencyPlayers.length > 0) {
                const avgEfficientPPG = efficiencyPlayers.reduce((sum, p) => sum + p.player.avgPoints, 0) / efficiencyPlayers.length;
                const count = efficiencyPlayers.length;
                
                stats.push({
                    value: efficiencyThreshold.toFixed(2),
                    label: `Efficiency Elites (${count} players)`,
                    text: `Players with <strong>${efficiencyThreshold.toFixed(2)}+ points per touch</strong> average <strong>${avgEfficientPPG.toFixed(1)} PPG</strong>. Elite efficiency often signals quality over quantity—target these players in trades.`,
                    category: 'Efficiency Elites'
                });
            }
            
            // Insight 4: Red Zone Kings - Players with 2+ RZ opps/game
            const rzThresholdPerGame = 2.0;
            const rzPlayers = allPlayers
                .map(p => ({
                    player: p,
                    rzOppsPerGame: p.rzOpportunities / p.gamesPlayed
                }))
                .filter(d => d.rzOppsPerGame >= rzThresholdPerGame)
                .sort((a, b) => b.rzOppsPerGame - a.rzOppsPerGame);
            
            if (rzPlayers.length > 0) {
                const avgRZPlayerPPG = rzPlayers.reduce((sum, p) => sum + p.player.avgPoints, 0) / rzPlayers.length;
                const avgAllPlayersPPG = allPlayers.reduce((sum, p) => sum + p.avgPoints, 0) / allPlayers.length;
                const rzAdvantage = avgRZPlayerPPG - avgAllPlayersPPG;
                const count = rzPlayers.length;
                
                stats.push({
                    value: `${rzThresholdPerGame.toFixed(1)}+`,
                    label: `Red Zone Kings (${count} players)`,
                    text: `Players averaging <strong>${rzThresholdPerGame.toFixed(1)}+ red zone opportunities/game</strong> score <strong>+${rzAdvantage.toFixed(1)} PPG</strong> more than the field. RZ usage = TD equity—target these scoring threats.`,
                    category: 'Red Zone Kings'
                });
            }
            
            // Store insights and initialize
            keyInsightsState.insights = stats;
            keyInsightsState.currentIndex = 0;
            
            // Display first insight
            displayInsight(0);
            
            // Start auto-rotation (15 seconds)
            startInsightRotation();
        }
        
        // Display a specific insight with fade effect
        function displayInsight(index) {
            const statContainer = document.getElementById('stat-of-week');
            const indicator = document.getElementById('insight-indicator');
            
            if (!statContainer || keyInsightsState.insights.length === 0) return;
            
            // Ensure index is within bounds
            index = ((index % keyInsightsState.insights.length) + keyInsightsState.insights.length) % keyInsightsState.insights.length;
            keyInsightsState.currentIndex = index;
            
            const insight = keyInsightsState.insights[index];
            
            // Fade out
            statContainer.style.opacity = '0';
            
            setTimeout(() => {
                // Update content
                statContainer.innerHTML = `
                    <div class="stat-highlight-value">${insight.value}</div>
                    <div class="stat-highlight-content">
                        <div class="stat-highlight-label">${insight.label}</div>
                        <div class="stat-highlight-text">
                            ${insight.text}
                        </div>
                    </div>
                `;
                
                // Update indicator
                if (indicator) {
                    indicator.textContent = `${index + 1}/${keyInsightsState.insights.length}`;
                }
                
                // Fade in
                statContainer.style.opacity = '1';
            }, 300);
        }
        
        // Navigate to next insight
        function nextInsight() {
            stopInsightRotation();
            displayInsight(keyInsightsState.currentIndex + 1);
            startInsightRotation();
        }
        
        // Navigate to previous insight
        function previousInsight() {
            stopInsightRotation();
            displayInsight(keyInsightsState.currentIndex - 1);
            startInsightRotation();
        }
        
        // Start auto-rotation every 15 seconds
        function startInsightRotation() {
            stopInsightRotation(); // Clear any existing interval
            keyInsightsState.autoRotateInterval = setInterval(() => {
                displayInsight(keyInsightsState.currentIndex + 1);
            }, 15000); // 15 seconds
        }
        
        // Stop auto-rotation
        function stopInsightRotation() {
            if (keyInsightsState.autoRotateInterval) {
                clearInterval(keyInsightsState.autoRotateInterval);
                keyInsightsState.autoRotateInterval = null;
            }
        }
        
        // ============================================
        // DASHBOARD TREND CHARTS
        // ============================================
        
        let dashboardTrendState = {
            wr: { 
                isPlaying: false, 
                currentTranche: 3,  // Start at final position
                chart: null, 
                trails: {},
                fixedAxes: null,
                medianX: null,
                medianY: null,
                filter: 'all'  // 'all', 'positive', 'negative'
            },
            rb: { 
                isPlaying: false, 
                currentTranche: 3,  // Start at final position
                chart: null,
                trails: {},
                fixedAxes: null,
                medianX: null,
                medianY: null,
                filter: 'all'  // 'all', 'positive', 'negative'
            }
        };
        
        // Toggle chart expand/collapse
        function toggleChartExpand(position) {
            const wrWidget = document.getElementById('wr-trend-widget');
            const rbWidget = document.getElementById('rb-trend-widget');
            const wrBtn = document.getElementById('wr-expand-btn');
            const rbBtn = document.getElementById('rb-expand-btn');
            
            if (position === 'wr') {
                if (wrWidget.classList.contains('expanded')) {
                    // Collapse - show both
                    wrWidget.classList.remove('expanded');
                    rbWidget.classList.remove('collapsed');
                    wrBtn.textContent = '⛶';
                    wrBtn.title = 'Expand';
                } else {
                    // Expand WR, hide RB
                    wrWidget.classList.add('expanded');
                    rbWidget.classList.add('collapsed');
                    wrBtn.textContent = '⛶';
                    wrBtn.title = 'Collapse';
                }
            } else {
                if (rbWidget.classList.contains('expanded')) {
                    // Collapse - show both
                    rbWidget.classList.remove('expanded');
                    wrWidget.classList.remove('collapsed');
                    rbBtn.textContent = '⛶';
                    rbBtn.title = 'Expand';
                } else {
                    // Expand RB, hide WR
                    rbWidget.classList.add('expanded');
                    wrWidget.classList.add('collapsed');
                    rbBtn.textContent = '⛶';
                    rbBtn.title = 'Collapse';
                }
            }
            
            // Re-render charts after expansion animation
            setTimeout(() => {
                if (position === 'wr' || !wrWidget.classList.contains('collapsed')) {
                    renderDashboardWRTrend();
                }
                if (position === 'rb' || !rbWidget.classList.contains('collapsed')) {
                    renderDashboardRBTrend();
                }
            }, 100);
        }
        
        // Set dashboard filter for movers
        function setDashboardFilter(position, filter) {
            dashboardTrendState[position].filter = filter;
            
            // Update button states for this position's filter buttons
            ['all', 'positive', 'negative'].forEach(f => {
                const btn = document.getElementById(`${position}-filter-${f}`);
                if (btn) {
                    if (f === filter) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                }
            });
            
            // Re-render the chart for this position
            if (position === 'wr') {
                renderDashboardWRTrend();
            } else {
                renderDashboardRBTrend();
            }
        }
        
        // Calculate 3-week tranche averages and total movement
        function calculateTrancheData(players, position) {
            // Find the global maximum week across all players
            let globalMaxWeek = 0;
            players.forEach(player => {
                if (player.weeks && player.weeks.length > 0) {
                    const maxWeek = Math.max(...player.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });
            
            // Dynamically create tranches based on current max week
            // Tranche 1: Weeks 1-3
            // Tranche 2: Weeks 4-6
            // Tranche 3: Latest weeks (will be 7-8 for Week 8 data, 7-9 for Week 9 data, etc.)
            const tranche3Start = 7;
            const tranche3Weeks = [];
            for (let w = tranche3Start; w <= globalMaxWeek; w++) {
                tranche3Weeks.push(w);
            }
            
            const tranches = [
                { name: 'Weeks 1-3', weeks: [1, 2, 3] },
                { name: 'Weeks 4-6', weeks: [4, 5, 6] },
                { name: `Weeks ${tranche3Start}-${globalMaxWeek}`, weeks: tranche3Weeks }
            ];
            
            return players.map(player => {
                const trancheData = tranches.map((tranche, idx) => {
                    const weeksInTranche = player.weeks.filter(w => tranche.weeks.includes(w.week));
                    
                    if (weeksInTranche.length === 0) return null;
                    
                    let volume, efficiency;
                    
                    if (position === 'WR') {
                        // Volume = avg targets per game in tranche
                        volume = weeksInTranche.reduce((sum, w) => sum + (w.targets || 0), 0) / weeksInTranche.length;
                        // Efficiency = points per target
                        const totalTargets = weeksInTranche.reduce((sum, w) => sum + (w.targets || 0), 0);
                        const totalPoints = weeksInTranche.reduce((sum, w) => sum + w.fpts, 0);
                        efficiency = totalTargets > 0 ? totalPoints / totalTargets : 0;
                    } else {
                        // RB: Volume = avg RB opportunities (rush att + targets) per game
                        volume = weeksInTranche.reduce((sum, w) => sum + ((w.rushAttempts || 0) + (w.targets || 0)), 0) / weeksInTranche.length;
                        // Efficiency = points per RB opportunity
                        const totalOpps = weeksInTranche.reduce((sum, w) => sum + ((w.rushAttempts || 0) + (w.targets || 0)), 0);
                        const totalPoints = weeksInTranche.reduce((sum, w) => sum + w.fpts, 0);
                        efficiency = totalOpps > 0 ? totalPoints / totalOpps : 0;
                    }
                    
                    return {
                        tranche: idx + 1,
                        trancheName: tranche.name,
                        volume: volume,
                        efficiency: efficiency,
                        gamesPlayed: weeksInTranche.length
                    };
                }).filter(t => t !== null);
                
                // Calculate total distance traveled
                let totalDistance = 0;
                if (trancheData.length >= 2) {
                    for (let i = 1; i < trancheData.length; i++) {
                        const dx = trancheData[i].volume - trancheData[i-1].volume;
                        const dy = trancheData[i].efficiency - trancheData[i-1].efficiency;
                        totalDistance += Math.sqrt(dx*dx + dy*dy);
                    }
                }
                
                return {
                    player: player,
                    tranches: trancheData,
                    totalDistance: totalDistance
                };
            }).filter(p => p.tranches.length > 0);
        }
        
        // Calculate fixed axis ranges for locked axes and median values
        function calculateFixedAxesAndMedian(trancheData) {
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let allX = [], allY = [];
            
            // Also collect current week (tranche 3) data separately
            let currentWeekX = [], currentWeekY = [];
            
            trancheData.forEach(playerData => {
                playerData.tranches.forEach(t => {
                    minX = Math.min(minX, t.volume);
                    maxX = Math.max(maxX, t.volume);
                    minY = Math.min(minY, t.efficiency);
                    maxY = Math.max(maxY, t.efficiency);
                    allX.push(t.volume);
                    allY.push(t.efficiency);
                    
                    // Collect tranche 3 (current week) data
                    if (t.tranche === 3) {
                        currentWeekX.push(t.volume);
                        currentWeekY.push(t.efficiency);
                    }
                });
            });
            
            // Calculate CURRENT WEEK medians (tranche 3) - this is what we'll use for the lines
            currentWeekX.sort((a, b) => a - b);
            currentWeekY.sort((a, b) => a - b);
            const currentMedianX = currentWeekX.length > 0 ? currentWeekX[Math.floor(currentWeekX.length / 2)] : 0;
            const currentMedianY = currentWeekY.length > 0 ? currentWeekY[Math.floor(currentWeekY.length / 2)] : 0;
            
            // Calculate overall medians for axis centering
            allX.sort((a, b) => a - b);
            allY.sort((a, b) => a - b);
            const medianX = allX[Math.floor(allX.length / 2)];
            const medianY = allY[Math.floor(allY.length / 2)];
            
            console.log('📊 Median Calculation:', {
                'Overall Median X': medianX.toFixed(2),
                'Overall Median Y': medianY.toFixed(2),
                'Current Week (T3) Median X': currentMedianX.toFixed(2),
                'Current Week (T3) Median Y': currentMedianY.toFixed(2),
                'Tranche 3 sample size': currentWeekX.length
            });
            
            // Zoom in: center on overall median, show ±60% of range on each side
            const rangeX = maxX - minX;
            const rangeY = maxY - minY;
            const zoomedMinX = medianX - (rangeX * 0.6);
            const zoomedMaxX = medianX + (rangeX * 0.6);
            const zoomedMinY = medianY - (rangeY * 0.6);
            const zoomedMaxY = medianY + (rangeY * 0.6);
            
            return {
                axes: {
                    x: { min: zoomedMinX, max: zoomedMaxX },
                    y: { min: zoomedMinY, max: zoomedMaxY }
                },
                median: { x: currentMedianX, y: currentMedianY } // Return CURRENT week median
            };
        }
        
        // Render the combined dashboard trend chart (routes to WR or RB based on currentPosition)
        function renderDashboardCombinedTrend() {
            // Render both charts independently
            renderDashboardWRTrend();
            renderDashboardRBTrend();
        }
        
        // Render dashboard WR trend chart
        function renderDashboardWRTrend() {
            const canvas = document.getElementById('wr-trend-chart');
            if (!canvas) {
                console.warn('WR trend chart canvas not found');
                return;
            }
            
            // Check if we have data
            if (!aggregatedWRs || Object.keys(aggregatedWRs).length === 0) {
                console.warn('No WR data available for dashboard trend');
                return;
            }
            
            const wrs = Object.values(aggregatedWRs)
                .filter(p => p.gamesPlayed >= 3)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 36);
            
            const trancheData = calculateTrancheData(wrs, 'WR');
            
            // Update tranche label based on current position (not last tranche)
            updateTrancheLabel('wr', dashboardTrendState.wr.currentTranche);
            
            // Calculate fixed axes and median if not set
            if (!dashboardTrendState.wr.fixedAxes) {
                const result = calculateFixedAxesAndMedian(trancheData);
                dashboardTrendState.wr.fixedAxes = result.axes;
                dashboardTrendState.wr.medianX = result.median.x;
                dashboardTrendState.wr.medianY = result.median.y;
            }
            
            // Find top movers (by distance traveled)
            const sortedByDistance = [...trancheData].sort((a, b) => b.totalDistance - a.totalDistance);
            const topMovers = new Set(sortedByDistance.slice(0, 5).map(d => d.player.id));
            
            // Calculate movement direction (efficiency change from tranche 2 to 3 - previous to current)
            const movementData = trancheData.map(pd => {
                const effT2 = pd.tranches.find(t => t.tranche === 2)?.efficiency || 0;
                const effT3 = pd.tranches.find(t => t.tranche === 3)?.efficiency || 0;
                const volT2 = pd.tranches.find(t => t.tranche === 2)?.volume || 0;
                const volT3 = pd.tranches.find(t => t.tranche === 3)?.volume || 0;
                
                // Calculate combined movement (efficiency change + volume change normalized)
                const effChange = effT3 - effT2;
                const volChange = (volT3 - volT2) / 10; // Normalize volume change
                const movement = effChange + volChange;
                
                return { playerId: pd.player.id, movement };
            });
            
            // Apply filter based on selection
            const filter = dashboardTrendState.wr.filter;
            let filteredPlayerIds = new Set(trancheData.map(d => d.player.id));
            
            if (filter === 'positive') {
                // Top 10 positive movers
                const topPositive = movementData
                    .filter(m => m.movement > 0)
                    .sort((a, b) => b.movement - a.movement)
                    .slice(0, 10)
                    .map(m => m.playerId);
                filteredPlayerIds = new Set(topPositive);
            } else if (filter === 'negative') {
                // Top 10 negative movers
                const topNegative = movementData
                    .filter(m => m.movement < 0)
                    .sort((a, b) => a.movement - b.movement)
                    .slice(0, 10)
                    .map(m => m.playerId);
                filteredPlayerIds = new Set(topNegative);
            }
            
            // Destroy existing chart
            if (dashboardTrendState.wr.chart) {
                dashboardTrendState.wr.chart.destroy();
            }
            
            // Get current tranche (interpolated)
            const currentTranche = dashboardTrendState.wr.currentTranche;
            let currentData = interpolateTranchePlayers(trancheData, currentTranche, 'wr');
            
            // Filter data based on selection
            currentData = currentData.filter(d => filteredPlayerIds.has(d.player.id));
            
            // Build trail data with gradient fade - optimized for performance
            const trailDatasets = [];
            if (currentTranche > 0) {
                // Track current phase (0-1, 1-2, 2-3) and clear trails when phase changes
                const currentPhase = Math.floor(currentTranche);
                if (!dashboardTrendState.wr.lastPhase) {
                    dashboardTrendState.wr.lastPhase = 0;
                }
                
                // Clear trails when entering a new phase
                if (currentPhase > dashboardTrendState.wr.lastPhase) {
                    dashboardTrendState.wr.trails = {};
                    dashboardTrendState.wr.lastPhase = currentPhase;
                }
                
                currentData.forEach(point => {
                    const playerId = point.player.id;
                    
                    // Add to trail history
                    if (!dashboardTrendState.wr.trails[playerId]) {
                        dashboardTrendState.wr.trails[playerId] = [];
                    }
                    dashboardTrendState.wr.trails[playerId].push({ x: point.x, y: point.y });
                    
                    // Keep trail length reasonable (max 30 points for better performance)
                    if (dashboardTrendState.wr.trails[playerId].length > 30) {
                        dashboardTrendState.wr.trails[playerId].shift();
                    }
                    
                    // Create trail as a single line dataset with gradient effect
                    const trail = dashboardTrendState.wr.trails[playerId];
                    if (trail.length > 2) {
                        const teamColor = teamColors[point.player.team] || '#666';
                        const r = parseInt(teamColor.slice(1, 3), 16);
                        const g = parseInt(teamColor.slice(3, 5), 16);
                        const b = parseInt(teamColor.slice(5, 7), 16);
                        
                        // Create a single line dataset with all trail points
                        trailDatasets.push({
                            type: 'line',
                            data: trail,
                            borderColor: `rgba(${r}, ${g}, ${b}, 0.3)`,
                            borderWidth: 2.5, // Thicker trail for better visibility
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            tension: 0.4, // Smooth curve
                            segment: {
                                borderColor: ctx => {
                                    // Gradient along the line - fade from transparent to more visible
                                    const progress = ctx.p0DataIndex / (trail.length - 1);
                                    const opacity = 0.1 + (progress * 0.3);
                                    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                                }
                            }
                        });
                    }
                });
            }
            
            const ctx = canvas.getContext('2d');
            dashboardTrendState.wr.chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        ...trailDatasets,
                        {
                            data: currentData,
                            backgroundColor: currentData.map(d => {
                                const isTopMover = topMovers.has(d.player.id);
                                const color = teamColors[d.player.team] || '#666';
                                const r = parseInt(color.slice(1, 3), 16);
                                const g = parseInt(color.slice(3, 5), 16);
                                const b = parseInt(color.slice(5, 7), 16);
                                return isTopMover ? `rgba(${r}, ${g}, ${b}, 0.9)` : `rgba(${r}, ${g}, ${b}, 0.6)`;
                            }),
                            borderColor: currentData.map(d => {
                                const isTopMover = topMovers.has(d.player.id);
                                const color = teamColors[d.player.team] || '#666';
                                return isTopMover ? color : color;
                            }),
                            borderWidth: 2,
                            pointRadius: 6,
                            pointHoverRadius: 8
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const lastDataset = dashboardTrendState.wr.chart.data.datasets.length - 1;
                            if (elements[0].datasetIndex === lastDataset) {
                                const index = elements[0].index;
                                openPlayerModal(currentData[index].player.id);
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            filter: (tooltipItem) => {
                                // Only show tooltips for main scatter dataset
                                return tooltipItem.datasetIndex === dashboardTrendState.wr.chart.data.datasets.length - 1;
                            },
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    return [
                                        p.name,
                                        `Targets/G: ${context.parsed.x.toFixed(1)}`,
                                        `Pts/Target: ${context.parsed.y.toFixed(2)}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            min: dashboardTrendState.wr.fixedAxes.x.min,
                            max: dashboardTrendState.wr.fixedAxes.x.max,
                            title: { display: true, text: 'Targets per Game', color: '#8e8e93', font: { size: 11 } },
                            grid: { 
                                color: '#2c2c2e',
                                drawTicks: true
                            },
                            ticks: { 
                                color: '#8e8e93', 
                                font: { size: 10 },
                                stepSize: 2
                            }
                        },
                        y: {
                            min: dashboardTrendState.wr.fixedAxes.y.min,
                            max: dashboardTrendState.wr.fixedAxes.y.max,
                            title: { display: true, text: 'Points per Target', color: '#8e8e93', font: { size: 11 } },
                            grid: { 
                                color: '#2c2c2e',
                                drawTicks: true
                            },
                            ticks: { 
                                color: '#8e8e93', 
                                font: { size: 10 },
                                stepSize: 0.5
                            }
                        }
                    }
                },
                plugins: [{
                    id: 'quadrantLines',
                    afterDatasetsDraw: (chart) => {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const xAxis = chart.scales.x;
                        const yAxis = chart.scales.y;
                        
                        // Use stored median values
                        const xMid = dashboardTrendState.wr.medianX;
                        const yMid = dashboardTrendState.wr.medianY;
                        
                        // Draw dotted median lines
                        ctx.strokeStyle = 'rgba(142, 142, 147, 0.5)';
                        ctx.setLineDash([3, 3]);
                        ctx.lineWidth = 1;
                        
                        // Vertical line
                        ctx.beginPath();
                        ctx.moveTo(xAxis.getPixelForValue(xMid), chartArea.top);
                        ctx.lineTo(xAxis.getPixelForValue(xMid), chartArea.bottom);
                        ctx.stroke();
                        
                        // Horizontal line
                        ctx.beginPath();
                        ctx.moveTo(chartArea.left, yAxis.getPixelForValue(yMid));
                        ctx.lineTo(chartArea.right, yAxis.getPixelForValue(yMid));
                        ctx.stroke();
                        
                        ctx.setLineDash([]);
                        
                        // Add quadrant labels - WR Chart
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.textAlign = 'center';
                        
                        const xMidPixel = xAxis.getPixelForValue(xMid);
                        const yMidPixel = yAxis.getPixelForValue(yMid);
                        
                        // Top-right: High Volume + High Efficiency
                        ctx.fillStyle = '#30d158';
                        ctx.fillText('ELITE', (xMidPixel + chartArea.right) / 2, (chartArea.top + yMidPixel) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('High Vol + Efficiency', (xMidPixel + chartArea.right) / 2, (chartArea.top + yMidPixel) / 2 + 8);
                        
                        // Top-left: Low Volume + High Efficiency
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillStyle = '#0a84ff';
                        ctx.fillText('SLEEPER', (chartArea.left + xMidPixel) / 2, (chartArea.top + yMidPixel) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('Efficient, Low Vol', (chartArea.left + xMidPixel) / 2, (chartArea.top + yMidPixel) / 2 + 8);
                        
                        // Bottom-right: High Volume + Low Efficiency
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillStyle = '#FFD60A';
                        ctx.fillText('HOLD', (xMidPixel + chartArea.right) / 2, (yMidPixel + chartArea.bottom) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('Volume, Poor Efficiency', (xMidPixel + chartArea.right) / 2, (yMidPixel + chartArea.bottom) / 2 + 8);
                        
                        // Bottom-left: Low Volume + Low Efficiency
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillStyle = '#ff453a';
                        ctx.fillText('FADE', (chartArea.left + xMidPixel) / 2, (yMidPixel + chartArea.bottom) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('Low Vol + Efficiency', (chartArea.left + xMidPixel) / 2, (yMidPixel + chartArea.bottom) / 2 + 8);
                    }
                }]
            });
        }
        
        // Render dashboard RB trend chart (similar to WR)
        function renderDashboardRBTrend() {
            const canvas = document.getElementById('rb-trend-chart');
            if (!canvas) {
                console.warn('RB trend chart canvas not found');
                return;
            }
            
            // Check if we have data
            if (!aggregatedRBs || Object.keys(aggregatedRBs).length === 0) {
                console.warn('No RB data available for dashboard trend');
                return;
            }
            
            const rbs = Object.values(aggregatedRBs)
                .filter(p => p.gamesPlayed >= 3)
                .sort((a, b) => b.avgPoints - a.avgPoints)
                .slice(0, 36);
            
            const trancheData = calculateTrancheData(rbs, 'RB');
            
            // Update tranche label based on current position (not last tranche)
            updateTrancheLabel('rb', dashboardTrendState.rb.currentTranche);
            
            // Calculate fixed axes and median if not set
            if (!dashboardTrendState.rb.fixedAxes) {
                const result = calculateFixedAxesAndMedian(trancheData);
                dashboardTrendState.rb.fixedAxes = result.axes;
                dashboardTrendState.rb.medianX = result.median.x;
                dashboardTrendState.rb.medianY = result.median.y;
            }
            
            // Find top movers (by distance traveled)
            const sortedByDistance = [...trancheData].sort((a, b) => b.totalDistance - a.totalDistance);
            const topMovers = new Set(sortedByDistance.slice(0, 5).map(d => d.player.id));
            
            // Calculate movement direction (efficiency change from tranche 2 to 3 - previous to current)
            const movementData = trancheData.map(pd => {
                const effT2 = pd.tranches.find(t => t.tranche === 2)?.efficiency || 0;
                const effT3 = pd.tranches.find(t => t.tranche === 3)?.efficiency || 0;
                const volT2 = pd.tranches.find(t => t.tranche === 2)?.volume || 0;
                const volT3 = pd.tranches.find(t => t.tranche === 3)?.volume || 0;
                
                // Calculate combined movement (efficiency change + volume change normalized)
                const effChange = effT3 - effT2;
                const volChange = (volT3 - volT2) / 10; // Normalize volume change
                const movement = effChange + volChange;
                
                return { playerId: pd.player.id, movement };
            });
            
            // Apply filter based on selection
            const filter = dashboardTrendState.rb.filter;
            let filteredPlayerIds = new Set(trancheData.map(d => d.player.id));
            
            if (filter === 'positive') {
                // Top 10 positive movers
                const topPositive = movementData
                    .filter(m => m.movement > 0)
                    .sort((a, b) => b.movement - a.movement)
                    .slice(0, 10)
                    .map(m => m.playerId);
                filteredPlayerIds = new Set(topPositive);
            } else if (filter === 'negative') {
                // Top 10 negative movers
                const topNegative = movementData
                    .filter(m => m.movement < 0)
                    .sort((a, b) => a.movement - b.movement)
                    .slice(0, 10)
                    .map(m => m.playerId);
                filteredPlayerIds = new Set(topNegative);
            }
            
            // Destroy existing chart
            if (dashboardTrendState.rb.chart) {
                dashboardTrendState.rb.chart.destroy();
            }
            
            // Get current tranche (interpolated)
            const currentTranche = dashboardTrendState.rb.currentTranche;
            let currentData = interpolateTranchePlayers(trancheData, currentTranche, 'rb');
            
            // Filter data based on selection
            currentData = currentData.filter(d => filteredPlayerIds.has(d.player.id));
            
            // Build trail data with gradient fade - optimized for performance
            const trailDatasets = [];
            if (currentTranche > 0) {
                // Track current phase (0-1, 1-2, 2-3) and clear trails when phase changes
                const currentPhase = Math.floor(currentTranche);
                if (!dashboardTrendState.rb.lastPhase) {
                    dashboardTrendState.rb.lastPhase = 0;
                }
                
                // Clear trails when entering a new phase
                if (currentPhase > dashboardTrendState.rb.lastPhase) {
                    dashboardTrendState.rb.trails = {};
                    dashboardTrendState.rb.lastPhase = currentPhase;
                }
                
                currentData.forEach(point => {
                    const playerId = point.player.id;
                    
                    // Add to trail history
                    if (!dashboardTrendState.rb.trails[playerId]) {
                        dashboardTrendState.rb.trails[playerId] = [];
                    }
                    dashboardTrendState.rb.trails[playerId].push({ x: point.x, y: point.y });
                    
                    // Keep trail length reasonable (max 30 points for better performance)
                    if (dashboardTrendState.rb.trails[playerId].length > 30) {
                        dashboardTrendState.rb.trails[playerId].shift();
                    }
                    
                    // Create trail as a single line dataset with gradient effect
                    const trail = dashboardTrendState.rb.trails[playerId];
                    if (trail.length > 2) {
                        const teamColor = teamColors[point.player.team] || '#666';
                        const r = parseInt(teamColor.slice(1, 3), 16);
                        const g = parseInt(teamColor.slice(3, 5), 16);
                        const b = parseInt(teamColor.slice(5, 7), 16);
                        
                        // Create a single line dataset with all trail points
                        trailDatasets.push({
                            type: 'line',
                            data: trail,
                            borderColor: `rgba(${r}, ${g}, ${b}, 0.3)`,
                            borderWidth: 2.5, // Thicker trail for better visibility
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            tension: 0.4, // Smooth curve
                            segment: {
                                borderColor: ctx => {
                                    // Gradient along the line - fade from transparent to more visible
                                    const progress = ctx.p0DataIndex / (trail.length - 1);
                                    const opacity = 0.1 + (progress * 0.3);
                                    return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                                }
                            }
                        });
                    }
                });
            }
            
            const ctx = canvas.getContext('2d');
            dashboardTrendState.rb.chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        ...trailDatasets,
                        {
                            data: currentData,
                            backgroundColor: currentData.map(d => {
                                const isTopMover = topMovers.has(d.player.id);
                                const color = teamColors[d.player.team] || '#666';
                                const r = parseInt(color.slice(1, 3), 16);
                                const g = parseInt(color.slice(3, 5), 16);
                                const b = parseInt(color.slice(5, 7), 16);
                                return isTopMover ? `rgba(${r}, ${g}, ${b}, 0.9)` : `rgba(${r}, ${g}, ${b}, 0.6)`;
                            }),
                            borderColor: currentData.map(d => {
                                const color = teamColors[d.player.team] || '#666';
                                return color;
                            }),
                            borderWidth: 2,
                            pointRadius: 6,
                            pointHoverRadius: 8
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const lastDataset = dashboardTrendState.rb.chart.data.datasets.length - 1;
                            if (elements[0].datasetIndex === lastDataset) {
                                const index = elements[0].index;
                                openPlayerModal(currentData[index].player.id);
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            filter: (tooltipItem) => {
                                return tooltipItem.datasetIndex === dashboardTrendState.rb.chart.data.datasets.length - 1;
                            },
                            callbacks: {
                                label: (context) => {
                                    const p = context.raw.player;
                                    return [
                                        p.name,
                                        `Opps/G: ${context.parsed.x.toFixed(1)}`,
                                        `Pts/Opp: ${context.parsed.y.toFixed(2)}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            min: dashboardTrendState.rb.fixedAxes.x.min,
                            max: dashboardTrendState.rb.fixedAxes.x.max,
                            title: { display: true, text: 'RB Opportunities per Game', color: '#8e8e93', font: { size: 11 } },
                            grid: { 
                                color: '#2c2c2e',
                                drawTicks: true
                            },
                            ticks: { 
                                color: '#8e8e93', 
                                font: { size: 10 },
                                stepSize: 2
                            }
                        },
                        y: {
                            min: dashboardTrendState.rb.fixedAxes.y.min,
                            max: dashboardTrendState.rb.fixedAxes.y.max,
                            title: { display: true, text: 'Points per Opportunity', color: '#8e8e93', font: { size: 11 } },
                            grid: { 
                                color: '#2c2c2e',
                                drawTicks: true
                            },
                            ticks: { 
                                color: '#8e8e93', 
                                font: { size: 10 },
                                stepSize: 0.2
                            }
                        }
                    }
                },
                plugins: [{
                    id: 'quadrantLines',
                    afterDatasetsDraw: (chart) => {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const xAxis = chart.scales.x;
                        const yAxis = chart.scales.y;
                        
                        // Use stored median values
                        const xMid = dashboardTrendState.rb.medianX;
                        const yMid = dashboardTrendState.rb.medianY;
                        
                        // Draw dotted median lines
                        ctx.strokeStyle = 'rgba(142, 142, 147, 0.5)';
                        ctx.setLineDash([3, 3]);
                        ctx.lineWidth = 1;
                        
                        // Vertical line
                        ctx.beginPath();
                        ctx.moveTo(xAxis.getPixelForValue(xMid), chartArea.top);
                        ctx.lineTo(xAxis.getPixelForValue(xMid), chartArea.bottom);
                        ctx.stroke();
                        
                        // Horizontal line
                        ctx.beginPath();
                        ctx.moveTo(chartArea.left, yAxis.getPixelForValue(yMid));
                        ctx.lineTo(chartArea.right, yAxis.getPixelForValue(yMid));
                        ctx.stroke();
                        
                        ctx.setLineDash([]);
                        
                        // Add quadrant labels - RB Chart
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.textAlign = 'center';
                        
                        const xMidPixel = xAxis.getPixelForValue(xMid);
                        const yMidPixel = yAxis.getPixelForValue(yMid);
                        
                        // Top-right: High Volume + High Efficiency
                        ctx.fillStyle = '#30d158';
                        ctx.fillText('ELITE', (xMidPixel + chartArea.right) / 2, (chartArea.top + yMidPixel) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('High Vol + Efficiency', (xMidPixel + chartArea.right) / 2, (chartArea.top + yMidPixel) / 2 + 8);
                        
                        // Top-left: Low Volume + High Efficiency
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillStyle = '#0a84ff';
                        ctx.fillText('SLEEPER', (chartArea.left + xMidPixel) / 2, (chartArea.top + yMidPixel) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('Efficient, Low Vol', (chartArea.left + xMidPixel) / 2, (chartArea.top + yMidPixel) / 2 + 8);
                        
                        // Bottom-right: High Volume + Low Efficiency
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillStyle = '#FFD60A';
                        ctx.fillText('HOLD', (xMidPixel + chartArea.right) / 2, (yMidPixel + chartArea.bottom) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('Volume, Poor Efficiency', (xMidPixel + chartArea.right) / 2, (yMidPixel + chartArea.bottom) / 2 + 8);
                        
                        // Bottom-left: Low Volume + Low Efficiency
                        ctx.font = 'bold 10px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillStyle = '#ff453a';
                        ctx.fillText('FADE', (chartArea.left + xMidPixel) / 2, (yMidPixel + chartArea.bottom) / 2 - 4);
                        ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                        ctx.fillText('Low Vol + Efficiency', (chartArea.left + xMidPixel) / 2, (yMidPixel + chartArea.bottom) / 2 + 8);
                    }
                }]
            });
        }
        
        // Easing function for smooth transitions (ease-in-out cubic)
        function easeInOutCubic(t) {
            return t < 0.5 
                ? 4 * t * t * t 
                : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        // Interpolate player positions between tranches
        function interpolateTranchePlayers(trancheData, currentTranche, position) {
            // Get position-specific median for center point
            const medianX = dashboardTrendState[position].medianX;
            const medianY = dashboardTrendState[position].medianY;
            
            return trancheData.map(playerData => {
                // Handle tranche 0 - all at center
                if (currentTranche === 0) {
                    return {
                        x: medianX,
                        y: medianY,
                        player: playerData.player
                    };
                }
                
                // For tranches 0-1, interpolate from center to tranche 1
                if (currentTranche < 1) {
                    const data1 = playerData.tranches.find(t => t.tranche === 1);
                    if (!data1) return null;
                    
                    const t = easeInOutCubic(currentTranche); // Apply easing
                    return {
                        x: medianX + (data1.volume - medianX) * t,
                        y: medianY + (data1.efficiency - medianY) * t,
                        player: playerData.player
                    };
                }
                
                // For tranches >= 1, use existing logic with easing
                const tranche1 = Math.floor(currentTranche);
                const tranche2 = Math.ceil(currentTranche);
                const rawT = currentTranche - tranche1; // interpolation factor (0 to 1)
                const t = easeInOutCubic(rawT); // Apply easing for smooth transitions
                
                const data1 = playerData.tranches.find(t => t.tranche === tranche1);
                const data2 = playerData.tranches.find(t => t.tranche === tranche2);
                
                if (!data1 && !data2) return null;
                if (!data2 || tranche1 === tranche2) {
                    return data1 ? {
                        x: data1.volume,
                        y: data1.efficiency,
                        player: playerData.player
                    } : null;
                }
                if (!data1) {
                    return {
                        x: data2.volume,
                        y: data2.efficiency,
                        player: playerData.player
                    };
                }
                
                // Eased interpolation for rounded transitions
                return {
                    x: data1.volume + (data2.volume - data1.volume) * t,
                    y: data1.efficiency + (data2.efficiency - data1.efficiency) * t,
                    player: playerData.player
                };
            }).filter(d => d !== null);
        }
        
        // Toggle dashboard trend animation - single run only
        function toggleDashboardTrend(positionParam) {
            // If called with 'combined', use the current position
            const position = positionParam === 'combined' ? dashboardTrendState.currentPosition : positionParam;
            const state = dashboardTrendState[position];
            
            if (state.isPlaying) {
                // Stop if already playing
                state.isPlaying = false;
                const btn = document.getElementById(`${position}-play-btn`);
                btn.textContent = '▶';
                btn.classList.remove('playing');
                return;
            }
            
            // Reset to start
            state.currentTranche = 0;
            state.trails = {}; // Clear trails
            state.lastPhase = 0; // Reset phase tracker
            state.isPlaying = true;
            
            const btn = document.getElementById(`${position}-play-btn`);
            btn.textContent = '⏸';
            btn.classList.add('playing');
            
            const scrubber = document.getElementById(`${position}-tranche-scrubber`);
            scrubber.value = 0;
            
            updateTrancheLabel(position, 0);
            
            animateDashboardTrend(position);
        }
        
        // Animate dashboard trend - smoother animation
        function animateDashboardTrend(position) {
            const state = dashboardTrendState[position];
            if (!state.isPlaying) return;
            
            state.currentTranche += 0.0325; // Slowed down by 35% for better visual clarity
            
            if (state.currentTranche >= 3) {
                state.currentTranche = 3;
                state.isPlaying = false;
                
                const btn = document.getElementById(`${position}-play-btn`);
                btn.textContent = '▶';
                btn.classList.remove('playing');
            }
            
            // Update scrubber
            const scrubber = document.getElementById(`${position}-tranche-scrubber`);
            scrubber.value = state.currentTranche;
            
            // Update label
            updateTrancheLabel(position, state.currentTranche);
            
            // Re-render appropriate chart
            if (position === 'wr') {
                renderDashboardWRTrend();
            } else {
                renderDashboardRBTrend();
            }
            
            // Continue animation if still playing
            if (state.isPlaying) {
                requestAnimationFrame(() => animateDashboardTrend(position));
            }
        }
        
        // Update tranche label
        function updateTrancheLabel(position, tranche) {
            const label = document.getElementById(`${position}-tranche-label`);
            if (!label) return;
            
            // Find max week dynamically from the data
            let globalMaxWeek = 0;
            const players = position === 'wr' ? aggregatedWRs : aggregatedRBs;
            Object.values(players).forEach(player => {
                if (player.weeks && player.weeks.length > 0) {
                    const maxWeek = Math.max(...player.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });
            
            // Handle tranche 0 (center position)
            if (tranche === 0) {
                label.textContent = 'Start';
                return;
            }
            
            // Interpolate between positions for smooth label updates
            if (tranche < 1) {
                label.textContent = 'Start → Weeks 1-3';
                return;
            }
            
            // Create dynamic tranche names based on actual max week
            const trancheNames = [
                'Start',           // 0
                'Weeks 1-3',       // 1
                'Weeks 4-6',       // 2
                `Weeks 7-${globalMaxWeek}` // 3
            ];
            
            // For values between tranches, show transition
            if (tranche % 1 !== 0) {
                const idx1 = Math.floor(tranche);
                const idx2 = Math.ceil(tranche);
                label.textContent = `${trancheNames[idx1]} → ${trancheNames[idx2]}`;
            } else {
                // Exact tranche
                const idx = Math.round(tranche);
                label.textContent = trancheNames[idx] || trancheNames[3];
            }
        }
        
        // Setup scrubber listeners
        function setupDashboardTrendScrubbers() {
            // Setup WR scrubber
            const wrScrubber = document.getElementById('wr-tranche-scrubber');
            if (wrScrubber) {
                wrScrubber.addEventListener('input', (e) => {
                    const tranche = parseFloat(e.target.value);
                    dashboardTrendState.wr.currentTranche = tranche;
                    dashboardTrendState.wr.isPlaying = false;
                    dashboardTrendState.wr.lastPhase = Math.floor(tranche); // Update phase tracker
                    
                    const btn = document.getElementById('wr-play-btn');
                    btn.textContent = '▶';
                    btn.classList.remove('playing');
                    
                    updateTrancheLabel('wr', tranche);
                    renderDashboardWRTrend();
                });
            }
            
            // Setup RB scrubber
            const rbScrubber = document.getElementById('rb-tranche-scrubber');
            if (rbScrubber) {
                rbScrubber.addEventListener('input', (e) => {
                    const tranche = parseFloat(e.target.value);
                    dashboardTrendState.rb.currentTranche = tranche;
                    dashboardTrendState.rb.isPlaying = false;
                    dashboardTrendState.rb.lastPhase = Math.floor(tranche); // Update phase tracker
                    
                    const btn = document.getElementById('rb-play-btn');
                    btn.textContent = '▶';
                    btn.classList.remove('playing');
                    
                    updateTrancheLabel('rb', tranche);
                    renderDashboardRBTrend();
                });
            }
        }
        
        // Render Dashboard Categories
        function renderDashboardCategories() {
            const container = document.getElementById('dashboard-categories');
            if (!container) {
                console.error('Dashboard categories container not found');
                return;
            }
            
            const categories = calculateDashboardCategories();
            console.log('Categories calculated:', categories);
            
            if (!categories) {
                console.error('Categories is null or undefined');
                container.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 40px;">Loading categories...</p>';
                return;
            }
            
            // Log each category's data
            console.log('Volume Monsters:', categories.volumeMonsters?.length || 0, 'players');
            console.log('Efficiency Elites:', categories.efficiencyElites?.length || 0, 'players');
            console.log('RZ Kings WR:', categories.redZoneKingsWR?.length || 0, 'players');
            console.log('RZ Backs:', categories.redZoneBacks?.length || 0, 'players');
            console.log('RB Efficiency:', categories.rbEfficiency?.length || 0, 'players');
            console.log('High-Volume Alphas:', categories.consistentFloor?.length || 0, 'players');
            console.log('Air Yards Leaders:', categories.airYardsLeaders?.length || 0, 'players');
            console.log('Pass-Catching Backs:', categories.passCatchingBacks?.length || 0, 'players');
            console.log('Target Leaders TE:', categories.targetLeadersTE?.length || 0, 'players');
            console.log('RZ Dominance TE:', categories.redZoneDominanceTE?.length || 0, 'players');
            console.log('Total TD Leaders WR:', categories.totalTouchdownLeadersWR?.length || 0, 'players');
            
            // Also update stat of the week
            renderStatOfTheWeek();
            
            // Render dashboard trend chart (both WR and RB)
            renderDashboardCombinedTrend();
            
            const categoryConfigs = [
                { key: 'volumeMonsters', title: 'Volume Monsters (RB)', color: '#ff453a', tooltip: 'RBs with the highest opportunities (carries + targets) per game in last 3 weeks. High volume = reliable fantasy production.' },
                { key: 'efficiencyElites', title: 'Efficiency Elites', color: '#FFD60A', tooltip: 'Players scoring the most fantasy points per touch in last 3 weeks. High efficiency = doing more with less. League-winner upside if volume increases.' },
                { key: 'redZoneKingsWR', title: 'Red Zone Kings (WR)', color: '#bf5af2', tooltip: 'WRs with the most red zone targets per game in last 3 weeks. More RZ targets = higher TD upside.' },
                { key: 'redZoneBacks', title: 'Red Zone Backs (RB)', color: '#ff453a', tooltip: 'RBs with the most red zone opportunities (carries + targets) per game in last 3 weeks. Dominant in scoring position.' },
                { key: 'rbEfficiency', title: 'RB Efficiency (Yds/Att)', color: '#30d158', tooltip: 'RBs with highest yards per carry in last 3 weeks. Explosive runners who maximize every touch.' },
                { key: 'consistentFloor', title: 'High-Volume Alphas (WR)', color: '#64d2ff', tooltip: 'WRs with the most targets per game in last 3 weeks. Commanding volume = alpha status in their offense.' },
                { key: 'airYardsLeaders', title: 'Air Yards Leaders (WR)', color: '#0a84ff', tooltip: 'WRs with highest air yards per game in last 3 weeks. Deep threats with explosive upside potential.' },
                { key: 'passCatchingBacks', title: 'Pass-Catching Backs (RB)', color: '#5e5ce6', tooltip: 'RBs with highest target share in last 3 weeks. PPR gold with receiving work in the passing game.' },
                { key: 'targetLeadersTE', title: 'Target Leaders (TE)', color: '#30d158', tooltip: 'TEs with the most targets per game in last 3 weeks. High volume = consistent TE production.' },
                { key: 'redZoneDominanceTE', title: 'Red Zone Dominance (TE)', color: '#bf5af2', tooltip: 'TEs with most red zone production in last 3 weeks. RZ Score = (RZ Targets + RZ TDs × 3) per game. TDs weighted 3x because they\'re more valuable than targets.' },
                { key: 'totalTouchdownLeadersWR', title: 'Total TD Leaders (WR)', color: '#ff453a', tooltip: 'WRs scoring the most total touchdowns (receiving + rushing) in last 3 weeks. Elite scorers.' }
            ];
            
            let html = '';
            html += '<div class="categories-carousel-container">';
            html += '<div class="categories-carousel-scroll" id="categories-carousel">';
            
            let hasAnyData = false;
            let categoriesHTML = ''; // Build categories first
            
            categoryConfigs.forEach(config => {
                const categoryData = categories[config.key];
                if (!categoryData || categoryData.length === 0) {
                    console.log(`Category ${config.key} has no data`);
                    return;
                }
                
                hasAnyData = true;
                console.log(`Rendering category ${config.key} with ${categoryData.length} players`);
                
                categoriesHTML += `
                    <div class="category-carousel-item">
                        <div class="category-header">
                            <div class="category-title" style="position: relative; cursor: help;" title="${config.tooltip}">
                                ${config.title}
                            </div>
                        </div>
                        <div class="category-cards-container" id="category-${config.key}">
                `;
                
                // Show all 8 players
                categoryData.forEach((item, idx) => {
                    categoriesHTML += renderCategoryCard(item, config.color, config.key, config.title);
                });
                
                categoriesHTML += `
                        </div>
                    </div>
                `;
            });
            
            // Duplicate categories for infinite scroll (like ticker)
            html += categoriesHTML + categoriesHTML;
            
            html += '</div>';
            html += '</div>';
            
            if (!hasAnyData) {
                console.error('No category data available');
                container.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 40px;">No category data available. Please upload player data.</p>';
            } else {
                container.innerHTML = html;
                // CSS animation handles the infinite scroll automatically
            }
        }
        
        // Render all leaderboards in a static 2x2 grid for the all-leaderboards page
        function renderAllLeaderboards() {
            const container = document.getElementById('all-leaderboards-grid');
            if (!container) {
                console.error('All leaderboards grid container not found');
                return;
            }
            
            const categories = calculateDashboardCategories();
            
            if (!categories) {
                console.error('Categories is null or undefined');
                container.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 40px;">Loading categories...</p>';
                return;
            }
            
            const categoryConfigs = [
                { key: 'volumeMonsters', title: 'Volume Monsters (RB)', color: '#ff453a', tooltip: 'RBs with the highest opportunities (carries + targets) per game in last 3 weeks.' },
                { key: 'consistentFloor', title: 'High-Volume Alphas (WR)', color: '#64d2ff', tooltip: 'WRs with the most targets per game in last 3 weeks.' },
                { key: 'redZoneKingsWR', title: 'Red Zone Kings (WR)', color: '#bf5af2', tooltip: 'WRs with the most red zone targets per game in last 3 weeks.' },
                { key: 'redZoneBacks', title: 'Red Zone Backs (RB)', color: '#ff453a', tooltip: 'RBs with the most red zone opportunities per game in last 3 weeks.' },
                { key: 'efficiencyElites', title: 'Efficiency Elites', color: '#FFD60A', tooltip: 'Players scoring the most fantasy points per touch in last 3 weeks.' },
                { key: 'rbEfficiency', title: 'RB Efficiency (Yds/Att)', color: '#30d158', tooltip: 'RBs with highest yards per carry in last 3 weeks.' },
                { key: 'airYardsLeaders', title: 'Air Yards Leaders (WR)', color: '#0a84ff', tooltip: 'WRs with highest air yards per game in last 3 weeks.' },
                { key: 'passCatchingBacks', title: 'Pass-Catching Backs (RB)', color: '#5e5ce6', tooltip: 'RBs with highest target share in last 3 weeks.' },
                { key: 'targetLeadersTE', title: 'Target Leaders (TE)', color: '#30d158', tooltip: 'TEs with the most targets per game in last 3 weeks.' },
                { key: 'redZoneDominanceTE', title: 'Red Zone Dominance (TE)', color: '#bf5af2', tooltip: 'TEs with most red zone production in last 3 weeks. RZ Score = (RZ Targets + RZ TDs × 3) per game. TDs weighted 3x.' },
                { key: 'totalTouchdownLeadersWR', title: 'Total TD Leaders (WR)', color: '#ff453a', tooltip: 'WRs with the most total touchdowns (receiving + rushing) in last 3 weeks.' }
            ];
            
            let html = '';
            
            categoryConfigs.forEach(config => {
                const categoryData = categories[config.key];
                if (!categoryData || categoryData.length === 0) {
                    return;
                }
                
                html += `
                    <div style="background: var(--bg-secondary); border-radius: 12px; padding: 20px; border: 1px solid var(--border-color);">
                        <div class="category-header" style="margin-bottom: 16px;">
                            <div class="category-title" style="position: relative; cursor: help; font-size: 16px; font-weight: 700; color: var(--text-primary);" title="${config.tooltip}">
                                ${config.title}
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr; gap: 8px;">
                `;
                
                // Show all 8 players with compact cards
                const maxMetricValue = Math.max(...categoryData.map(item => parseFloat(item.metric) || 0));
                
                categoryData.forEach((item, idx) => {
                    html += renderCompactCategoryCard(item, config.color, config.key, config.title, maxMetricValue);
                });
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            if (html === '') {
                container.innerHTML = '<p style="color: var(--text-secondary); text-align: center; padding: 40px; grid-column: 1 / -1;">No leaderboard data available. Please upload player data.</p>';
            } else {
                // Wrap in grid container
                container.innerHTML = `<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(450px, 1fr)); gap: 24px; width: 100%;">${html}</div>`;
            }
        }
        
        // Render compact category card for all-leaderboards page (single line, no grey labels)
        function renderCompactCategoryCard(item, color, categoryKey, categoryTitle, maxMetricValue) {
            const player = item.player;
            const teamColor = teamColors[player.team] || '#666';
            const escapedId = player.id.replace(/'/g, "\\'");
            const escapedCategory = (categoryTitle || '').replace(/'/g, "\\'");
            const escapedExplanation = (item.explanation || '').replace(/'/g, "\\'");
            
            // Calculate bar width percentage
            const metricValue = parseFloat(item.metric) || 0;
            const barWidthPercent = maxMetricValue > 0 ? (metricValue / maxMetricValue) * 100 : 0;
            
            // Determine if change should be shown and its direction
            const change = parseFloat(item.change || 0);
            const changeClass = change > 0 ? 'comparison-up' : change < 0 ? 'comparison-down' : '';
            const changeIcon = change > 0 ? '▲' : change < 0 ? '▼' : '';
            const showChange = Math.abs(change) >= 0.1; // Only show if change is meaningful
            
            // Create tooltip text for the metric value
            let tooltipText = '';
            if (item.metricLabel.includes('Opps/Game')) {
                tooltipText = `Average opportunities (rush attempts + targets) per game over the last 3 games.`;
            } else if (item.metricLabel.includes('Pts/Tgt')) {
                tooltipText = `Fantasy points per target over the last 3 games. Higher = more efficient.`;
            } else if (item.metricLabel.includes('Pts/Opp')) {
                tooltipText = `Fantasy points per opportunity over the last 3 games. Higher = more efficient.`;
            } else if (item.metricLabel.includes('RZ Opps')) {
                tooltipText = `Red zone opportunities per game over the last 3 games. More = higher TD potential.`;
            } else if (item.metricLabel.includes('Tgt/Game')) {
                tooltipText = `Average targets per game over the last 3 games. Higher = more consistent volume.`;
            } else if (item.metricLabel.includes('Yds/Att')) {
                tooltipText = `Yards per carry over the last 3 games. Higher = more explosive rushing.`;
            } else if (item.metricLabel.includes('RZ Tgt')) {
                tooltipText = `Red zone targets per game over the last 3 games. More = higher TD potential.`;
            } else if (item.metricLabel.includes('Air Yds')) {
                tooltipText = `Air yards per game over the last 3 games. Higher = more deep threat opportunities.`;
            } else if (item.metricLabel.includes('Tgt Share')) {
                tooltipText = `Target share over the last 3 games. Higher = more involved in passing game.`;
            } else {
                tooltipText = `${item.metricLabel} over the last 3 games.`;
            }
            
            return `
                <div class="compact-player-card" onclick="openPlayerModalWithCategory('${escapedId}', '${escapedCategory}', '${escapedExplanation}', '${item.rank}', '${item.metricLabel}', '${item.metric}')" style="
                    background: var(--bg-tertiary);
                    border: 1px solid var(--border-color);
                    border-radius: 8px;
                    padding: 10px 14px;
                    display: flex;
                    align-items: center;
                    gap: 12px;
                    cursor: pointer;
                    transition: all 0.2s ease;
                ">
                    <div style="
                        background: ${teamColor};
                        color: white;
                        font-size: 10px;
                        font-weight: 700;
                        padding: 4px 6px;
                        border-radius: 4px;
                        min-width: 32px;
                        text-align: center;
                    ">${player.team}</div>
                    
                    <div style="
                        flex: 1;
                        display: flex;
                        flex-direction: column;
                        gap: 4px;
                    ">
                        <div style="
                            font-size: 13px;
                            font-weight: 600;
                            color: var(--text-primary);
                            white-space: nowrap;
                            overflow: hidden;
                            text-overflow: ellipsis;
                        ">${player.name}</div>
                        <div class="metric-bar-container" style="width: 150px;">
                            <div class="metric-bar" style="width: ${barWidthPercent}%; background: ${teamColor};"></div>
                        </div>
                    </div>
                    
                    <div style="
                        font-size: 11px;
                        color: var(--text-tertiary);
                        min-width: 24px;
                    ">${player.position}</div>
                    
                    <div style="
                        font-size: 13px;
                        color: var(--text-secondary);
                        min-width: 28px;
                        text-align: center;
                    ">#${item.rank}</div>
                    
                    <div style="
                        display: flex;
                        align-items: center;
                        gap: 6px;
                        position: relative;
                    ">
                        <span class="compact-metric-value" 
                            data-tooltip-text="${tooltipText.replace(/"/g, '&quot;')}"
                            style="
                            font-size: 14px;
                            font-weight: 700;
                            color: var(--text-primary);
                            position: relative;
                            cursor: help;
                        ">
                            ${item.metric}
                        </span>
                        ${showChange ? `
                            <span class="player-comparison ${changeClass}" style="
                                display: flex;
                                align-items: center;
                                gap: 2px;
                                font-size: 11px;
                                white-space: nowrap;
                                position: relative;
                            ">
                                <span class="comparison-icon">${changeIcon}</span>
                                ${Math.abs(change).toFixed(item.metric.includes('.') && item.metric.split('.')[1].length > 1 ? 2 : 1)}
                                <span class="change-tooltip" style="
                                    position: absolute;
                                    bottom: 100%;
                                    right: 0;
                                    transform: translateY(0);
                                    margin-bottom: 8px;
                                    background: var(--bg-elevated);
                                    border: 1px solid var(--border-color-light);
                                    border-radius: 8px;
                                    padding: 8px 12px;
                                    font-size: 10px;
                                    white-space: nowrap;
                                    opacity: 0;
                                    pointer-events: none;
                                    transition: opacity 0.2s ease;
                                    z-index: 2001;
                                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
                                ">vs prior 3 weeks</span>
                            </span>
                        ` : `
                            <span style="
                                display: flex;
                                align-items: center;
                                gap: 2px;
                                font-size: 11px;
                                color: var(--text-tertiary);
                                min-width: 40px;
                                justify-content: center;
                            ">—</span>
                        `}
                    </div>
                </div>
            `;
        }
        
        // Manual scroll function for arrow buttons (optional - can be removed if arrows removed)
        function scrollCategories(direction) {
            const carousel = document.getElementById('categories-carousel');
            if (!carousel) return;
            
            // Temporarily disable animation for manual scroll
            carousel.style.animation = 'none';
            
            const scrollAmount = carousel.offsetWidth / 2; // Scroll by width of 2 items
            
            if (direction === 1) {
                carousel.scrollLeft += scrollAmount;
            } else {
                carousel.scrollLeft -= scrollAmount;
            }
            
            // Re-enable animation after a short delay
            setTimeout(() => {
                carousel.style.animation = '';
            }, 500);
        }
        
        // Render Individual Category Card
        function renderCategoryCard(item, color, categoryKey, categoryTitle) {
            const player = item.player;
            const teamColor = teamColors[player.team] || '#666';
            const escapedId = player.id.replace(/'/g, "\\'");
            const escapedCategory = (categoryTitle || '').replace(/'/g, "\\'");
            const escapedExplanation = (item.explanation || '').replace(/'/g, "\\'");
            
            // Determine if change should be shown and its direction
            const change = parseFloat(item.change || 0);
            const changeClass = change > 0 ? 'comparison-up' : change < 0 ? 'comparison-down' : '';
            const changeIcon = change > 0 ? '▲' : change < 0 ? '▼' : '';
            const showChange = Math.abs(change) >= 0.1; // Only show if change is meaningful
            
            // Create tooltip text based on metric type
            let tooltipText = '';
            if (item.metricLabel.includes('Opps/Game')) {
                tooltipText = `Average opportunities (rush attempts + targets) per game in last 3 weeks. Change vs weeks 4-6 back.`;
            } else if (item.metricLabel.includes('Pts/Tgt')) {
                tooltipText = `Fantasy points per target in last 3 weeks. Higher = more efficient. Change vs weeks 4-6 back.`;
            } else if (item.metricLabel.includes('Pts/Opp')) {
                tooltipText = `Fantasy points per opportunity in last 3 weeks. Higher = more efficient. Change vs weeks 4-6 back.`;
            } else if (item.metricLabel.includes('RZ')) {
                tooltipText = `Red zone opportunities per game in last 3 weeks. More = higher TD potential. Change vs weeks 4-6 back.`;
            } else if (item.metricLabel.includes('Tgt/Game') || item.metricLabel.includes('Tgt/G')) {
                tooltipText = `Average targets per game in last 3 weeks. Higher = more consistent volume. Change vs weeks 4-6 back.`;
            } else if (item.metricLabel.includes('Yds/Att')) {
                tooltipText = `Yards per carry in last 3 weeks. Higher = more explosive running. Change vs weeks 4-6 back.`;
            } else if (item.metricLabel.includes('Air Yds')) {
                tooltipText = `Air yards (depth of target) per game in last 3 weeks. Higher = deep threat. Change vs weeks 4-6 back.`;
            } else if (item.metricLabel.includes('Tgt Share')) {
                tooltipText = `Target share percentage in last 3 weeks. Higher = more passing game involvement. Change vs weeks 4-6 back.`;
            } else {
                tooltipText = `${item.metricLabel} in last 3 weeks. Change vs weeks 4-6 back.`;
            }
            
            // Create simplified tooltip for main stat value  
            let mainStatTooltip = '';
            if (item.metricLabel.includes('Opps/Game')) {
                mainStatTooltip = 'Opportunities per game (Rush Att + Targets)';
            } else if (item.metricLabel.includes('Pts/Tgt')) {
                mainStatTooltip = 'Fantasy points per target';
            } else if (item.metricLabel.includes('Pts/Opp')) {
                mainStatTooltip = 'Fantasy points per opportunity';
            } else if (item.metricLabel.includes('RZ')) {
                mainStatTooltip = 'Red zone opportunities per game';
            } else if (item.metricLabel.includes('Tgt/Game') || item.metricLabel.includes('Tgt/G')) {
                mainStatTooltip = 'Targets per game';
            } else if (item.metricLabel.includes('Yds/Att')) {
                mainStatTooltip = 'Yards per carry';
            } else if (item.metricLabel.includes('Air Yds')) {
                mainStatTooltip = 'Air yards per game';
            } else if (item.metricLabel.includes('Tgt Share')) {
                mainStatTooltip = 'Target share %';
            } else {
                mainStatTooltip = `${item.metricLabel} (Avg Last 3 games)`;
            }
            
            return `
                <div class="player-card" onclick="openPlayerModalWithCategory('${escapedId}', '${escapedCategory}', '${escapedExplanation}', '${item.rank}', '${item.metricLabel}', '${item.metric}')">
                    <div class="player-card-header" style="margin-bottom: 0;">
                        <div class="category-rank-simple" style="margin-right: 12px;">#${item.rank}</div>
                        <div class="player-card-badge" style="background: ${teamColor};">
                            ${player.team}
                        </div>
                        <div style="flex: 1; display: flex; flex-direction: column; gap: 2px;">
                            <div class="player-card-name">${player.name}</div>
                            <div class="player-card-team">${player.position}</div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 4px; position: relative;">
                            <span class="player-stat-value" style="white-space: nowrap; font-size: 12px; font-weight: 700;">
                                ${item.metric}
                            </span>
                            ${showChange ? `
                                <span class="player-comparison ${changeClass}" style="white-space: nowrap; font-size: 12px;">
                                    <span class="comparison-icon">${changeIcon}</span>
                                    ${Math.abs(change).toFixed(item.metric.includes('.') && item.metric.split('.')[1].length > 1 ? 2 : 1)}
                                </span>
                            ` : ''}
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Toggle footnote visibility
        function toggleFootnote() {
            const content = document.getElementById('footnote-content');
            const icon = document.getElementById('footnote-icon');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.textContent = '✕';
            } else {
                content.style.display = 'none';
                icon.textContent = 'ⓘ';
            }
        }
        
        // Toggle Category Expand/Collapse
        
        // Render mini scatter plots for category cards
        function renderMiniScatterPlots() {
            // This will be called after categories are rendered
            // For now, we'll render simple placeholder charts
            // In a full implementation, you'd create mini scatter plots with the player highlighted
            
            document.querySelectorAll('.category-card-chart canvas').forEach(canvas => {
                if (!canvas.id) return;
                
                // Simple placeholder - you can enhance this to show actual mini scatter plots
                const ctx = canvas.getContext('2d');
                if (!ctx) return;
                
                canvas.width = canvas.offsetWidth;
                canvas.height = 100;
                
                // Draw simple gradient background
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, 'rgba(48, 209, 88, 0.1)');
                gradient.addColorStop(1, 'rgba(10, 132, 255, 0.1)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw a simple trend line or indicator
                ctx.strokeStyle = 'rgba(48, 209, 88, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height * 0.7);
                ctx.lineTo(canvas.width * 0.5, canvas.height * 0.4);
                ctx.lineTo(canvas.width, canvas.height * 0.3);
                ctx.stroke();
            });
        }
        
        // ============================================
        // ADVANCED ANALYTICS
        // ============================================
        
        let advancedScatterChart = null;
        let highlightedPlayerIds = []; // Now supports up to 2 players
        let selectedWeekRange = 'all';
        let advancedCurrentPosition = 'WR';
        let currentQuadrantExplanation = '';
        
        // Preset scatterplot configurations
        const scatterPresets = {
            WR: [
                {
                    name: 'Volume vs Efficiency',
                    xAxis: 'targets',
                    yAxis: 'catch_rate',
                    description: 'High-volume receivers with strong catch rates',
                    quadrantExplanation: 'Top-right = High volume + reliable hands. Bottom-right = Volume without efficiency. Top-left = Efficient but limited opportunities.'
                },
                {
                    name: 'Volume vs Production',
                    xAxis: 'targets',
                    yAxis: 'fantasy_points',
                    description: 'Target share translating to fantasy points',
                    quadrantExplanation: 'Top-right = Elite fantasy assets (volume + production). Bottom-right = High volume underperformers. Top-left = Efficient scorers with limited volume.'
                },
                {
                    name: 'Target Share vs Production',
                    xAxis: 'target_share',
                    yAxis: 'fantasy_points',
                    description: 'Team involvement vs fantasy output',
                    quadrantExplanation: 'Top-right = Offensive centerpieces. Bottom-right = High target share not converting. Top-left = Boom/bust players or red zone specialists.'
                },
                {
                    name: 'Red Zone Usage',
                    xAxis: 'rz_targets',
                    yAxis: 'fantasy_points',
                    description: 'Red zone opportunities vs scoring',
                    quadrantExplanation: 'Top-right = TD-dependent scorers. Bottom-right = Red zone targets not converting. Top-left = Yardage-based scorers with limited red zone work.'
                },
                {
                    name: 'More with Less',
                    xAxis: 'targets',
                    yAxis: 'receiving_yards',
                    description: 'Target efficiency and big-play ability',
                    quadrantExplanation: 'Top-right = High volume + yards. Top-left = Explosive playmakers doing more with fewer touches. Bottom-right = Volume without yards.'
                },
                {
                    name: 'Team Dominance',
                    xAxis: 'target_share',
                    yAxis: 'team_points',
                    description: 'Target share in high/low-scoring offenses',
                    quadrantExplanation: 'Top-right = Alpha WRs on elite offenses. Bottom-right = Dominant share on bad offenses. Top-left = Supporting cast on great offenses.'
                }
            ],
            RB: [
                {
                    name: 'Talent Indicator',
                    xAxis: 'ybc_per_att',
                    yAxis: 'yac_per_att',
                    description: 'Vision vs power/elusiveness',
                    quadrantExplanation: 'Top-right = Elite talent (vision + contact balance). Bottom-right = Great vision, poor after contact. Top-left = Contact breakers relying on line.'
                },
                {
                    name: 'Volume vs Production',
                    xAxis: 'opportunities',
                    yAxis: 'fantasy_points',
                    description: 'Opportunity share vs fantasy output',
                    quadrantExplanation: 'Top-right = Workhorse RBs producing. Bottom-right = High volume underperformers. Top-left = Efficient, limited-touch backs.'
                },
                {
                    name: 'Red Zone Usage',
                    xAxis: 'rz_opportunities',
                    yAxis: 'fantasy_points',
                    description: 'Red zone touches vs scoring',
                    quadrantExplanation: 'Top-right = Goal-line backs. Bottom-right = Red zone work not converting. Top-left = Yardage scorers with limited red zone role.'
                },
                {
                    name: 'Carries vs Opportunities',
                    xAxis: 'carries',
                    yAxis: 'opportunities',
                    description: 'Rushing role vs total touches',
                    quadrantExplanation: 'Top-right = Three-down backs (high carries + targets). Bottom-right = Pure rushers with minimal pass work. Top-left = Pass-catching specialists.'
                },
                {
                    name: 'Rushing Efficiency',
                    xAxis: 'carries',
                    yAxis: 'rushing_yards',
                    description: 'Rushing volume vs yards produced',
                    quadrantExplanation: 'Top-right = Bell-cow rushers. Bottom-right = High volume, low efficiency. Top-left = Explosive runners with limited carries.'
                },
                {
                    name: 'Team Context',
                    xAxis: 'opportunities',
                    yAxis: 'team_points',
                    description: 'Workload in high/low-scoring offenses',
                    quadrantExplanation: 'Top-right = Lead backs on elite offenses. Bottom-right = Workhorse on bad offenses. Top-left = Committee backs on great offenses.'
                }
            ],
            TE: [
                {
                    name: 'Volume vs Efficiency',
                    xAxis: 'targets',
                    yAxis: 'catch_rate',
                    description: 'High-volume tight ends with strong catch rates',
                    quadrantExplanation: 'Top-right = High volume + reliable hands. Bottom-right = Volume without efficiency. Top-left = Efficient but limited opportunities.'
                },
                {
                    name: 'Volume vs Production',
                    xAxis: 'targets',
                    yAxis: 'fantasy_points',
                    description: 'Target share translating to fantasy points',
                    quadrantExplanation: 'Top-right = Elite fantasy assets (volume + production). Bottom-right = High volume underperformers. Top-left = Efficient scorers with limited volume.'
                },
                {
                    name: 'Target Share vs Production',
                    xAxis: 'target_share',
                    yAxis: 'fantasy_points',
                    description: 'Team involvement vs fantasy output',
                    quadrantExplanation: 'Top-right = Offensive centerpieces. Bottom-right = High target share not converting. Top-left = Boom/bust players or red zone specialists.'
                },
                {
                    name: 'Red Zone Usage',
                    xAxis: 'rz_targets',
                    yAxis: 'fantasy_points',
                    description: 'Red zone opportunities vs scoring',
                    quadrantExplanation: 'Top-right = TD-dependent scorers. Bottom-right = Red zone targets not converting. Top-left = Yardage-based scorers with limited red zone work.'
                },
                {
                    name: 'More with Less',
                    xAxis: 'targets',
                    yAxis: 'receiving_yards',
                    description: 'Target efficiency and big-play ability',
                    quadrantExplanation: 'Top-right = High volume + yards. Top-left = Explosive playmakers doing more with fewer touches. Bottom-right = Volume without yards.'
                },
                {
                    name: 'Team Dominance',
                    xAxis: 'target_share',
                    yAxis: 'team_points',
                    description: 'Target share in high/low-scoring offenses',
                    quadrantExplanation: 'Top-right = Alpha TEs on elite offenses. Bottom-right = Dominant share on bad offenses. Top-left = Supporting cast on great offenses.'
                }
            ]
        };
        
        // Populate preset buttons
        // Player Search Functions
        function filterPlayerSearch() {
            const input = document.getElementById('player-search-input');
            const searchTerm = input.value.toLowerCase().trim();
            const dropdown = document.getElementById('player-search-dropdown');
            
            if (searchTerm.length === 0) {
                dropdown.style.display = 'none';
                return;
            }
            
            // Get all players for current position
            const players = Object.values(allPlayers).filter(p => 
                p.position === advancedCurrentPosition && p.gamesPlayed >= 3
            );
            
            // Filter players by search term
            const matches = players.filter(p => 
                p.name.toLowerCase().includes(searchTerm)
            ).sort((a, b) => b.avgPoints - a.avgPoints).slice(0, 10);
            
            if (matches.length === 0) {
                dropdown.innerHTML = '<div style="padding: 12px; color: var(--text-secondary); font-size: 13px;">No players found</div>';
                dropdown.style.display = 'block';
                return;
            }
            
            // Build dropdown HTML
            let html = '';
            matches.forEach(player => {
                html += `
                    <div onclick="selectPlayerHighlight('${player.id.replace(/'/g, "\\'")}', '${player.name.replace(/'/g, "\\'")}', '${player.team}')" 
                         style="padding: 10px 12px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid var(--border-color); transition: background 0.2s;"
                         onmouseover="this.style.background='var(--bg-tertiary)'" 
                         onmouseout="this.style.background='transparent'">
                        <div>
                            <div style="font-weight: 600; color: var(--text-primary); font-size: 13px;">${player.name}</div>
                            <div style="font-size: 11px; color: var(--text-secondary);">${player.team} · ${player.avgPoints.toFixed(1)} PPG</div>
                        </div>
                        <div style="width: 24px; height: 24px; border-radius: 4px; background: ${teamColors[player.team] || '#666'}; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: 700; color: white;">
                            ${player.team}
                        </div>
                    </div>
                `;
            });
            
            dropdown.innerHTML = html;
            dropdown.style.display = 'block';
        }
        
        function showPlayerSearchDropdown() {
            const input = document.getElementById('player-search-input');
            if (input.value.length > 0) {
                filterPlayerSearch();
            }
        }
        
        function selectPlayerHighlight(playerId, playerName, team) {
            // Check if player is already highlighted
            if (highlightedPlayerIds.includes(playerId)) {
                return; // Don't add duplicates
            }
            
            // Add player (max 4 players)
            if (highlightedPlayerIds.length < 4) {
                highlightedPlayerIds.push(playerId);
            } else {
                // Replace oldest player if already at max
                highlightedPlayerIds.shift();
                highlightedPlayerIds.push(playerId);
            }
            
            // Update selected players display
            updateSelectedPlayersDisplay();
            
            // Clear the input for next selection
            const input = document.getElementById('player-search-input');
            input.value = '';
            
            const dropdown = document.getElementById('player-search-dropdown');
            dropdown.style.display = 'none';
            
            const clearBtn = document.getElementById('clear-player-btn');
            clearBtn.style.display = highlightedPlayerIds.length > 0 ? 'block' : 'none';
            
            updateAdvancedScatter();
        }
        
        function updateSelectedPlayersDisplay() {
            const container = document.getElementById('selected-players-container');
            
            if (highlightedPlayerIds.length === 0) {
                container.style.display = 'none';
                return;
            }
            
            container.style.display = 'flex';
            
            let html = '';
            highlightedPlayerIds.forEach((playerId, index) => {
                const player = allPlayers[playerId];
                if (player) {
                    // Use white border for all highlighted players
                    html += `
                        <div style="
                            display: flex;
                            align-items: center;
                            gap: 6px;
                            padding: 4px 8px;
                            background: var(--bg-elevated);
                            border: 2px solid #fff;
                            border-radius: 6px;
                            font-size: 12px;
                            font-weight: 600;
                        ">
                            <span>${player.name} (${player.team})</span>
                            <button onclick="removePlayerHighlight('${playerId}')" style="
                                background: transparent;
                                border: none;
                                color: var(--text-secondary);
                                cursor: pointer;
                                font-size: 16px;
                                padding: 0;
                                width: 16px;
                                height: 16px;
                                line-height: 1;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                            ">×</button>
                        </div>
                    `;
                }
            });
            
            container.innerHTML = html;
        }
        
        function removePlayerHighlight(playerId) {
            highlightedPlayerIds = highlightedPlayerIds.filter(id => id !== playerId);
            updateSelectedPlayersDisplay();
            
            const clearBtn = document.getElementById('clear-player-btn');
            clearBtn.style.display = highlightedPlayerIds.length > 0 ? 'block' : 'none';
            
            updateAdvancedScatter();
        }
        
        function clearPlayerHighlight() {
            highlightedPlayerIds = [];
            
            const input = document.getElementById('player-search-input');
            input.value = '';
            
            updateSelectedPlayersDisplay();
            
            const clearBtn = document.getElementById('clear-player-btn');
            clearBtn.style.display = 'none';
            
            const dropdown = document.getElementById('player-search-dropdown');
            dropdown.style.display = 'none';
            
            updateAdvancedScatter();
        }
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            const input = document.getElementById('player-search-input');
            const dropdown = document.getElementById('player-search-dropdown');
            if (input && dropdown && !input.contains(e.target) && !dropdown.contains(e.target)) {
                dropdown.style.display = 'none';
            }
        });
        
        // Week Range Filter Function
        function getWeekFilteredData(player, weekRange) {
            if (weekRange === 'all') {
                return player.weeks;
            }
            
            // Find global max week
            let globalMaxWeek = 0;
            Object.values(allPlayers).forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });
            
            if (weekRange === 'last3') {
                const targetWeeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2];
                return player.weeks.filter(w => targetWeeks.includes(w.week));
            } else if (weekRange === 'last5') {
                const targetWeeks = [globalMaxWeek, globalMaxWeek - 1, globalMaxWeek - 2, globalMaxWeek - 3, globalMaxWeek - 4];
                return player.weeks.filter(w => targetWeeks.includes(w.week));
            } else if (weekRange.includes('-')) {
                const [start, end] = weekRange.split('-').map(Number);
                return player.weeks.filter(w => w.week >= start && w.week <= end);
            } else if (!isNaN(weekRange)) {
                return player.weeks.filter(w => w.week == weekRange);
            }
            
            return player.weeks;
        }
        
        function populatePresetButtons() {
            const container = document.getElementById('preset-buttons-container');
            if (!container) return;
            
            const presets = scatterPresets[advancedCurrentPosition];
            
            container.innerHTML = presets.map(preset => `
                <button class="preset-btn" onclick="applyPreset('${preset.xAxis}', '${preset.yAxis}')" title="${preset.description}">
                    ${preset.name}
                </button>
            `).join('');
        }
        
        // Apply a preset configuration
        function applyPreset(xAxis, yAxis) {
            const xSelect = document.getElementById('x-axis-select');
            const ySelect = document.getElementById('y-axis-select');
            
            if (xSelect && ySelect) {
                xSelect.value = xAxis;
                ySelect.value = yAxis;
                
                // Find the preset to get its quadrant explanation
                const presets = scatterPresets[advancedCurrentPosition];
                const preset = presets.find(p => p.xAxis === xAxis && p.yAxis === yAxis);
                
                // Store the quadrant explanation for use in rendering
                currentQuadrantExplanation = preset ? preset.quadrantExplanation : '';
                
                updateAdvancedScatter();
            }
        }
        
        // Stat definitions with calculation functions
        const advancedStatDefinitions = {
            WR: [
                {
                    id: 'fantasy_points',
                    label: 'Fantasy Points per Game',
                    calculate: (player) => player.avgPoints || 0
                },
                {
                    id: 'targets',
                    label: 'Targets per Game',
                    calculate: (player) => player.totalTargets / player.gamesPlayed
                },
                {
                    id: 'receptions',
                    label: 'Receptions per Game',
                    calculate: (player) => player.totalRec / player.gamesPlayed
                },
                {
                    id: 'receiving_yards',
                    label: 'Receiving Yards per Game',
                    calculate: (player) => player.totalYDS / player.gamesPlayed
                },
                {
                    id: 'catch_rate',
                    label: 'Catch Rate (%)',
                    calculate: (player) => player.catchRate || 0
                },
                {
                    id: 'target_share',
                    label: 'Target Share (%)',
                    calculate: (player) => {
                        // Calculate average team share across all weeks
                        if (!player.weeks || player.weeks.length === 0) return 0;
                        const totalShare = player.weeks.reduce((sum, w) => sum + (w.teamShare || 0), 0);
                        return totalShare / player.weeks.length;
                    }
                },
                {
                    id: 'rz_targets',
                    label: 'Red Zone Targets per Game',
                    calculate: (player) => (player.rzOpportunities || 0) / player.gamesPlayed
                },
                {
                    id: 'air_yards',
                    label: 'Air Yards per Game',
                    calculate: (player) => player.airYardsPerGame || 0
                },
                {
                    id: 'yac_per_rec',
                    label: 'Yards After Catch per Reception',
                    calculate: (player) => player.yacPerRec || 0
                },
                {
                    id: 'team_points',
                    label: 'Team Points per Game',
                    calculate: (player) => {
                        // Get team's average points from teamStats
                        if (!teamStats || !teamStats[player.team]) return 0;
                        return teamStats[player.team].avgPoints || 0;
                    }
                },
                {
                    id: 'receiving_tds',
                    label: 'Receiving TDs per Game',
                    calculate: (player) => (player.totalRecTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'rushing_tds',
                    label: 'Rushing TDs per Game',
                    calculate: (player) => (player.totalRushTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'total_tds',
                    label: 'Total TDs per Game',
                    calculate: (player) => ((player.totalRecTDs || 0) + (player.totalRushTDs || 0)) / player.gamesPlayed
                },
                {
                    id: 'rz_tds',
                    label: 'Red Zone TDs per Game',
                    calculate: (player) => (player.rzTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'yards_per_touch',
                    label: 'Yards per Touch',
                    calculate: (player) => {
                        const totalYards = (player.totalYDS || 0) + (player.totalRushYards || 0);
                        const totalTouches = (player.totalRec || 0) + (player.totalCarries || 0);
                        return totalTouches > 0 ? totalYards / totalTouches : 0;
                    }
                },
                {
                    id: 'td_rate',
                    label: 'TD Rate (per Touch)',
                    calculate: (player) => {
                        const totalTDs = (player.totalRecTDs || 0) + (player.totalRushTDs || 0);
                        const totalTouches = (player.totalRec || 0) + (player.totalCarries || 0);
                        return totalTouches > 0 ? (totalTDs / totalTouches) * 100 : 0;
                    }
                },
                {
                    id: 'total_yards',
                    label: 'Total Yards per Game',
                    calculate: (player) => {
                        const totalYards = (player.totalYDS || 0) + (player.totalRushYards || 0);
                        return totalYards / player.gamesPlayed;
                    }
                },
                {
                    id: 'rushing_yards',
                    label: 'Rushing Yards per Game',
                    calculate: (player) => (player.totalRushYards || 0) / player.gamesPlayed
                }
            ],
            RB: [
                {
                    id: 'fantasy_points',
                    label: 'Fantasy Points per Game',
                    calculate: (player) => player.avgPoints || 0
                },
                {
                    id: 'opportunities',
                    label: 'Opportunities per Game',
                    calculate: (player) => player.totalOpportunities / player.gamesPlayed
                },
                {
                    id: 'rushing_yards',
                    label: 'Rushing Yards per Game',
                    calculate: (player) => (player.totalRushYards || 0) / player.gamesPlayed
                },
                {
                    id: 'ybc_per_att',
                    label: 'Yards Before Contact per Att',
                    calculate: (player) => {
                        const carries = player.totalCarries || 0;
                        return carries > 0 ? (player.totalYBCON || 0) / carries : 0;
                    }
                },
                {
                    id: 'yac_per_att',
                    label: 'Yards After Contact per Att',
                    calculate: (player) => {
                        const carries = player.totalCarries || 0;
                        return carries > 0 ? (player.totalYACON || 0) / carries : 0;
                    }
                },
                {
                    id: 'rz_opportunities',
                    label: 'Red Zone Opportunities per Game',
                    calculate: (player) => (player.rzOpportunities || 0) / player.gamesPlayed
                },
                {
                    id: 'carries',
                    label: 'Carries per Game',
                    calculate: (player) => (player.totalCarries || 0) / player.gamesPlayed
                },
                {
                    id: 'targets',
                    label: 'Targets per Game',
                    calculate: (player) => (player.totalTargets || 0) / player.gamesPlayed
                },
                {
                    id: 'team_points',
                    label: 'Team Points per Game',
                    calculate: (player) => {
                        // Get team's average points from teamStats
                        if (!teamStats || !teamStats[player.team]) return 0;
                        return teamStats[player.team].avgPoints || 0;
                    }
                },
                {
                    id: 'receiving_tds',
                    label: 'Receiving TDs per Game',
                    calculate: (player) => (player.totalRecTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'rushing_tds',
                    label: 'Rushing TDs per Game',
                    calculate: (player) => (player.totalRushTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'total_tds',
                    label: 'Total TDs per Game',
                    calculate: (player) => ((player.totalRecTDs || 0) + (player.totalRushTDs || 0)) / player.gamesPlayed
                },
                {
                    id: 'rz_tds',
                    label: 'Red Zone TDs per Game',
                    calculate: (player) => (player.rzTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'yards_per_touch',
                    label: 'Yards per Touch',
                    calculate: (player) => {
                        const totalYards = (player.totalRushYards || 0) + (player.totalRecYards || 0);
                        const totalTouches = (player.totalCarries || 0) + (player.totalRec || 0);
                        return totalTouches > 0 ? totalYards / totalTouches : 0;
                    }
                },
                {
                    id: 'td_rate',
                    label: 'TD Rate (per Touch)',
                    calculate: (player) => {
                        const totalTDs = (player.totalRecTDs || 0) + (player.totalRushTDs || 0);
                        const totalTouches = (player.totalCarries || 0) + (player.totalRec || 0);
                        return totalTouches > 0 ? (totalTDs / totalTouches) * 100 : 0;
                    }
                },
                {
                    id: 'total_yards',
                    label: 'Total Yards per Game',
                    calculate: (player) => {
                        const totalYards = (player.totalRushYards || 0) + (player.totalRecYards || 0);
                        return totalYards / player.gamesPlayed;
                    }
                },
                {
                    id: 'receiving_yards',
                    label: 'Receiving Yards per Game',
                    calculate: (player) => (player.totalRecYards || 0) / player.gamesPlayed
                }
            ],
            TE: [
                {
                    id: 'fantasy_points',
                    label: 'Fantasy Points per Game',
                    calculate: (player) => player.avgPoints || 0
                },
                {
                    id: 'targets',
                    label: 'Targets per Game',
                    calculate: (player) => player.totalTargets / player.gamesPlayed
                },
                {
                    id: 'receptions',
                    label: 'Receptions per Game',
                    calculate: (player) => player.totalRec / player.gamesPlayed
                },
                {
                    id: 'receiving_yards',
                    label: 'Receiving Yards per Game',
                    calculate: (player) => player.totalYDS / player.gamesPlayed
                },
                {
                    id: 'catch_rate',
                    label: 'Catch Rate (%)',
                    calculate: (player) => player.catchRate || 0
                },
                {
                    id: 'target_share',
                    label: 'Target Share (%)',
                    calculate: (player) => {
                        // Calculate average team share across all weeks
                        if (!player.weeks || player.weeks.length === 0) return 0;
                        const totalShare = player.weeks.reduce((sum, w) => sum + (w.teamShare || 0), 0);
                        return totalShare / player.weeks.length;
                    }
                },
                {
                    id: 'rz_targets',
                    label: 'Red Zone Targets per Game',
                    calculate: (player) => (player.rzOpportunities || 0) / player.gamesPlayed
                },
                {
                    id: 'air_yards',
                    label: 'Air Yards per Game',
                    calculate: (player) => player.airYardsPerGame || 0
                },
                {
                    id: 'yac_per_rec',
                    label: 'Yards After Catch per Reception',
                    calculate: (player) => player.yacPerRec || 0
                },
                {
                    id: 'team_points',
                    label: 'Team Points per Game',
                    calculate: (player) => {
                        // Get team's average points from teamStats
                        if (!teamStats || !teamStats[player.team]) return 0;
                        return teamStats[player.team].avgPoints || 0;
                    }
                },
                {
                    id: 'receiving_tds',
                    label: 'Receiving TDs per Game',
                    calculate: (player) => (player.totalRecTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'rz_tds',
                    label: 'Red Zone TDs per Game',
                    calculate: (player) => (player.rzTDs || 0) / player.gamesPlayed
                },
                {
                    id: 'yards_per_touch',
                    label: 'Yards per Reception',
                    calculate: (player) => {
                        return player.totalRec > 0 ? (player.totalYDS || 0) / player.totalRec : 0;
                    }
                },
                {
                    id: 'td_rate',
                    label: 'TD Rate (per Target)',
                    calculate: (player) => {
                        const totalTDs = player.totalRecTDs || 0;
                        return player.totalTargets > 0 ? (totalTDs / player.totalTargets) * 100 : 0;
                    }
                }
            ]
        };
        
        // Switch position in Advanced Analytics
        // Toggle axis control collapse/expand
        function toggleAxisControl(axisId) {
            const content = document.getElementById(`${axisId}-content`);
            const icon = document.getElementById(`${axisId}-icon`);
            
            if (content && icon) {
                if (content.classList.contains('collapsed')) {
                    content.classList.remove('collapsed');
                    icon.classList.remove('collapsed');
                } else {
                    content.classList.add('collapsed');
                    icon.classList.add('collapsed');
                }
            }
        }
        
        function switchAdvancedPosition(position) {
            advancedCurrentPosition = position;
            
            // Clear quadrant explanation when switching positions
            currentQuadrantExplanation = '';
            
            // Clear player highlight when switching positions
            clearPlayerHighlight();
            
            // Update button states
            document.getElementById('advanced-wr-btn').classList.toggle('active', position === 'WR');
            document.getElementById('advanced-rb-btn').classList.toggle('active', position === 'RB');
            document.getElementById('advanced-te-btn').classList.toggle('active', position === 'TE');
            
            // Populate preset buttons for new position
            populatePresetButtons();
            
            // Populate dropdowns with new stats
            populateAdvancedDropdowns();
            
            // Update scatter plot
            updateAdvancedScatter();
        }
        
        // Populate stat dropdowns
        function populateAdvancedDropdowns() {
            const stats = advancedStatDefinitions[advancedCurrentPosition];
            const xSelect = document.getElementById('x-axis-select');
            const ySelect = document.getElementById('y-axis-select');
            
            // Store current selections
            const currentX = xSelect.value;
            const currentY = ySelect.value;
            
            // Clear and populate
            xSelect.innerHTML = '';
            ySelect.innerHTML = '';
            
            stats.forEach(stat => {
                const xOption = document.createElement('option');
                xOption.value = stat.id;
                xOption.textContent = stat.label;
                xSelect.appendChild(xOption);
                
                const yOption = document.createElement('option');
                yOption.value = stat.id;
                yOption.textContent = stat.label;
                ySelect.appendChild(yOption);
            });
            
            // Set default selections or restore previous
            if (currentX && stats.find(s => s.id === currentX)) {
                xSelect.value = currentX;
            } else {
                // Default X-axis: Targets for WR, Opportunities for RB
                xSelect.value = advancedCurrentPosition === 'WR' ? 'targets' : 'opportunities';
            }
            
            if (currentY && stats.find(s => s.id === currentY)) {
                ySelect.value = currentY;
            } else {
                // Default Y-axis: Fantasy Points for both
                ySelect.value = 'fantasy_points';
            }
        }
        
        // Calculate stat value for a player
        function calculateAdvancedStat(player, statId, weekFilteredWeeks = null) {
            const stats = advancedStatDefinitions[advancedCurrentPosition];
            const stat = stats.find(s => s.id === statId);
            if (!stat) return 0;
            
            // Create a temporary player object with filtered weeks if provided
            const playerForCalc = weekFilteredWeeks ? {
                ...player,
                weeks: weekFilteredWeeks,
                gamesPlayed: weekFilteredWeeks.length,
                totalTargets: weekFilteredWeeks.reduce((sum, w) => sum + (w.targets || 0), 0),
                totalOpportunities: weekFilteredWeeks.reduce((sum, w) => sum + ((w.rushAttempts || 0) + (w.targets || 0)), 0),
                totalPoints: weekFilteredWeeks.reduce((sum, w) => sum + w.fpts, 0),
                avgPoints: weekFilteredWeeks.length > 0 ? weekFilteredWeeks.reduce((sum, w) => sum + w.fpts, 0) / weekFilteredWeeks.length : 0
            } : player;
            
            const value = stat.calculate(playerForCalc);
            return isFinite(value) ? value : 0;
        }
        
        // Get stat label
        function getAdvancedStatLabel(statId) {
            const stats = advancedStatDefinitions[advancedCurrentPosition];
            const stat = stats.find(s => s.id === statId);
            return stat ? stat.label : '';
        }
        
        // Generate intelligent quadrant explanations for custom stat combinations
        function generateQuadrantExplanation(xStatId, yStatId, xLabel, yLabel) {
            // Define stat categories
            const volumeStats = ['targets_per_game', 'opportunities_per_game', 'team_share', 'air_yards_per_game'];
            const efficiencyStats = ['yards_per_target', 'yards_per_reception', 'yards_per_touch', 'catch_rate', 'points_per_target', 'points_per_opportunity'];
            const productionStats = ['fantasy_ppg', 'yards_per_game', 'receiving_yards_per_game', 'rushing_yards_per_game'];
            const scoringStats = ['rz_targets_per_game', 'rz_opportunities_per_game', 'td_rate'];
            
            const xIsVolume = volumeStats.includes(xStatId);
            const xIsEfficiency = efficiencyStats.includes(xStatId);
            const xIsProduction = productionStats.includes(xStatId);
            const xIsScoring = scoringStats.includes(xStatId);
            
            const yIsVolume = volumeStats.includes(yStatId);
            const yIsEfficiency = efficiencyStats.includes(yStatId);
            const yIsProduction = productionStats.includes(yStatId);
            const yIsScoring = scoringStats.includes(yStatId);
            
            let explanation = '';
            
            // Volume vs Efficiency
            if ((xIsVolume && yIsEfficiency) || (xIsEfficiency && yIsVolume)) {
                explanation = `<strong>What to look for:</strong> Top-right = elite players with high volume AND efficiency (studs). Bottom-right = volume without efficiency (sell high). Top-left = efficient with low volume (buy low candidates).`;
            }
            // Volume vs Production
            else if ((xIsVolume && yIsProduction) || (xIsProduction && yIsVolume)) {
                explanation = `<strong>What to look for:</strong> Top-right = workhorses producing (league winners). Bottom-right = volume hogs underperforming (regression candidates). Top-left = efficient producers lacking volume (breakout potential if usage increases).`;
            }
            // Volume vs Scoring
            else if ((xIsVolume && yIsScoring) || (xIsScoring && yIsVolume)) {
                explanation = `<strong>What to look for:</strong> Top-right = high-volume goal-line threats (must-starts with TD upside). Bottom-right = volume without scoring opportunities (TD-dependent floor). Top-left = goal-line specialists (boom/bust).`;
            }
            // Efficiency vs Production
            else if ((xIsEfficiency && yIsProduction) || (xIsProduction && yIsEfficiency)) {
                explanation = `<strong>What to look for:</strong> Top-right = efficient producers (sustainable performers). Bottom-right = producing despite inefficiency (volume-driven, regression risk). Top-left = efficient low producers (need more volume).`;
            }
            // Efficiency vs Scoring
            else if ((xIsEfficiency && yIsScoring) || (xIsScoring && yIsEfficiency)) {
                explanation = `<strong>What to look for:</strong> Top-right = efficient players with TD equity (high ceiling). Bottom-right = TD-dependent without efficiency (volatility). Top-left = efficient players without scoring (steady floor, limited ceiling).`;
            }
            // Production vs Scoring
            else if ((xIsProduction && yIsScoring) || (xIsScoring && yIsProduction)) {
                explanation = `<strong>What to look for:</strong> Top-right = elite producers with scoring equity (championship upside). Bottom-right = big producers without TDs (high floor). Top-left = TD-dependent scorers (boom/bust weekly).`;
            }
            // Same category (e.g., two volume stats)
            else if ((xIsVolume && yIsVolume) || (xIsEfficiency && yIsEfficiency) || (xIsProduction && yIsProduction) || (xIsScoring && yIsScoring)) {
                explanation = `<strong>What to look for:</strong> Top-right = elite in both ${xLabel.includes('Opp') || yLabel.includes('Opp') ? 'opportunity metrics' : 'metrics'} (target these players). Bottom-left = struggling in both areas (avoid). Diagonal = trade-offs between the two stats.`;
            }
            // Generic fallback
            else {
                explanation = `<strong>What to look for:</strong> Top-right = above median in both ${xLabel} and ${yLabel} (target these players). Bottom-left = below median in both (avoid). <span style="color: var(--text-tertiary);">Grey dotted lines show median values.</span>`;
            }
            
            return explanation;
        }
        
        // Update scatter plot
        function updateAdvancedScatter() {
            if (!allPlayers || Object.keys(allPlayers).length === 0) {
                console.log('No player data available yet');
                return;
            }
            
            const xStatId = document.getElementById('x-axis-select').value;
            const yStatId = document.getElementById('y-axis-select').value;
            const weekRange = document.getElementById('week-range-select').value;
            
            const xLabel = getAdvancedStatLabel(xStatId);
            const yLabel = getAdvancedStatLabel(yStatId);
            
            // Update title with week range info
            const weekRangeText = weekRange === 'all' ? '' : ` (${document.getElementById('week-range-select').selectedOptions[0].text})`;
            document.getElementById('scatter-title').textContent = `${yLabel} vs ${xLabel}${weekRangeText}`;
            
            // Generate intelligent quadrant explanation based on stat combination
            const descriptionEl = document.getElementById('scatter-description');
            if (currentQuadrantExplanation) {
                descriptionEl.innerHTML = 
                    `<strong>What to look for:</strong> ${currentQuadrantExplanation}`;
            } else {
                // Generate smart explanation based on metrics
                let explanation = generateQuadrantExplanation(xStatId, yStatId, xLabel, yLabel);
                descriptionEl.innerHTML = explanation;
            }
            
            // Convert allPlayers object to array and filter by position and games played
            const players = Object.values(allPlayers).filter(p => 
                p.position === advancedCurrentPosition && 
                p.gamesPlayed >= 3
            );
            
            // Calculate stats for each player with week filtering
            const scatterData = players.map(player => {
                const weekFilteredWeeks = getWeekFilteredData(player, weekRange);
                
                // Skip if no data in the selected week range
                if (weekFilteredWeeks.length === 0) return null;
                
                const x = calculateAdvancedStat(player, xStatId, weekFilteredWeeks);
                const y = calculateAdvancedStat(player, yStatId, weekFilteredWeeks);
                
                return {
                    x: x,
                    y: y,
                    player: player
                };
            }).filter(d => d && isFinite(d.x) && isFinite(d.y));
            
            // Render chart
            renderAdvancedScatter(scatterData, xLabel, yLabel);
        }
        
        // Render the scatter plot
        function renderAdvancedScatter(data, xLabel, yLabel) {
            const canvas = document.getElementById('advanced-scatter-chart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Destroy existing chart
            if (advancedScatterChart) {
                advancedScatterChart.destroy();
            }
            
            // Calculate medians
            const xValues = data.map(d => d.x).sort((a, b) => a - b);
            const yValues = data.map(d => d.y).sort((a, b) => a - b);
            
            const xMedian = xValues.length > 0 ? xValues[Math.floor(xValues.length / 2)] : 0;
            const yMedian = yValues.length > 0 ? yValues[Math.floor(yValues.length / 2)] : 0;
            
            // Calculate axis ranges with padding
            const xMin = Math.min(...xValues);
            const xMax = Math.max(...xValues);
            const yMin = Math.min(...yValues);
            const yMax = Math.max(...yValues);
            
            const xRange = xMax - xMin;
            const yRange = yMax - yMin;
            
            // Ensure minimum range to prevent overly zoomed charts
            const minRange = 0.1;
            const xPadding = Math.max(xRange * 0.1, minRange); // 10% padding or minimum
            const yPadding = Math.max(yRange * 0.1, minRange);
            
            // Handle edge case where all values are identical
            const xAxisMin = xRange > 0 ? xMin - xPadding : xMin - 1;
            const xAxisMax = xRange > 0 ? xMax + xPadding : xMax + 1;
            const yAxisMin = yRange > 0 ? yMin - yPadding : yMin - 1;
            const yAxisMax = yRange > 0 ? yMax + yPadding : yMax + 1;
            
            // Prepare datasets - separate highlighted players from others
            let datasets = [];
            
            // Regular players dataset (exclude any highlighted players)
            const regularData = highlightedPlayerIds.length > 0
                ? data.filter(d => !highlightedPlayerIds.includes(d.player.id))
                : data;
            
            datasets.push({
                label: advancedCurrentPosition,
                data: regularData,
                backgroundColor: regularData.map(d => {
                    const color = teamColors[d.player.team] || '#666';
                    return color + '99'; // Add transparency
                }),
                borderColor: regularData.map(d => teamColors[d.player.team] || '#666'),
                borderWidth: 2,
                pointRadius: 8,
                pointHoverRadius: 12,
                pointHoverBorderWidth: 3
            });
            
            // Highlighted players datasets (up to 4 players, all with white borders)
            if (highlightedPlayerIds.length > 0) {
                highlightedPlayerIds.forEach((playerId, index) => {
                    const highlightedData = data.filter(d => d.player.id === playerId);
                    if (highlightedData.length > 0) {
                        const player = highlightedData[0].player;
                        const color = teamColors[player.team] || '#666';
                        
                        datasets.push({
                            label: `Highlighted ${index + 1}`,
                            data: highlightedData,
                            backgroundColor: color,
                            borderColor: '#fff',
                            borderWidth: 4,
                            pointRadius: 16,
                            pointHoverRadius: 20,
                            pointHoverBorderWidth: 5,
                            pointStyle: 'circle'
                        });
                    }
                });
            }
            
            // Create chart with median annotations
            advancedScatterChart = new Chart(ctx, {
                type: 'scatter',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: '#30d158',
                            borderWidth: 1,
                            padding: 12,
                            displayColors: false,
                            callbacks: {
                                title: (context) => {
                                    const point = context[0].raw;
                                    return `${point.player.name} (${point.player.team})`;
                                },
                                label: (context) => {
                                    const point = context.raw;
                                    return [
                                        `${xLabel}: ${point.x.toFixed(1)}`,
                                        `${yLabel}: ${point.y.toFixed(1)}`
                                    ];
                                }
                            }
                        },
                        annotation: {
                            annotations: {
                                xMedianLine: {
                                    type: 'line',
                                    xMin: xMedian,
                                    xMax: xMedian,
                                    borderColor: 'rgba(142, 142, 147, 0.4)',
                                    borderWidth: 2,
                                    borderDash: [8, 4],
                                    label: {
                                        display: false
                                    }
                                },
                                yMedianLine: {
                                    type: 'line',
                                    yMin: yMedian,
                                    yMax: yMedian,
                                    borderColor: 'rgba(142, 142, 147, 0.4)',
                                    borderWidth: 2,
                                    borderDash: [8, 4],
                                    label: {
                                        display: false
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: xLabel,
                                color: '#8e8e93',
                                font: {
                                    size: 14,
                                    weight: '600'
                                }
                            },
                            min: xAxisMin,
                            max: xAxisMax,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)'
                            },
                            ticks: {
                                color: '#8e8e93',
                                font: {
                                    size: 12
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: yLabel,
                                color: '#8e8e93',
                                font: {
                                    size: 14,
                                    weight: '600'
                                }
                            },
                            min: yAxisMin,
                            max: yAxisMax,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)'
                            },
                            ticks: {
                                color: '#8e8e93',
                                font: {
                                    size: 12
                                }
                            }
                        }
                    },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            const dataIndex = elements[0].index;
                            const player = data[dataIndex].player;
                            openPlayerModal(player.id);
                        }
                    }
                }
            });
        }
        
        // Initialize Advanced Analytics when page loads
        function initializeAdvancedAnalytics() {
            populatePresetButtons();
            populateAdvancedDropdowns();
            populateWeekSelector();
            updateAdvancedScatter();
        }
        
        // Populate week selector with dynamic week options
        function populateWeekSelector() {
            const select = document.getElementById('week-range-select');
            if (!select) return;
            
            // Find global max week
            let globalMaxWeek = 0;
            Object.values(allPlayers).forEach(p => {
                if (p.weeks && p.weeks.length > 0) {
                    const maxWeek = Math.max(...p.weeks.map(w => w.week));
                    if (maxWeek > globalMaxWeek) globalMaxWeek = maxWeek;
                }
            });
            
            // Keep existing options and add individual week options
            let html = `
                <option value="all">All Weeks</option>
                <option value="last3">Last 3 Weeks</option>
                <option value="last5">Last 5 Weeks</option>
                <option value="1-4">Weeks 1-4</option>
                <option value="5-8">Weeks 5-8</option>
            `;
            
            // Add individual week options
            if (globalMaxWeek > 0) {
                html += `<option disabled>──────────</option>`;
                for (let week = 1; week <= globalMaxWeek; week++) {
                    html += `<option value="${week}">Week ${week} Only</option>`;
                }
            }
            
            select.innerHTML = html;
        }
        
        // ============================================
        // FOOTER & AUTH FUNCTIONS
        // ============================================
        
        // Google Sheets Integration for Waitlist
        const GOOGLE_SHEETS_URL = 'https://script.google.com/macros/s/AKfycbxgIp_XJLI1rc8g3cH4V6mQhXOQRE80vNyIQU18JiFRSInJwjjPfI5Qjj2i_3XgqRbSUg/exec';
        
        // Debug: Log that this script is loaded
        console.log('✅ Waitlist script loaded, GOOGLE_SHEETS_URL:', GOOGLE_SHEETS_URL);
        
        function submitWaitlist(event) {
            console.log('🚀 submitWaitlist function called!');
            event.preventDefault();
            event.stopPropagation();
            
            const emailInput = document.getElementById('waitlist-email');
            const successMsg = document.getElementById('waitlist-success');
            
            if (!emailInput || !successMsg) {
                console.error('Waitlist elements not found');
                showWaitlistModal(false, 'Error: Form not properly initialized');
                return false;
            }
            
            const email = emailInput.value.trim();
            console.log('📧 Email entered:', email);
            
            // Enhanced email validation
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!email || !emailRegex.test(email)) {
                console.log('❌ Invalid email format');
                alert('⚠️ Please enter a valid email address');
                emailInput.focus();
                return false;
            }
            
            console.log('✅ Email validation passed');
            
            // Disable button and show loading state
            const submitBtn = event.target.querySelector('button[type="submit"]');
            if (submitBtn) {
                const originalBtnText = submitBtn.textContent;
                submitBtn.disabled = true;
                submitBtn.textContent = 'Submitting...';
                
                // Send to Google Sheets
                console.log('📤 Sending to Google Sheets...');
                console.log('📍 URL:', GOOGLE_SHEETS_URL);
                
                const payload = {
                    email: email,
                    timestamp: new Date().toISOString()
                };
                console.log('📦 Payload:', payload);
                
                fetch(GOOGLE_SHEETS_URL, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                }).then(() => {
                    console.log('✅ Email submitted to waitlist:', email);
                    
                    // Show modal
                    showWaitlistModal(true);
                    emailInput.value = '';
                    
                    // Re-enable button
                    submitBtn.disabled = false;
                    submitBtn.textContent = originalBtnText;
                    
                }).catch(err => {
                    console.error('Error submitting to waitlist:', err);
                    
                    // Show modal anyway (no-cors mode doesn't return errors reliably)
                    showWaitlistModal(true);
                    emailInput.value = '';
                    
                    // Re-enable button
                    submitBtn.disabled = false;
                    submitBtn.textContent = originalBtnText;
                });
            }
            
            return false;
        }
        
        // Make submitWaitlist globally available
        window.submitWaitlist = submitWaitlist;
        
        // Show waitlist confirmation modal
        function showWaitlistModal(success, customMessage) {
            const modal = document.getElementById('waitlist-modal');
            if (modal) {
                if (!success && customMessage) {
                    alert(customMessage);
                    return;
                }
                modal.classList.add('show');
            }
        }
        
        // Close waitlist modal
        function closeWaitlistModal() {
            const modal = document.getElementById('waitlist-modal');
            if (modal) {
                modal.classList.remove('show');
            }
        }
        
        // Login Modal Functions
        function showLoginModal() {
            document.getElementById('login-modal').style.display = 'flex';
            document.getElementById('login-error').classList.remove('show');
        }
        
        function closeLoginModal() {
            document.getElementById('login-modal').style.display = 'none';
            document.getElementById('login-email').value = '';
            document.getElementById('login-password').value = '';
            document.getElementById('login-error').classList.remove('show');
        }
        
        // Privacy Modal Functions
        function showPrivacyModal() {
            document.getElementById('privacy-modal').style.display = 'flex';
        }
        
        function closePrivacyModal() {
            document.getElementById('privacy-modal').style.display = 'none';
        }
        
        // Login handler - make it globally accessible
        window.handleLogin = function(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            console.log('Login attempt started');
            
            const emailEl = document.getElementById('login-email');
            const passwordEl = document.getElementById('login-password');
            
            if (!emailEl || !passwordEl) {
                console.error('Login inputs not found');
                alert('Error: Login form not properly initialized');
                return false;
            }
            
            const email = emailEl.value.trim();
            const password = passwordEl.value;
            
            console.log('Email entered:', email);
            console.log('Password length:', password.length);
            
            const ADMIN_EMAIL = 'aryi3025@gmail.com';
            const ADMIN_PASSWORD = 'admin051213!';
            
            if (email === ADMIN_EMAIL && password === ADMIN_PASSWORD) {
                // Successful login
                console.log('Login successful');
                localStorage.setItem('ffse_admin_logged_in', 'true');
                closeLoginModal();
                updateUIForAdmin(true);
                
                // Navigate to admin panel
                setTimeout(() => {
                    navigateToPage('admin-panel');
                }, 100);
                
                alert('Login successful! Welcome back.');
            } else {
                // Failed login
                console.log('Login failed - credentials do not match');
                console.log('Expected email:', ADMIN_EMAIL);
                console.log('Expected password length:', ADMIN_PASSWORD.length);
                
                const errorMsg = document.getElementById('login-error');
                if (errorMsg) {
                    errorMsg.classList.add('show');
                    
                    setTimeout(() => {
                        errorMsg.classList.remove('show');
                    }, 3000);
                } else {
                    alert('Invalid credentials. Please try again.');
                }
            }
            
            return false;
        };
        
        // Check if user is logged in on page load
        function checkAdminStatus() {
            const isLoggedIn = localStorage.getItem('ffse_admin_logged_in') === 'true';
            if (isLoggedIn) {
                console.log('Admin is logged in');
                updateUIForAdmin(true);
            } else {
                updateUIForAdmin(false);
            }
            updateLastUpdatedDisplay();
        }
        
        // Function to navigate to a page (used by footer links)
        function navigateToPage(pageName) {
            // Update active tab
            document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
            const activeTab = document.querySelector(`.nav-tab[data-page="${pageName}"]`);
            if (activeTab) activeTab.classList.add('active');
            
            // Show page
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            const targetPage = document.getElementById(pageName);
            if (targetPage) targetPage.classList.add('active');
            
            // Render dashboard categories if on dashboard page
            if (pageName === 'top-movers') {
                setTimeout(() => {
                    renderDashboardCategories();
                    setTimeout(renderMiniScatterPlots, 100);
                }, 100);
            }
            
            // Render all leaderboards if on all-leaderboards page
            if (pageName === 'all-leaderboards') {
                setTimeout(() => {
                    renderAllLeaderboards();
                }, 100);
            }
            
            // Scroll to top of page
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        // Set scoring format and reprocess all data
        function setScoringFormat(format) {
            console.log(`🏈 Switching to ${format.toUpperCase()} scoring format`);
            
            // Show scoring format details
            if (format === 'std') {
                console.log('   Standard scoring: Fantasy Points = Base Points - Receptions');
            } else if (format === 'half') {
                console.log('   Half-PPR scoring: Fantasy Points = Base Points - (0.5 × Receptions)');
            } else {
                console.log('   PPR scoring: Fantasy Points = Base Points (includes full reception points)');
            }
            
            // Update global variable
            currentScoringFormat = format;
            
            // Save to localStorage
            localStorage.setItem('ffse_scoring_format', format);
            
            // Update UI - toggle buttons
            document.querySelectorAll('.scoring-option').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.format === format) {
                    btn.classList.add('active');
                }
            });
            
            // Add fade animation to main content
            const mainContent = document.querySelector('.main-content');
            if (mainContent) {
                mainContent.classList.add('updating-values');
                setTimeout(() => {
                    mainContent.classList.remove('updating-values');
                }, 600);
            }
            
            // Reprocess all data with new scoring format
            if (wrData && rbData) {
                console.log('♻️ Reprocessing data for new scoring format...');
                // Small delay to let fade animation start
                setTimeout(() => {
                    processAllData();
                }, 100);
            }
        }
        
        // Initialize scoring format on page load
        function initializeScoringFormat() {
            const savedFormat = localStorage.getItem('ffse_scoring_format') || 'ppr';
            currentScoringFormat = savedFormat;
            
            // Update UI to match saved format
            document.querySelectorAll('.scoring-option').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.format === savedFormat) {
                    btn.classList.add('active');
                }
            });
            
            // Update header dropdown
            updateHeaderScoringDropdown(savedFormat);
            
            console.log(`✅ Initialized with ${savedFormat.toUpperCase()} scoring format`);
            if (savedFormat === 'std') {
                console.log('   📊 Formula: Fantasy Points = PPR Points - Receptions');
            } else if (savedFormat === 'half') {
                console.log('   📊 Formula: Fantasy Points = PPR Points - (0.5 × Receptions)');
            } else {
                console.log('   📊 Formula: Fantasy Points = PPR Points (full reception value)');
            }
        }
        
        // Toggle header scoring dropdown
        function toggleHeaderScoringDropdown() {
            const dropdown = document.getElementById('header-scoring-dropdown');
            dropdown.classList.toggle('open');
            
            // Close dropdown when clicking outside
            if (dropdown.classList.contains('open')) {
                setTimeout(() => {
                    document.addEventListener('click', closeHeaderDropdownOutside);
                }, 0);
            } else {
                document.removeEventListener('click', closeHeaderDropdownOutside);
            }
        }
        
        function closeHeaderDropdownOutside(e) {
            const dropdown = document.getElementById('header-scoring-dropdown');
            if (!dropdown.contains(e.target)) {
                dropdown.classList.remove('open');
                document.removeEventListener('click', closeHeaderDropdownOutside);
            }
        }
        
        // Set scoring format from header dropdown
        function setHeaderScoringFormat(format) {
            // Close dropdown
            document.getElementById('header-scoring-dropdown').classList.remove('open');
            document.removeEventListener('click', closeHeaderDropdownOutside);
            
            // Update header dropdown UI
            updateHeaderScoringDropdown(format);
            
            // Call existing setScoringFormat function
            setScoringFormat(format);
        }
        
        // Update header dropdown display
        function updateHeaderScoringDropdown(format) {
            const label = document.getElementById('header-scoring-label');
            const buttons = document.querySelectorAll('.header-scoring-menu button');
            
            // Update label text
            if (format === 'ppr') {
                label.textContent = 'PPR';
            } else if (format === 'half') {
                label.textContent = 'Half-PPR';
            } else {
                label.textContent = 'Standard';
            }
            
            // Update active state
            buttons.forEach(btn => {
                btn.classList.remove('active');
                if ((format === 'ppr' && btn.textContent === 'PPR') ||
                    (format === 'half' && btn.textContent === 'Half-PPR') ||
                    (format === 'std' && btn.textContent === 'Standard')) {
                    btn.classList.add('active');
                }
            });
        }
        
        // Scroll to waitlist section
        function scrollToWaitlist() {
            const footer = document.querySelector('.footer');
            if (footer) {
                footer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                setTimeout(() => {
                    const emailInput = document.getElementById('waitlist-email');
                    if (emailInput) emailInput.focus();
                }, 500);
            }
        }
        
        // Update last updated date display
        function updateLastUpdatedDisplay() {
            const lastUpdated = localStorage.getItem('ffse_last_updated');
            const displayEl = document.getElementById('last-updated-date');
            
            if (displayEl) {
                if (lastUpdated) {
                    const date = new Date(lastUpdated);
                    const options = { month: 'short', day: 'numeric', year: 'numeric' };
                    displayEl.textContent = date.toLocaleDateString('en-US', options);
                } else {
                    displayEl.textContent = 'No data uploaded';
                }
            }
        }
        
        // Set last updated date
        function setLastUpdatedDate() {
            const now = new Date().toISOString();
            localStorage.setItem('ffse_last_updated', now);
            updateLastUpdatedDisplay();
        }
        
        // Update UI based on admin status
        function updateUIForAdmin(isAdmin) {
            const adminLoginLink = document.getElementById('admin-login-link');
            const adminTab = document.getElementById('admin-tab');
            
            if (isAdmin) {
                // Show admin tab
                if (adminTab) adminTab.style.display = 'block';
                
                // Update footer link
                if (adminLoginLink) {
                    adminLoginLink.textContent = 'Admin Panel';
                    adminLoginLink.onclick = (e) => {
                        e.preventDefault();
                        navigateToPage('admin-panel');
                        return false;
                    };
                }
            } else {
                // Hide admin tab
                if (adminTab) adminTab.style.display = 'none';
                
                // Update footer link
                if (adminLoginLink) {
                    adminLoginLink.textContent = 'Admin Login';
                    adminLoginLink.onclick = (e) => {
                        e.preventDefault();
                        showLoginModal();
                        return false;
                    };
                }
            }
            
            // Update admin panel display if on that page
            updateAdminPanelDisplay();
        }
        
        // Logout admin
        function logoutAdmin() {
            localStorage.removeItem('ffse_admin_logged_in');
            updateUIForAdmin(false);
            // Navigate to dashboard if currently on admin panel
            if (document.getElementById('admin-panel').classList.contains('active')) {
                navigateToPage('top-movers');
            }
            alert('Logged out successfully');
        }
        
        // Update admin panel display with current data info
        function updateAdminPanelDisplay() {
            const lastUpdatedEl = document.getElementById('admin-last-updated');
            if (lastUpdatedEl) {
                const lastUpdated = localStorage.getItem('ffse_last_updated');
                if (lastUpdated) {
                    const date = new Date(lastUpdated);
                    const options = { month: 'short', day: 'numeric', year: 'numeric', hour: 'numeric', minute: '2-digit' };
                    lastUpdatedEl.textContent = date.toLocaleDateString('en-US', options);
                } else {
                    lastUpdatedEl.textContent = 'No data uploaded';
                }
            }
        }
        
        // Admin upload handlers
        function handleAdminWRUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const statusEl = document.getElementById('admin-wr-status');
                if (statusEl) statusEl.textContent = 'Processing...';
                if (statusEl) statusEl.style.color = 'var(--text-secondary)';
                
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        wrData = results.data.filter(row => row.Player && row.Week);
                        localStorage.setItem('wrData', JSON.stringify(wrData));
                        
                        if (statusEl) statusEl.textContent = '✓ WR data uploaded successfully';
                        if (statusEl) statusEl.style.color = 'var(--positive)';
                        
                        if (rbData && teData) {
                            processAllData();
                            updateAdminPanelDisplay();
                        }
                    },
                    error: function(error) {
                        if (statusEl) statusEl.textContent = '✗ Error uploading WR data';
                        if (statusEl) statusEl.style.color = 'var(--negative)';
                        console.error('WR upload error:', error);
                    }
                });
            }
        }
        
        function handleAdminRBUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const statusEl = document.getElementById('admin-rb-status');
                if (statusEl) statusEl.textContent = 'Processing...';
                if (statusEl) statusEl.style.color = 'var(--text-secondary)';
                
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        rbData = results.data.filter(row => row.Player && row.Week);
                        localStorage.setItem('rbData', JSON.stringify(rbData));
                        
                        if (statusEl) statusEl.textContent = '✓ RB data uploaded successfully';
                        if (statusEl) statusEl.style.color = 'var(--positive)';
                        
                        if (wrData && teData) {
                            processAllData();
                            updateAdminPanelDisplay();
                        }
                    },
                    error: function(error) {
                        if (statusEl) statusEl.textContent = '✗ Error uploading RB data';
                        if (statusEl) statusEl.style.color = 'var(--negative)';
                        console.error('RB upload error:', error);
                    }
                });
            }
        }
        
        function handleAdminTEUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const statusEl = document.getElementById('admin-te-status');
                if (statusEl) statusEl.textContent = 'Processing...';
                if (statusEl) statusEl.style.color = 'var(--text-secondary)';
                
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: function(results) {
                        teData = results.data.filter(row => row.Player && row.Week);
                        localStorage.setItem('teData', JSON.stringify(teData));
                        
                        if (statusEl) statusEl.textContent = '✓ TE data uploaded successfully';
                        if (statusEl) statusEl.style.color = 'var(--positive)';
                        
                        if (wrData && rbData) {
                            processAllData();
                            updateAdminPanelDisplay();
                        }
                    },
                    error: function(error) {
                        if (statusEl) statusEl.textContent = '✗ Error uploading TE data';
                        if (statusEl) statusEl.style.color = 'var(--negative)';
                        console.error('TE upload error:', error);
                    }
                });
            }
        }
        
        // Portal tooltip system for leaderboard metrics
        function initializePortalTooltip() {
            // Create tooltip element if it doesn't exist
            let tooltip = document.getElementById('portal-tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'portal-tooltip';
                document.body.appendChild(tooltip);
            }
            
            // Add event listeners using delegation
            document.addEventListener('mouseover', function(e) {
                const target = e.target.closest('.compact-metric-value');
                if (target && target.hasAttribute('data-tooltip-text')) {
                    const tooltipText = target.getAttribute('data-tooltip-text');
                    const rect = target.getBoundingClientRect();
                    
                    // Set tooltip content
                    tooltip.innerHTML = tooltipText + '<span class="tooltip-secondary">Bar shows relative performance vs. #1</span>';
                    
                    // Make visible but transparent to measure
                    tooltip.style.opacity = '0';
                    tooltip.style.display = 'block';
                    
                    // Get dimensions after content is set
                    const tooltipWidth = tooltip.offsetWidth;
                    const tooltipHeight = tooltip.offsetHeight;
                    
                    // Position tooltip to the left of the element
                    let left = rect.left - tooltipWidth - 12;
                    let top = rect.top + (rect.height / 2) - (tooltipHeight / 2);
                    
                    // If tooltip goes off left edge, show on right instead
                    if (left < 10) {
                        left = rect.right + 12;
                    }
                    
                    // Keep tooltip within viewport vertically
                    if (top < 10) {
                        top = 10;
                    } else if (top + tooltipHeight > window.innerHeight - 10) {
                        top = window.innerHeight - tooltipHeight - 10;
                    }
                    
                    tooltip.style.left = left + 'px';
                    tooltip.style.top = top + 'px';
                    tooltip.style.opacity = '';
                    tooltip.style.display = '';
                    tooltip.classList.add('visible');
                }
            });
            
            document.addEventListener('mouseout', function(e) {
                const target = e.target.closest('.compact-metric-value');
                if (target && target.hasAttribute('data-tooltip-text')) {
                    tooltip.classList.remove('visible');
                }
            });
        }
        
        // Initialize on page load
        window.addEventListener('DOMContentLoaded', () => {
            initializeScoringFormat();
            checkAdminStatus();
            initializePortalTooltip();
        });
        
    </script>
</body>
</html>